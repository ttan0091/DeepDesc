Type of vulnerability: Reentrancy or Arithmetic Underflow
Cause of vulnerability: Lack of proper validation and handling of balance underflow in the `withdraw()` function
Working process of the code: An attacker can repeatedly call the `withdraw()` function with the same amount of tokens, leading to all ether in the contract being drained due to the unguarded balance subtraction. This is either a reentrancy attack or an underflow vulnerability, depending on subsequent interactions after the first attack.