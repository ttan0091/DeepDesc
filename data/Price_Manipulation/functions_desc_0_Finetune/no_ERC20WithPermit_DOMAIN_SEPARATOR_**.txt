Type of contract: ERC EIP2612 Permit for Smart Vaults (Tranche 2)
Programming language: Solidity
Working process: The Vault‘s Router interacts with a user via the permit() function to allow the user to lend / borrow assets on behalf of a vault. 
The functions in Router then call the functions of the Bank contract, which in turn fetch Vault ’s manager and do an action on behalf of the manager. This logic abstracts interactions with complex options on lending. 
When the result of the action between Manager and Bank is allocated /deallocated, the manager can swap physical assets of the vault to txResult.amountPeg and txResult.basisValue (the user swap interests&payment into collateral basal price) and fetch new collateral price via ICurveSwap (ICurveSwap fetches pricing on underlying collateral on AAMM vaults) . 
Bank contract has two main components of ERC20Permit – inside structure _init(): _init calls the permit() for this user and ERC20 extension calls DOMAIN_SEPARATOR() . permit() is invoked inside collateral token framework and Bank during Router actions, to allow for contracts to act on behalf of token holder without the need of signature. Permitting sets an allowance for the future and concludes transaction based on these permissions without a need for individual signatures. permit() implementation is generated by:
perl 0777 nE '/\n(\s)function permit\(\s(\S+)\s+value,\s+(\S+)\s\S+\s\S+\) external returns\s\(bool\);/sg && print "$2 = 1;\n$1" . 'permit()\n$1$2.send(msg.sender, msg.sender, 0x9661d0\1);' . 'permit() = Permit allowing spend up to value on your behalf in [' . 'uCHandle's vaults' . '];' . $1/seg'
So as user of AlsCore I allow Router to lend/borrow on my behalf without the need of singnatures. Permit() uses the DOMAIN_SEPARATOR() in EIP2612.