[H-01]PortcalFacet.repayAavePortal()can trigger an underflow ofrouterBalances
Submitted by Ruhum, also found by 0x1f8b and WatchPug
PortalFacet.sol#L80-L113
The caller ofrepayAavePortal()can trigger an underflow to arbitrarily increase the caller’s balance through an underflow.
Proof of Concept
// Relevant code sections:// PortalFacet.solfunctionrepayAavePortal(address_local,uint256_backingAmount,uint256_feeAmount,uint256_maxIn,bytes32_transferId)external{uint256totalAmount=_backingAmount+_feeAmount;// in adopteduint256routerBalance=s.routerBalances[msg.sender][_local];// in local// Sanity check: has that much to spendif(routerBalance<_maxIn)revertPortalFacet__repayAavePortal_insufficientFunds();// Need to swap into adopted asset or asset that was backing the loan// The router will always be holding collateral in the local asset while the loaned asset// is the adopted asset// Swap for exact `totalRepayAmount` of adopted asset to repay aave(boolsuccess,uint256amountIn,addressadopted) =AssetLogic.swapFromLocalAssetIfNeededForExactOut(_local,totalAmount,_maxIn);if(!success)revertPortalFacet__repayAavePortal_swapFailed();// decrement router balancesunchecked{s.routerBalances[msg.sender][_local] -=amountIn;}// back loan_backLoan(_local,_backingAmount,_feeAmount,_transferId);}// AssetLogic.solfunctionswapFromLocalAssetIfNeededForExactOut(address_asset,uint256_amount,uint256_maxIn)internalreturns(bool,uint256,address){AppStoragestorages=LibConnextStorage.connextStorage();// Get the token id(,bytes32id) =s.tokenRegistry.getTokenId(_asset);// If the adopted asset is the local asset, no need to swapaddressadopted=s.canonicalToAdopted[id];if(adopted==_asset) {return(true,_amount,_asset);}return_swapAssetOut(id,_asset,adopted,_amount,_maxIn);}
First, callrepayAavePortal()where_backingAmount + _feeAmount > s.routerBalances[msg.sender][_local] && _maxIn > s.routerBalances[msg.sender][_local]. That will trigger the call to the AssetLogic contract:
(boolsuccess,uint256amountIn,addressadopted) =AssetLogic.swapFromLocalAssetIfNeededForExactOut(_local,totalAmount,_maxIn);
By setting_localto the same value as the adopted asset, you trigger the following edge case:
addressadopted=s.canonicalToAdopted[id];if(adopted==_asset) {return(true,_amount,_asset);}
So theamountInvalue returned byswapFromLocalAssetIfNeededForExactOut()is thetotalAmountvalue that was passed to it. AndtotalAmount == _backingAmount + _feeAmount.
Meaning theamountInvalue is user-specified for this edge case. Finally, we reach the following line:
unchecked{s.routerBalances[msg.sender][_local] -=amountIn;}
amountIn(user-specified) is subtracted from therouterBalancesin anuncheckedblock. Thus, the attacker is able to trigger an underflow and increase their balance arbitrarily high. TherepayAavePortal()function only verifies thatrouterBalance < _maxIn.
Here’s a test as PoC:
// PortalFacet.t.solfunctiontest_PortalFacet_underflow()public{s.routerPermissionInfo.approvedForPortalRouters[router] =true;uintbacking=2ether;uintfee=10000;uintinit=1ether;s.routerBalances[router][_local] =init;s.portalDebt[_id] =backing;s.portalFeeDebt[_id] =fee;vm.mockCall(s.aavePool,abi.encodeWithSelector(IAavePool.backUnbacked.selector),abi.encode(true));vm.prank(router);this.repayAavePortal(_local,backing,fee,init-0.5ether,_id);// balance > init => underflowrequire(s.routerBalances[router][_local] >init);}
Recommended Mitigation Steps
After the call toswapFromLocalAssetIfNeededForExactOut()you should add the following check:
if(_local==adopted) {require(routerBalance>=amountIn);}
LayneHaber (Connext) confirmed and resolved:
connext/nxtp@ac95c1b
0xleastwood (judge) commented:
This is entirely valid and a really severe issue. If the local asset is the adopted asset,AssetLogic.swapFromLocalAssetIfNeededForExactOut()will returnamountIn == totalAmount. So in order to overflowrouterBalances, the router just needs to provide_backingAmount + _feeAmountinputs that sum to exceed the router’s current balance.

[H-02] Wrong implementation ofwithdrawAdminFees()can cause theadminFeesto be charged multiple times and therefore cause users’ fund loss
Submitted by WatchPug
SwapUtils.sol#L1053-L1062
functionwithdrawAdminFees(Swapstorageself,addressto)internal{IERC20[]memorypooledTokens=self.pooledTokens;for(uint256i=0;i<pooledTokens.length;i++) {IERC20token=pooledTokens[i];uint256balance=self.adminFees[i];if(balance!=0) {token.safeTransfer(to,balance);}}}
self.adminFees[i]should be reset to 0 every time it’s withdrawn. Otherwise, theadminFeescan be withdrawn multiple times.
The admin may just be unaware of this issue and casualtywithdrawAdminFees()from time to time, and rug all the users slowly.
Recommended Mitigation Steps
Change to:
functionwithdrawAdminFees(Swapstorageself,addressto)internal{IERC20[]memorypooledTokens=self.pooledTokens;for(uint256i=0;i<pooledTokens.length;i++) {IERC20token=pooledTokens[i];uint256balance=self.adminFees[i];if(balance!=0) {self.adminFees[i] =0;token.safeTransfer(to,balance);}}}
LayneHaber (Connext) confirmed and resolved:
connext/nxtp@8eef974
0xleastwood (judge) commented:
Completely agree with the validity of this finding. Even if the admin wasnotmalicious, the bug will still continue to withdraw additional fees which were not included as part of the swap calculations. LPs would lose considerable value as a result.

[H-03] Router Owner Could Steal All The Funds WithinSponsorVault
Submitted by xiaoming90
BridgeFacet.sol#L541SponsorVault.sol#L196
Assume the following:
For simplicity sake, only two (2) routers exist within Connext. Gas, relayer, callback fees and slippage are ignored.An attacker owns Router A. Router A has1,000,000oUSDC on Optimism Domain/ChainRouter B has only100oUSDC on Optimism Domain/ChainThe liquidity fee is 5% for fast transfer serviceSponserVault will reimbursed 50% of the liquidity fee incurred by the users
At this point, attacker balances are as follows (2,000,000 USDC in total)
Attacker’s wallet in Ethereum =1,000,000USDCAttacker’s wallet in Optimism =0oUSDCAttacker’s router in Optimism =1,000,000oUSDC
First, the attacker attempts to transfer an extremely large amount -1,000,000USDC from attacker’s address in Ethereum to attacker’s address in Optimism Chain. The transfer amount should be much larger than the rest of the router’s liquidity so that only attacker’s router is capable of providing the liqudity.
In our example, since Router B does not have sufficient liquidity to faciliate the fast transfer, Router B will not be selected by the Sequencer. Since only Router A has sufficient liquidity, Router A, which is owned by the attacker, will faciliate the fast transfer and selected by the Sequencer.
Since the liquidity fee is 5%, Router A only need to supply950,000oUSDC onexecute. The Sponsor will then reimburse 50% of the liquidity fee, which is25,000oUSDC in total. The final amount of oUSDC send to the attacker’s wallet address in Optimism will be975,000oUSDC.
At this point, attacker balances are as follows (1,025,000 USDC in total)
Attacker’s wallet in Ethereum =0USDCAttacker’s wallet in Optimism =975,000oUSDCAttacker’s router in Optimism =50,000oUSDC
When the nomad message arrives, the attacker will be reimbursed1,000,000oUSDC whenBridgeFacet._reconcileis triggered.
At this point, attacker balances are as follows (2,025,000 USDC in total)
Attacker’s wallet in Ethereum =0USDCAttacker’s wallet in Optimism =975,000oUSDCAttacker’s router in Optimism =50,000+1,000,000oUSDC
Attacker earned25,000USDC, and SponsorVault lost25,000USDC.
Impact
Router owner can intentionally perform many large transfer between their own wallets in two different domain to siphon all the funds from the SponsorVault, and then proceed to withdraw all liquidity from his router.
Recommended Mitigation Steps
Although having a sponsor to subside the liqudity fee to encourage users to use sponsor’s chain, this subsidy can be gamed by malicious actors for their own benefits. It is recommended to reconsider the need of having a sponsor in Connext as extreme care have to be taken in its design to ensure that it will not be exploited.
LayneHaber (Connext) acknowledged and commented:
TheSponsorVaultis not mandatory for the bridge flow, and the entire point of the vault option is to allow domains to subsidize fees for users transferring funds there. This is incredibly useful for new domains, that have no default bridge and want to remove any friction for users to get to their chain. Sponsor vault funders should be informed there is no way to enforce only legitimate users get the funds and it is inherently vulnerable to sybil attacks. In our conversations with potential sponsors, they are aware of these issues and are still willing to fund sponsor vaults to a limited capacity.
0xleastwood (judge) commented:
It seems that it would be easy for routers to sybil attack the protocol and continuously drain the sponsor vault of all its funds. While I understand this might not be an issue when the set of routers is trusted, however, as the protocol continues to become more decentralized, this would be a likely path of attack. I also agree with the current risk even though users’ funds aren’t at direct risk, the functionality of the sponsor vault is rendered useless and the router profits from this attack.

[H-04] Inexecute()the amount routers pay is what user signed, but in_reconcile()the amount routers get is what nomad sends and these two amounts are not necessary equal because of slippage in original domain
Submitted by unforgiven
BridgeFacet.sol#L526-L616BridgeFacet.sol#L753-L803BridgeFacet.sol#L398-L428BridgeFacet.sol#L345-L351
Routers pay for transaction in destination domain then nomad messages come and routers get paid again. but the amount routers pay inexecute()are what transaction sender signed and the amount routers receive is what nomad sends and handles in_reconcile()but this two amount can be different because of slippage and swap that happens inxcall()because the amount sent in nomad message is the result ofswapToLocalAssetIfNeeded().So it’s possible for routers to lose funds if some slippage happens in that swap.
Proof of Concept
This isxcall()code:
function xcall(XCallArgs calldata _args) external payable whenNotPaused nonReentrant returns (bytes32) {// Sanity checks.{// Correct origin domain.if (_args.params.originDomain != s.domain) {revert BridgeFacet__xcall_wrongDomain();}// Recipient is defined.if (_args.params.to == address(0)) {revert BridgeFacet__xcall_emptyTo();}// If callback address is not set, callback fee should be 0.if (_args.params.callback == address(0) && _args.params.callbackFee > 0) {revert BridgeFacet__xcall_nonZeroCallbackFeeForCallback();}// Callback is contract if supplied.if (_args.params.callback != address(0) && !Address.isContract(_args.params.callback)) {revert BridgeFacet__xcall_callbackNotAContract();}}bytes32 transferId;bytes memory message;XCalledEventArgs memory eventArgs;{// Get the remote BridgeRouter address; revert if not found.bytes32 remote = _mustHaveRemote(_args.params.destinationDomain);// Get the true transacting asset ID (using wrapper instead of native, if applicable).address transactingAssetId = _args.transactingAssetId == address(0)? address(s.wrapper): _args.transactingAssetId;// Check that the asset is supported -- can be either adopted or local.ConnextMessage.TokenId memory canonical = s.adoptedToCanonical[transactingAssetId];if (canonical.id == bytes32(0)) {// Here, the asset is *not* the adopted asset. The only other valid option// is for this asset to be the local asset (i.e. transferring madEth on optimism)// NOTE: it *cannot* be the canonical asset. the canonical asset is only used on// the canonical domain, where it is *also* the adopted asset.if (s.tokenRegistry.isLocalOrigin(transactingAssetId)) {// revert, using a token of local origin that is not registered as adoptedrevert BridgeFacet__xcall_notSupportedAsset();}(uint32 canonicalDomain, bytes32 canonicalId) = s.tokenRegistry.getTokenId(transactingAssetId);canonical = ConnextMessage.TokenId(canonicalDomain, canonicalId);}transferId = _getTransferId(_args, canonical);s.nonce += 1;// Store the relayer fees.relayerFees[transferId] = _args.params.relayerFee;// Transfer funds of transacting asset to the contract from the user.// NOTE: Will wrap any native asset transferred to wrapped-native automatically.(, uint256 amount) = AssetLogic.handleIncomingAsset(_args.transactingAssetId,_args.amount,_args.params.relayerFee + _args.params.callbackFee);// Swap to the local asset from adopted if applicable.(uint256 bridgedAmt, address bridged) = AssetLogic.swapToLocalAssetIfNeeded(canonical,transactingAssetId,amount,_args.params.slippageTol);// Transfer callback fee to PromiseRouter if setif (_args.params.callbackFee != 0) {s.promiseRouter.initCallbackFee{value: _args.params.callbackFee}(transferId);}message = _formatMessage(_args, bridged, transferId, bridgedAmt);s.xAppConnectionManager.home().dispatch(_args.params.destinationDomain, remote, message);// Format arguments for XCalled event that will be emitted below.eventArgs = XCalledEventArgs({transactingAssetId: transactingAssetId,amount: amount,bridgedAmt: bridgedAmt,bridged: bridged});}// emit eventemit XCalled(transferId, _args, eventArgs, s.nonce - 1, message, msg.sender);return transferId;}
As you can see it swaps what user sent toLoccalAssetwhich the amount isbridgedAmtand then send value ofbridgedAmtto nomad bridgemessage = _formatMessage(_args, bridged, transferId, bridgedAmt).But the amount user signed in_args.amountis different and that what user sends to contract.The reasons thatbridgedAmtcould be different than_args.amountis:1- deflationary tokens in transferring from user.2- slippage in swap to local token.This is_reconcile()code:
function _reconcile(uint32 _origin, bytes memory _message) internal {// Parse tokenId and action from the message.bytes29 msg_ = _message.ref(0).mustBeMessage();bytes29 tokenId = msg_.tokenId();bytes29 action = msg_.action();// Assert that the action is valid.if (!action.isTransfer()) {revert BridgeFacet__reconcile_invalidAction();}// Load the transferId.bytes32 transferId = action.transferId();// Ensure the transaction has not already been handled (i.e. previously reconciled).if (s.reconciledTransfers[transferId]) {revert BridgeFacet__reconcile_alreadyReconciled();}// NOTE: `tokenId` and `amount` must be in plaintext in the message so funds can *only* be minted by// `handle`. They are both used in the generation of the `transferId` so routers must provide them// correctly to be reimbursed.// Get the appropriate local token contract for the given tokenId on this chain.// NOTE: If the token is of remote origin and there is no existing representation token contract,// the TokenRegistry will deploy a new one.address token = s.tokenRegistry.ensureLocalToken(tokenId.domain(), tokenId.id());// Load amount once.uint256 amount = action.amnt();// Mint tokens if the asset is of remote origin (i.e. is representational).// NOTE: If the asset IS of local origin (meaning it's canonical), then the tokens will already be held// in escrow in this contract (from previous `xcall`s).if (!s.tokenRegistry.isLocalOrigin(token)) {IBridgeToken(token).mint(address(this), amount);// Update the recorded `detailsHash` for the token (name, symbol, decimals).// TODO: do we need to keep thisbytes32 details = action.detailsHash();IBridgeToken(token).setDetailsHash(details);}// Mark the transfer as reconciled.s.reconciledTransfers[transferId] = true;// If the transfer was executed using fast-liquidity provided by routers, then this value would be set// to the participating routers.// NOTE: If the transfer was not executed using fast-liquidity, then the funds will be reserved for// execution (i.e. funds will be delivered to the transfer's recipient in a subsequent `execute` call).address[] memory routers = s.routedTransfers[transferId];// If fast transfer was made using portal liquidity, we need to repay// FIXME: routers can repay any-amount out-of-band using the `repayAavePortal` method// or by interacting with the aave contracts directlyuint256 portalTransferAmount = s.portalDebt[transferId] + s.portalFeeDebt[transferId];uint256 toDistribute = amount;uint256 pathLen = routers.length;if (portalTransferAmount != 0) {// ensure a router took on credit riskif (pathLen != 1) revert BridgeFacet__reconcile_noPortalRouter();toDistribute = _reconcileProcessPortal(amount, token, routers[0], transferId);}if (pathLen != 0) {// fast liquidity path// Credit each router that provided liquidity their due 'share' of the asset.uint256 routerAmt = toDistribute / pathLen;for (uint256 i; i < pathLen; ) {s.routerBalances[routers[i]][token] += routerAmt;unchecked {i++;}}}emit Reconciled(transferId, _origin, routers, token, amount, msg.sender);}
As you can see it uses amount in message to calculate what router should receive.This is_handleExecuteLiquidity()code which is used inexecute():
function _handleExecuteLiquidity(bytes32 _transferId,bool _isFast,ExecuteArgs calldata _args) private returns (uint256, address) {uint256 toSwap = _args.amount;// If this is a fast liquidity path, we should handle deducting from applicable routers' liquidity.// If this is a slow liquidity path, the transfer must have been reconciled (if we've reached this point),// and the funds would have been custodied in this contract. The exact custodied amount is untracked in state// (since the amount is hashed in the transfer ID itself) - thus, no updates are required.if (_isFast) {uint256 pathLen = _args.routers.length;// Calculate amount that routers will provide with the fast-liquidity fee deducted.toSwap = _getFastTransferAmount(_args.amount, s.LIQUIDITY_FEE_NUMERATOR, s.LIQUIDITY_FEE_DENOMINATOR);// Save the addressess of all routers providing liquidity for this transfer.s.routedTransfers[_transferId] = _args.routers;// If router does not have enough liquidity, try to use Aave Portals.// only one router should be responsible for taking on this credit risk, and it should only// deal with transfers expecting adopted assets (to avoid introducing runtime slippage)if (!_args.params.receiveLocal &&pathLen == 1 &&s.routerBalances[_args.routers[0]][_args.local] < toSwap &&s.aavePool != address(0)) {if (!s.routerPermissionInfo.approvedForPortalRouters[_args.routers[0]])revert BridgeFacet__execute_notApprovedForPortals();// Portal provides the adopted asset so we early return herereturn _executePortalTransfer(_transferId, toSwap, _args.local, _args.routers[0]);} else {// for each router, assert they are approved, and deduct liquidityuint256 routerAmount = toSwap / pathLen;for (uint256 i; i < pathLen; ) {// decrement routers liquiditys.routerBalances[_args.routers[i]][_args.local] -= routerAmount;unchecked {i++;}}}}
As you can see it uses the amount defined inExecuteArgsto see how much routers should pay.
Because of these two issues (deflationary tokens and swap slippage) attacker could fool protocol to spend more than what he transferred to protocol. This could be seen as two bugs.
Tools Used
VIM
Recommended Mitigation Steps
Update spending amount based on  (deflationary tokens and swap slippage).
LayneHaber (Connext) disputed and commented:
I think there is a misunderstanding here — the user takes on the slippage risk both into and out of the local assets, and the router has consistent returns on what was bridged.Onxcall, the user swaps the amount put in for the local asset. This incurs some slippage, and only the amount of the local asset is bridged directly. It is the bridged amount that the router should supply liquidity for, and take fees on. Once the router supplies liquidity inexecute(bridged amount minus the fees), then it is swapped for the local asset and sent to the user. The user may get some different amount here, but it is the user who is impacted by this slippage. On handle, the router is credited the bridged amount.However, there was a separate bug where thetransferIdwas generated with the wrongamounton execute, so that could be where the confusion is coming from.
0xleastwood (judge) commented:
I actually agree with the warden here, it seems that they’re right about the issue but they just failed to mention the main reason why its an issue is becausetransferIdis calculated using_args.amountwhich does not necessarily equalbridgedAmtdue to slippage. Therefore, routers may end up fronting too much liquidity and receive considerably less when the bridge transfer is eventually reconciled. This seems rather severe as the user will receive the full transfer amount without slippage. This could be abused to drain routers on low liquidity tokens.
LayneHaber (Connext) commented:
Right — I agree that the problems outlined here would be the true consequences for a mismatchedtransferId. If the question is to take the action outlinedhere— specifically to keep this open and downgrade #227 as a QA — that would work with me.
LayneHaber (Connext) resolved:
connext/nxtp@f41a156

[H-05] Routers are not Enforced to Repay AAVE Portal Loan
Submitted by xiaoming90
BridgeFacet.sol#L984
Background
AAVE Portal
AAVE portal provides a trusted credit line that allows bridges to take on an unbacked position, and Connext intents to use this credit line to provide fast-liquidity for its users in the event the routers do not have sufficient liquidity.
Connext will assign one (1) router to be responsible for taking on credit risk of borrowing an unbacked position from AAVE portal as perSource Code.
Under normal circumstance, theBridgeFacet._reconcilefunction will automatically repay back the loan to AAVE portal when the nomad message arrives. However, if the repayment fails for certain reason, Connext expects that the router will use therepayAavePortalfunction out-of-band to help Connext to repay the loan.
Ultimately, it is Connext that take on the credit risk because AAVE portal only provides a trusted credit line to Connext, but not to the individual routers.
Nomad Message
When nomad message arrives, it will callBridgeFacet.handlefunction, which will in turn trigger the internal_reconcilefunction. Note that thehandleor_reconcilefunction cannot be reverted under any circumstances because nomad message cannot be reprocessed on the nomad side.
Proof-of-Concept
Alice transfers1,000,000DAI from Ethereum domain to Polygon domainNone of the existing routers have sufficient liquidity, thus the sequencer decided that AAVE Portal should be usedBob’s router has been selected to take on the credit risk for the unbacked position, and Connext proceeds to borrow1,000,000DAI from AAVE Portal and send the1,000,000DAI to Alice’s wallet on Polygon domainWhen slow nomad message arrives,BridgeFacet._reconcilefunction is triggered to attempt to repay back the loan to AAVE portal. This function will in turn trigger theBridgeFacet._reconcileProcessPortalfunction where the portal repayment logic resides.Within theBridgeFacet._reconcileProcessPortal, notice that if theAssetLogic.swapFromLocalAssetIfNeededForExactOutswap fails, it will return_amount.Within theBridgeFacet._reconcileProcessPortal, notice that if the ``AavaPool.backUnbackedexternal repayment call fails, it will setamountIn = 0, and then return [return (_amount - amountIn)](https://github.com/code-423n4/2022-06-connext/blob/b4532655071566b33c41eac46e75be29b4a381ed/contracts/contracts/core/connext/facets/BridgeFacet.sol#L1061) , which is basically the same as_amount`.When the_reconcileProcessPortalfunction call returned atLine 603, it will set thetoDistributeto theamount.amountin this example is1,000,000DAI.Next, atLine 611, the contract will increase Bob’s router balance by1,000,000DAIBob notices that his router balance has increased by1,000,000DAI, and he could not resist the tempation of1,000,000DAI. Therefore, instead of helping Connext to repay the loan viarepayAavePortalfunction out-of-band, he decided to quickly withdraws all his liquidty from his router.Bob gained1,000,000DAI, while Connext still owns AAVE portal1,000,000DAI
Impact
If routers decided not to repay the loan, Connext will incur large amount of debt from AAVE portal.
Recommended Mitigation Steps
Understood that there is a whitelist for routers that can use portals to ensure that only trusted routers could use this feature. In this case, the trust entirely depends on the integrity of the router owner and the assumption that the owner will not act against Connext and its community. However, as seen in many of the past security incidents, trusted actor or even own protocol team member might turn rogue when dealing with significant gain. In the above example,1,000,000DAI. It is common to see even larger amount of funds transferring across the bridge.
Therefore, to overcome the above-mentioned risk, some protocol would implementm-of-nmultisig or validation, which help to mitigate the risk of a single trusted actor from turning rogue and perform malicious action.
Therefore, it is recommended to reconsider such design and explore other alternatives. One such alternative would be as follows:
Assuming that the AAVE portal interest rate is fixed, therefore, the amount of repayment is deterministic, and Connext can compute the amount of repayment that needs to be repaid at any point of time.When theBridgeFacet._reconcileProcessPortalswap orAavaPool.backUnbackedfails, do not immediately credit the Bob’s router balance. Instead, escrow the amount  (1,000,000DAI) received from nomad in anEscrowcontract. Implement a function calledsettleAAVEPortalLoanwithin theEscrowcontract, which contains the logic to perform the necessary actions to repay AAVE portal loan. In this case, Bob is responsible for triggering theEscrow.settleAAVEPortalLoanto kick start the out-of-band repayment process. If the repayment is sucessful, Bob’s router will be credited with the earning for taking on credit risk.One positive side effect of this approach is that Bob will be incentivize to make the repayment as fast as possible because the longer he delays, the higher the interest rate, and thus less earning for him.This approach is quite similar to the withdrawal pattern.
LayneHaber (Connext) acknowledged and commented:
This is correct, and using an escrow contract would be helpful, but in general the router has no incentive ever to repay aave loans (even with this fix). This eliminates the possibility of a router profiting from the mishandling ofreconcile, but doesn’t address the root of the trustedness, which is embedded at the aave layer (by being able to take out unbacked loans).

[H-06] Malicious Relayer can Replay Execute Calldata on Different Chains Causing Double-Spend Issue
Submitted by xiaoming90
BridgeFacet.sol#L411
This issue is only applicable for fast-transfer. Slow transfer would not have this issue because of the built-in fraud-proof mechanism in Nomad.
First, the attacker will attempt to use Connext to send1000 USDCfrom Ethereum domain to Optimism domain.
Assume that the attacker happens to be a relayer on the relayer network utilised by Connext, and the attacker’s relayer happens to be tasked to relay the above execute calldata to the Optimism’s ConnextBridgeFacet.executefunction.
Optimism’s ConnextBridgeFacet.executereceived the execute calldata and observed within the calldata that it is a fast-transfer and Router A is responsible for providing the liquidity. It will then check that the router signature is valid, and proceed to transfer1000 oUSDCto attacker wallet (0x123456) in Optimism.
Next, attacker will update theExecuteArgs.localwithin the execute calldata to a valid local representation of canonical token (USDC) used within Polygon. Attacker will then send the modified execute calldata to Polygon’s ConnextBridgeFacet.executefunction. Assume that the same Router A is also providing liquidity in Polygon. TheBridgeFacet.executefunction checks that the router signature is valid, and proceed to transfer1000 POS-USDCto atttack wallet (0x123456) in Polygon.
At this point, the attacker has1000 oUSDCand1000 POS-USDCin his wallets. When the nomad message arrives at Optimism, Router A can claim the1000 oUSDCback from Connext. However, Router A is not able to claim back any fund in Polygon.
Note that same wallet address exists on different chains. For instance, the wallet address on Etherum and Polygon is the same.
Why changing theExecuteArgs.localdoes not affect the router signature verification?
This is because the router signature is generated from thetransferId+pathLengthonly, and these data are stored within theCallParams paramswithin theExecuteArgsstruct.
LibConnextStorage.sol#L77
structExecuteArgs{CallParamsparams;addresslocal;// local representation of canonical tokenaddress[]routers;bytes[]routerSignatures;uint256amount;uint256nonce;addressoriginSender;}
Within theBridgeFacet._executeSanityChecksfunction, it will attempt to rebuild totransferIdby calling the following code:
// Derive transfer ID based on given arguments.bytes32transferId=_getTransferId(_args);
Within theBridgeFacet._getTransferIdfunction, we can see that thes.tokenRegistry.getTokenId(_args.local)will always return the canonicaltokenDomainandtokenId. In our example, it will beEthereumandUSDC. Therefore, as long as the attacker specify a valid local representation of canonical token on a chain, thetransferIdreturned bys.tokenRegistry.getTokenId(_args.local)will always be the same across all domains. Thus, this allows the attacker to modify theExecuteArgs.localand yet he could pass the router signature check.
BridgeFacet.sol#L719
function_getTransferId(ExecuteArgscalldata_args)privateviewreturns(bytes32) {(uint32tokenDomain,bytes32tokenId) =s.tokenRegistry.getTokenId(_args.local);return_calculateTransferId(_args.params,_args.amount,_args.nonce,tokenId,tokenDomain,_args.originSender);}
Impact
Router liquidity would be drained by attacker, and affected router owner could not claim back their liquidity.
Recommended Mitigation Steps
The security of the current Connext design depends on how secure or reliable the relayer is. If the relayer turns rouge or acts against Connext, many serious consequences can happen.
The root cause is that the current design places enormous trust on the relayers to accurately and reliably to deliver calldata to the bridge in various domains. For instance, delivering of execute call data toexecutefunction. There is an attempt to prevent message replay on a single domain, however, it does not prevent message replay across multiple domains. Most importantly, the Connext’s bridge appears to have full trust on the calldata delivered by the relayer. However, the fact is that the calldata can always be altered by the relayer.
Consider a classic 0x off-chain ordering book protocol. A user will sign his order with his private key, and attach the signature to the order, and send the order (with signature) to the relayer network. If the relayer attempts to tamper the order message or signature, the decoded address will be different from the signer’s address and this will be detected by 0x’s Smart contract on-chain when processing the order. This ensures that the integrity of the message and signer can be enforced.
Per good security practice, relayer network should always be considered as a hostile environment/network. Therefore, it is recommended that similar approach could be taken with regards to passing execute calldata across domains/chains.
For instance, at a high level, the sequencer should sign the execute calldata with its private key, and attach the signature to the execute calldata. Then, submit the execute calldata (with signature) to the relayer network. When the bridge receives the execute calldata (with signature), it can verify if the decoded address matches the sequencer address to ensure that the calldata has not been altered. This will ensure the intergrity of the execute calldata and prevent any issue that arise due to unauthorised modification of calldata.
Additionally, the execute calldata should also have a field that correspond to the destination domain. The bridge that receives the execute calldata must verify that the execute calldata is intended for its domain, otherwise reject the calldata if it belongs to other domains. This also helps to prevent the attack mentioned earlier where same execute calldata can be accepted in different domains.
LayneHaber (Connext) confirmed and commented:
Agree that this is an issue, but disagree with the framing and mitigation.Thecalldatais included in the generation of thetransferIdvia theCallParams, so it cannot be easily manipulated by the relayer network once signed by routers. However, because you are not validating thes.domainagainst theCallParams.destinationDomainyou can use the same transfer data across multiple chains, which is a big problem.
LayneHaber (Connext) resolved:
connext/nxtp@bc241f8
0xleastwood (judge) commented:
This seems like the most severe finding of the entire contest. Kudos to the warden on a great find!Because transfer data is replicated across multiple chains, relayers are also able to execute data on each chain. If_executeSanityChecksdoes not check that the message’s destination chain matchess.domain, then transfers could be spent on all available chains.Interestingly, because the remote router is included in the message, only the correct destination chain will be able to reconcile the transfer and reimburse routers for providing liquidity. Hence, the issue is only prevalent on other chains if routers readily bid on incoming transfers, which seems possible because signatures can be replayed on other chains. So if the same set of routers have sufficient liquidity on another chain, the relayer can execute this message again to create a double spend issue.Another point to add, this issue would only be prevalent on chains which have its local asset pointing to the same address as this is what the bridge will attempt to transfer to the recipient. Additionally, in order for the relayer to replay a router’s signature, thetransferIdmust exactly match thetransferIdon the intended destination chain. This is only possible ifTokenRegistry.getTokenIdreturns the same canonical domain and ID values.It would be good to confirm this. Is it possible for a local asset to be registered to the same canonical domain and ID on multiple chains?
LayneHaber (Connext) commented:
Is it possible for a local asset to be registered to the same canonical domain and ID on multiple chains?Yes, that is actually the purpose of thecanonicalIdandcanonicalDomain— there should only be one canonical (locked) token that maps to any number of local (minted) instances.This issue is valid, and enforcing in_executeSanityChecksit is only executed on the destination domain should prevent this attack, correct?
0xleastwood (judge) commented:
Okay great! Because local assets map to the same canonical domain and ID on each chain, I think this issue is most definitely valid._args.localis not used to calculatetransferId, hence the representation for each asset may differ on each chain but theTokenRegistry.getTokenIdshould return the correct information.I can confirm that the enforcing check in_executeSanityChecksshould ensure that transfer data is only executed on the intended destination domain.

