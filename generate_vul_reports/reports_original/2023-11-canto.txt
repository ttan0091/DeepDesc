[H-01] Owner cannot withdraw all interest due to wrong calculation of accrued interest inWithdrawCarry
Submitted by100su, also found bypontifex,immeas,nazirite,Soul22,bart1e,adriro,Oxsadeeq,ast3ros,osmanozdemir1,ether_sky,T1MOH,bin2chen,0xpiken,ustas,SpicyMeatball,wangxx2026, and0xluckhu
The currentwithdrawCarryfunction in the contract underestimates the accrued interest due to a miscalculation. This error prevents the rightful owner from withdrawing their accrued interest, effectively locking the assets. The primary issue lies in the calculation ofmaximumWithdrawablewithinwithdrawCarry.
Flawed Calculation
The following code segment is used to determinemaximumWithdrawable:
uint256 exchangeRate = CTokenInterface(cNote).exchangeRateCurrent(); // Scaled by 1 * 10^(18 - 8 + Underlying Token Decimals), i.e. 10^(28) in our case// The amount of cNOTE the contract has to hold (based on the current exchange rate which is always increasing) such that it is always possible to receive 1 NOTE when burning 1 asDuint256 maximumWithdrawable = (CTokenInterface(cNote).balanceOf(address(this)) * exchangeRate) / 1e28 - totalSupply();
The problem arises with the scaling ofexchangeRate, which is assumed to be scaled by10^28. However, forCNOTEin the Canto network, theexchangeRateis actually scaled by10^18. This discrepancy causes the owner to withdraw only10^(-10)times the actual interest amount.
Consequently, when a non-zero_amountis specified,withdrawCarryoften fails due to therequire(_amount <= maximumWithdrawable, "Too many tokens requested");condition.
Proof of Concept
CNOTE Scaling Verification
An essential aspect of this audit involves verifying the scaling factor of theCNOTEexchange rate. TheexchangeRatescale forCNOTEcan be verified in theCanto Network’s GitHub repository.  Evidence confirming that the exponent of theCNOTEexchange rate is indeed18can be found throughthis link to the token tracker. The data provided there shows the current value of the stored exchange rate (exchangeRateStored) as approximately1004161485744613000. This value corresponds to1.00416 * 1e18, reaffirming the10^18scaling factor.
This information is critical for accurately understanding the mechanics of CNOTE and ensuring the smart contract’s calculations align with the actual scaling used in the token’s implementation. The verification of this scaling factor supports the recommendations for adjusting the main contract’s calculations and the associated test cases, as previously outlined.
Testing with Solidity Codes
Testing with the following Solidity code illustrates the actualCNOTEvalues:
functionupdateBalance()external{updatedUnderlyingBalance=ICNoteSimple(cnote).balanceOfUnderlying(msg.sender);updatedExchangeRate=ICNoteSimple(cnote).exchangeRateCurrent();uint256balance=IERC20(cnote).balanceOf(msg.sender);calculatedUnderlying=balance*updatedExchangeRate/1e28;}
The corresponding TypeScript logs show a clear discrepancy between the expected and calculated underlying balances:
console.log("balanceCnote: ", (Number(balanceCnote) / 1e18).toString());console.log("exchangeRate: ", Number(exchangeRate).toString());console.log("underlyingBalance: ", Number(underlyingBalance).toString());console.log("calculatedUnderlying: ", Number(calculatedUnderlying).toString());
With the logs:
balanceCnote:  400100.9100006097exchangeRate:  1004122567006264000underlyingBalance:  4.017503528113544e+23calculatedUnderlying:  40175035281135
Tools Used
Solidity for interacting with the Canto mainnet.TypeScript for testing and validation.
Recommended Mitigation Steps
UsingbalanceOfUnderlyingFunction- Replace the flawed calculation with thebalanceOfUnderlyingfunction. This function accurately calculates the underlyingNOTEbalance and is defined inCToken.sol(source).
Proposed Code Modifications- Two alternative implementations are suggested:
WithoutbalanceOfUnderlying: Modify the scaling factor in the existing calculation from1e28to1e18.
function withdrawCarry(uint256 _amount) external onlyOwner {uint256 exchangeRate = CTokenInterface(cNote).exchangeRateCurrent(); // Scaled by 10^18// The amount of cNOTE the contract has to hold (based on the current exchange rate which is always increasing) such that it is always possible to receive 1 NOTE when burning 1 asDuint256 maximumWithdrawable = (CTokenInterface(cNote).balanceOf(address(this)) * exchangeRate) /1e18 -totalSupply();if (_amount == 0) {_amount = maximumWithdrawable;} else {require(_amount <= maximumWithdrawable, "Too many tokens requested");}// Technically, _amount can still be 0 at this point, which would make the following two calls unnecessary.// But we do not handle this case specifically, as the only consequence is that the owner wastes a bit of gas when there is nothing to withdrawuint256 returnCode = CErc20Interface(cNote).redeemUnderlying(_amount);require(returnCode == 0, "Error when redeeming"); // 0 on success: https://docs.compound.finance/v2/ctokens/#redeemIERC20 note = IERC20(CErc20Interface(cNote).underlying());SafeERC20.safeTransfer(note, msg.sender, _amount);emit CarryWithdrawal(_amount);}
WithbalanceOfUnderlying(Recommended): Utilize thebalanceOfUnderlyingfunction for a simpler calculation ofmaximumWithdrawable.
function withdrawCarry(uint256 _amount) external onlyOwner {// The amount of cNOTE the contract has to hold (based on the current exchange rate which is always increasing) such that it is always possible to receive 1 NOTE when burning 1 asDuint256 maximumWithdrawable = CTokenInterface(cNote).balanceOfUnderlying(address(this)) - totalSupply();if (_amount == 0) {_amount = maximumWithdrawable;} else {require(_amount <= maximumWithdrawable, "Too many tokens requested");}// Technically, _amount can still be 0 at this point, which would make the following two calls unnecessary.// But we do not handle this case specifically, as the only consequence is that the owner wastes a bit of gas when there is nothing to withdrawuint256 returnCode = CErc20Interface(cNote).redeemUnderlying(_amount);require(returnCode == 0, "Error when redeeming"); // 0 on success: https://docs.compound.finance/v2/ctokens/#redeemIERC20 note = IERC20(CErc20Interface(cNote).underlying());SafeERC20.safeTransfer(note, msg.sender, _amount);emit CarryWithdrawal(_amount);}
The second option is highly recommended for its accuracy and simplicity.
Modification of Related Test Codes
For post-modifications to the main contract code, it’s essential to update the associated test cases. In theMockCNOTEtest contract, all scaling is currently set to10^28. To align with the main contract changes, the following modifications are recommended forMockCNOTE:
contract MockCNOTE is MockERC20 {address public underlying;uint256 public constant SCALE = 1e18;uint256 public exchangeRateCurrent = SCALE;constructor(string memory symbol, string memory name, address _underlying) MockERC20(symbol, name) {underlying = _underlying;}function mint(uint256 amount) public returns (uint256 statusCode) {SafeERC20.safeTransferFrom(IERC20(underlying), msg.sender, address(this), amount);_mint(msg.sender, (amount * SCALE) / exchangeRateCurrent);statusCode = 0;}function redeemUnderlying(uint256 amount) public returns (uint256 statusCode) {SafeERC20.safeTransfer(IERC20(underlying), msg.sender, amount);_burn(msg.sender, (amount * exchangeRateCurrent) / SCALE);statusCode = 0;}function redeem(uint256 amount) public returns (uint256 statusCode) {SafeERC20.safeTransfer(IERC20(underlying), msg.sender, (amount * exchangeRateCurrent) / SCALE);_burn(msg.sender, amount);statusCode = 0;}function setExchangeRate(uint256 _exchangeRate) public {exchangeRateCurrent = _exchangeRate;}}
This revisedMockCNOTEcontract reflects the updated scale factor and aligns with the main contract’s logic.
Scenario Testing with Mainnet Forking
For comprehensive validation, scenario testing using a fork of the mainnet is highly recommended. This approach allows for real-world testing conditions by simulating interactions with existing contracts on the mainnet. It provides a robust environment to verify the correctness and reliability of the contract modifications in real-world scenarios, ensuring that the contract behaves as expected when interfacing with other mainnet contracts.
This step is crucial to identify potential issues that might not be apparent in isolated or simulated environments, enhancing the overall reliability of the contract before deployment.
Assessed type
Math
OpenCoreCH (Canto) confirmed and commented via duplicate issue #227:
True,cNOTEonly has 8 decimals unlike all other cTokens that have 18 decimals, causing this discrepancy. Will be fixed.
OpenCoreCH (Canto) commented:
Fixed.

