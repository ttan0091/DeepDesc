[H-01] Re-entrancy bug allows inflating balance
One can call theMarginRouter.crossSwapExactTokensForTokensfunction first with a fake contract disguised as a token pair:crossSwapExactTokensForTokens(0.0001 WETH, 0, [ATTACKER_CONTRACT], [WETH, WBTC]). When the amounts are computed by theamounts = UniswapStyleLib.getAmountsOut(amountIn - fees, pairs, tokens);call, the attacker contract returns fake reserves that yield 1 WBTC for the tiny input. The resulting amount is credited throughregisterTrade. Afterwards,_swapExactT4T([0.0001 WETH, 1 WBTC], 0, [ATTACKER_CONTRACT], [WETH, WBTC])is called with the fake pair and token amounts. At some point_swapis called, the starting balance is stored instartingBalance, and the attacker contract call allows a re-entrancy:
pair.swap(0.0001WETH,1WBTC,FUND,newbytes(0));// can re-enter here
From the ATTACKERCONTRACT we re-enter the `MarginRouter.crossSwapExactTokensForTokens(30 WETH, 0, WETHWBTCPAIR, [WETH, WBTC])function with the actual WETH <> WBTC pair contract. All checks pass, the FUND receives the actual amount, the outerswapcontinues execution after the re-entrancy and theendingBalance >= startingBalance + amounts[amounts.length - 1]` check passes as well because the inner swap successfully deposited these funds. We end up doing 1 real trade but being credited twice the output amount.
This allows someone to be credited multiples of the actual swap result. This can be repeated many times and finally, all tokens can be stolen.
Recommend adding re-entrancy guards (from OpenZeppelin) to all external functions ofMarginRouter. There might be several attack vectors of this function as the attacker controls many parameters. The idea of first doing an estimation withUniswapStyleLib.getAmountsOut(amountIn - fees, pairs, tokens)and updating the user with these estimated amounts, before doing the actual trade, feels quite vulnerable to me. Consider removing the estimation and only doing the actual trade first, then callingregisterTradewith the actual trade amounts returned.
[H-02] MissingfromToken != toTokencheck
Attacker callsMarginRouter.crossSwapExactTokensForTokenswith a fake pair and the same token[0] == token[1].crossSwapExactTokensForTokens(1000 WETH, 0, [ATTACKER_CONTRACT], [WETH, WETH]). When the amounts are computed by theamounts = UniswapStyleLib.getAmountsOut(amountIn - fees, pairs, tokens);call, the attacker contract returns fake reserves that yield 0 output. When_swapExactT4Tis called, the funds are sent to the fake contract and doing nothing passes all checks in_swapcall that follows because thestartingBalanceis storedafterthe initial Fund withdraw to the pair.
function_swapExactT4T() {// withdraw happens hereFund(fund()).withdraw(tokens[0],pairs[0],amounts[0]);_swap(amounts,pairs,tokens,fund());}function_swap() {uint256startingBalance=IERC20(outToken).balanceOf(_to);uint256endingBalance=IERC20(outToken).balanceOf(_to);// passes as startingBalance == endingBalance + 0require(endingBalance>=startingBalance+amounts[amounts.length-1],"Defective AMM route; balances don't match");}
The full impact is not yet known asregisterTradecould still fail when subtracting theinAmountand adding 0outAmount.
At least, this attack is similar to a withdrawal which is supposed to only occur after a certaincoolingOffPeriodhas passed, but this time-lock is circumvented with this attack.
Recommend moving the fund withdrawal to the first pairafterthestartingBalanceassignment. CheckfromToken != toTokenas cyclical trades (arbitrages) are likely not what margin traders are after. Consider if the same check is required forregisterTradeAndBorrow/adjustAmountsfunctions.
[H-03] Price feed can be manipulated
Anyone can trigger an update to the price feed by callingPriceAware.getCurrentPriceInPeg(token, inAmount, forceCurBlock=true).
If the update window has passed, the price will be computed by simulating a Uniswap-like trade with the amounts.
This simulation uses the reserves of the Uniswap pairs which can be changed drastically using flash loans to yield almost arbitrary output amounts, and thus prices. Wrong prices break the core functionality of the contracts such as borrowing on margin, liquidations, etc.
Recommend against using the Uniswap spot price as the real price. Uniswap itself warns against this and instead recommends implementing aTWAP price oracleusing theprice*CumulativeLastvariables.
[H-04] Inconsistent usage ofapplyInterest
It is unclear if the functionapplyInterestis supposed to return a new balance with the interest applied or only the accrued interest? There are various usages of it, some calls add the return value to the old amount:
returnbond.amount+applyInterest(bond.amount,cumulativeYield,yieldQuotientFP);andsomenot:balanceWithInterest=applyInterest(balance,yA.accumulatorFP,yieldQuotientFP);
This makes the code misbehave and return the wrong values for the balance and accrued interest.
Recommend making it consistent in all cases when calling this function.
[H-05] Wrong liquidation logic
ThebelowMaintenanceThresholdfunction decides if a trader can be liquidated:
functionbelowMaintenanceThreshold(CrossMarginAccountstorageaccount)internalreturns(bool){uint256loan=loanInPeg(account,true);uint256holdings=holdingsInPeg(account,true);// The following should hold:// holdings / loan >= 1.1// =>return100*holdings>=liquidationThresholdPercent*loan;}
The inequality in the last equation is wrong because it says the higher the holdings (margin + loan) compared to the loan, the higher the chance of being liquidated. The inverse equality was probably intendedreturn 100 * holdings <= liquidationThresholdPercent * loan;. Users that shouldn’t be liquidated can be liquidated, and users that should be liquidated cannot get liquidated.
[H-06] Users are credited more tokens when paying back debt withregisterTradeAndBorrow
TheregisterTradeAndBorrowis called with the results of a trade (inAmount,outAmount). It first tries to pay back any debt with theoutAmount. However, thefulloutAmountis credited to the user again as a deposit in theadjustAmounts(account, tokenFrom, tokenTo, sellAmount, outAmount);call. As the user pays back their debt and is credited the same amount again, they are essentially credited twice theoutAmount, making a profit of oneoutAmount. This can be withdrawn and the process can be repeated until the funds are empty.
In theadjustAmountscall, it should only creditoutAmount - extinguishableDebtas a deposit like inregisterDeposit.
TheregisterDepositfunction correctly handles this case.
[H-07]account.holdsTokenis never set
TheaddHoldingfunction does not update theaccount.holdsTokenmap.
functionaddHolding(CrossMarginAccountstorageaccount,addresstoken,uint256depositAmount)internal{if(!hasHoldingToken(account,token)) {// SHOULD SET account.holdsToken hereaccount.holdingTokens.push(token);}account.holdings[token] +=depositAmount;}
This leads to a critical vulnerability where deposits of the same token keep being pushed to theaccount.holdingTokensarray but the sum is correctly updated inaccount.holdings[token]. However, because of the duplicate token in theholdingTokensarray the same token is counted several times in thegetHoldingAmountsfunction:
functiongetHoldingAmounts(addresstrader)externalviewoverridereturns(address[]memoryholdingTokens,uint256[]memoryholdingAmounts){CrossMarginAccountstorageaccount=marginAccounts[trader];holdingTokens=account.holdingTokens;holdingAmounts=newuint256[](account.holdingTokens.length);for(uint256idx=0;holdingTokens.length>idx;idx++) {addresstokenAddress=holdingTokens[idx];// RETURNS SUM OF THE BALANCE FOR EACH TOKEN ENTRYholdingAmounts[idx] =account.holdings[tokenAddress];}}
TheMarginRouter.crossCloseAccountfunction uses these wrong amounts to withdraw all tokens:
functioncrossCloseAccount()external{(address[]memoryholdingTokens,uint256[]memoryholdingAmounts) =IMarginTrading(marginTrading()).getHoldingAmounts(msg.sender);// requires all debts paid offIMarginTrading(marginTrading()).registerLiquidation(msg.sender);for(uint256i;holdingTokens.length>i;i++) {Fund(fund()).withdraw(holdingTokens[i],msg.sender,holdingAmounts[i]);}}
An attacker can just deposit the same token X times which increases their balance by X times the actual value.
This inflated balance can then be withdrawn to steal all tokens.
Recommend correctly setting theaccount.holdsTokenmap inaddHolding.
[H-08] Rewards cannot be withdrawn
The rewards for a recipient inIncentiveDistribution.solare stored in the storage mapping indexed by recipientaccruedReward[recipient]and the recipient is the actual margin trader account, seeupdateAccruedReward.
These rewards are supposed to be withdrawn through thewithdrawRewardfunction butmsg.senderis used here instead of arecipient(withdrawer) parameter.
However,msg.senderis enforced to be the incentive reporter and can therefore not be the margin trader.
Nobody can withdraw the rewards.
Recommend removing theisIncentiveReporter(msg.sender)check fromwithdrawRewardfunction.
[H-09] lastUpdatedDay not initialized
The variable lastUpdatedDay in IncentiveDistribution.sol is not (properly) initialized. This means the function updateDayTotals will end up in a very large loop which will lead to an out of gas error. Even if the loop would end, the variable currentDailyDistribution would be updated very often. Thus updateDayTotals cannot be performed.
The entire IncentiveDistribution does not work. If the loop would stop, the variable currentDailyDistribution is not accurate, resulting in a far lower incentive distribution than expected.
Recommend initializing lastUpdatedDay with something like block.timestamp / (1 days)
uint256lastUpdatedDay; # ==>lastUpdatedDay=0#WhenthefunctionupdateDayTotalsiscalled:uint256publicnowDay=block.timestamp/ (1days); #==> ~18721uint256dayDiff=nowDay-lastUpdatedDay; #==>18721-0=18721for(uint256i=0;i<dayDiff;i++) { #verylongloop(18721)currentDailyDistribution= ....}#willresultinanoutofgaserror## [[H-10]functionbuyBondchargesmsg.sendertwice](https://github.com/code-423n4/2021-04-marginswap-findings/issues/38)functionbuyBondtransfersamountfrommsg.sendertwice:Fund(fund()).depositFor(msg.sender,issuer,amount);...collectToken(issuer, msg.sender,amount);
[H-11] Impossible to call withdrawReward fails due to run out of gas
The withdrawReward (https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L224) fails due to the loop athttps://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L269. Based on testing, the dayDiff would be 18724 and with a gasLimit of 9500000 it stops at iteration 270 due to the fact that lastUpdatedDay is not initialized so is 0. Other than that it could run out of gas also for the loop of allTranches (https://github.com/code-423n4/marginswap/blob/main/contracts/IncentiveDistribution.sol#L281) because it’s an unbounded array.
I’m not sure of the logic behind the shrinking of the daily distribution but i think that maybe you just missed to initialize the lastUpdatedDay to the day of deployment? If that’s the case it resolves partially the problem because allTranches is theoretically unbounded even though only the owner can add element to it and you should do deeply testing to understand how many elements it can have until it run out of gas. I read the comment that says you tried to shift the gas to the withdrawal people maybe you went too further and is it worth rethinking the design?
werg (Marginswap) confirmed:
Exactly. we need to initialize lastUpdatedDay.
