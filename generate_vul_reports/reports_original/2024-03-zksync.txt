[H-01]paymasterwill refundspentOnPubdatato user
Submitted bybin2chen
A very important modification of this update is that the GAS spent bypubdatais collected at the final step of the transaction.
But if there is apaymaster, when executingpaymaster.postTransaction(_maxRefundedGas),_maxRefundedGasdoes not subtract thespentOnPubdata.
bootloader.yulthe code is as follow：
function refundCurrentL2Transaction(txDataOffset,transactionIndex,success,gasLeft,gasPrice,reservedGas,basePubdataSpent,gasPerPubdata) -> finalRefund {setTxOrigin(BOOTLOADER_FORMAL_ADDR())finalRefund := 0let innerTxDataOffset := add(txDataOffset, 32)let paymaster := getPaymaster(innerTxDataOffset)let refundRecipient := 0switch paymastercase 0 {// No paymaster means that the sender should receive the refundrefundRecipient := getFrom(innerTxDataOffset)}default {refundRecipient := paymasterif gt(gasLeft, 0) {checkEnoughGas(gasLeft)let nearCallAbi := getNearCallABI(gasLeft)let gasBeforePostOp := gas()pop(ZKSYNC_NEAR_CALL_callPostOp(// Maximum number of gas that the postOp could spendnearCallAbi,paymaster,txDataOffset,success,// Since the paymaster will be refunded with reservedGas,// it should know about it@>                          safeAdd(gasLeft, reservedGas, "jkl"),basePubdataSpent,reservedGas,gasPerPubdata))let gasSpentByPostOp := sub(gasBeforePostOp, gas())gasLeft := saturatingSub(gasLeft, gasSpentByPostOp)}}// It was expected that before this point various `isNotEnoughGasForPubdata` methods would ensure that the user// has enough funds for pubdata. Now, we just subtract the leftovers from the user.@>              let spentOnPubdata := getErgsSpentForPubdata(basePubdataSpent,gasPerPubdata)let totalRefund := saturatingSub(add(reservedGas, gasLeft), spentOnPubdata)askOperatorForRefund(totalRefund,spentOnPubdata,gasPerPubdata)let operatorProvidedRefund := getOperatorRefundForTx(transactionIndex)// If the operator provides the value that is lower than the one suggested for// the bootloader, we will use the one calculated by the bootloader.let refundInGas := max(operatorProvidedRefund, totalRefund)// The operator cannot refund more than the gasLimit for the transactionif gt(refundInGas, getGasLimit(innerTxDataOffset)) {assertionError("refundInGas > gasLimit")}if iszero(validateUint32(refundInGas)) {assertionError("refundInGas is not uint32")}let ethToRefund := safeMul(refundInGas,gasPrice,"fdf")directETHTransfer(ethToRefund, refundRecipient)finalRefund := refundInGas}
paymaster's_maxRefundedGas = gasLeft + reservedGas, without subtractingspentOnPubdata.
This way_maxRefundedGaswill be much larger than the correct value.
paymasterwill refund the usedspentOnPubdatato the user.
Impact
paymasterwill refund thespentOnPubdataalready used by the user.
Recommended Mitigation
function refundCurrentL2Transaction(txDataOffset,transactionIndex,success,gasLeft,gasPrice,reservedGas,basePubdataSpent,gasPerPubdata) -> finalRefund {setTxOrigin(BOOTLOADER_FORMAL_ADDR())finalRefund := 0let innerTxDataOffset := add(txDataOffset, 32)let paymaster := getPaymaster(innerTxDataOffset)let refundRecipient := 0switch paymastercase 0 {// No paymaster means that the sender should receive the refundrefundRecipient := getFrom(innerTxDataOffset)}default {refundRecipient := paymaster+                   let expectSpentOnPubdata := getErgsSpentForPubdata(+                        basePubdataSpent,+                        gasPerPubdata+                    )if gt(gasLeft, 0) {checkEnoughGas(gasLeft)let nearCallAbi := getNearCallABI(gasLeft)let gasBeforePostOp := gas()pop(ZKSYNC_NEAR_CALL_callPostOp(// Maximum number of gas that the postOp could spendnearCallAbi,paymaster,txDataOffset,success,// Since the paymaster will be refunded with reservedGas,// it should know about it-                           safeAdd(gasLeft, reservedGas, "jkl"),+                           saturatingSub(add(reservedGas, gasLeft), expectSpentOnPubdata),basePubdataSpent,reservedGas,gasPerPubdata))let gasSpentByPostOp := sub(gasBeforePostOp, gas())gasLeft := saturatingSub(gasLeft, gasSpentByPostOp)}}// It was expected that before this point various `isNotEnoughGasForPubdata` methods would ensure that the user// has enough funds for pubdata. Now, we just subtract the leftovers from the user.let spentOnPubdata := getErgsSpentForPubdata(basePubdataSpent,gasPerPubdata)let totalRefund := saturatingSub(add(reservedGas, gasLeft), spentOnPubdata)askOperatorForRefund(totalRefund,spentOnPubdata,gasPerPubdata)let operatorProvidedRefund := getOperatorRefundForTx(transactionIndex)// If the operator provides the value that is lower than the one suggested for// the bootloader, we will use the one calculated by the bootloader.let refundInGas := max(operatorProvidedRefund, totalRefund)// The operator cannot refund more than the gasLimit for the transactionif gt(refundInGas, getGasLimit(innerTxDataOffset)) {assertionError("refundInGas > gasLimit")}if iszero(validateUint32(refundInGas)) {assertionError("refundInGas is not uint32")}let ethToRefund := safeMul(refundInGas,gasPrice,"fdf")directETHTransfer(ethToRefund, refundRecipient)finalRefund := refundInGas}
Assessed type
Context
saxenism (zkSync) confirmed, but disagreed with severity and commented:
We confirm the finding. It is good.We however believe that this is a medium severity issue since this is a rarely used functionality.
0xsomeone (judge) commented:
The Warden has identified a discrepancy in the way paymaster refunds are processed for L2 transactions, resulting in an over-compensation that overlaps with the gas spent on public data.The exhibit is correct, and I am not in complete agreement with the Sponsor’s assessment in relation to the submission’s severity. The referenced code will trigger if a paymaster has been defined, and I do not believe there is any constraint that permits a malicious user fromalways triggering the surplus refundand thusfrom slowly siphoning funds in the form of gas from the system.As the flawis always presentand its impactis properly considered medium, I consider the combination of those two factors to merit ahigh severity rating.

