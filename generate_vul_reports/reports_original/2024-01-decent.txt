[H-01] Anyone can update the address of the Router in the DcntEth contract to any address they would like to set.
Submitted byNPCsCorp, also found byseraviz,dutra,0xSimeon,EV_om,azanux,Aymen0909,0xprinc,ZdravkoHr,0x11singh99,CDSecurity,nuthan2x,GhK3Ndf,0xAadi,Eeyore, ZanyBonzy (1,2),DadeKuma,Matue,Timeless,Giorgio,slylandro_star,0xdice91,Nikki,ke1caM,cu5t0mpeo,Greed,nobody2018,Tendency,Inference,al88nsk,DarkTower,th13vn,Soliditors,Timenov,wangxx2026,NentoR,ether_sky,peanuts,MrPotatoMagic,ravikiranweb3,mrudenko,Kaysoft,deth,0xBugSlayer,nmirchev8,GeekyLumberjack,Aamir,adeolu,stealth,simplor,PUSH0,0xabhay,darksnow,haxatron,m4ttm,0xE1,boredpukar,abiih,0xSmartContract,bareli, mgf15 (1,2,3,4),vnavascues,d4r3d3v1l,zaevlad,0xPluto,rouhsamad,Krace,kodyvim,Tigerfrake,JanuaryPersimmon2024, andpiyushshukla
By allowing anybody to set the address of the Router contract to any address they want to set it allows malicious users to get access to the mint and burn functions of the DcntEth contract.
Proof of Concept
TheDcntEth::setRouter() functionhas not an access control to restrict who can call this function. This allows anybody to set the address of the router contract to any address they’d like to set it.
DcntEth.sol
//@audit-issue => No access control to restrict who can set the address of the router contractfunctionsetRouter(address_router)public{router=_router;}
The functionsDcntEth::mint() function&DcntEth::burn() functioncan be called only by the router contract.
DcntEth.sol
//@audit-info => Only the router can call the mint()functionmint(address_to,uint256_amount)publiconlyRouter{_mint(_to,_amount);}//@audit-info => Only the router can call the burn()functionburn(address_from,uint256_amount)publiconlyRouter{_burn(_from,_amount);}
A malicious user can set the address of the router contract to an account of their own and:
Gain access to mint unlimited amounts of DcntEth token, which could be used to disrupt the crosschain accounting mechanism, or to steal the deposited weth in the DecentEthRouter contract.Burn all the DcntEth tokens that were issued to the DecentEthRouter contract when liquidity providers deposited their WETH or ETH into it.Cause a DoS to the add and remove liquidity functions of the DecentEthRouter contract. All of these functions end up calling theDcntEth::mint() functionor theDcntEth::burn() function, if the router address is set to be different than the address of the DecentEthRouter, all the calls made from the DecentEthRouter to the DcnEth contract will revert.
DecentEthRouter.sol
/// @inheritdoc IDecentEthRouterfunctionaddLiquidityEth()publicpayableonlyEthChainuserDepositing(msg.value){weth.deposit{value:msg.value}();//@audit-issue => If router in the dcnteth contract is not set to the address of the DecentEthRouter, this call will revertdcntEth.mint(address(this),msg.value);}/// @inheritdoc IDecentEthRouterfunctionremoveLiquidityEth(uint256amount)publiconlyEthChainuserIsWithdrawing(amount) {//@audit-issue => If router in the dcnteth contract is not set to the address of the DecentEthRouter, this call will revertdcntEth.burn(address(this),amount);weth.withdraw(amount);payable(msg.sender).transfer(amount);}/// @inheritdoc IDecentEthRouterfunctionaddLiquidityWeth(uint256amount)publicpayableuserDepositing(amount) {weth.transferFrom(msg.sender,address(this),amount);//@audit-issue => If router in the dcnteth contract is not set to the address of the DecentEthRouter, this call will revertdcntEth.mint(address(this),amount);}/// @inheritdoc IDecentEthRouterfunctionremoveLiquidityWeth(uint256amount)publicuserIsWithdrawing(amount) {//@audit-issue => If router in the dcnteth contract is not set to the address of the DecentEthRouter, this call will revertdcntEth.burn(address(this),amount);weth.transfer(msg.sender,amount);}
Recommended Mitigation Steps
Make sure to add an Acess Control mechanism to limit who can set the address of the Router in the DcnEth contract.
0xsomeone (Judge) commented:
This and all relevant submissions correctly specify that the lack of access control in theDcntEth::setRouterfunction can be exploited maliciously and effectively compromise the entire TVL of the Decent ETH token.A high-risk severity is appropriate, and this submission was selected as the best due to detailing all possible impacts:Arbitrary mints of the token to withdraw funds provided as liquidity toUTBArbitrary burns to sabotage liquidity pools and other escrow-based contractsSabotage of liquidity provision function invocations
wkantaros (Decent) confirmed

[H-02] Due to missing checks on minimum gas passed through LayerZero, executions can fail on the destination chain
Submitted byiamandreiski, also found byNPCsCorp,EV_om, windhustler (1,2), andnuthan2x
https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L148-L194
https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L80-L111
In LayerZero, the destination chain’s function call requires a specific gas amount; otherwise, it will revert with an out-of-gas exception. It falls under the responsibility of the User Application to ensure that appropriate limits are established. These limits guide relayers in specifying the correct gas amount on the source chain, preventing users from inputting insufficient values for gas.
The contract logic inDecentEthRouter, assumes that a user will first get their estimated fees throughestimateSendAndCallFee()and pass it as an argument in eitherbridge()orbridgeWithPayload()to be added to the calculation together with the hardcodedGAS_FOR_RELAYso that it can be passed as the adapter params whenCommonOFT.LzCallParamsis called, although this is not enforced and is left on the user’s responsibility.
A user can pass an arbitrary value as the_dstGasForCallargument to be added to the hardcodedGAS_FOR_RELAYfee, thus sending less gas than required which can lead to out-of-gas exceptions.
Once the message is received by destination, the message is considered delivered (transitioning from INFLIGHT to either SUCCESS or STORED), even though it threw an out-of-gas error.
Any uncaught errors/exceptions (including out-of-gas) will cause the message to transition into STORED. A STORED message will block the delivery of any future message from source to all destination on the same destination chain and can be retried until the message becomes SUCCESS.
As per:https://layerzero.gitbook.io/docs/faq/messaging-properties
Proof of Concept
According to the LayerZero integration checklist:https://layerzero.gitbook.io/docs/troubleshooting/layerzero-integration-checklist
LayerZero recommends a 200,000 amount of gas to be enough for most chains and is set as default.
“200k for OFT for all EVMs except Arbitrum is enough. For Arbitrum, set as 2M.”
In the DecentEthRouter, theGAS_FOR_RELAYis hardcoded at 100,000.
uint256 GAS_FOR_RELAY = 100000;uint256 gasAmount = GAS_FOR_RELAY + _dstGasForCall;
The contract logic assumes that a user would willingly first call theestimateSendAndCallFeeto get thenativeFee+ thezroFeefomdcntEth.estimateSendAndCallFeeand then pass the addition of the nativeFee + zeroFee as the_dstGasForCallargument when callingbridge()orbridgeWithPayload():
function bridgeWithPayload(uint16 _dstChainId,address _toAddress,uint _amount,bool deliverEth,uint64 _dstGasForCall,bytes memory additionalPayload) public payable {return_bridgeWithPayload(MT_ETH_TRANSFER_WITH_PAYLOAD,_dstChainId,_toAddress,_amount,_dstGasForCall,additionalPayload,deliverEth);}
Once the internal_bridgeWithPayloadfunction is called:
bytes32 destinationBridge,bytes memory adapterParams,bytes memory payload) = _getCallParams(msgType,_toAddress,_dstChainId,_dstGasForCall,deliverEth,additionalPayload);ICommonOFT.LzCallParams memory callParams = ICommonOFT.LzCallParams({refundAddress: payable(msg.sender),zroPaymentAddress: address(0x0),adapterParams: adapterParams});
It calls the_getCallParamsfunction which will calculate and pack the needed arguments to be passed as the LayerZero call params, without performing any checks whether the total gas amount is sufficient or that the user passed argument_dstGasForCallis greater than the total of(uint nativeFee, uint zroFee) = dcntEth.estimateSendAndCallFee.
function _getCallParams(uint8 msgType,address _toAddress,uint16 _dstChainId,uint64 _dstGasForCall,bool deliverEth,bytes memory additionalPayload)privateviewreturns (bytes32 destBridge,bytes memory adapterParams,bytes memory payload){uint256 GAS_FOR_RELAY = 100000;uint256 gasAmount = GAS_FOR_RELAY + _dstGasForCall;adapterParams = abi.encodePacked(PT_SEND_AND_CALL, gasAmount);
This can lead to failed messages on the destination. Which would yield the above-message results of a possible blockage in the communication with the source and destination.
A malicious or an unbeknownst user can pass 1,000 as an argument for_dstGasForCall, making the total gas forwarded to theLzCallParams()101,000 which will make a certain type of calls fail (depending on payload), and especially calls made on Arbitrum.
Recommended Mitigation Steps
Validate/require that the_dstGasForCallparameter is greater thannativeFee+zroFeeor re-engineer the architecture to make theestimateSendAndCallFee()function a mandatory step of the process.
0xsomeone (Judge) increased severity to High and commented:
This and all duplicate exhibits highlight that theGAS_FOR_RELAYis a hard-coded value and that the overall gas supplied for a cross-chain call can be controlled by a user.A severity of high is appropriate given that the cross-chain LayerZero channel will be permanently blocked.None of the submissions have correctly proposed a solution as a mere adjustment of theGAS_FOR_RELAYis insufficient. TheDecentBridgeExecutorpermits arbitrary calls to be made that can force the transaction to run out-of-gas regardless of the gas limit imposed. This is properly defined in#697.A valid solution for this problem would be a combination of a minimum enforced at the transaction level and a maximum gas consumed enforced at the executor level, ensuring that the gas remainderafter the executor performs the arbitrary callis enough to store the failed message. This can be achieved by performing a subtraction from thegasleftvalue (hard to implement as it would need to take into account the cost ofkeccak256encoding the data payload) or by enforcing a fixed value that should be much less than the minimum imposed on the source chain.This submission was selected as the best given that it illustrates in-depth knowledge of the LayerZero system states and correctly highlights that a user can also maliciously block the channel.
wkantaros (Decent) acknowledged via duplicate #212, but disagreed with severity and commented:
This vulnerability is not a concern in Layer Zero v2. Decent designed the contracts expecting to use LZ v2 and have since implemented this upgrade.

[H-03] WhenDecentBridgeExecutor.executefails, funds will be sent to a random address
Submitted byDadeKuma, also found byNPCsCorp,MrPotatoMagic,SBSecurity,deth,nmirchev8,Tendency,ether_sky,Kow,haxatron,EV_om,0xJaeger,ZdravkoHr,Giorgio,Soliditors,Aamir,Eeyore,Inference, andkutugu
https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentEthRouter.sol#L101-L105
https://github.com/decentxyz/decent-bridge/blob/7f90fd4489551b69c20d11eeecb17a3f564afb18/src/DecentBridgeExecutor.sol#L63
When theDecentBridgeExecutor._executeWeth/_executeEthtarget call fails, a refund is issued to thefromaddress.
However, this address is wrongly set, so those refunds will be permanently lost.
Proof of Concept
UTB.bridgeAndExecute(Link) callsDecentBridgeAdapter.bridge(Link), which callsDecentEthRouter.bridgeWithPayload(Link), where the payload is constructed (Link):
function_bridgeWithPayload(uint8msgType,uint16_dstChainId,address_toAddress,uint_amount,uint64_dstGasForCall,bytesmemoryadditionalPayload,booldeliverEth)internal{(bytes32destinationBridge,bytesmemoryadapterParams,bytesmemorypayload) =_getCallParams(msgType,_toAddress,_dstChainId,_dstGasForCall,deliverEth,additionalPayload);...
Inside_getCallParamsthefromaddress is themsg.sender, i.e. theDecentBridgeAdapteraddress on the source chain (Link):
function_getCallParams(uint8msgType,address_toAddress,uint16_dstChainId,uint64_dstGasForCall,booldeliverEth,bytesmemoryadditionalPayload)privateviewreturns(bytes32destBridge,bytesmemoryadapterParams,bytesmemorypayload){uint256GAS_FOR_RELAY=100000;uint256gasAmount=GAS_FOR_RELAY+_dstGasForCall;adapterParams=abi.encodePacked(PT_SEND_AND_CALL,gasAmount);destBridge=bytes32(abi.encode(destinationBridges[_dstChainId]));if(msgType==MT_ETH_TRANSFER) {@>payload=abi.encode(msgType,msg.sender,_toAddress,deliverEth);}else{payload=abi.encode(msgType,@>msg.sender,//@audit 'from' address_toAddress,deliverEth,additionalPayload);}}
After the payload is constructed,DecentEthRoutersends the message:
dcntEth.sendAndCall{value:gasValue}(address(this),// from address that has dcntEth (so DecentRouter)_dstChainId,destinationBridge,// toAddress_amount,// amountpayload,//payload (will have recipients address)_dstGasForCall,// dstGasForCallcallParams// refundAddress, zroPaymentAddress, adapterParams);
Finally, on the destination chain,DecentEthRouterwill receive the message (Link):
functiononOFTReceived(uint16_srcChainId,bytescalldata,uint64,bytes32,uint_amount,bytesmemory_payload)externaloverrideonlyLzApp{//@audit from is the decentBridgeAdapter address on the source chain(uint8msgType,address_from,address_to,booldeliverEth) =abi.decode(_payload, (uint8,address,address,bool));...}
At the end of this function, theexecutoris invoked with the same_fromaddress:
}else{weth.approve(address(executor),_amount);executor.execute(_from,_to,deliverEth,_amount,callPayload);}
Finally, this is theexecutefunction inDecentBridgeExecutor(Link):
functionexecute(addressfrom,addresstarget,booldeliverEth,uint256amount,bytesmemorycallPayload)publiconlyOwner{weth.transferFrom(msg.sender,address(this),amount);if(!gasCurrencyIsEth|| !deliverEth) {_executeWeth(from,target,amount,callPayload);}else{_executeEth(from,target,amount,callPayload);}}
Both_executeWethand_executeEthhave the same issue and funds will be lost when the target call fails, for example_executeEth(Link):
function_executeEth(addressfrom,addresstarget,uint256amount,bytesmemorycallPayload)private{weth.withdraw(amount);(boolsuccess, ) =target.call{value:amount}(callPayload);if(!success) {@>payable(from).transfer(amount);//@audit wrong address as it uses the source address, not destination}}
Now,DecentBridgeAdapteras a refund address seems wrong, as I disclosed in another issue, but let’s suppose that it isn’t, as it’s possible to prove both scenarios.
As proof by contradiction, funds should be sent toDecentBridgeAdapter, and this would be a non-issue if these contracts are deployed withCREATE2, as they would have the same address. But they are not deployed like that.
There is hard evidence that they have different addresses, for example, these are the addresses forDcntEthandDecentEthRouterin two different chains, which are already deployed:
lib/decent-bridge/actual-deployments/latest/arbitrumAddresses.json
{"arbitrum_DcntEth":"0x8450e1A0DebF76fd211A03c0c7F4DdbB1eEF8A85","done":true,"arbitrum_DecentEthRouter":"0x17479B712A1FE1FFaeaf155379DE3ad1440fA99e"}
lib/decent-bridge/actual-deployments/latest/optimismAddresses.json
{"DcntEth":"0x4DB4ea27eA4b713E766bC13296A90bb42C5438D0","done":true,"DecentEthRouter":"0x57beDF28C3CB3F019f40F330A2a2B0e0116AA0c2"}
If we take a look at the deploy script forDecentBridgeAdapterit also doesn’t useCREATE2, as there isn’t a factory:
functiondeployDecentBridgeAdapter(addressutb,addressdecentEthRouter,addressdecentBridgeExecutor)internalreturns(DecentBridgeAdapterdecentBridgeAdapter) {stringmemorychain=vm.envString("CHAIN");boolgasIsEth=gasEthLookup[chain];addressweth=wethLookup[chain];addressbridgeToken=gasIsEth?address(0) :weth;@>decentBridgeAdapter=newDecentBridgeAdapter(gasIsEth,bridgeToken);decentBridgeAdapter.setUtb(utb);decentBridgeAdapter.setRouter(decentEthRouter);decentBridgeAdapter.setBridgeExecutor(decentBridgeExecutor);UTB(payable(utb)).registerBridge(address(decentBridgeAdapter));}
So these funds will be sent to a random address in any case.
Recommended Mitigation Steps
Theexecutor.executecall inDecentEthRouter.onOFTReceivedshould be changed to an appropriate address (e.g. the user refund address) instead of using_from:
}else{weth.approve(address(executor),_amount);executor.execute(_from,_to,deliverEth,_amount,callPayload);}
0xsomeone (Judge) commented:
The Warden has detailed how the encoding of the cross-chain payload will use an incorrect_fromparameter under normal operating conditions, leading to failed transfers at the target chain refunding the wrong address.This submission was selected as the best given that it precisely details that the_fromaddress is known to be incorrect at all times when the protocol is used normally.A high-risk rating is appropriate as any failed call will lead tofull fund loss for the cross-chain call.
wkantaros (Decent) confirmed

[H-04] Users will lose their cross-chain transaction if the destination router do not have enough WETH reserves.
Submitted byhaxatron, also found byEV_om,MrPotatoMagic,deth,rouhsamad,Aamir,Topmark, andbart1e
When the DecentEthRouter receives the dcntEth OFT token from a cross-chain transaction, if the WETH balance of the destination router is less than amount of dcntEth received (this could be due to the router receiving more cross-chain transactions than than sending cross-chain transactions which depletes its WETH reserves), then the dcntEth will get transferred to the address specified by_to.
DecentEthRouter.sol#L266-L281
functiononOFTReceived(uint16_srcChainId,bytescalldata,uint64,bytes32,uint_amount,bytesmemory_payload)externaloverrideonlyLzApp{...if(weth.balanceOf(address(this)) <_amount) {=>dcntEth.transfer(_to,_amount);return;}if(msgType==MT_ETH_TRANSFER) {if(!gasCurrencyIsEth|| !deliverEth) {weth.transfer(_to,_amount);}else{weth.withdraw(_amount);payable(_to).transfer(_amount);}}else{weth.approve(address(executor),_amount);executor.execute(_from,_to,deliverEth,_amount,callPayload);}}
This dcntEth is sent to the user so that they can either redeem the WETH / ETH from the router once the WETH balance is refilled or send it back to the source chain to redeem back the WETH.
The problem is that if the msgType != MTETHTRANSFER, then the_toaddress is not the user, it is instead the target meant to be called by the destination chain’s bridge executor (if the source chain uses a decent bridge adapter, the target is always the destination chain’s bridge adapter which does not have a way to withdraw the dcntEth).
The following snippet shows what occurs in the bridge executor (_executeEthomitted as it does largely the same thing as_executeWeth):
DecentBridgeExecutor.sol#L24-L82
function_executeWeth(addressfrom,addresstarget,uint256amount,bytesmemorycallPayload)private{uint256balanceBefore=weth.balanceOf(address(this));weth.approve(target,amount);(boolsuccess, ) =target.call(callPayload);if(!success) {weth.transfer(from,amount);return;}uint256remainingAfterCall=amount-(balanceBefore-weth.balanceOf(address(this)));// refund the sender with excess WETHweth.transfer(from,remainingAfterCall);}...functionexecute(addressfrom,addresstarget,booldeliverEth,uint256amount,bytesmemorycallPayload)publiconlyOwner{weth.transferFrom(msg.sender,address(this),amount);if(!gasCurrencyIsEth|| !deliverEth) {_executeWeth(from,target,amount,callPayload);}else{_executeEth(from,target,amount,callPayload);}}
Therefore, once the dcntEth is transferred to the execution target (which is almost always the destination chain bridge adapter, see Appendix for the code walkthrough). The user cannot do anything to retrieve the dcntEth out of the execution target, so the cross-chain transaction is lost.
Recommended Mitigation Steps
Pass a destination chain refund address into the payload sent cross-chain and replace the_toaddress used inDecentEthRouter.sol#L267:
if(weth.balanceOf(address(this)) <_amount) {// REPLACE '_to' with the destination chain refund address=>dcntEth.transfer(_to,_amount);return;}
AppendixTo see why the target is always the destination bridge adapter if the source chain is a decent bridge adapter:UTB.sol will first call thebridgefunction in the adapter with the destination bridge adapter address as the 2nd argument.DecentBridgeAdapter.sol#L117C1-L124C11functionbridge(...router.bridgeWithPayload{value:msg.value}(lzIdLookup[dstChainId],destinationBridgeAdapter[dstChainId],swapParams.amountIn,false,dstGas,bridgePayload);}Which calls the below function in the router, where the_toAddressis the 2nd argument and therefore is the destination bridge adapter address:DecentEthRouter.sol#L196C1-L204C23/// @inheritdoc IDecentEthRouterfunctionbridgeWithPayload(uint16_dstChainId,address_toAddress,uint_amount,booldeliverEth,uint64_dstGasForCall,bytesmemoryadditionalPayload)publicpayable{return_bridgeWithPayload(MT_ETH_TRANSFER_WITH_PAYLOAD,_dstChainId,_toAddress,_amount,_dstGasForCall,additionalPayload,deliverEth);...which calls_bridgeWithPayloadwhich calls_getCallParamsto encode the payload to send to the destination chain:DecentEthRouter.sol#L148C1-L168C15function_bridgeWithPayload(uint8msgType,uint16_dstChainId,address_toAddress,uint_amount,uint64_dstGasForCall,bytesmemoryadditionalPayload,booldeliverEth)internal{(bytes32destinationBridge,bytesmemoryadapterParams,bytesmemorypayload) =_getCallParams(msgType,_toAddress,_dstChainId,_dstGasForCall,deliverEth,additionalPayload);...The_toAddressparameter is always the 3rd parameter in the payload sent.DecentEthRouter.sol#L101-L110function _getCallParams...if (msgType == MT_ETH_TRANSFER) {payload = abi.encode(msgType, msg.sender, _toAddress, deliverEth);} else {payload = abi.encode(msgType,msg.sender,_toAddress,deliverEth,additionalPayload);}...Which matches_tovariable inonOFTReceivedDecentEthRouter.sol#L236/// @inheritdoc IOFTReceiverV2functiononOFTReceived(uint16_srcChainId,bytescalldata,uint64,bytes32,uint_amount,bytesmemory_payload)externaloverrideonlyLzApp{(uint8msgType,address_from,address_to,booldeliverEth) =abi.decode(_payload, (uint8,address,address,bool));bytesmemorycallPayload="";if(msgType==MT_ETH_TRANSFER_WITH_PAYLOAD) {(, , , ,callPayload) =abi.decode(_payload,(uint8,address,address,bool,bytes));}...
wkantaros (Decent) confirmed but disagreed with severity
0xsomeone (Judge) commented:
This and all duplicate submissions detail an interesting way in which cross-chain relays will fail to properly invoke the target recipient of the relayed call, effectively leading to loss of funds as the assets will be transferred to an entity that potentially is not equipped to handle the token.Based on discussions in#505, this is a very likely scenario and thus a high-risk severity is appropriate as the vulnerability should manifest consistently in non-Ethereum chains.

