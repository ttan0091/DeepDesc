[H-01] InLlamaRelativeQuorum, the governance result might be incorrect as it counts the wrong approval/disapproval
Submitted byauditor0517, also found byToshii,kutugu,0xnev, andT1MOH
https://github.com/code-423n4/2023-06-llama/blob/9d641b32e3f4092cc81dbac7b1c451c695e78983/src/strategies/LlamaRelativeQuorum.sol#L223https://github.com/code-423n4/2023-06-llama/blob/9d641b32e3f4092cc81dbac7b1c451c695e78983/src/strategies/LlamaRelativeQuorum.sol#L242
Proof of Concept
TheLlamaRelativeQuorumuses approval/disapproval thresholds that are specified as percentages of total supply and the approval/disapproval supplies are set atvalidateActionCreation()during the action creation.
functionvalidateActionCreation(ActionInfocalldataactionInfo)external{LlamaPolicyllamaPolicy=policy;// Reduce SLOADs.uint256approvalPolicySupply=llamaPolicy.getRoleSupplyAsNumberOfHolders(approvalRole);if(approvalPolicySupply==0)revertRoleHasZeroSupply(approvalRole);uint256disapprovalPolicySupply=llamaPolicy.getRoleSupplyAsNumberOfHolders(disapprovalRole);if(disapprovalPolicySupply==0)revertRoleHasZeroSupply(disapprovalRole);// Save off the supplies to use for checking quorum.actionApprovalSupply[actionInfo.id] =approvalPolicySupply;actionDisapprovalSupply[actionInfo.id] =disapprovalPolicySupply;}
As we can see,actionApprovalSupplyandactionDisapprovalSupplyare set usinggetRoleSupplyAsNumberOfHolderswhich means the total number of role holders.
But while counting fortotalApprovals/totalDisapprovalsingetApprovalQuantityAt()/getDisapprovalQuantityAt(), it adds the quantity instead of role holders(1 for each holder).
functiongetApprovalQuantityAt(addresspolicyholder,uint8role,uint256timestamp)externalviewreturns(uint128) {if(role!=approvalRole&& !forceApprovalRole[role])return0;uint128quantity=policy.getPastQuantity(policyholder,role,timestamp);returnquantity>0&&forceApprovalRole[role] ?type(uint128).max:quantity;//@audit should return supply, not quantity}
So the governance result would be wrong with the below example.
There are 3 role holders(Alice, Bob, Charlie) and Alice has 2 quantities, others have 1.During the action creation with theLlamaRelativeQuorumstrategy,actionApprovalSupply = 3and there should be 2 approved holders at least whenminApprovalPct = 51%.But if Alice approves the action, the result ofgetApprovalQuantityAt()will be 2 and the action will be approved with only one approval.
It’s becausegetApprovalQuantityAt()return the quantity althoughactionApprovalSupplyequalsNumberOfHolders.
Recommended Mitigation Steps
getApprovalQuantityAt()andgetDisapprovalQuantityAt()should return 1 instead ofquantityfor the positive quantity.
I think we can modify these functions like below.
functiongetApprovalQuantityAt(addresspolicyholder,uint8role,uint256timestamp)externalviewreturns(uint128) {if(role!=approvalRole&& !forceApprovalRole[role])return0;uint128quantity=policy.getPastQuantity(policyholder,role,timestamp);if(quantity>1)quantity=1;returnquantity>0&&forceApprovalRole[role] ?type(uint128).max:quantity;}functiongetDisapprovalQuantityAt(addresspolicyholder,uint8role,uint256timestamp)externalviewreturns(uint128){if(role!=disapprovalRole&& !forceDisapprovalRole[role])return0;uint128quantity=policy.getPastQuantity(policyholder,role,timestamp);if(quantity>1)quantity=1;returnquantity>0&&forceDisapprovalRole[role] ?type(uint128).max:quantity;}
AustinGreen (Llama) disputed and commented:
This is actually how we intend this strategy to work but we’re open to feedback! Here’s an example:An instance has 10 role holders and a 50% min approval percentage. Each role holder’s quantity is 1, so 5 role holders can approve this action.2 of the role holders have their quantity increased to 2.This means that if each of these role holders cast approvals, then their approval power will count as 4. That means just one other role holder is needed to cast approval to approve the action.In this system quantity can be used to provide granular approval weights to role holders.
gzeon (Judge) commented:
@AustinGreen- I don’t think this make sense. Sure, if each holder’s quantity is 1, thengetRoleSupplyis same asgetRoleSupplyAsNumberOfHoldersand what you said is valid. However, if you have 10 holders each with quantity 10 at snapshot, then youractionApprovalSupplyis set to 10 (number of holder) and any of their approval (10 quantity) would hit quorum.
AustinGreen (Llama) commented:
@gzeon- Yes that’s exactly how the design is intended to work!
gzeon (Judge) commented:
@AustinGreen- This sounds weird, is this design documented anywhere? From what I can see in the code comments it seems to be hard for anyone (including potential user/dao) to understand such logic.In the code, there is a commentMinimum percentage oftotalApprovalQuantity / totalApprovalSupplyAtCreationTimerequired for the action to be queuedI think it is fair for one to assumetotalApprovalQuantityandtotalApprovalSupplyAtCreationTimewould be using the same metric, instead of one using the raw count and the other usingAsNumberOfHolders.
AustinGreen (Llama) commented:
Although this is the intended design for this strategy, we decided to create an additional strategy that Llama instances can adopt that follows the warden’s recommendations. It uses total (dis)approval quantity for the quorum calculation as specified.

[H-02] Anyone can change approval/disapproval threshold for any action using LlamaRelativeQuorum strategy
Submitted byktg, also found byauditor0517anddirk_y
Proof of Concept
When a new action is created withLlamaRelativeQuorumstrategy,LlamaCorewill call functionvalidateActionCreationwhich is currently implemented as below:
function validateActionCreation(ActionInfo calldata actionInfo) external {LlamaPolicy llamaPolicy = policy; // Reduce SLOADs.uint256 approvalPolicySupply = llamaPolicy.getRoleSupplyAsNumberOfHolders(approvalRole);if (approvalPolicySupply == 0) revert RoleHasZeroSupply(approvalRole);uint256 disapprovalPolicySupply = llamaPolicy.getRoleSupplyAsNumberOfHolders(disapprovalRole);if (disapprovalPolicySupply == 0) revert RoleHasZeroSupply(disapprovalRole);// Save off the supplies to use for checking quorum.actionApprovalSupply[actionInfo.id] = approvalPolicySupply;actionDisapprovalSupply[actionInfo.id] = disapprovalPolicySupply;}
The last 2 lines of code is toSave off the supplies to use for checking quorum. The 2 variablesactionApprovalSupplyandactionDisapprovalSupplyare described asMapping of action ID to the supply of the approval/disapproval role at the time the action was created.
This means the strategy will save the total supply of approval/disapproval role at creation time and then use them to calculate the approval/disapproval threshold, which equals to (approval/disapproval percentage) * (total supply of approval/disapproval).
However, since the functionvalidateActionCreation’s scope isexternaland does not require any privilege to be called, any user can call this function and update the total supply of approval/disapproval role to the current timestamp and break the intention to keep total supply of approval/disapproval roleat the time the action was created. This issue is highly critical because many Llama protocol’s functions depend on these 2 variables to function as intended.
For example, if the total supply of approval role is 10 at the creation of action and theminApprovalPct= 100% - which means requires all policy holders to approve the action to pass it.
If it then be casted 9 votes (1 vote short), the action’s state is still Active (not approved yet).
However, if 1 user is revoked their approval/role, anyone can call functionvalidateActionCreationand update the required threshold to 9 votes and thus the action’s state becomes Approved.
Below is a POC for the above example, for ease of testing, place this test case under fileLlamaStrategy.t.sol, contractIsActionApproved:
function testAnyoneCanChangeActionApprovalSupply() public {// Deploy a relative quorum strategyuint256 numberOfHolders = 10;// Assign 10 users role of TestRole1for (uint256 i=0; i< numberOfHolders; i++){address _policyHolder = address(uint160(i + 100));if (mpPolicy.balanceOf(_policyHolder) == 0) {vm.prank(address(mpExecutor));mpPolicy.setRoleHolder(uint8(Roles.TestRole1), _policyHolder, 1, type(uint64).max);}}// Create  a LlamaRelativeQuorum strategy// in this minApprovalPct = 10_000 (meaning we require all 10 policyholders to approve)LlamaRelativeQuorum.Config memory testStrategyData = LlamaRelativeQuorum.Config({approvalPeriod: 2 days,queuingPeriod: 2 days,expirationPeriod: 8 days,isFixedLengthApprovalPeriod: true,minApprovalPct: 10000, // require all policyholder to approveminDisapprovalPct: 2000,approvalRole: uint8(Roles.TestRole1),disapprovalRole: uint8(Roles.TestRole1),forceApprovalRoles: new uint8[](0),forceDisapprovalRoles: new uint8[](0)});ILlamaStrategy testStrategy = lens.computeLlamaStrategyAddress(address(relativeQuorumLogic), DeployUtils.encodeStrategy(testStrategyData), address(mpCore));LlamaRelativeQuorum.Config[] memory testStrategies= new LlamaRelativeQuorum.Config[](1);testStrategies[0] = testStrategyData;vm.prank(address(mpExecutor));mpCore.createStrategies(relativeQuorumLogic, DeployUtils.encodeStrategyConfigs(testStrategies));// create actionActionInfo memory actionInfo = createAction(testStrategy);assertEq(LlamaRelativeQuorum(address(testStrategy)).actionApprovalSupply(actionInfo.id), numberOfHolders);// Suppose that 9 policyholder approve// the action lacks 1 more approval vote so isActionApproved = falseapproveAction(9, actionInfo);assertEq(LlamaRelativeQuorum(address(testStrategy)).isActionApproved(actionInfo), false);// Revoke 1 uservm.prank(address(mpExecutor));mpPolicy.revokePolicy(address(100));// Now anyone can update the actionApprovalSupply and therefore// change the approval thresholdaddress anyOne = address(12345);vm.prank(anyOne);LlamaRelativeQuorum(address(testStrategy)).validateActionCreation(actionInfo);// The actionApproval for the above action is reduced to 9// and the action state changes to approvedassertEq(LlamaRelativeQuorum(address(testStrategy)).actionApprovalSupply(actionInfo.id), numberOfHolders - 1);assertEq(LlamaRelativeQuorum(address(testStrategy)).isActionApproved(actionInfo), true);}
Recommended Mitigation Steps
Since the intention is to keep valuesactionApprovalSupplyandactionDisapprovalSupplysnapshot at creation time for every action andLlamaCoreonly callvalidateActionCreationat creation time, I think the easiest way is to allow onlyllamaCoreto call this function.
AustinGreen (Llama) confirmed and commented:
This finding was addressed in this PR:https://github.com/llamaxyz/llama/pull/384(note our repo is private until we launch)

