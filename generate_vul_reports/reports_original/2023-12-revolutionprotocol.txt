[H-01] Incorrect amounts of ETH are transferred to the DAO treasury inERC20TokenEmitter::buyToken(), causing a value leak in every transaction
Submitted byosmanozdemir1, also found byshaka,SovaSlava,KupiaSec,MrPotatoMagic,ast3ros,BARW,0xDING99YA,0xCiphky,bart1e,ktg,AS,SpicyMeatball,hakymulla,plasmablocks,Abdessamed,0xlemon,twcctop,0xluckhu, andn1punp
While users buying governance tokens withERC20TokenEmitter::buyTokenfunction, some portion of the provided ETH is reserved for creators according to thecreatorRateBps.
A part of this creator’s reserved ETH is directly sent to the creators according toentropyRateBps, and the remaining part is used to buy governance tokens for creators.
That remaining part, which is used to buy governance tokens, is never sent to the DAO treasury. It is locked in theERC20Emittercontract, causing value leaks for treasury in everybuyTokenfunction call.
https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/ERC20TokenEmitter.sol#L190C1-L198C10
functionbuyToken(address[]calldataaddresses,uint[]calldatabasisPointSplits,ProtocolRewardAddressescalldataprotocolRewardsRecipients)publicpayablenonReentrantwhenNotPausedreturns(uint256tokensSoldWad) {// ...// Get value left after protocol rewardsuint256msgValueRemaining=_handleRewardsAndGetValueToSend(msg.value,protocolRewardsRecipients.builder,protocolRewardsRecipients.purchaseReferral,protocolRewardsRecipients.deployer);//Share of purchase amount to send to treasuryuint256toPayTreasury= (msgValueRemaining* (10_000-creatorRateBps)) /10_000;//Share of purchase amount to reserve for creators//Ether directly sent to creatorsuint256creatorDirectPayment= ((msgValueRemaining-toPayTreasury) *entropyRateBps) /10_000;//Tokens to emit to creatorsinttotalTokensForCreators= ((msgValueRemaining-toPayTreasury) -creatorDirectPayment) >0?getTokenQuoteForEther((msgValueRemaining-toPayTreasury) -creatorDirectPayment):int(0);// Tokens to emit to buyersinttotalTokensForBuyers=toPayTreasury>0?getTokenQuoteForEther(toPayTreasury) :int(0);//Transfer ETH to treasury and update emittedemittedTokenWad+=totalTokensForBuyers;if(totalTokensForCreators>0)emittedTokenWad+=totalTokensForCreators;//Deposit funds to treasury-->     (boolsuccess, ) =treasury.call{ value:toPayTreasury}(newbytes(0));//@audit-issue Treasury is not paid correctly. Only the buyers share is sent. Creators share to buy governance tokens are not sent to treasuryrequire(success,"Transfer failed.");//@audit `creators total share` - `creatorDirectPayment` should also be sent to treasury. ==> Which is "((msgValueRemaining - toPayTreasury) - creatorDirectPayment)"//Transfer ETH to creatorsif(creatorDirectPayment>0) {(success, ) =creatorsAddress.call{ value:creatorDirectPayment}(newbytes(0));require(success,"Transfer failed.");}// ... rest of the code}
In the code above:
toPayTreasuryis the buyer’s portion of the sent ether.(msgValueRemaining - toPayTreasury)is the creator’s portion of the sent ether.((msgValueRemaining - toPayTreasury) - creatorDirectPayment)is the remaining part of the creator’s share after direct payment(which is used to buy the governance token).
As we can see above, the part that is used to buy governance tokens is not sent to the treasury. Only the buyer’s portion is sent.
Impact
DAO treasury is not properly paid even though the corresponding governance tokens are minted.EverybuyTokentransaction will cause a value leak to the DAO treasury. The leaked ETH amounts are stuck in theERC20TokenEmittercontract.
Proof of Concept
Coded PoC
You can use the protocol’s own test suite to run this PoC.
-Copy and paste the snippet below into theERC20TokenEmitter.t.soltest file.-Run it withforge test --match-test testBuyToken_ValueLeak -vvv
functiontestBuyToken_ValueLeak()public{// Set creator and entropy rates.// Creator rate will be 10% and entropy rate will be 40%uint256creatorRate=1000;uint256entropyRate=5000;vm.startPrank(address(dao));erc20TokenEmitter.setCreatorRateBps(creatorRate);erc20TokenEmitter.setEntropyRateBps(entropyRate);// Check dao treasury and erc20TokenEmitter balances. Balance of both of them should be 0.uint256treasuryETHBalance_BeforePurchase=address(erc20TokenEmitter.treasury()).balance;uint256emitterContractETHBalance_BeforePurchase=address(erc20TokenEmitter).balance;assertEq(treasuryETHBalance_BeforePurchase,0);assertEq(emitterContractETHBalance_BeforePurchase,0);// Create token purchase parametersaddress[]memoryrecipients=newaddress[](1);recipients[0] =address(1);uint256[]memorybps=newuint256[](1);bps[0] =10_000;// Give some ETH to user and buy governance token.vm.startPrank(address(0));vm.deal(address(0),100000ether);erc20TokenEmitter.buyToken{ value:100ether}(recipients,bps,IERC20TokenEmitter.ProtocolRewardAddresses({builder:address(0),purchaseReferral:address(0),deployer:address(0)}));// User bought 100 ether worth of tokens.// Normally with 2.5% fixed protocol rewards, 10% creator share and 50% entropy share://  ->  2.5 ether is protocol rewards.//  ->  87.75 ether is buyer share (90% of the 97.5)//  ->  9.75 of the ether is creators share//          - 4.875 ether directly sent to creators//          - 4.875 ether should be used to buy governance token and should be sent to the treasury.// However, the 4.875 ether is never sent to the treasury even though it is used to buy governance tokens. It is stuck in the Emitter contract.// Check balances after purchase.uint256treasuryETHBalance_AfterPurchase=address(erc20TokenEmitter.treasury()).balance;uint256emitterContractETHBalance_AfterPurchase=address(erc20TokenEmitter).balance;uint256creatorETHBalance_AfterPurchase=address(erc20TokenEmitter.creatorsAddress()).balance;// Creator direct payment amount is 4.875 as expectedassertEq(creatorETHBalance_AfterPurchase,4.875ether);// Dao treasury has 87.75 ether instead of 92.625 ether.// 4.875 ether that is used to buy governance tokens for creators is never sent to treasury and still in the emitter contract.assertEq(treasuryETHBalance_AfterPurchase,87.75ether);assertEq(emitterContractETHBalance_AfterPurchase,4.875ether);}
Results after running the test:
Running1testfortest/token-emitter/ERC20TokenEmitter.t.sol:ERC20TokenEmitterTest[PASS]testBuyToken_ValueLeak() (gas:459490)Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 11.25msRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1totaltests)
Tools Used
Foundry
Recommended Mitigation Steps
I would recommend transferring the remaining ETH used to buy governance tokens to the treasury.
+       uint256 creatorsEthAfterDirectPayment = ((msgValueRemaining - toPayTreasury) - creatorDirectPayment);//Deposit funds to treasury-       (bool success, ) = treasury.call{ value: toPayTreasury }(new bytes(0));+       (bool success, ) = treasury.call{ value: toPayTreasury + creatorsEthAfterDirectPayment }(new bytes(0));require(success, "Transfer failed.");
rocketman-21 (Revolution) confirmed

[H-02]ArtPiece.totalVotesSupplyandArtPiece.quorumVotesare incorrectly calculated due to inclusion of the inaccessible voting powers of the NFT that is being auctioned at the moment when an art piece is created
Submitted byosmanozdemir1, also found byhals,0xG0P1,King_,SpicyMeatball,ktg, andrvierdiiev
https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/CultureIndex.sol#L228
https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/CultureIndex.sol#L234
In this protocol, art pieces are uploaded, voted on by the community and auctioned. Being the highest-voted art piece is not enough to go to auction, and that art piece also must reach the quorum.
The quorum for the art piece is determined according to the total vote supply when the art piece is created. This total vote supply is calculated according to the current supply of theerc20VotingTokenanderc721VotingToken.erc721VotingTokenshaveweightcompared to regularerc20VotingTokensand ERC721 tokens give users much more voting power.
https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/CultureIndex.sol#L226C1-L229C11
file:CultureIndex.solfunctioncreatePiece...{// ...newPiece.totalVotesSupply=_calculateVoteWeight(erc20VotingToken.totalSupply(),-->erc721VotingToken.totalSupply()//@audit-issue This includes the erc721 token which is currently on auction. No one can use that token to vote on this piece.);// ...-->newPiece.quorumVotes= (quorumVotesBPS*newPiece.totalVotesSupply) /10_000;//@audit quorum votes will also be higher than it should be.// ...}
_calculateVoteWeightfunction:
function_calculateVoteWeight(uint256erc20Balance,uint256erc721Balance)internalviewreturns(uint256) {returnerc20Balance+ (erc721Balance*erc721VotingTokenWeight*1e18);}
As I mentioned above,totalVotesSupplyandquorumVotesof an art piece are calculated when the art piece is created based on the total supplies of the erc20 and erc721 tokens.
However, there is an important logic/context issue here.This calculation includes the erc721 verbs token which iscurrently on auctionand sitting in theAuctionHousecontract. The voting power of this token can never be used for that art piece because:
AuctionHousecontract obviously can not vote.The future buyer of this NFT also can not vote since users’ right to vote is determined based on thecreation blockof the art piece.
In the end, totally inaccessible voting powers are included when calculatingArtPiece.totalVotesSupplyandArtPiece.quorumVotes, which results in incorrect quorum requirements and makes it harder to reach the quorum.
Impact
Quorum vote requirements for created art pieces will be incorrect if there is an ongoing auction at the time the art piece is created.This will make it harder to reach the quorum.Unfair situations can occur between two art pieces (different totalVotesSuppy, different quorum requirements, but the same accessible/actual vote supply)
I also would like to that add the impact of this issue is not linear. It will decrease over time with theerc721VotingTokensupply starts to increase day by day.
The impact is much higher in the early phase of the protocol, especially in the first days/weeks after the protocol launch where theverbsTokensupply is only a handful.
Proof of Concept
Let’s assume that:-The currenterc20VotingTokensupply is 1000 and it won’t change for this scenario.-The weight oferc721VotingTokenis 100.-quorumVotesBPSis 5000 (50% quorum required)
Day 0: Protocol Launched
Users started to upload their art pieces.There is no NFT minted yet.The total votes supply for all of these art pieces is 1000.
Day 1: First Mint
One of the art pieces is chosen.The art piece is minted inVerbsTokencontract and transferred toAuctionHousecontract.The auction has started.erc721VotingTokensupply is 1 at the moment.Users keep uploading art pieces for the next day’s auction.For these art pieces uploaded on day 1:totalVotesSupplyis 1100quorumVotesis 550Accessible vote supply is still 1000.According to accessible votes, the quorum rate is 55% not 50.
Day 2: Next Day
The auction on the first day is concluded and transferred to the buyer.The nextverbsTokenis minted and the auction is started.erc721VotingTokensupply is 2.Users keep uploading art pieces for the next day’s auction.For these art pieces uploaded on day 2:totalVotesSupplyis 1200quorumVotesis 600Accessible vote supply is 1100. (1000 + 100 from the buyer of the first NFT)The actual quorum rate for these art pieces is ~54.5% (600 / 1100).
NOTE: The numbers used here are just for demonstration purposes. The impact will be much much higher if theerc721VotingTokenweight is a bigger value like 1000.
Recommended Mitigation Steps
I strongly recommend subtracting the voting power of the NFT currently on auction when calculating the vote supply of the art piece and the quorum requirements.
// Note: You will also need to store auctionHouse contract addressin this contract.+   address auctionHouse;function createPiece () {...newPiece.totalVotesSupply = _calculateVoteWeight(erc20VotingToken.totalSupply(),-           erc721VotingToken.totalSupply()+           // Note: We don't subtract 1 as fixed amount in case of auction house being paused and not having an NFT at that moment. We only subtract if there is an ongoing auction.+           erc721VotingToken.totalSupply() - erc721VotingToken.balanceOf(auctionHouse));...}
0xTheC0der (Judge) commented:
@rocketman-21 Requesting additional sponsor input on this one.This seems to be valid to me after a first review.
rocketman-21 (Revolution) confirmed and commented:
Super valid ty sirs.
0xTheC0der (Judge) increased severity to High and commented:
Severity increase was discussed with sponsor privately.

[H-03]VerbsToken.tokenURI()is vulnerable to JSON injection attacks
Submitted byKingNFT, also found byZanyBonzyandArmedGoose
https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/CultureIndex.sol#L209
https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/VerbsToken.sol#L193
CultureIndex.createPiece()function doesn’t sanitize malicious charcacters inmetadata.imageandmetadata.animationUrl,  which would causeVerbsToken.tokenURI()suffering various JSON injection attack vectors.
If the front end APP doesn’t process the JSON string properly, such as usingeval()to parse token URI, then any malicious code can be executed in the front end. Obviously, funds in users’ connected wallet, such as Metamask, might be stolen in this case.Even while the front end processes securely, such as using the standard builtinJSON.parse()to read URI. Adversary can still exploit this vulnerability to replace art piece image/animation with arbitrary other ones after voting stage completed.
That is the final metadata used by the NFT (VerbsToken) is not the art piece users vote. This attack could be benefit to attackers, such as creating NFTs containing same art piece data with existing high price NFTs. And this attack could also make the project sufferring legal risks, such as creating NFTs with violence or pornography images.
More reference:https://www.comparitech.com/net-admin/json-injection-guide/
Proof of Concept
As shown ofcreatePiece()function, there is no check ifmetadata.imageandmetadata.animationUrlcontain malicious charcacters, such as",:and,.
File:src\CultureIndex.sol209:functioncreatePiece(210:ArtPieceMetadatacalldatametadata,211:CreatorBps[]calldatacreatorArray212:     )publicreturns(uint256) {213:uint256creatorArrayLength=validateCreatorsArray(creatorArray);214:215:// Validate the media type and associated data216:validateMediaType(metadata);217:218:uint256pieceId=_currentPieceId++;219:220:/// @dev Insert the new piece into the max heap221:maxHeap.insert(pieceId,0);222:223:ArtPiecestoragenewPiece=pieces[pieceId];224:225:newPiece.pieceId=pieceId;226:newPiece.totalVotesSupply=_calculateVoteWeight(227:erc20VotingToken.totalSupply(),228:erc721VotingToken.totalSupply()229:         );230:newPiece.totalERC20Supply=erc20VotingToken.totalSupply();231:newPiece.metadata=metadata;232:newPiece.sponsor=msg.sender;233:newPiece.creationBlock=block.number;234:newPiece.quorumVotes= (quorumVotesBPS*newPiece.totalVotesSupply) /10_000;235:236:for(uinti;i<creatorArrayLength;i++) {237:newPiece.creators.push(creatorArray[i]);238:         }239:240:emitPieceCreated(pieceId,msg.sender,metadata,newPiece.quorumVotes,newPiece.totalVotesSupply);241:242:// Emit an event for each creator243:for(uinti;i<creatorArrayLength;i++) {244:emitPieceCreatorAdded(pieceId,creatorArray[i].creator,msg.sender,creatorArray[i].bps);245:         }246:247:returnnewPiece.pieceId;248:     }
Adverary can exploit this to makeVerbsToken.tokenURI()to return various malicious JSON objects to front end APP.
File:src\Descriptor.sol097:functionconstructTokenURI(TokenURIParamsmemoryparams)publicpurereturns(stringmemory) {098:stringmemoryjson=string(099:abi.encodePacked(100:'{"name":"',101:params.name,102:'", "description":"',103:params.description,104:'", "image": "',105:params.image,106:'", "animation_url": "',107:params.animation_url,108:'"}'109:             )110:         );111:returnstring(abi.encodePacked("data:application/json;base64,",Base64.encode(bytes(json))));112:     }
For example, if attacker submit the following metadata:
ICultureIndex.ArtPieceMetadata({name:'Mona Lisa',description:'A renowned painting by Leonardo da Vinci',mediaType:ICultureIndex.MediaType.IMAGE,image:'ipfs://realMonaLisa',text:'',animationUrl:'", "image": "ipfs://fakeMonaLisa'// malicious string injected});
During voting stage, front end getsimagefield byCultureIndex.pieces[pieceId].metadata.image, which isipfs://realMonaLisa. But, after voting complete, art piece is minted toVerbsTokenNFT. Now, front end would queryVerbsToken.tokenURI(tokenId)to get base64 encoded metadata, which would be:
data:application/json;base64,eyJuYW1lIjoiVnJiIDAiLCAiZGVzY3JpcHRpb24iOiJNb25hIExpc2EuIEEgcmVub3duZWQgcGFpbnRpbmcgYnkgTGVvbmFyZG8gZGEgVmluY2kiLCAiaW1hZ2UiOiAiaXBmczovL3JlYWxNb25hTGlzYSIsICJhbmltYXRpb25fdXJsIjogIiIsICJpbWFnZSI6ICJpcGZzOi8vZmFrZU1vbmFMaXNhIn0=
In the front end, we useJSON.parse()to parse the above data, we getimageasipfs://fakeMonaLisa.Image link:https://gist.github.com/assets/68863517/d769d7ac-db02-4e3b-94d2-dfaf3752b763
Below is the full coded PoC:
// SPDX-License-Identifier: MITpragmasolidity0.8.22;import{Test}from"forge-std/Test.sol";import{console2}from"forge-std/console2.sol";import{RevolutionBuilderTest}from"./RevolutionBuilder.t.sol";import{ICultureIndex}from"../src/interfaces/ICultureIndex.sol";contractJsonInjectionAttackTestisRevolutionBuilderTest{stringpublictokenNamePrefix="Vrb";stringpublictokenName="Vrbs";stringpublictokenSymbol="VRBS";functionsetUp()publicoverride{super.setUp();super.setMockParams();super.setERC721TokenParams(tokenName,tokenSymbol,"https://example.com/token/",tokenNamePrefix);super.setCultureIndexParams("Vrbs","Our community Vrbs. Must be 32x32.",10,500,0);super.deployMock();}functiontestImageReplacementAttack()public{ICultureIndex.CreatorBps[]memorycreators=_createArtPieceCreators();ICultureIndex.ArtPieceMetadatamemorymetadata=ICultureIndex.ArtPieceMetadata({name:'Mona Lisa',description:'A renowned painting by Leonardo da Vinci',mediaType:ICultureIndex.MediaType.IMAGE,image:'ipfs://realMonaLisa',text:'',animationUrl:'", "image": "ipfs://fakeMonaLisa'// malicious string injected});uint256pieceId=cultureIndex.createPiece(metadata,creators);vm.startPrank(address(erc20TokenEmitter));erc20Token.mint(address(this),10_000e18);vm.stopPrank();vm.roll(block.number+1);// ensure vote snapshot is takencultureIndex.vote(pieceId);// 1. the image used during voting stage is 'ipfs://realMonaLisa'ICultureIndex.ArtPiecememorytopPiece=cultureIndex.getTopVotedPiece();assertEq(pieceId,topPiece.pieceId);assertEq(keccak256("ipfs://realMonaLisa"),keccak256(bytes(topPiece.metadata.image)));// 2. after being minted to VerbsToken, the image becomes to 'ipfs://fakeMonaLisa'vm.startPrank(address(auction));uint256tokenId=erc721Token.mint();vm.stopPrank();assertEq(pieceId,tokenId);stringmemoryencodedURI=erc721Token.tokenURI(tokenId);console2.log(encodedURI);stringmemoryprefix=_substring(encodedURI,0,29);assertEq(keccak256('data:application/json;base64,'),keccak256(bytes(prefix)));stringmemoryactualBase64Encoded=_substring(encodedURI,29,bytes(encodedURI).length);stringmemoryexpectedBase64Encoded='eyJuYW1lIjoiVnJiIDAiLCAiZGVzY3JpcHRpb24iOiJNb25hIExpc2EuIEEgcmVub3duZWQgcGFpbnRpbmcgYnkgTGVvbmFyZG8gZGEgVmluY2kiLCAiaW1hZ2UiOiAiaXBmczovL3JlYWxNb25hTGlzYSIsICJhbmltYXRpb25fdXJsIjogIiIsICJpbWFnZSI6ICJpcGZzOi8vZmFrZU1vbmFMaXNhIn0=';assertEq(keccak256(bytes(expectedBase64Encoded)),keccak256(bytes(actualBase64Encoded)));}function_createArtPieceCreators()internalpurereturns(ICultureIndex.CreatorBps[]memory) {ICultureIndex.CreatorBps[]memorycreators=newICultureIndex.CreatorBps[](1);creators[0] =ICultureIndex.CreatorBps({creator:address(0xc),bps:10_000});returncreators;}function_substring(stringmemorystr,uint256startIndex,uint256endIndex)internalpurereturns(stringmemory){bytesmemorystrBytes=bytes(str);bytesmemoryresult=newbytes(endIndex-startIndex);for(uint256i=startIndex;i<endIndex;i++) {result[i-startIndex] =strBytes[i];}returnstring(result);}}
And, test logs:
2023-12-revolutionprotocol\packages\revolution>forgetest--match-contractJsonInjectionAttackTest-vv[⠑]Compiling...Nofileschanged,compilationskippedRunning1testfortest/JsonInjectionAttack.t.sol:JsonInjectionAttackTest[PASS]testImageReplacementAttack() (gas:1437440)Logs:data:application/json;base64,eyJuYW1lIjoiVnJiIDAiLCAiZGVzY3JpcHRpb24iOiJNb25hIExpc2EuIEEgcmVub3duZWQgcGFpbnRpbmcgYnkgTGVvbmFyZG8gZGEgVmluY2kiLCAiaW1hZ2UiOiAiaXBmczovL3JlYWxNb25hTGlzYSIsICJhbmltYXRpb25fdXJsIjogIiIsICJpbWFnZSI6ICJpcGZzOi8vZmFrZU1vbmFMaXNhIn0=Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 16.30msRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1totaltests)
Recommended Mitigation Steps
Sanitize input data according:https://github.com/OWASP/json-sanitizer
rocketman-21 (Revolution) confirmed
0xTheC0der (Judge) commented:
Looks like aMediumat the first glance, but after some thoughtHighseverity seems appropriate due to assets being compromised in a pretty straight-forward way.The front-end part of the present issue is definitely QA but is part of a more severe correctly identified root cause, see point 4.The purpose of using IPFS isimmutability. Thus, the art piece cannot be simply changed on the server. If users vote on an NFT where the underlying art is hosted on a normal webserver, it’s user error.I agree that the provided example findings are QA due to lack of impact on contract/protocol level.The critical part of this attack is that the art piece (IPFS link) that is voted on will differ from the art piece (IPFS link) in the minted VerbsToken which makes this an issue on protocol level where assets are compromised and users will be misled as a result.On the one hand, users have to be careful and review their actions responsibly, but on the other hand it’s any protocol’s duty to protect users to a certain degree (example: slippage control).Here, multiple users are put at risk because of one malicious user.Furthermore, due to the voting mechanism and later minting, users are exposed to a risk that is not as clear to see as if they could see the final NFT from the beginning.I have to draw the line somewhere and here it becomes evident that the protocol’s duty to protect it’s users outweighs the required user scrutiny.
Note: See full discussionhere.

[H-04] Malicious delegatees can block delegators from redelegating and from sending their NFTs
Submitted bybart1e, also found by0xDING99YA,BowTiedOriole, andWard
https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/base/VotesUpgradeable.sol#L166
https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/base/VotesUpgradeable.sol#L235-L244
https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/base/ERC721CheckpointableUpgradeable.sol#L41
If userXdelegates his votes toY,Ycan blockXfrom redelegating and even from sending his NFT anywhere, forever.
Detailed description
Users can acquire votes in two ways:
by having someNontransferableERC20Votestokensby havingVerbsTokentokens
It is possible for them to delegate their votes to someone else. It is handled in theVotesUpgradablecontract, that is derived from OpenZeppelin’sVotesUpgradableand the following change is made with respect to the original implementation:
function delegates(address account) public view virtual returns (address) {-        return $._delegatee[account];+        return $._delegatee[account] == address(0) ? account : $._delegatee[account];
It is meant to be a convenience feature so that users don’t have to delegate to themselves in order to be able to vote. However, it has very serious implications.
In order to see that, let’s look at the_moveDelegateVotesfunction that is invoked every time someone delegates his votes or wants to transfer a voting token (VerbsTokenin this case asNontransferableERC20Votesis non-transferable):
function_moveDelegateVotes(addressfrom,addressto,uint256amount)private{VotesStoragestorage$=_getVotesStorage();if(from!=to&&amount>0) {if(from!=address(0)) {(uint256oldValue,uint256newValue) =_push($._delegateCheckpoints[from],_subtract,SafeCast.toUint208(amount));emitDelegateVotesChanged(from,oldValue,newValue);}if(to!=address(0)) {(uint256oldValue,uint256newValue) =_push($._delegateCheckpoints[to],_add,SafeCast.toUint208(amount));emitDelegateVotesChanged(to,oldValue,newValue);}}}
As can be seen, it subtracts votes from current delegatee and adds them to the new one. There are 2 edge cases here:
from == address(0), which is the case when current delegatee equals0to == address(0), which is the case when users delegates to0
If any of these conditions hold, only one of$._delegateCheckpointsis updated. This is fine in the original implementation as the function ignores cases whenfrom == toand if function updates only$._delegateCheckpoints[from]it means that a user was delegating to0and when he changes delegatee, votes only should be added to some account, not subtracted from any account. Similarly, if the function updates only$._delegateCheckpoints[to], it means that user temporarily removes his votes from the system and hence his current delegatee’s votes should be subtracted and not added into any other account.
As long as user cannot cause this function to update one of$._delegateCheckpoints[from]and$._delegateCheckpoints[to]several times in a row, it works correctly. It is indeed the case in the original OpenZeppelin’s implementation as whenfrom == to, function doesn’t perform any operation.
However, the problem with the current implementation is that it is possible to call this function withto == 0several times in a row.In order to see it, consider the_delegatefunction which is called when users want to (re)delegate their votes:
function_delegate(addressaccount,addressdelegatee)internalvirtual{VotesStoragestorage$=_getVotesStorage();addressoldDelegate=delegates(account);$._delegatee[account] =delegatee;emitDelegateChanged(account,oldDelegate,delegatee);_moveDelegateVotes(oldDelegate,delegatee,_getVotingUnits(account));}
As we can see, it calls_moveDelegateVotes, but witholdDelegateequal todelegates(account).But if$._delegatee[account] == address(0), that function returnsaccount.
It means that_moveDelegateVotescan be called several times in a row with parameters(account, 0, _getVotingUnits(account)). In other words, if user delegates toaddress(0), he will be able to do it several times in a row asfromwill be different thantoin_moveDelegateVotesand the function will subtract his amount of votes from his$._delegateCheckpointsevery time.
It may seem that a userXwho delegates toaddress(0)multiple times will only harm himself, but it’s not true as someone else can delegate to him and each time he delegates to0, his original voting power will be subtracted from his$._delegateCheckpoints, making it0or some small, value. If a userYwho delegated toXwants to redelegate to someone else or transfer his tokens,_moveDelegateVoteswill revert with integer underflow as it will try to subtractY’s votes from$._delegateCheckpoints[X], but it will already be either a small number or even0meaning thatYwill be unable to transfer his tokens or redelegate.
Impact
Victims of the exploit presented above will neither be able to transfer their NFTs (the same would be true forNontransferableERC20Votes, but it’s not transferable by design) nor to even redelegate back to themselves or to any other address.
While it can be argued that users will only delegate to users they trust, I argue that the issue is of High severity because of the following reasons:
Possibility of delegating is implemented in the code and it’s expected to be used.Every user who uses it risks the loss of access to all his NFTs and to redelegating his votes.Even when delegatees are trusted, it still shouldn’t be possible for them to block redelegating and blocking access to NFTs of their delegators; if delegators stop trusting delegatees, they should have a possibility to redelegate back, let alone to have access to their own NFTs, which is not the case in the current implementation.The attack is not costly for the attacker as he doesn’t have to lose any tokens - for instance, if he has1NFT and the victim who delegates to him has10, he can delegate toaddress(0)10times and then transfer his NFT to a different address - it will still block his victim and the attacker wouldn’t lose anything.
Proof of Concept
Please put the following test into theVoting.t.solfile and run it. It shows how a victim loses access to all his votes and all his NFTs just by delegating to someone:
functiontestBlockingOfTransferAndRedelegating()public{addressuser=address(0x1234);addressattacker=address(0x4321);vm.stopPrank();// create 3 random piecescreateDefaultArtPiece();createDefaultArtPiece();createDefaultArtPiece();// transfer 2 pieces to normal user and 1 to the attackervm.startPrank(address(auction));erc721Token.mint();erc721Token.transferFrom(address(auction),user,0);erc721Token.mint();erc721Token.transferFrom(address(auction),user,1);erc721Token.mint();erc721Token.transferFrom(address(auction),attacker,2);vm.stopPrank();// user delegates his votes to attackervm.prank(user);erc721Token.delegate(attacker);// attacker delegates to address(0) multiple times, blocking user from redelegatingvm.prank(attacker);erc721Token.delegate(address(0));vm.prank(attacker);erc721Token.delegate(address(0));// now, user cannot redelegatevm.prank(user);vm.expectRevert();erc721Token.delegate(user);// attacker transfer his only NFT to an address controlled by himself// he doesn't lose anything, but he still trapped victim's votes and NFTsvm.prank(attacker);erc721Token.transferFrom(attacker,address(0x43214321),2);// user cannot transfer any of his NTFs eithervm.prank(user);vm.expectRevert();erc721Token.transferFrom(user,address(0x1234567890),0);}
Tools Used
VS Code
Recommended Mitigation Steps
Do not allow users to delegate toaddress(0).
rocketman-21 (Revolution) confirmed and commented:
This is valid, major find thank you so much.Proposed fix here:https://github.com/collectivexyz/revolution-protocol/commit/ef2a492e93e683f5d9d8c77cbcf3622bb936522a
0xTheC0der (Judge) commented:
Warden has shown how assets can be permanently frozen.

