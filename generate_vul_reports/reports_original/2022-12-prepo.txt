[H-01] griefing / blocking / delaying users to withdraw
Submitted byzaskoh, also found byunforgiven,deliriusz,rvierdiiev, andTricko
To withdraw, a user needs to convert his collateral for the base token. This is done in thewithdrawfunction in Collateral.
The WithdrawHook has some security mechanics that can be activated like a global max withdraw in a specific timeframe, also for users to have a withdraw limit for them in a specific timeframe. It also collects the fees.
The check for the user withdraw is wrongly implemented and can lead to an unepexted delay for a user with a position> userWithdrawLimitPerPeriod. To withdraw all his funds he needs to be the first in every first new epoch (lastUserPeriodReset+userPeriodLength) to get his amount out. If he is not the first transaction in the new epoch, he needs to wait for a complete new epoch and depending on the timeframe fromlastUserPeriodReset+userPeriodLengththis can get a long delay to get his funds out.
The documentation says, that after every epoch all the user withdraws will be reset and they can withdraw the next set.
File:apps/smart-contracts/core/contracts/interfaces/IWithdrawHook.sol63:/**64:    *@noticeSets the length in seconds for which user withdraw limits will65:    * be evaluated against. Every time `userPeriodLength` seconds passes, the66:    * amount withdrawn for all users will be reset to 0. This amount is only
But the implementation only resets the amount for the first user that interacts with the contract in the new epoch and leaves all other users with their old limit. This can lead to a delay for every user that is on his limit from a previous epoch until they manage to be the first to interact with the contract in the new epoch.
Proof of Concept
https://github.com/prepo-io/prepo-monorepo/blob/feat/2022-12-prepo/apps/smart-contracts/core/contracts/WithdrawHook.sol#L66-L72
The following test shows how a user is locked out to withdraw if he’s at his limit from a previous epoch and another withdraw is done before him.
apps/smart-contracts/core/test/WithdrawHook.test.ts
describe('user withdraw is delayd', () => {beforeEach(async () => {await withdrawHook.setCollateral(collateral.address)await withdrawHook.connect(deployer).setWithdrawalsAllowed(true)await withdrawHook.connect(deployer).setGlobalPeriodLength(0)await withdrawHook.connect(deployer).setUserPeriodLength(TEST_USER_PERIOD_LENGTH)await withdrawHook.connect(deployer).setGlobalWithdrawLimitPerPeriod(0)await withdrawHook.connect(deployer).setUserWithdrawLimitPerPeriod(TEST_USER_WITHDRAW_LIMIT)await withdrawHook.connect(deployer).setDepositRecord(depositRecord.address)await withdrawHook.connect(deployer).setTreasury(treasury.address)await withdrawHook.connect(deployer).setTokenSender(tokenSender.address)await testToken.connect(deployer).mint(collateral.address, TEST_GLOBAL_DEPOSIT_CAP)await testToken.connect(deployer).mint(user.address, TEST_GLOBAL_DEPOSIT_CAP)await testToken.connect(deployer).mint(user2.address, TEST_GLOBAL_DEPOSIT_CAP)await testToken.connect(collateralSigner).approve(withdrawHook.address, ethers.constants.MaxUint256)tokenSender.send.returns()})it('reverts if user withdraw limit exceeded for period', async () => {// first withdraw with the limit amount for a userawait withdrawHook.connect(collateralSigner).hook(user.address, TEST_USER_WITHDRAW_LIMIT, TEST_USER_WITHDRAW_LIMIT)expect(await withdrawHook.getAmountWithdrawnThisPeriod(user.address)).to.eq(TEST_USER_WITHDRAW_LIMIT)// we move to a new epoch in the futureconst previousResetTimestamp = await getLastTimestamp(ethers.provider)await setNextTimestamp(ethers.provider,previousResetTimestamp + TEST_USER_PERIOD_LENGTH + 1)// now another user is the first one to withdraw in this new epochawait withdrawHook.connect(collateralSigner).hook(user2.address, TEST_USER_WITHDRAW_LIMIT, TEST_USER_WITHDRAW_LIMIT)expect(await withdrawHook.getAmountWithdrawnThisPeriod(user2.address)).to.eq(TEST_USER_WITHDRAW_LIMIT)// this will revert, because userToAmountWithdrawnThisPeriod[_sender] is not reset// but it should not revert as it's a new epoch and the user didn't withdraw yetawait expect(withdrawHook.connect(collateralSigner).hook(user.address, 1, 1)).to.revertedWith('user withdraw limit exceeded')})})
To get the test running you need to addlet user2: SignerWithAddressand the user2 inawait ethers.getSigners()
Recommended Mitigation Steps
The check how the user periods are handled need to be changed. One possible way is to change the lastUserPeriodReset to a mapping likemapping(address => uint256) private lastUserPeriodResetto track the time for every user separately.
With a mapping you can change the condition to:
File:apps/smart-contracts/core/contracts/WithdrawHook.sol18:mapping(address=>uint256)lastUserPeriodReset;File:apps/smart-contracts/core/contracts/WithdrawHook.sol66:if(lastUserPeriodReset[_sender] +userPeriodLength<block.timestamp) {67:lastUserPeriodReset[_sender] =block.timestamp;68:userToAmountWithdrawnThisPeriod[_sender] =_amountBeforeFee;69:     }else{70:require(userToAmountWithdrawnThisPeriod[_sender] +_amountBeforeFee<=userWithdrawLimitPerPeriod,"user withdraw limit exceeded");71:userToAmountWithdrawnThisPeriod[_sender] +=_amountBeforeFee;72:     }
With this change, we can change the test to how we would normaly expect the contract to work and see that it is correct.
it('withdraw limit is checked for every use seperatly', async () => {// first withdraw with the limit amount for a userawait withdrawHook.connect(collateralSigner).hook(user.address, TEST_USER_WITHDRAW_LIMIT, TEST_USER_WITHDRAW_LIMIT)// we move to a new epoch in the futureconst previousResetTimestamp = await getLastTimestamp(ethers.provider)await setNextTimestamp(ethers.provider,previousResetTimestamp + TEST_USER_PERIOD_LENGTH + 1)// now another user is the first one to withdraw in this new epochawait withdrawHook.connect(collateralSigner).hook(user2.address, TEST_USER_WITHDRAW_LIMIT, TEST_USER_WITHDRAW_LIMIT)// the first user also can withdraw his limit in this epochawait withdrawHook.connect(collateralSigner).hook(user.address, TEST_USER_WITHDRAW_LIMIT, TEST_USER_WITHDRAW_LIMIT)// we move the time, but stay in the same epochconst previousResetTimestamp2 = await getLastTimestamp(ethers.provider)await setNextTimestamp(ethers.provider,previousResetTimestamp2 + TEST_USER_PERIOD_LENGTH - 1)// this now will fail as we're in the same epochawait expect(withdrawHook.connect(collateralSigner).hook(user.address, 1, 1)).to.revertedWith('user withdraw limit exceeded')})
ramenforbreakfast (prePO) confirmed

[H-02] A whale user is able to cause freeze of funds of other users by bypassing withdraw limit
Submitted byTrust, also found by0Kage,imare,hansfriese,ayeslick,rvierdiiev,bin2chen,fs0c,mert_eren,Parth,cccz,aviggiano, andchaduke)
https://github.com/prepo-io/prepo-monorepo/blob/3541bc704ab185a969f300e96e2f744a572a3640/apps/smart-contracts/core/contracts/WithdrawHook.sol#L61
https://github.com/prepo-io/prepo-monorepo/blob/3541bc704ab185a969f300e96e2f744a572a3640/apps/smart-contracts/core/contracts/WithdrawHook.sol#L68
Description
In Collateral.sol, users may withdraw underlying tokens using withdraw. Importantly, the withdrawal must be approved by withdrawHook if set:
function withdraw(uint256 _amount) external override nonReentrant {uint256 _baseTokenAmount = (_amount * baseTokenDenominator) / 1e18;uint256 _fee = (_baseTokenAmount * withdrawFee) / FEE_DENOMINATOR;if (withdrawFee > 0) { require(_fee > 0, "fee = 0"); }else { require(_baseTokenAmount > 0, "amount = 0"); }_burn(msg.sender, _amount);uint256 _baseTokenAmountAfterFee = _baseTokenAmount - _fee;if (address(withdrawHook) != address(0)) {baseToken.approve(address(withdrawHook), _fee);withdrawHook.hook(msg.sender, _baseTokenAmount, _baseTokenAmountAfterFee);baseToken.approve(address(withdrawHook), 0);}baseToken.transfer(msg.sender, _baseTokenAmountAfterFee);emit Withdraw(msg.sender, _baseTokenAmountAfterFee, _fee);}
The hook requires that two checks are passed:
if (lastGlobalPeriodReset + globalPeriodLength < block.timestamp) {lastGlobalPeriodReset = block.timestamp;globalAmountWithdrawnThisPeriod = _amountBeforeFee;} else {require(globalAmountWithdrawnThisPeriod + _amountBeforeFee <= globalWithdrawLimitPerPeriod, "global withdraw limit exceeded");globalAmountWithdrawnThisPeriod += _amountBeforeFee;}if (lastUserPeriodReset + userPeriodLength < block.timestamp) {lastUserPeriodReset = block.timestamp;userToAmountWithdrawnThisPeriod[_sender] = _amountBeforeFee;} else {require(userToAmountWithdrawnThisPeriod[_sender] + _amountBeforeFee <= userWithdrawLimitPerPeriod, "user withdraw limit exceeded");userToAmountWithdrawnThisPeriod[_sender] += _amountBeforeFee;}
If it has been less than “globalPeriodLength” seconds since the global reset, we step into the if block, reset time becomes now and starting amount is the current requested amount. Otherwise, the new amount must not overpass the globalWithdrawLimitPerPeriod. Very similar check is done for “user” variables.
The big issue here is that the limit can be easily bypassed by the first person calling withdraw in each group (“global” and “user”). It will step directly into the if block where no check is done, and fill the variable with any input amount.
As I understand, the withdraw limit is meant to make sure everyone is guaranteed to be able to withdraw the specified amount, so there is no chance of freeze of funds. However, due to the bypassing of this check, a whale user is able to empty the current reserves put in place and cause a freeze of funds for other users, until the Collateral contract is replenished.
Impact
A whale user is able to cause freeze of funds of other users by bypassing withdraw limit.
Proof of Concept
Collateral.sol has 10,000 USDC reserveWithdraw limit is 150 USDC per user per periodThere are 5 users - Alpha with collateral worth 12,000 USDC, and 4 users each with 1,000 USDCAlpha waits for a time when request would create a new lastGlobalPeriodResetandnew lastUserPeriodReset. He requests a withdraw of 10,000 USDC.The hook is passed and he withdraws the entire collateral reserves.At this point, victim Vic is not able to withdraw their 150 USDC. It is a freeze of funds.
Recommended Mitigation Steps
Add limit checks in the if blocks as well, to make sure the first request does not overflow the limit.
Judge note
I’ve confirmed with the PrePO team during the contest that withdraw limit bypass is a very serious issue.
ramenforbreakfast (prePO) confirmed

