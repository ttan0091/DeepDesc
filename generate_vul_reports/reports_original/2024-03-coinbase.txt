[H-01] Remove owner calls can be replayed to remove a different owner at the same index, leading to severe issues when combined with lack of last owner guard
Submitted byCircolors, also found bylsaudit
Users are able to upgrade their account’s owners via either directly onto the contract with a regular transaction or via an ERC-4337 EntryPoint transaction callingexecuteWithoutChainIdValidation. If a user chooses to use a combination of these methods it’s very likely that the addresses at a particular ownership index differ across chain. Therefore if a user later callsremoveOwnerAtIndexon another chain will end up removing different addresses on different chains. It is unlikely this would be the user’s intention. The severity of this ranges from minimal (the user can just add the mistakenly removed owner back) or critical (the user mistakenly removes their only accessible owner on a specific chain, permanently locking the account).
Proof Of Concept
Scenario A: Alice permanently bricks her account on an unused chain:
Alice has a CoinbaseSmartWallet, and uses it on Base, Ethereum & OptimismAlice later decides to add a new owner using a cross-chainexecuteWithoutChainIdValidationAlice later wants to remove the initial owner (index 0) and does so by signing another cross-chain replayable signatureDespite it not being her intention anyone could take that signature and replay it on Arbitrum, Avalanche, etc as there is no check to stop the user from removing the final owner
Scenario A: Alice adds owners using both methods and ends up with undesired results:
Alice has a CoinbaseSmartWallet and uses it across all chainsShe has Gnosis Safe’s and ERC-6551 token bound accounts on different chains so adds them as owners on those specific chains usingexecuteShe then adds a secondary EOA address on all chains usingexecuteWithoutChainIdValidationNow if she usesexecuteWithoutChainIdValidationto callremoveOwnerAtIndeshe will be removing different owners on different chains, which is likely not her intention
While more complex scenarios than this might sound bizarre it’s important to remember that Alice could be using this smart account for the next N years, only making changes sporadically, and as her ownership mappings across different chains become more out of sync the likelihood of a significant error occurring increases.
Recommended Mitigation Steps
AsMultiOwnableStorageuses a mapping to track owner information rather than a conventional array, it might be simpler to do away with the indexes entirely and have aremoveOwner(bytes calldata _ownerToRemove)function. This would avoid the situations outlined above where when callingremoveOwnerAtIndexremoves different owners on different chains. To ensure replayability and avoid having a stuck nonce on chains where_ownerToRemoveis not an owner the function should not revert in the case the owner is not there, but instead return a boolremovedto indicate whether an owner was removed or not.
This would make it significantly less likely that users run into the issues stated above, without having to limit their freedom to make ownership changes manually or via ERC-4337 EntryPoint transactions.
3docSec (judge) increased severity to High and commented:
Root cause:removeOwnerAtIndexcan be replayed cross-chain despite the same index may point to a different owner. The issue was confirmed by the sponsor in theissue #57thread and addressedin this PR.After consulting with a fellow judge, I’m upgrading this one as high, as there is a well-defined attack path that causes the user to lose ownership of their wallet.
Coinbase mitigated:
The issue is remediated by updating the parameterization ofremoveOwnerAtIndexto also take anownerargument. We then check that theownerpassed matches the owner found at the index. In this way, we prevent a replayable transaction removing a different owner at the same index. (PRhere)
Status:Mitigation confirmed. Full details in reports fromMcToady,cheatc0d3, andimare.

