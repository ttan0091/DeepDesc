[H-01] Reentrancy in buy function for ERC777 tokens allows buying funds with considerable discount
Submitted bycarlitox477, also found byminhquanym,gzeon,9svR6w,Lambda,koxuan,KingNFT,cozzetti,rvierdiiev, andcccz
https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L95https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L137https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L172https://github.com/code-423n4/2022-12-caviar/blob/0212f9dc3b6a418803dbfacda0e340e059b8aae2/src/Pair.sol#L203
Current implementation of functionsadd,remove,buyandsellfirst transfer fractional tokens, and then base tokens.
If this base token is ERC777 (extension of ERC20), we can call this function without updating the base token balance, but updating the fractional token balance.
Impact
Allows to drain funds of a pairs which implements an ERC-777 token.
Proof of Concept
function buy(uint256 outputAmount, uint256 maxInputAmount) public payable returns (uint256 inputAmount) {// *** Checks *** //// check that correct eth input was sent - if the baseToken equals address(0) then native ETH is usedrequire(baseToken == address(0) ? msg.value == maxInputAmount : msg.value == 0, "Invalid ether input");// calculate required input amount using xyk invariant+   @audit Use current balancesinputAmount = buyQuote(outputAmount);// check that the required amount of base tokens is less than the max amountrequire(inputAmount <= maxInputAmount, "Slippage: amount in");// *** Effects *** //+   @audit Modifies just fractional balance// transfer fractional tokens to sender_transferFrom(address(this), msg.sender, outputAmount);// *** Interactions *** //if (baseToken == address(0)) {// refund surplus ethuint256 refundAmount = maxInputAmount - inputAmount;if (refundAmount > 0) msg.sender.safeTransferETH(refundAmount);} else {// transfer base tokens in+       @audit If an ERC-777 token is used, we can re call buy function with the same balance of base token, but with different fractional balanceERC20(baseToken).safeTransferFrom(msg.sender, address(this), inputAmount);}emit Buy(inputAmount, outputAmount);}
functionbuyQuote(uint256outputAmount)publicviewreturns(uint256) {return(outputAmount*1000*baseTokenReserves()) / ((fractionalTokenReserves() -outputAmount) *997);}
The buy quote is used to calculate the amount of fractional token that the user will receive, and it should be less/equal tomaxInputAmountsent by parameter in order to achieve a successful execution of function buy.
Current buy quote can be mathematically expressed as: $\frac{outputAmount \times 1000 \times baseTokenReserves}{fractionalTokenReserves - outPutAmount} \times 997$.
Then, about sales
function sell(uint256 inputAmount, uint256 minOutputAmount) public returns (uint256 outputAmount) {// *** Checks *** //// calculate output amount using xyk invariantoutputAmount = sellQuote(inputAmount);// check that the outputted amount of fractional tokens is greater than the min amountrequire(outputAmount >= minOutputAmount, "Slippage: amount out");// *** Effects *** //// transfer fractional tokens from sender+   //@audit fractional balance is updated_transferFrom(msg.sender, address(this), inputAmount);// *** Interactions *** //if (baseToken == address(0)) {// transfer ether outmsg.sender.safeTransferETH(outputAmount);} else {// transfer base tokens out+       @audit If an ERC-777 token is used, we can re call sell function with the same balance of base token, but with different fractional balance.ERC20(baseToken).safeTransfer(msg.sender, outputAmount);}emit Sell(inputAmount, outputAmount);}
uint256 inputAmountWithFee = inputAmount * 997;return (inputAmountWithFee * baseTokenReserves()) / ((fractionalTokenReserves() * 1000) + inputAmountWithFee);}
Current sellQuote function can be expressed mathematically as:
$inputAmount = \frac{inputAmount \times 997 \times baseTokenReserves}{fractionalTokenReserves \times 1000 + inputAmountWithFee}$
Then we can think next scenario to drain a pair which use an ERC-777 token as base token:
Let’s suppose the pair has 1000 base tokens(BT777) and 1000 Fractional reserve tokens (FRT)The attacker call buy function, all with next inputs:outputAmount = 50maxInputAmount = 80The attacker implements a hook, that will be executed 6 times (using a counter inside a malicus contract) when a transfer is done, and call the buy function. After this 6 times the malicious contract is call again, but this times calls the sell function, doing a huge sell for the fractional reserve token obtained.
A simulation of this attack can be visualized in next table
OperationoutputAmount (FRT)maxInputAmount (BT777)BT777 reserveFRT reserveinputAmount (BT777 to pay)inputAmount < maxInputAmountAttaker buy 150801000100052TRUECallback buy 25080100095055TRUECallback buy 35080100090059TRUECallback buy 45080100085062TRUECallback buy 55080100080066TRUECallback buy 65080100075071TRUECallback buy 75080100070077TRUE
The result of this operation is that the attaker/malicious contract has 350 FRT, while BT777 reserve still has 1000 and FRT reserve has 650 tokens. The success execution needs that the attacker pays 442 BT777 eventually.
To do this, the last operation of the malicious contract is calling sell function
OperationinputAmount(BT777)minOutputAmountBT777 reserveFRT reserveoutputAmount (BT777 to receive)outputAmount > minOutputAmountcalback Sell3504421000650536TRUE
The result is that the attacker now controls 536 BT777, the attacker use this balance to pay the debt of 442 BT77, with a profit of 94 BT77 tokens.
Recommended Mitigation steps
Add openzeppelin nonReentrant modifier to mentioned functions, or state clear in the documentation that this protocol should not be used with ERC777 tokens.
outdoteth (Caviar) acknowledged and commented:
Technically valid, though we don’t intend to support erc777 tokens.

[H-02] Liquidity providers may lose funds when adding liquidity
Submitted byJeiwan, also found byminhtrng,minhquanym,HE1M,wait,hansfriese,BAHOZ,unforgiven,0xxm,Junnon,bytehat,UNCHAIN,carlitox477,RaymondFam,Chom,CRYP70,9svR6w,mauricio1802,__141345__,hihen,caventa,koxuan,obront,nicobevi,shung,cccz,Bobface, andchaduke
Liquidity providers may lose a portion of provided liquidity in either of the pair tokens. While theminLpTokenAmountprotects from slippage when adding liquidity, it doesn’t protect from providing liquidity at different K.
Proof of Concept
ThePaircontract is designed to receive liquidity from liquidity providers (Pair.sol#L63). First liquidity provider in a pool may provide arbitrary token amounts and set the initial price (Pair.sol#L425-L426), but all other liquidity providers must provide liquidity proportionally to current pool reserves (Pair.sol#L420-L423). Since a pool is made of two tokens and liquidity is provided in both tokens, there’s a possibility for a discrepancy: token amounts may be provided in different proportions. When this happens, the smaller of the proportions is chosen to calculate the amount of LP tokens minted (Pair.sol#L420-L423):
// calculate amount of lp tokens as a fraction of existing reservesuint256baseTokenShare= (baseTokenAmount*lpTokenSupply) /baseTokenReserves();uint256fractionalTokenShare= (fractionalTokenAmount*lpTokenSupply) /fractionalTokenReserves();returnMath.min(baseTokenShare,fractionalTokenShare);
As a result, the difference in proportions will create an excess of tokens that won’t be redeemable for the amount of LP tokens minted. The excess of tokens gets, basically, donated to the pool: it’ll be shared among all liquidity providers of the pool. While theminLpTokenAmountargument of theaddfunction (Pair.sol#L63) allows liquidity providers to set the minimal amount of LP tokens they want to receive, it doesn’t allow them to minimize the disproportion of token amounts or avoid it at all.
// test/Pair/unit.Add.t.solfunctiontestLockOfFunds_AUDIT()public{addressalice=address(0x31337);addressbob=address(0x12345);vm.label(alice,"alice");vm.label(bob,"bob");deal(address(usd),alice,100e18,true);deal(address(usd),bob,100e18,true);deal(address(p),alice,100e18,true);deal(address(p),bob,100e18,true);// Alice is the first liquidity provider.vm.startPrank(alice);usd.approve(address(p),type(uint256).max);p.add(10ether,10ether,0);vm.stopPrank();// Bob provides liquidity to the pool and sets the minimal LP amount.// The token amounts are deposited in different proportions, thus the smaller// one will be chosen to calculate the amount of LP tokens Bob will receive.vm.startPrank(bob);usd.approve(address(p),type(uint256).max);uint256minLPAmount=1e18;uint256bobLPAmount=p.add(1.2ether,1ether,minLPAmount);vm.stopPrank();// Bob has received the minimal LP amount he wanted.assertEq(bobLPAmount,minLPAmount);// However, after removing all his liquidity from the pool...(uint256bobUSDBefore,uint256bobFracBefore) = (usd.balanceOf(bob),p.balanceOf(bob));vm.prank(bob);p.remove(minLPAmount,0,0);(uint256bobUSDAfter,uint256bobFracAfter) = (usd.balanceOf(bob),p.balanceOf(bob));// ... Bob received less USD than he deposited.assertEq(bobUSDAfter-bobUSDBefore,1.018181818181818181ether);assertEq(bobFracAfter-bobFracBefore,1.000000000000000000ether);}
Recommended Mitigation Steps
In theaddfunction, consider calculating optimal token amounts based on the amounts specified by user, current pool reserves, and the minimal LP tokens amount specified by user. As a reference, consider this piece from the Uniswap V2 Router:UniswapV2Router02.sol#L45-L60.
outdoteth (Caviar) confirmed and commented:
Fixed in:https://github.com/outdoteth/caviar/pull/2By allowing a user to specify aminPriceandmaxPricethat they are willing to LP at along with theminLpTokenAmountthat they would like to receive. The price calculation is based on this:https://github.com/outdoteth/caviar/blob/main/src/Pair.sol#L471

[H-03] First depositor can break minting of shares
Submitted byminhquanym, also found byApocalypto,0xDecorativePineapple,Franfran,dipp,rjs,ak1,Tricko,Jeiwan,unforgiven,hansfriese,BAHOZ,unforgiven,bytehat,UNCHAIN,immeas,SamGMK,fs0c,Tointer,haku,Koolex,__141345__,ElKu,rajatbeladiya,hihen,izhelyazkov,KingNFT,koxuan,0x52,carrotsmuggler,yixxas,HE1M,supernova,cozzetti,rvierdiiev,SamGMK,aviggiano,seyni,lumoswiz,ladboy233,chaduke,cccz, andeyexploit
The attack vector and impact is the same asTOB-YEARN-003, where users may not receive shares in exchange for their deposits if the total asset amount has been manipulated through a large “donation”.
Proof of Concept
InPair.add(), the amount of LP token minted is calculated as
functionaddQuote(uint256baseTokenAmount,uint256fractionalTokenAmount)publicviewreturns(uint256) {uint256lpTokenSupply=lpToken.totalSupply();if(lpTokenSupply>0) {// calculate amount of lp tokens as a fraction of existing reservesuint256baseTokenShare= (baseTokenAmount*lpTokenSupply) /baseTokenReserves();uint256fractionalTokenShare= (fractionalTokenAmount*lpTokenSupply) /fractionalTokenReserves();returnMath.min(baseTokenShare,fractionalTokenShare);}else{// if there is no liquidity then initreturnMath.sqrt(baseTokenAmount*fractionalTokenAmount);}}
An attacker can exploit using these steps
Create and add1 wei baseToken - 1 wei quoteTokento the pair. At this moment, attacker is minted1 wei LP tokenbecausesqrt(1 * 1) = 1Transfer large amount ofbaseTokenandquoteTokendirectly to the pair, such as1e9 baseToken - 1e9 quoteToken. Since no new LP token is minted,1 wei LP tokenworths1e9 baseToken - 1e9 quoteToken.Normal users add liquidity to pool will receive0LP token if they add less than1e9token because of rounding division.
baseTokenShare= (X*1) /1e9;fractionalTokenShare= (Y*1) /1e9;
Recommended Mitigation Steps
Uniswap V2 solved this problem by sending the first 1000 LP tokens to the zero address. The same can be done in this case i.e. whenlpTokenSupply == 0, send the first min liquidity LP tokens to the zero address to enable share dilution.Inadd(), ensure the number of LP tokens to be minted is non-zero:
require(lpTokenAmount!=0,"No LP minted");
outdoteth (Caviar) confirmed and commented:
Fixed in:https://github.com/outdoteth/caviar/pull/3

