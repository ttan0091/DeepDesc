[H-01] Self-delgated users can have their delegation unknowingly hijacked during crowdfunding
Submitted by0x52
Self-delegation can be hijacked.
Proof of Concept
PartyGovernance.sol#L886-L906
function _adjustVotingPower(address voter, int192 votingPower, address delegate) internal {VotingPowerSnapshot memory oldSnap = _getLastVotingPowerSnapshotForVoter(voter);address oldDelegate = delegationsByVoter[voter];// If `oldDelegate` is zero and `voter` never delegated, then have// `voter` delegate to themself.oldDelegate = oldDelegate == address(0) ? voter : oldDelegate;// If the new `delegate` is zero, use the current (old) delegate.delegate = delegate == address(0) ? oldDelegate : delegate;VotingPowerSnapshot memory newSnap = VotingPowerSnapshot({timestamp: uint40(block.timestamp),delegatedVotingPower: oldSnap.delegatedVotingPower,intrinsicVotingPower: (oldSnap.intrinsicVotingPower.safeCastUint96ToInt192() +votingPower).safeCastInt192ToUint96(),isDelegated: delegate != voter});_insertVotingPowerSnapshot(voter, newSnap);delegationsByVoter[voter] = delegate;// Handle rebalancing delegates._rebalanceDelegates(voter, oldDelegate, delegate, oldSnap, newSnap);}
Self-delegation is triggered when a user specifies their delegate as address(0). This means that if a user wishes to self-delegate they will can contribute to a crowdfund with delegate == address(0).
ETHCrowdfundBase.sol#L169-L181
function _processContribution(address payable contributor,address delegate,uint96 amount) internal returns (uint96 votingPower) {address oldDelegate = delegationsByContributor[contributor];if (msg.sender == contributor || oldDelegate == address(0)) {// Update delegate.delegationsByContributor[contributor] = delegate;} else {// Prevent changing another's delegate if already delegated.delegate = oldDelegate;}
This method of self-delegation is problematic when combined with _processContribution. When contributing for someone else, the caller is allowed to specify any delegate they wish. If that user is currently self delegated, then the newly specified delegate will overwrite their self delegation. This allows anyone to hijack the voting power of a self-delegated user.
This can create serious issues for ReraiseETHCrowdfund because party NFTs are not minted until after the entire crowdfund is successful. Unlike InitialETHCrowdfund, this allows the attacker to hijack all of the user’s newly minted votes.
Example:minContribution = 1andmaxContribution = 100. User A contributes 100 to ReraiseETHCrowdfund. They wish to self-delegate so they call contribute with delegate == address(0). An attacker now contributes 1 on behalf of User A with themselves as the delegate. Now when the NFTs are claimed, they will be delegated to the attacker.
Recommended Mitigation Steps
Self-delegation should be automatically hardcoded:
+   if (msg.sender == contributor && delegate == address(0)) {+       delegationsByContributor[contributor] = contributor;+   }address oldDelegate = delegationsByContributor[contributor];if (msg.sender == contributor || oldDelegate == address(0)) {// Update delegate.delegationsByContributor[contributor] = delegate;} else {// Prevent changing another's delegate if already delegated.delegate = oldDelegate;}
0xean (judge) commented:
This appears valid at first pass and allows anyone to steal self delegations.
0xble (Party) confirmed

[H-02] An attacker can contribute to the ETH crowdfund using a flash loan and control the party as he likes
Submitted byhansfriese
https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ETHCrowdfundBase.sol#L273
https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/party/PartyGovernance.sol#L470
An attacker can have more than half of the total voting power using a flash loan and abuse other contributors.
Proof of Concept
The main flaw is that the party can distribute funds right after the crowdfund is finalized within the same block.
So the attacker can contribute using a flash loan and repay by distributing the part’s ETH.
Let’s assumemaxContribution = type(uint96).max, minTotalContributions = 10 ether, maxTotalContributions = 20 ether, fundingSplitBps = 0.An attacker contributes 1 ether(attacker’s fund) to the crowdfund and another user contributes 9 ether.The attacker knows the crowdfund will be finalized as it satisfies theminTotalContributionsalready but he will have 10% of the total voting power.So he decides to contribute 10 ether using a flash loan.InETHCrowdfundBase._processContribution(), the crowdfund will be finalized immediately astotal contribution is greater than maxTotalContributions.Then the attacker will have(1 + 10) / 20 = 55%voting power of the party and he can pass any proposal.So he callsdistribute()with 19 ether.distribute()can be called directly ifopts.distributionsRequireVote == false, otherwise, he should create/execute the distribution proposal and he can do it within the same block.After that, he can receive ETH usingTokenDistributor.claim()and the amount will be19 * 55% = 10.45 ether. (We ignore the distribution fee for simplicity)He repays 10 ether to the flash loan provider and he can control the party as he likes now.
This attack is possible for bothInitialETHCrowdfundandReraiseETHCrowdfund.
Recommended Mitigation Steps
I think we should implement a kind ofcooldown logicafter the crowdfund is finalized.
Add apartyStartedTimeinPartyGovernance.sol.While finalizing the ETH crowdfund inETHCrowdfundBase._finalize(), we setparty.partyStartedTime = block.timestamp.After that,PartyGovernance.distribute()can work only whenblock.timestamp > partyStartTime.
0xean (judge) commented:
Coded POC would have been welcomed here due to the number of steps in the attack, will review further.
hansfriese commented:
Hello @0xean - Here is a POC. It should be appended toInitialETHCrowdfund.t.solfunctiontest_finalizeUsingFlashloan()public{InitialETHCrowdfundcrowdfund=_createCrowdfund({initialContribution:0,initialContributor:payable(address(0)),initialDelegate:address(0),minContributions:0,maxContributions:type(uint96).max,disableContributingForExistingCard:false,minTotalContributions:10ether,maxTotalContributions:20ether,duration:7days,fundingSplitBps:0,fundingSplitRecipient:payable(address(0))});TokenDistributordistributor=newTokenDistributor(globals,0);globals.setAddress(LibGlobals.GLOBAL_TOKEN_DISTRIBUTOR,address(distributor));Partyparty=crowdfund.party();// Attacker has 1 ether nowaddressattacker=_randomAddress();vm.deal(attacker,1ether);// An honest member has 9 etheraddressmember=_randomAddress();vm.deal(member,9ether);// Contributevm.prank(attacker);uint256vp1=crowdfund.contribute{ value:1ether}(attacker,"");vm.prank(member);crowdfund.contribute{ value:9ether}(member,"");// Attacker noticed his voting power will be 10% after finalization, so he decided to contribute 10 ether using flashloanvm.deal(attacker,10ether);// he borrowed 10 ethervm.prank(attacker);uint256vp2=crowdfund.contributeFor{ value:10ether}(1,payable(attacker),attacker,"");//contributed 10 ether again// Crowdfund is finalizedassertTrue(crowdfund.getCrowdfundLifecycle() ==ETHCrowdfundBase.CrowdfundLifecycle.Finalized);assertEq(party.getGovernanceValues().totalVotingPower,20ether);assertEq(vp1+vp2,11ether);//his voting power is 11/20 = 55% nowassertEq(address(party).balance,20ether);assertEq(address(attacker).balance,0);//attacker's eth balance = 0// attacker starts eth distribution of 19 ether from party's balancevm.prank(attacker);ITokenDistributor.DistributionInfomemorydistInfo=party.distribute(19ether,ITokenDistributor.TokenType.Native,address(0),0);assertEq(address(distributor).balance,19ether);//distributor's balanceassertEq(address(party).balance,1ether);//party's remaining balancevm.prank(attacker);distributor.claim(distInfo,1);//attacker claims 55% of 19 etherassertEq(address(attacker).balance,10.45ether);//finally, attacker's balance = 10.45 ether and he can repay the flashloanassertEq(party.getGovernanceValues().totalVotingPower,20ether);assertEq(vp1+vp2,11ether);//his voting power is still 55%}
0xble (Party) confirmed and commented:
Great finding, still debating the mitigation internally.
0xble (Party) acknowledged and commented:
Looking into this more, the issue can only occur if a party sets anexecutionDelayof 0. In the POC, the party was created with default values (null) which is why this could happen in testing. However if changed to a nonzero value, it would require waiting delay duration before the proposal could be executed which would prevent the repayment of the flash loan in a single execution. Since parties are expected to have a nonzero execution delay, we are less concerned about the flash loan aspect of this attack.This finding did prompt us to consider the risk of majority attacks more broadly, where an individual can contribute and become a majority voter in a party (flash loan or not) and take control of the party. We acknowledged the majority attack before audit and don’t consider it a vulnerability. Our reasoning is (1) our governance model prioritizes simplicity and speed of coordination which would be sacrificed by introducing more complex mechanisms to robustly protect against majority attacks and (2) the expectation is parties will have reasonable governance settings and active governance to veto malicious proposals to manage the risk of a majority attack and if they don’t (e.g. set an execution delay of 0) it is a deliberate choice on their part rather than a vulnerability.

[H-03] Users wouldn’t refund from the lost ETH crowdfunds due to the lack of ETH
Submitted byhansfriese, also found by0x52andevan
After the ETH crowdfunds are lost, contributors wouldn’t refund their funds because the crowdfunds contract doesn’t have enough ETH balance.
Proof of Concept
The core flaw is_calculateRefundAmount()might return more refund amount than the original contribution amount.
function_calculateRefundAmount(uint96votingPower)internalviewreturns(uint96amount) {amount= (votingPower*1e4) /exchangeRateBps;// Add back fee to contribution amount if applicable.addresspayablefundingSplitRecipient_=fundingSplitRecipient;uint16fundingSplitBps_=fundingSplitBps;if(fundingSplitRecipient_!=address(0) &&fundingSplitBps_>0) {amount= (amount*1e4) / (1e4-fundingSplitBps_);//@audit might be greater than original contribution}}
When users contribute to the ETH crowdfunds, it subtracts the fee from the contribution amount.
File:2023-04-party\contracts\crowdfund\ETHCrowdfundBase.sol226:uint16fundingSplitBps_=fundingSplitBps;227:if(fundingSplitRecipient_!=address(0) &&fundingSplitBps_>0) {228:uint96feeAmount= (amount*fundingSplitBps_) /1e4;229:amount-=feeAmount;230:         }
During the calculation, it calculatesfeeAmountfirst which is rounded down and subtracts from the contribution amount. It means the final amount after subtracting the fee would be rounded up.
So when we calculate the original amount using_calculateRefundAmount(), we might get a greater value.
This shows the detailed example and POC.
Let’s assumefundingSplitBps = 1e3(10%), exchangeRateBps = 1e4.A user contributed1e18 - 1wei of ETH. After subtracting the fee, the voting power was1e18 - 1 - (1e18 - 1) / 10 = 9 * 1e17Let’s assume there are no other contributors and the crowdfund was lost.When the user callsrefund(), the refund amount will be9 * 1e17 * 1e4 / 9000 = 1e18in_calculateRefundAmount()So it will try to transfer 1e18 wei of ETH from the crowdfund contract that contains 1e18 - 1 wei only. As a result, the transfer will revert and the user can’t refund his funds.
functiontest_refund_reverts()public{InitialETHCrowdfundcrowdfund=_createCrowdfund({initialContribution:0,initialContributor:payable(address(0)),initialDelegate:address(0),minContributions:0,maxContributions:type(uint96).max,disableContributingForExistingCard:false,minTotalContributions:3ether,maxTotalContributions:5ether,duration:7days,fundingSplitBps:1000,//10% feefundingSplitRecipient:payable(_randomAddress())//recipient exists});Partyparty=crowdfund.party();uint256ethAmount=1ether-1;//contribute amountaddressmember=_randomAddress();vm.deal(member,ethAmount);// Contributevm.prank(member);crowdfund.contribute{ value:ethAmount}(member,"");assertEq(address(member).balance,0);assertEq(address(crowdfund).balance,ethAmount);//crowdfund's balance = 1 ether - 1skip(7days);assertTrue(crowdfund.getCrowdfundLifecycle() ==ETHCrowdfundBase.CrowdfundLifecycle.Lost);// Claim refundvm.prank(member);uint256tokenId=1;crowdfund.refund(tokenId);//reverts as it tried to withdraw 1 ether}
Recommended Mitigation Steps
When we subtract the fee in_processContribution(), we should calculate the final amount using1e4 - fundingSplitBpsdirectly. Then there will be 2 rounds down in_processContribution()and_calculateRefundAmountand the refund amount won’t be greater than the original amount.
if(fundingSplitRecipient_!=address(0) &&fundingSplitBps_>0) {amount= (amount* (1e4-fundingSplitBps_)) /1e4;}
0xble (Party) confirmed

[H-04]ReraiseETHCrowdfund.sol: Multiple scenarios how pending votes might not be claimable which is a complete loss of funds for a user
Submitted byHollaDieWaldfee, also found byevanandhansfriese
https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L256-L303
https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L333-L382
This issue is about how theReraiseETHCrowdfundclaim functionality can be broken.
When the claim functionality is broken this means that a user cannot claim his voting power, resulting in a complete loss of funds.
The claim functionality is not broken in any case, i.e. with any configuration of theReraiseETHCrowdfundcontract.
However the contract can be configured in a way - and by configured I mean specifically theminContribution,maxContribution,minTotalContributionsandmaxTotalContributionsvariables - that the claim functionality breaks.
And the configurations under which it breaks are NOT edge cases. They represent theintended useof the contract as discussed with the sponsor.
The fact that when the contract is used as intended it can lead to a complete loss of funds for the users makes me estimate this to be “High” severity.
Proof of Concept
We first need to understand theclaim(uint256 tokenId, address contributor)andclaimMultiple(uint96[] memory votingPowerByCard, address contributor)functions. They essentially make up the claim functionality as all other functions regarding claiming are just wrappers around them.
Let’s first look at theclaim(uint256 tokenId, address contributor)function. The first part of the function is what we are interested in:
Link
functionclaim(uint256tokenId,addresscontributor)public{// Check crowdfund lifecycle.{CrowdfundLifecyclelc=getCrowdfundLifecycle();if(lc!=CrowdfundLifecycle.Finalized) {revertWrongLifecycleError(lc);}}uint96votingPower=pendingVotingPower[contributor];if(votingPower==0)return;{uint96contribution= (votingPower*1e4) /exchangeRateBps;uint96maxContribution_=maxContribution;// Check that the contribution equivalent of total pending voting// power is not above the max contribution range. This can happen// for contributors who contributed multiple times In this case, the// `claimMultiple` function should be called instead. This is done// so parties may use the minimum and maximum contribution values to// limit the voting power of each card (e.g.  a party desiring a "1// card = 1 vote"-like governance system where each card has equal// voting power).if(contribution>maxContribution_) {revertAboveMaximumContributionsError(contribution,maxContribution_);}}
What is important is thatcontributionis calculatesd as:
uint96contribution= (votingPower*1e4) /exchangeRateBps;
And thencontributionis checked that it is<= maxContribution:
if(contribution>maxContribution_) {revertAboveMaximumContributionsError(contribution,maxContribution_);}
The explanation for why this check is necessary can be seen in the comment:
// This is done// so parties may use the minimum and maximum contribution values to// limit the voting power of each card (e.g.  a party desiring a "1// card = 1 vote"-like governance system where each card has equal// voting power).
TheclaimMultiple(uint96[] memory votingPowerByCard, address contributor)function allows to divide the pending voting power across multiple party cards and it employs the following checks:
Link
uint96minContribution_=minContribution;uint96maxContribution_=maxContribution;for(uint256i;i<votingPowerByCard.length; ++i) {if(votingPowerByCard[i] ==0)continue;// Check that the contribution equivalent of voting power is within// contribution range. This is done so parties may use the minimum// and maximum contribution values to limit the voting power of each// card (e.g. a party desiring a "1 card = 1 vote"-like governance// system where each card has equal voting power).uint96contribution= (votingPowerByCard[i] *1e4) /exchangeRateBps;if(contribution<minContribution_) {revertBelowMinimumContributionsError(contribution,minContribution_);}if(contribution>maxContribution_) {revertAboveMaximumContributionsError(contribution,maxContribution_);}votingPower-=votingPowerByCard[i];// Mint contributor a new party card.uint256tokenId=party.mint(contributor,votingPowerByCard[i],delegate);emitClaimed(contributor,tokenId,votingPowerByCard[i]);}// Requires that all voting power is claimed because the contributor is// expected to have burned their crowdfund NFT.if(votingPower!=0)revertRemainingVotingPowerAfterClaimError(votingPower);}
We can see that for each party card thecontributionneeds to be>= minContributionand<= maxContribution. Also the function must deal with all the voting power, so after the function call all pending voting power must be processed:
if(votingPower!=0)revertRemainingVotingPowerAfterClaimError(votingPower);
Now we are in a position to look at a simple scenario how a user can end up without being able to claim his pending voting power (Note that this can also be a griefing attack whereby an attacker contributes for the victim some possibly small amount thereby making it impossible for the victim to claim):
(The test should be added to theReraiseETHCrowdfund.t.soltest file)
functiontest_cannotClaim1()public{ReraiseETHCrowdfundcrowdfund=_createCrowdfund({initialContribution:0,initialContributor:payable(address(0)),initialDelegate:address(0),minContributions:0.9ether,maxContributions:1ether,disableContributingForExistingCard:false,minTotalContributions:1ether,maxTotalContributions:1.5ether,duration:7days,fundingSplitBps:0,fundingSplitRecipient:payable(address(0))});addressmember=_randomAddress();vm.deal(member,2ether);// Contributevm.startPrank(member);crowdfund.contribute{ value:1ether}(member,"");crowdfund.contribute{ value:1ether}(member,"");vm.stopPrank();assertEq(crowdfund.pendingVotingPower(member),1.5ether);vm.expectRevert(abi.encodeWithSelector(ETHCrowdfundBase.AboveMaximumContributionsError.selector,1500000000000000000,1000000000000000000));crowdfund.claim(member);}
In this test the following values were chosen for the important variables that I mentioned above:
minContribution = 0.9e18maxContribution = 1e18minTotalContributions = 1e18maxTotalContributions = 1.5e18
What happens in the test is that first1 ETHis contributed then another0.5 ETHis contributed (It says1 ETHbutmaxTotalContributionsis hit and so only0.5 ETHis contributed and the crowdfund is finalized).
The call to theclaimfunction fails becausecontribution = 1.5 ETHwhich is abovemaxContribution.
The important thing is now to understand thatclaimMultiplecan also not be called (therefore the pending voting power cannot be claimed at all).
When we callclaimMultiplethe contribution for the first party card must be in the range[0.9e18, 1e18]to succeed and therefore the second contribution can only be in the range of[0.5e18,0.6e18]which is belowminContributionand therefore it is not possible to distribute the voting power across cards such that the call succeeds.
What we discussed so far could be mitigated by introducing some simple checks when setting up the crowdfund. The sort of checks required are like ”minTotalContributionsmust be divisible byminContribution”. I won’t go into this deeply however because these checks are insufficient when we introduce a funding fee.
Let’s consider a case with:
minContribution = 1e18maxContribution = 1e18minTotalContributions = 2e18maxTotalContributions = 2e18
(Note that setting up the crowdfund withminContribution==maxContributionis an important use case where the party wants to enforce a “1 card = 1 vote”-policy).
There should be no way how this scenario causes a problem right? The contribution of a user can only be1e18or2e18and in both cases the checks in the claim functions should pass. - No
It breaks when we introduce a fee. Say there is a 1% fee (fundingSplitBps=100).
The contribution is calculated as (as we know from above):
(Also note thatexchangeRateBps=1e4for all tests, i.e. the exchange rate between ETH and votes is 1:1)
uint96contribution= (votingPower*1e4) /exchangeRateBps;
The problem is thatvotingPowerhas been reduced by 1% due to the funding fee. So when a user initially contributes1e18, thecontributionhere is calculated to be0.99e18 * 1e4 / 1e4 = 0.99e18which is belowminContributionand claiming is not possible.
Let’s make a final observation: The parameters can also be such that due to rounding a similar thing happens:
minContribution = 1e18 + 1 WeimaxContribution = 1e18 + 1 WeiminTotalContributions = 2e18 + 2 WeimaxTotalContributions = 2e18 + 2 Wei
Due to rounding (when calculating the funding fee or when there is not a 1:1 exchange rate) the 1 Wei in the contribution can be lost (or some other small amount) and thereby when callingclaim, thecontributionwhich has been rounded down is belowminContributionand the claim fails.
To summarize we have seen 3 scenarios. It is not possible for me to provide an overview of all the things that can go wrong. There are just too many variables. I come back to this point in my recommendation.
Tools Used
VSCode, Foundry
Recommended Mitigation Steps
A part of the fix is straightforward. However this is not a full fix.
I recommend to implement a functionality for claiming that cannot be blocked. I know that this may cause the “1 card = 1 vote”-policy to be violated and it may also causeminContributionormaxContributionto be violated. But maybe this is the price to pay to ensure that users can always claim.
An alternative solution may be to reduce the range of possible configurations of the crowdfund drastically such that it can be mathematically proven that users are always able to claim.
That being said there is an obvious flaw in the current code that has been confirmed by the sponsor.
Thecontributionamount that is calculated when claiming needs to add back the funding fee amount. I.e. if there was a 1% funding fee, thecontributionamount should be1e18instead of0.99e18.
Partial fix:
diff --git a/contracts/crowdfund/ReraiseETHCrowdfund.sol b/contracts/crowdfund/ReraiseETHCrowdfund.solindex 580623d..0b1ba9e 100644--- a/contracts/crowdfund/ReraiseETHCrowdfund.sol+++ b/contracts/crowdfund/ReraiseETHCrowdfund.sol@@ -268,6 +268,13 @@ contract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {{uint96 contribution = (votingPower * 1e4) / exchangeRateBps;++            address payable fundingSplitRecipient_ = fundingSplitRecipient;+            uint16 fundingSplitBps_ = fundingSplitBps;+            if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {+                contribution = (contribution * 1e4) / (1e4 - fundingSplitBps_);+            }+uint96 maxContribution_ = maxContribution;// Check that the contribution equivalent of total pending voting// power is not above the max contribution range. This can happen@@ -360,6 +367,13 @@ contract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {// card (e.g. a party desiring a "1 card = 1 vote"-like governance// system where each card has equal voting power).uint96 contribution = (votingPowerByCard[i] * 1e4) / exchangeRateBps;++            address payable fundingSplitRecipient_ = fundingSplitRecipient;+            uint16 fundingSplitBps_ = fundingSplitBps;+            if (fundingSplitRecipient_ != address(0) && fundingSplitBps_ > 0) {+                contribution = (contribution * 1e4) / (1e4 - fundingSplitBps_);+            }+if (contribution < minContribution_) {revert BelowMinimumContributionsError(contribution, minContribution_);}
0xble (Party) commented:
Additional to the partial fix recommended in the mitigation, this will be mitigated bypreventing the case whereminContributionmay be bypassed for the last contributor when the remaining contribution is less than the minimum.

[H-05]ReraiseETHCrowdfund.sol: party card transfer can be front-run by claiming pending voting power which results in a loss of the voting power
Submitted byHollaDieWaldfee
In this report I show how an attacker can abuse the fact that anyone can callReraiseETHCrowdfund.claimfor any user and add voting power to an existing party card.
The result can be a griefing attack whereby the victim loses voting power. In some cases the attacker can take advantage himself.
In short this is what needs to happen:
The victim sends a transaction to transfer one of his party cardsThe transaction is front-run and pending voting power of the victim from theReraiseETHCrowdfundcontract is claimed to this party card that is transferredThe victim thereby loses the pending voting power
The fact that any user is at risk that has pending voting power and transfers a party card and that voting power is arguably the most important asset in the protocol makes me estimate this to be “High” severity.
Proof of Concept
We start by observing that when theReraiseETHCrowdfundis won, any user can callReraiseETHCrowdfund.claimfor any other user and either mint a new party card to him or add the pending voting power to an existing party card:
Link
/// @notice Claim a party card for a contributor if the crowdfund won. Can be called///         to claim for self or on another's behalf./// @param tokenId The ID of the party card to add voting power to. If 0, a///                new card will be minted./// @param contributor The contributor to claim for.functionclaim(uint256tokenId,addresscontributor)public{// Check crowdfund lifecycle.{CrowdfundLifecyclelc=getCrowdfundLifecycle();if(lc!=CrowdfundLifecycle.Finalized) {revertWrongLifecycleError(lc);}}uint96votingPower=pendingVotingPower[contributor];if(votingPower==0)return;{uint96contribution= (votingPower*1e4) /exchangeRateBps;uint96maxContribution_=maxContribution;// Check that the contribution equivalent of total pending voting// power is not above the max contribution range. This can happen// for contributors who contributed multiple times In this case, the// `claimMultiple` function should be called instead. This is done// so parties may use the minimum and maximum contribution values to// limit the voting power of each card (e.g.  a party desiring a "1// card = 1 vote"-like governance system where each card has equal// voting power).if(contribution>maxContribution_) {revertAboveMaximumContributionsError(contribution,maxContribution_);}}// Burn the crowdfund NFT._burn(contributor);deletependingVotingPower[contributor];if(tokenId==0) {// Mint contributor a new party card.tokenId=party.mint(contributor,votingPower,delegationsByContributor[contributor]);}elseif(disableContributingForExistingCard) {revertContributingForExistingCardDisabledError();}elseif(party.ownerOf(tokenId) ==contributor) {// Increase voting power of contributor's existing party card.party.addVotingPower(tokenId,votingPower);}else{revertNotOwnerError();}emitClaimed(contributor,tokenId,votingPower);}
Note that the caller can specify anycontributorand can add the pending votes to an existing party card if!disableContributingForExistingCard && party.ownerOf(tokenId) == contributor.
So if User A has pending voting power and transfers one of his party cards to User B, then User C might front-run this transfer and claim the pending voting power to the party card that is transferred.
If User B performs this attack it is not a griefing attack since User B benefits from it.
Note that at the time of sending the transfer transaction theReraiseETHCrowdfunddoes not have to be won already. The transaction that does the front-running might contribute to the crowdfund such that it is won and then claim the pending voting power.
Add the following test to theReraiseETHCrowdfund.t.soltest file. It shows how an attacker would perform such an attack:
functiontest_FrontRunTransfer()public{ReraiseETHCrowdfundcrowdfund=_createCrowdfund({initialContribution:0,initialContributor:payable(address(0)),initialDelegate:address(0),minContributions:0,maxContributions:type(uint96).max,disableContributingForExistingCard:false,minTotalContributions:2ether,maxTotalContributions:3ether,duration:7days,fundingSplitBps:0,fundingSplitRecipient:payable(address(0))});addressattacker=_randomAddress();addressvictim=_randomAddress();vm.deal(victim,2.5ether);vm.deal(attacker,0.5ether);// @audit-info the victim owns a party cardvm.prank(address(party));party.addAuthority(address(this));party.increaseTotalVotingPower(1ether);uint256victimTokenId=party.mint(victim,1ether,address(0));vm.startPrank(victim);crowdfund.contribute{ value:2.5ether}(victim,"");vm.stopPrank();/* @audit-infoThe victim wants to transfer the party card, say to the attacker, and the attackerfront-runs this by completing the crowdfund and claiming the victim's pending votingpower to the existing party card*/vm.startPrank(attacker);crowdfund.contribute{ value:0.5ether}(attacker,"");crowdfund.claim(victimTokenId,victim);vm.stopPrank();/* @audit-infowhen the victim's transfer is executed, he transfers also all of the voting powerthat was previously his pending voting power (effectively losing it)*/vm.prank(victim);party.tranferFrom(victim,attacker,victimTokenId);}
So when there is an ongoing crowdfund it is never safe to transfer one’s party card. It can always result in a complete loss of the pending voting power.
Tools Used
VSCode
Recommended Mitigation Steps
In theReraiseETHCrowdfund.claimfunction it should not be possible to add the pending voting power to an existing party card. It is possible though to allow it for thecontributorhimself but not for any user.
diff --git a/contracts/crowdfund/ReraiseETHCrowdfund.sol b/contracts/crowdfund/ReraiseETHCrowdfund.solindex 580623d..cb560e1 100644--- a/contracts/crowdfund/ReraiseETHCrowdfund.sol+++ b/contracts/crowdfund/ReraiseETHCrowdfund.sol@@ -292,7 +292,7 @@ contract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {tokenId = party.mint(contributor, votingPower, delegationsByContributor[contributor]);} else if (disableContributingForExistingCard) {revert ContributingForExistingCardDisabledError();-        } else if (party.ownerOf(tokenId) == contributor) {+        } else if (party.ownerOf(tokenId) == contributor && contributor == msg.sender) {// Increase voting power of contributor's existing party card.party.addVotingPower(tokenId, votingPower);} else {
0xble (Party) confirmed and commented:
Good finding, still thinking about the mitigation.Slightly hesitant to make the only action when claiming for someone else to be minting them a new card although minting to their existing card might be a rare action because of the friction involved in having to get the ID of one of the person’s cards first. Someone minting for someone else might just find it more convenient to mint them a new card, so having that be the only action might not be much of a loss.
0xble (Party) commented:
We’ve decided to refactor the way claiming works in theReraiseETHCrowdfund, partially because a large number of findings like this being submitted around that one area that highlighted for us the need to rework its logic.The change will make it so (1) crowdfund NFTs are minted per contribution instead of per address and (2) claiming works more like a 1:1 conversion of your crowdfund NFT into a party card instead of how it works now. In the future we will also add the ability to split/merge party cards.This should mitigate this finding because in this new system you cannot decide to add the voting power from a crowdfund NFT to an existing party card when claiming, only mint a new party card.

[H-06]ETHCrowdfundBase.sol:totalVotingPoweris increased too much in the_finalizefunction
Submitted byHollaDieWaldfee, also found byhansfriese
This issue is about how theETHCrowdfundBase._finalizefunctions callsPartyGovernanceNFT.increaseTotalVotingPowerwith an amount that does not reflect the sum of the individual users’ voting power.
Thereby it will become impossible to reach unanimous votes. In other words and more generally the users’ votes are worth less than they should be as the percentage is calculated against a total amount that is too big.
In short, this is how the issue is caused:
The voting power that a user receives is based on the amount they contribute MINUS funding feesThe amount of voting power by whichtotalVotingPoweris increased is based on the total contributions WITHOUT subtracting funding fees
Proof of Concept
Let’s first look at the affected code and then at the PoC.
ThevotingPowerthat a user receives for making a contribution is calculated in theETHCrowdfundBase._processContributionfunction.
We can see that first the funding fee is subtracted and then with the loweredamount, thevotingPoweris calculated:
Link
// Subtract fee from contribution amount if applicable.addresspayablefundingSplitRecipient_=fundingSplitRecipient;uint16fundingSplitBps_=fundingSplitBps;if(fundingSplitRecipient_!=address(0) &&fundingSplitBps_>0) {uint96feeAmount= (amount*fundingSplitBps_) /1e4;amount-=feeAmount;}// Calculate voting power.votingPower= (amount*exchangeRateBps) /1e4;
Even before that,totalContributionshas been increased by the fullamount(funding fees have not been subtracted yet):
Link
uint96newTotalContributions=totalContributions+amount;uint96maxTotalContributions_=maxTotalContributions;if(newTotalContributions>=maxTotalContributions_) {totalContributions=maxTotalContributions_;// Finalize the crowdfund.// This occurs before refunding excess contribution to act as a// reentrancy guard._finalize(maxTotalContributions_);// Refund excess contribution.uint96refundAmount=newTotalContributions-maxTotalContributions;if(refundAmount>0) {amount-=refundAmount;payable(msg.sender).transferEth(refundAmount);}}else{totalContributions=newTotalContributions;}
(Note that the above code looks more complicated than it is because it accounts for the fact thatmaxTotalContributionsmight be reached. But this is not important for explaining this issue)
WhenPartyGovernanceNFT.increaseTotalVotingPoweris called it is with thenewVotingPowerthat has been calculated BEFORE funding fees are subtracted:
Link
uint96newVotingPower= (totalContributions_*exchangeRateBps) /1e4;party.increaseTotalVotingPower(newVotingPower);// Transfer fee to recipient if applicable.addresspayablefundingSplitRecipient_=fundingSplitRecipient;uint16fundingSplitBps_=fundingSplitBps;if(fundingSplitRecipient_!=address(0) &&fundingSplitBps_>0) {uint96feeAmount= (totalContributions_*fundingSplitBps_) /1e4;totalContributions_-=feeAmount;fundingSplitRecipient_.transferEth(feeAmount);}
ThereforetotalVotingPoweris increased more than the sum of the voting power that the users have received.
Let’s look at the PoC:
functiontest_totalVotingPower_increased_too_much()public{ReraiseETHCrowdfundcrowdfund=_createCrowdfund({initialContribution:0,initialContributor:payable(address(0)),initialDelegate:address(0),minContributions:0,maxContributions:type(uint96).max,disableContributingForExistingCard:false,minTotalContributions:2ether,maxTotalContributions:5ether,duration:7days,fundingSplitBps:1000,fundingSplitRecipient:payable(address(1))});addressmember1=_randomAddress();addressmember2=_randomAddress();vm.deal(member1,1ether);vm.deal(member2,1ether);// Contribute, should be allowed to update delegatevm.startPrank(member1);crowdfund.contribute{ value:1ether}(member1,"");vm.stopPrank();vm.startPrank(member2);crowdfund.contribute{ value:1ether}(member2,"");vm.stopPrank();skip(7days);console.log(party.getGovernanceValues().totalVotingPower);crowdfund.finalize();console.log(party.getGovernanceValues().totalVotingPower);console.log(crowdfund.pendingVotingPower(member1));console.log(crowdfund.pendingVotingPower(member2));}
See thattotalVotingPoweris increased from0to2e18.
The voting power of both users is0.9e18(10% fee).
Thereby both users together receive a voting power of1.8e18which is only 90% of2e18.
Therefore it is impossible to reach an unanimous vote.
Tools Used
VSCode, Foundry
Recommended Mitigation Steps
The fix is easy:We must consider the funding fee when increasing thetotalVotingPower.
Fix:
diff --git a/contracts/crowdfund/ETHCrowdfundBase.sol b/contracts/crowdfund/ETHCrowdfundBase.solindex 4392655..3c11160 100644--- a/contracts/crowdfund/ETHCrowdfundBase.sol+++ b/contracts/crowdfund/ETHCrowdfundBase.sol@@ -274,10 +274,6 @@ contract ETHCrowdfundBase is Implementation {// Finalize the crowdfund.delete expiry;-        // Update the party's total voting power.-        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;-        party.increaseTotalVotingPower(newVotingPower);-// Transfer fee to recipient if applicable.address payable fundingSplitRecipient_ = fundingSplitRecipient;uint16 fundingSplitBps_ = fundingSplitBps;@@ -287,6 +283,10 @@ contract ETHCrowdfundBase is Implementation {fundingSplitRecipient_.transferEth(feeAmount);}+        // Update the party's total voting power.+        uint96 newVotingPower = (totalContributions_ * exchangeRateBps) / 1e4;+        party.increaseTotalVotingPower(newVotingPower);+// Transfer ETH to the party.payable(address(party)).transferEth(totalContributions_);}
0xean (judge) increased severity to High and commented:
I am upgrading severity here to match#27and will look forward to sponsor comments.I think this exposes a way in which there are parameter sets that leads to a loss of funds by not allowing any proposal to be executed.
0xble (Party) confirmed

[H-07]InitialETHCrowdfund+ReraiseETHCrowdfund:batchContributeForfunction may not refund ETH which leads to loss of funds
Submitted byHollaDieWaldfee, also found byevanandhansfriese
https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/InitialETHCrowdfund.sol#L235-L268
https://github.com/code-423n4/2023-04-party/blob/440aafacb0f15d037594cebc85fd471729bcb6d9/contracts/crowdfund/ReraiseETHCrowdfund.sol#L174-L202
This vulnerability exists in both theInitialETHCrowdfundandReraiseETHCrowdfundcontracts in exactly the same way.
I will continue this report by explaining the issue in only one contract. The mitigation section however contains the fix for both instances.
ThebatchContributeForfunction is a wrapper that allows to make multiple calls tocontributeForwithin one function call.
It is possible to specify that this function should not revert when one individual call tocontributeForfails by settingargs.revertOnFailure=false.
The issue is that in this case the ETH for a failed contribution is not refunded which leads a loss of funds for the user calling the function.
Note:This issue also exists in theCrowdfund.batchContributeForfunction which is out of scope. The sponsor knows about this and will fix it.
Proof of Concept
Let’s look at thebatchContributeForfunction:
Link
functionbatchContributeFor(BatchContributeForArgscalldataargs)externalpayableonlyDelegateCallreturns(uint96[]memoryvotingPowers) {uint256numContributions=args.recipients.length;votingPowers=newuint96[](numContributions);uint256ethAvailable=msg.value;for(uint256i;i<numContributions; ++i) {ethAvailable-=args.values[i];(bools,bytesmemoryr) =address(this).call{ value:args.values[i] }(abi.encodeCall(this.contributeFor,(args.tokenIds[i],args.recipients[i],args.initialDelegates[i],args.gateDatas[i])));if(!s) {if(args.revertOnFailure) {r.rawRevert();}}else{votingPowers[i] =abi.decode(r, (uint96));}}// Refund any unused ETH.if(ethAvailable>0)payable(msg.sender).transfer(ethAvailable);}
We can see thatethAvailableis reduced before every call tocontributeFor:
ethAvailable-=args.values[i];
But it is only checked later if the call was successful:
if(!s) {if(args.revertOnFailure) {r.rawRevert();}
And ifargs.revertOnFailure=falsethere is no revert andethAvailableis not increased again.
Therefore the user has to pay for failed contributions.
Add the following test to theInitialETHCrowdfund.t.soltest file:
functiontest_batchContributeFor_noETHRefund()public{InitialETHCrowdfundcrowdfund=_createCrowdfund({initialContribution:0,initialContributor:payable(address(0)),initialDelegate:address(0),minContributions:1ether,maxContributions:type(uint96).max,disableContributingForExistingCard:false,minTotalContributions:3ether,maxTotalContributions:5ether,duration:7days,fundingSplitBps:0,fundingSplitRecipient:payable(address(0))});Partyparty=crowdfund.party();addresssender=_randomAddress();vm.deal(sender,2.5ether);// Batch contribute forvm.prank(sender);uint256[]memorytokenIds=newuint256[](3);addresspayable[]memoryrecipients=newaddresspayable[](3);address[]memorydelegates=newaddress[](3);uint96[]memoryvalues=newuint96[](3);bytes[]memorygateDatas=newbytes[](3);for(uint256i;i<3; ++i) {recipients[i] =_randomAddress();delegates[i] =_randomAddress();values[i] =1ether;}// @audit-info set values[2] = 0.5 ether such that contribution fails (minContribution = 1 ether)values[2] =0.5ether;uint96[]memoryvotingPowers=crowdfund.batchContributeFor{ value:2.5ether}(InitialETHCrowdfund.BatchContributeForArgs({tokenIds:tokenIds,recipients:recipients,initialDelegates:delegates,values:values,gateDatas:gateDatas,revertOnFailure:false}));// @audit-info balance of sender is 0 ETH even though 0.5 ETH of the 2.5 ETH should have been refundedassertEq(address(sender).balance,0ether);}
Thesendersends 2.5 ETH and 1 of the 3 contributions fails sinceminContributionis above the amount thesenderwants to contribute (Note that in practice there are more ways for the contribution to fail).
The sender’s balance in the end is 0 ETH which shows that there is no refund.
Tools Used
VSCode,Foundry
Recommended Mitigation Steps
The following changes need to be made to theInitialETHCrowdfundandReraiseETHCrowdfundcontracts:
diff --git a/contracts/crowdfund/InitialETHCrowdfund.sol b/contracts/crowdfund/InitialETHCrowdfund.solindex 8ab3b5c..19e09ac 100644--- a/contracts/crowdfund/InitialETHCrowdfund.sol+++ b/contracts/crowdfund/InitialETHCrowdfund.sol@@ -240,8 +240,6 @@ contract InitialETHCrowdfund is ETHCrowdfundBase {uint256 ethAvailable = msg.value;for (uint256 i; i < numContributions; ++i) {-            ethAvailable -= args.values[i];-(bool s, bytes memory r) = address(this).call{ value: args.values[i] }(abi.encodeCall(this.contributeFor,@@ -260,6 +258,7 @@ contract InitialETHCrowdfund is ETHCrowdfundBase {}} else {votingPowers[i] = abi.decode(r, (uint96));+                ethAvailable -= args.values[i];}}
diff --git a/contracts/crowdfund/ReraiseETHCrowdfund.sol b/contracts/crowdfund/ReraiseETHCrowdfund.solindex 580623d..ad70b27 100644--- a/contracts/crowdfund/ReraiseETHCrowdfund.sol+++ b/contracts/crowdfund/ReraiseETHCrowdfund.sol@@ -179,8 +179,6 @@ contract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {uint256 ethAvailable = msg.value;for (uint256 i; i < numContributions; ++i) {-            ethAvailable -= args.values[i];-(bool s, bytes memory r) = address(this).call{ value: args.values[i] }(abi.encodeCall(this.contributeFor,@@ -194,6 +192,7 @@ contract ReraiseETHCrowdfund is ETHCrowdfundBase, CrowdfundNFT {}} else {votingPowers[i] = abi.decode(r, (uint96));+                ethAvailable -= args.values[i];}}
NowethAvailableis only reduced when the call tocontributeForwas successful.
0xean (judge) commented:
Would welcome comment on this issue.  AFAICT, this leads to a direct loss of user funds, which makes me think that a High severity is warranted.  There is no external pre-condition(s) required for this to happen.
HollaDieWaldfee (warden) commented:
@0xean - Yeah you are right, it leads to a direct loss of funds and there are no preconditions. Should have set it to “High” probably.
0xble (Party) confirmed
0xean (judge) increased severity to High

[H-08]VetoProposal: User can veto multiple times so every proposal can be vetoed by any user that has a small amount of votes
Submitted byHollaDieWaldfee, also found by0x52andhansfriese
TheVetoProposalcontract allows to veto proposals with thevoteToVetofunction.
When the amount of votes collected to veto a proposal exceeds a certain threshold (thepassThresholdBps, which is determined upon initialization of the party), the proposal is vetoed, meaning it cannot execute anymore (its status becomesDefeated).
ThepassThresholdBpsspecifies a percentage of thetotalVotingPowerof the party.
E.g.passThresholdBps=1000means that 10% of thetotalVotingPowermust veto a proposal such that the veto goes through.
The issue is that the contract lacks the obvious check that a user has not vetoed before, thereby a user can veto multiple times.
So say a user holds 1% oftotalVotingPowerand in order for the veto to go through, 10% oftotalVotingPowermust veto.
The user can just veto 10 times to reach the 10% requirement.
The impact is obvious: Any user with a small amount of votes can veto any proposal. This is a critical bug since the party may become unable to perform any actions if there is a user that vetoes all proposals.
Proof of Concept
Add the following test to theVetoProposal.t.soltest file:
functiontest_VetoMoreThanOnce()public{_assertProposalStatus(PartyGovernance.ProposalStatus.Voting);// Vote to vetovm.prank(voter1);vetoProposal.voteToVeto(party,proposalId,0);_assertProposalStatus(PartyGovernance.ProposalStatus.Voting);assertEq(vetoProposal.vetoVotes(party,proposalId),1e18);// Vote to veto (passes threshold)vm.prank(voter1);vetoProposal.voteToVeto(party,proposalId,0);_assertProposalStatus(PartyGovernance.ProposalStatus.Defeated);assertEq(vetoProposal.vetoVotes(party,proposalId),0);// Cleared after proposal is vetoed}
In the test file, these are the conditions:totalVotingPower = 3e18, required votes threshold is 51%,voter1has1e18votes which is~33%. Clearlyvoter1should not be able to veto the proposal on his own.
You can see in the test thatvoter1can veto 2 times.
After the first call tovoteToVeto, the threshold is not yet reached (the proposal is still in theVotingstate).
After the second call tovoteToVetothe threshold is reached and the proposal is in theDefeatedstate.
Tools Used
VSCode, Foundry
Recommended Mitigation Steps
The fix is straightforward.
We introduce ahasVotedmapping that tracks for each(party, proposalId, address)triplet if it has vetoed already.
Fix:
diff --git a/contracts/proposals/VetoProposal.sol b/contracts/proposals/VetoProposal.solindex 780826f..fb1f1ab 100644--- a/contracts/proposals/VetoProposal.sol+++ b/contracts/proposals/VetoProposal.sol@@ -8,9 +8,11 @@ import "../party/Party.sol";contract VetoProposal {error NotPartyHostError();error ProposalNotActiveError(uint256 proposalId);+    error AlreadyVotedError(address caller);/// @notice Mapping from party to proposal ID to votes to veto the proposal.mapping(Party => mapping(uint256 => uint96)) public vetoVotes;+    mapping(Party => mapping(uint256 => mapping(address => bool))) public hasVoted;/// @notice Vote to veto a proposal./// @param party The party to vote on.@@ -33,6 +35,12 @@ contract VetoProposal {if (proposalStatus != PartyGovernance.ProposalStatus.Voting)revert ProposalNotActiveError(proposalId);+        if (hasVoted[party][proposalId][msg.sender]) {+            revert AlreadyVotedError(msg.sender);+        }++        hasVoted[party][proposalId][msg.sender] = true;+// Increase the veto vote countuint96 votingPower = party.getVotingPowerAt(msg.sender,
0xble (Party) confirmed

