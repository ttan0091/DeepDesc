[H-01] Oracle data feed can be outdated yet used anyways which will impact payment logic
Submitted by 0xNineDec, also found by 0x1f8b, 0x29A, 0x52, 0xdanial, 0xDjango, 0xf15ers, bardamu, cccz, Cheeezzyyyy, Chom, codexploder, defsec, Franfran, Alex the Entreprenerd, Green, hake, hansfriese, horsefacts, hubble, hyh, IllIllI, jonatascm, kebabsec, Meera, oyc_109, pashov, rbserver, Ruhum, simon135, tabish, tintin, and zzzitron
https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBChainlinkV3PriceFeed.sol#L44
https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBPrices.sol#L57
https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L387
https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L585
https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L661
https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L830
https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBSingleTokenPaymentTerminalStore.sol#L868
Impact
The current implementation ofJBChainlinkV3PriceFeedis used by the protocol to showcase how the feed will be retrieved via Chainlink Data Feeds. The feed is used to retrieve thecurrentPrice, which is also used afterwards byJBPrices.priceFor(), then byJBSingleTokenPaymentTerminalStore.recordPaymentFrom(),JBSingleTokenPaymentTerminalStore.recordDistributionFor,JBSingleTokenPaymentTerminalStore.recordUsedAllowanceOf,JBSingleTokenPaymentTerminalStore._overflowDuringandJBSingleTokenPaymentTerminalStore._currentTotalOverflowOf.
Although the current feeds are calculated by a non implemented IJBPriceFeed, if the implementation of the price feed is the same as the showcased inJBChainlinkV3PriceFeed, the retrieved data can be outdated or out of bounds.
It is important to remember that the sponsor said on the dedicated Discord Channel that also oracle pricing and data retrieval is inside the scope.
Proof of Concept
Chainlink classifies their data feeds into four different groups regarding how reliable is each source thus, how risky they are. The groups areVerified Feeds, Monitored Feeds, Custom Feeds and Specialized Feeds(they can be seenhere). The risk is the lowest on the first one and highest on the last one.
A strong reliance on the price feeds has to be also monitored as recommended on theRisk Mitigation section. There are several reasons why a data feed may fail such as unforeseen market events, volatile market conditions, degraded performance of infrastructure, chains, or networks, upstream data providers outage, malicious activities from third parties among others.
Chainlink recommends using their data feeds along with some controls to prevent mismatches with the retrieved data. Along some recommendations, the feed can include circuit breakers (for extreme price events), contract update delays (to ensure that the injected data into the protocol is fresh enough), manual kill-switches (to cease connection in case of found bug or vulnerability in an upstream contract), monitoring (control the deviation of the data) and soak testing (of the price feeds).
Thefeed.lastRoundData()interface parametersaccording to Chainlinkare the following:
function latestRoundData() external viewreturns (uint80 roundId,             //  The round ID.int256 answer,              //  The price.uint256 startedAt,          //  Timestamp of when the round started.uint256 updatedAt,          //  Timestamp of when the round was updated.uint80 answeredInRound      //  The round ID of the round in which the answer was computed.)
Regarding Juicebox itself, only theansweris used on theJBChainlinkV3PriceFeed.currentPrice()implementation. The retrieved price of thepriceFeedcan be outdated and used anyways as a valid data because no timestamp tolerance of the update source time is checked while storing the return parameters offeed.latestRoundData()insideJBChainlinkV3PriceFeed.currentPrice()as recommended by Chainlink inhere. The usage of outdated data can impact on how the Payment terminals work regarding pricing calculation and value measurement.
Precisely the following protocol logic withinJBSingleTokenPaymentTerminalStore​‌will work unexpectedly regarding value management.
recordPaymentFrom():This function handles the minting of a project tokens according to a data source if one is given. If the retrieved value of the oracle is outdated, the_weightRatioatLine 387will return an incorrect value and then thetokenCountcalculated amount will suffer from this mismatch, impacting in the amount of tokens minted.recordDistributionFor():Performs the recording of recently distributed funds for a project. Online 580thedistributedAmountis computed and if the boolean check is false, then the call will perform a call topriceForatline 585. If the returned oracle value is not adjusted with current market prices, thedistributedAmountwill also drag that error computing an incorrectdistributedAmount. Afterwards, because thedistributedAmountis also used to update the token balances of themsg.sender(line 598) it means that the mismatch impacts on the modified balance.recordUsedAllowanceOf():Keeps record of used allowances of a project. It returns are analogue to the ones shown atrecordDistributionForwhere theusedAmountresembles thedistributedAmount. TheusedAmountis also used to update the project’s balance. If the data of the oracle is outdated, theusedAmountwill be calculated dragging that error._overflowDuring():Used to get the amount that is overflowing relative to a specified cycle. The data retrieved from the oracle is used to calculate the value of_distributionLimitRemainingonline 827which is used later to calculate the return value if the boolean check performed at line 834 is true. Because the return of this function is the current balance of a project minus the amount that can be still distributed, if the amount that can still be distributed is wrong so will be the subtraction thus the return value._currentTotalOverflowOf():Similar to the latter but used to get the overflow of all the terminals of a project. If the retrieved data has a mismatch with the market, the_totalOverflow18Decimalcalculated online 866if the boolean check is false will drag this mismatch which will also be dragged into the final return of the function.
The issues of those miscalculations impact on every project currently minted, which also affects subsequently on each user that has tokens of a project resulting in a high reach impact.
Recommended Mitigation Steps
As Chainlinkrecommends:
Your application should track thelatestTimestampvariable or use theupdatedAtvalue from thelatestRoundData()function to make sure that the latest answer is recent enough for your application to use it. If your application detects that the reported answer is not updated within the heartbeat or within time limits that you determine are acceptable for your application, pause operation or switch to an alternate operation mode while identifying the cause of the delay.During periods of low volatility, the heartbeat triggers updates to the latest answer. Some heartbeats are configured to last several hours, so your application should check the timestamp and verify that the latest answer is recent enough for your application.
It is recommended to add a tolerance that compares theupdatedAtreturn timestamp fromlatestRoundData()with the current block timestamp and ensure that thepriceFeedis being updated with the required frequency.
If theETH/USDis the only one that is needed to retrieve, because it is the most popular and available pair. It can also be useful to add other oracle to get the price feed (such as Uniswap’s). This can be used as a redundancy in the case of having one oracle that returns outdated values (what is outdated and what is up to date can be determined by a tolerance as mentioned).
mejango (Juicebox) confirmed, but disagreed with severity and commented:
There is also a good description in this duplicate #78
mejango (Juicebox) resolved:
PR with fix:PR #1
berndartmueller (warden) reviewed mitigation:
Appropriate validations to prevent price staleness, round incompleteness and a negative price is put in place now.

[H-02] Token Change Can Be Frontrun, Blocking Token
Submitted by philogy, also found by berndartmueller and Lambda
https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBTokenStore.sol#L246
https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBTokenStore.sol#L266
https://github.com/jbx-protocol/juice-contracts-v2-code4rena/blob/828bf2f3e719873daa08081cfa0d0a6deaa5ace5/contracts/JBController.sol#L605
Impact
This vulnerability allows malicious actors to block other users from changing tokens of their projects. Furthermore if ownership over the token contract is transferred to theJBTokenStorecontract prior to the change, as suggested in therecourse section of Juicebox’s 24.05.2022 post-mortem update, this vulnerability would allow an attacker to become the owner of tokens being transferred. ForJBTokenbased tokens this would allow an attacker to begin issuing arbitrary amounts the token that was meant to be transferred.
Proof of Concept
Exploit scenario:
Wanting to assign their token to their JB project an unsuspecting owner / admin transfers ownership to aJBTokenStorecontract, either directly by callingtransferOwnershipon the token or indirectly by calling thechangeFormethod on an olderJBTokenStorecontract with_newOwnerset as the newJBTokenStorecontract. (For the newer Juicebox contracts theJBControllercontract’schangeTokenOfmethod would be called)Seeing this change an attacker submits achangeTokenForcalling transaction to the newJBControllercontract, triggering theJBTokenStorecontract’schangeFormethod, linking it to one of the attacker’s projects (this could be created in advance or as part of the same transaction via an attack contract)The attacker can then gain ownership over the token by callingchangeTokenForagain with the_newOwnerset to the attacker’s addressAssuming the token has an owner restrictedmintmethod likeJBTokenbased tokens the attacker can now mint an arbitrary amount of the token
Recommended Mitigation Steps
Before allowing a caller to change to a specific token ensure that they have control over it. This can be achieved by storing a list of trusted older JB directories and projects which are then queried. Alternatively the contract could require the caller to actually be the.owner()address of the token to migrate, this would require admins to:
CallchangeTokenOfwith themselves as the new ownerCall the new change token method on the newer contract, since they are the owner they’d pass the checkIndependently transfer the ownership to the new token store to ensure that it can issue tokens
Future migrations can be made more seamless by having older contracts directly call new contracts via a sub-call, removing a necessary transaction for the admin. The newer contracts needs to verify that the older contract is the owner address of the token that’s being set and also has approval of the project owner which is being configured.
mejango (Juicebox) confirmed and commented:
Nice. The project should firstchangeTokenand then transfer ownership.
mejango (Juicebox) resolved:
PR with fix:PR #1
berndartmueller (warden) reviewed mitigation:
Changing an already set project token is not possible anymore.

