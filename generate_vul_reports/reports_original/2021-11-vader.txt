[H-01] Minting and burning synths exposes users to unlimited slippage
Submitted by TomFrenchBlockchain, also found by cmichel
Impact
The amount of synths minted / assets received when minting or burning synths can be manipulated to an unlimited extent by manipulating the reserves of the pool
Proof of Concept
SeeVaderPool.mintSynth:https://github.com/code-423n4/2021-11-vader/blob/607d2b9e253d59c782e921bfc2951184d3f65825/contracts/dex-v2/pool/VaderPoolV2.sol#L126-L167
Here a user sendsnativeDepositto the pool and the equivalent amount offoreignAssetis minted as a synth to be sent to the user. However the user can’t specify the minimum amount of synth that they would accept. A frontrunner can then manipulate the reserves of the pool in order to makeforeignAssetappear more valuable than it really is so the user receives synths which are worth much less than whatnativeDepositis worth. This is equivalent to a swap without a slippage limit.
Burning synths essentially runs the same process in behalf so manipulating the pool in the opposite direction will result in the user getting fewer ofnativeAssetthan they expect.
Recommended Mitigation Steps
Add a argument for the minimum amount of synths to mint or nativeAsset to receive.
SamSteinGG (Vader) acknowledged and disagreed with severity:
We believe the severity should be set to medium as there are no loss of funds and its exploit requires special circumstances to be profitable.
[H-02] Redemption value of synths can be manipulated to drainVaderPoolof all native assets
Submitted by TomFrenchBlockchain
Impact
Draining of funds fromVaderPool
Proof of Concept
See theVaderPool.mintSynthfunction:https://github.com/code-423n4/2021-11-vader/blob/607d2b9e253d59c782e921bfc2951184d3f65825/contracts/dex-v2/pool/VaderPoolV2.sol#L126-L167
As the pool’s reserves can be manipulated through flashloans similar to on UniswapV2, an attacker may set the exchange rate betweennativeAssetand synths (calculated from the reserves). An attacker can exploit this to drain funds from the pool.
The attacker first flashloans and sells a huge amount offoreignAssetto the pool. The pool now thinksnativeAssetis extremely valuable.The attacker now uses a relatively small amount ofnativeAssetto mint synths usingVaderPool.mintSynth. As the pool thinksnativeAssetis very valuable the attacker will receive a huge amount of synths.The attacker can now manipulate the pool in the opposite direction by buying up theforeignAssetthey sold to the pool.nativeAssetis now back at its normal price, or perhaps artificially low if the attacker wishes.The attacker now burns all of their synths. AsnativeAssetis considered much less valuable than at the point the synths were minted it takes a lot more ofnativeAssetin order to pay out for the burned synths.
For the price of a flashloan and some swap fees, the attacker has now managed to extract a large amount ofnativeAssetfrom the pool. This process can be repeated as long as it is profitable.
Recommended Mitigation Steps
Prevent minting of synths or at the very least tie the exchange rate to a manipulation resistant oracle.
[H-03] VADER contains a Fee-On-Transfer
Submitted by jayjonah8, also found by rfa, shri4net, and xYrYuYx
Impact
The whitepaper says that the Vader token contains a Fee-On-Transfer so in XVader.sol, an attacker may be able to keep callingenter()andleave()while being credited more tokens than the contract actually receives eventually draining it.
Proof of Concept
Attacker deposits 500 VaderAttacker receives credit for 500 while the xVader contract gets the 500 - fee.Attacker callsleave()leaving the contract with a difference of the fee.https://www.financegates.net/2021/07/28/another-polygon-yield-farm-crashes-to-zero-after-exploit/https://github.com/code-423n4/2021-11-vader/blob/main/contracts/x-vader/XVader.solhttps://www.vaderprotocol.io/whitepaper
Tools Used
Manually code review
Recommended Mitigation Steps
There should be pre and post checks on balances to get the real amount
0xstormtrooper (Vader) acknowledged:
Vader fee on transfer will be removed
[H-04] TwapOracle doesn’t calculate VADER:USDV exchange rate correctly
Submitted by TomFrenchBlockchain
Impact
Detailed description of the impact of this finding.
Proof of Concept
https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/twap/TwapOracle.sol#L156
On L156 ofTwapOraclewe perform the calculation:
result = ((sumUSD * IERC20Metadata(token).decimals()) / sumNative);
This seems extremely odd as for an 18 decimal token we’re then calculating
result = ((sumUSD * 18) / sumNative);
This is just plain weird. I expect what was meant is to replace this line with the below so we’re properly scaling fortoken’s number of decimals.
uint256 scalingFactor = 10 ** IERC20Metadata(token).decimals()result = (sumUSD * scalingFactor) / sumNative;
Marked as high severity as this exchange rate appears to be used insome form of minting mechanismand correctness of the oracle is listed as one of the key focuses of the audit.
Recommended Mitigation Steps
As above.
SamSteinGG (Vader) confirmed
The TWAP oracle module has been completely removed and redesigned from scratch as LBTwap that is subject of the new audit.
[H-05] LPs of VaderPoolV2 can manipulate pool reserves to extract funds from the reserve.
Submitted by TomFrenchBlockchain, also found by WatchPug
Impact
Impermanent loss protection can be exploited to drain the reserve.
Proof of Concept
InVaderPoolV2.burnwe calculate the current losses that the LP has made to impermanent loss.
https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex-v2/pool/VaderPoolV2.sol#L237-L269
These losses are then refunded to the LP in VADER tokens from the reserve
https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex-v2/router/VaderRouterV2.sol#L208-L227
This loss is calculated by the current reserves of the pool so if an LP can manipulate the pool’s reserves they can artificially engineer a huge amount of IL in order to qualify for a payout up to the size of their LP position.
https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex/math/VaderMath.sol#L73-L93
The attack is then as follows.
Be an LP for a reasonable period of time (IL protection scales linearly up to 100% after a year)Flashloan a huge amount of one of the pool’s assets.Trade against the pool with the flashloaned funds to unbalance it such that your LP position has huge IL.Remove your liquidity and receive compensation from the reserve for the IL you have engineered.Re-add your liquidity back to the pool.Trade against the pool to bring it back into balance.
The attacker now holds the majority of their flashloaned funds (minus slippage/swap fees) along with a large fraction of the value of their LP position in VADER paid out from the reserve. The value of their LP position is unchanged. Given a large enough LP position, the IL protection funds extracted from the reserve will exceed the funds lost to swap fees and the attacker will be able to repay their flashloan with a profit.
This is a high risk issue as after a year any large LP is incentivised and able to perform this attack.
Recommended Mitigation Steps
Use a manipulation resistant oracle for the relative prices of the pool’s assets (TWAP, etc.)
[H-06] Paying IL protection for all VaderPool pairs allows the reserve to be drained.
Submitted by TomFrenchBlockchain
Impact
Vader Reserve can be drained of funds.
Proof of Concept
InVaderPoolV2.burnwe calculate the current losses that the LP has made to impermanent loss.
https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex/pool/VaderPool.sol#L77-L89
These losses are then refunded to the LP in VADER tokens from the reserve. NOTE: This IL protection is paid for ALL token pairs. THIS IS IMPORTANT!
https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex/router/VaderRouter.sol#L187-L206
The loss is calculated by the comparing the amounts of each asset initially added to the pool against the amounts of each asset which are removed from the pool. There’s an unspoken assumption here that the LP entered the pool at the true price at that point.
https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex/math/VaderMath.sol#L73-L93
Crucially we see that if an attacker can cheaply create a pool with a token which starts off with a very low price in terms of VADER and is guaranteed to have a very high price in terms of VADER then they will benefit from a large amount of IL protection funds from the reserve.
An attacker could then perform this attack with the following.
Flashloan a huge amount of Vader (or flashloan + buy VADER).Deploy a token TKN, which the attacker can mint as much as they like.Add liquidity to a new pool with a large amount of VADER and a small amount of TKNUse their ability to mint TKN to buy up all the VADER in their poolRepay flashloan with VADER extracted from pool + some pre-existing funds as attacker needs to cover VADER lost to swap fees/slippage.
The attacker has now engineered a liquidity position which looks massively underwater due to IL but in reality was very cheap to produce. Nobody else can do anything to this pool except just give the attacker money by buying TKN so this attack can’t be prevented. The attacker now just needs to wait for at most a year for the IL protection to tick up and then they can cash in the LP position for a nice payday of up to the amount of VADER they initially added to the pool.
Recommended Mitigation Steps
Add a whitelist to the pairs which qualify for IL protection.
SamSteinGG (Vader) disputed:
Predicting the price fluctuations of an asset is impossible. An attacker cannot create a pool arbitrarily as that is governed by a special whitelist function that is in turn voted on by the DAO.
alcueca (judge) commented:
As we saw in other issues, the creation of pools is permissionless
SamSteinGG (Vader) commented:
@alcueca Again, there seems to be confusion as to the versions utilized. The submitter references the Vader V2 implementation in which pool creations are indeed permissioned (via the add supported token function) as the Vader pool factory is only relevant to the V1 implementation.
[H-07] VaderReserve does not support paying IL protection out to more than one address, resulting in locked funds
Submitted by TomFrenchBlockchain
Impact
All liquidity deployed to one ofVaderPoolorVaderPoolV2will be locked permanently.
Proof of Concept
BothVaderRouterandVaderRouterV2make calls toVaderReservein order to pay out IL protection.
https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex/router/VaderRouter.sol#L206https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex-v2/router/VaderRouterV2.sol#L227
HoweverVaderReserveonly allows a single router to claim IL protection on behalf of users.
https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/reserve/VaderReserve.sol#L80-L83
It’s unlikely that the intent is to deploy multiple reserves so there’s no way for bothVaderRouterandVaderRouterV2to pay out IL protection simultaneously.
This is a high severity issue as any LPs which are using the router which is not listed onVaderReservewill be unable to remove liquidity as the call to the reserve will revert. Vader governance is unable to update the allowed router onVaderReserveso all liquidity on eitherVaderPoolorVaderPoolV2will be locked permanently.
Recommended Mitigation Steps
Options:
Allow the reserve to whitelist multiple addresses to claim fundsAllow the call to the reserve to fail without reverting the entire transaction (probably want to make this optional for LPs)
SamSteinGG (Vader) disputed:
As the code indicates, only one of the two versioned instances of the AMM will be deployed and active at any given time rendering this exhibit incorrect.
alcueca (judge) commented:
Sorry @SamSteinGG, where does the code indicate that?
SamSteinGG (Vader) commented:
Correction, this was clarified during the audit in the discord channel.
[H-08] USDV and VADER rate can be wrong
Submitted by xYrYuYx
Impact
https://github.com/code-423n4/2021-11-vader/blob/main/contracts/twap/TwapOracle.sol#L166
tUSDInUSDVcan be smaller thantUSDInVader, and thengetRatewill return 0.
This will lead wrong rate calculation.
Tools Used
Manually
Recommended Mitigation Steps
Multiple enough decimals before division
SamSteinGG (Vader) confirmed
The TWAP oracle module has been completely removed and redesigned from scratch as LBTwap that is subject of the new audit.
[H-09] VaderPoolV2 incorrectly calculates the amount of IL protection to send to LPs
Submitted by TomFrenchBlockchain
Impact
TheVaderReservepays out IL fromVaderPoolV2LPs expressed in USDV with VADER (assuming a 1:1 exchange rate)
Proof of Concept
From the TwapOracle, it can be seen thatVaderPoolV2is intended to be deployed with USDV as itsnativeAsset:
https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/twap/TwapOracle.sol#L281-L296https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex-v2/pool/BasePoolV2.sol#L58-L59
All the pairs inVaderPoolV2are then USDV:TKN where TKN is some other token, exactly which is irrelevant in this case.
VaderPoolV2offers IL protection where any IL is refunded from theVaderReserve
https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex-v2/pool/VaderPoolV2.sol#L258-L268
TheVaderReserveholds a balance of VADER tokens which will be used to pay out this protection.
https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/reserve/VaderReserve.sol#L76-L90
The IL experienced by the LP is calculated inVaderMath.calculateLoss
https://github.com/code-423n4/2021-11-vader/blob/3a43059e33d549f03b021d6b417b7eeba66cf62e/contracts/dex/math/VaderMath.sol#L73-L93
This is the core of the issue. From the variable names it’s clear that this is written with the assumption that it is work on units of VADER whereas it is provided amounts in terms of USDV. CheckingVaderRouterV2we can see that we pass the output of this calculation directly to the reserve in order to claim VADER.
If an LP experienced 100 USDV worth of IL, instead of claiming the equivalent amount of VADER they would receive exactly 100 VADER as there’s no handling of the exchange rate between USDV and VADER.
As VADER and USDV are very unlikely to trade at parity LPs could get sustantially more or less than the amount of IL they experienced.
Recommended Mitigation Steps
Add handling for the conversion rate between VADER and USDV using a tamper resistant oracle (TwapOracle could potentially fulfil this role).
SamSteinGG (Vader) confirmed
[H-10]  calculate Loss is vulnerable to flashloan attack
Submitted by jonah1005
Impact
The VaderPool would compensate users’ IL. The formula it uses to calculate lp value is vulnerable to manipulation.
The formula to calculate the lp value is similar to warp finance which is known to be unsafe.warpfinance-incident-root-cause-analysis(Please to refer to the POC section)
The Attacker can purchase an old lp position, manipulate price, take IL compensation and drain the reserve.
I consider this is a high-risk issue.
Proof of Concept
VaderMath.sol#L69-L93
The lp value is calculated as[(A0 * P1) + V0]and// [(A1 * P1) + V1].
Assume that there’s an ETH pool and there’s 100 ETH and 100 Vader in the pool.
Attacker deposit 1 ETH and 1 Vader and own 1% of the liquidity.Wait 1 yearStart flash loan and buy a lot ETH with 99900 Vader.There’s  0.1 ETH 100,000 Vader in the pool.Burn 1 % lp at the price 1 ETH = 1,000,000 Vader.A0 * P1 + V0 = 1 (eth) * 1,000,000 (price) + 100 (vader)A1 * P1 + V1 = 0.001 (eth) * 1,000,000 (price) + 10,000 (vader)IL compensation would be around9891000.
Tools Used
None
Recommended Mitigation Steps
Please use the fair lp pricing formula from alpha finance instead.fair-lp-token-pricing
SamSteinGG (Vader) disputed:
The described attack scenario can not be executed as the pool would actually consume the flash loan. The CLP model follows a non-linear curve that actually diminishes in value as the trade size increases, meaning that at most 25% of the total assets in the pool can be drained at a given iteration. This, on top with the fees of each transaction render this attack vector impossible. Please request a tangible attack test from the warden if this is meant to be accepted as valid.
alcueca (judge) commented:
The CLP model isn’t mentioned in the readme or the whitepaper. The issue is valid according to the materials supplied.
SamSteinGG (Vader) commented:
@alcueca As the grading guidelines of C4 state, a documentation issue cannot constitute more than a low risk finding. We advise the severity to be lowered.
[H-11] (dex-v1) BasePool.mint() function can be frontrun
Submitted by Reigada
Impact
In the contract BasePool the mint function can be frontrun. This will assign the NFT to the attacker which later on he can burn it retrieving the corresponding\_nativeAssetand\_foreignAssetinitially deposited by the frontrun victim.https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex/pool/BasePool.sol#L149-L194
Proof of Concept
User1 transfers 1000\_nativeAssettokens and 1000\_foreignAssettokens into the BasePool contract.
User1 calls theBasePool.mint()function to retrieve his NFT.
Attacker is constantly polling for an increase of the balance of\_nativeAssetand\_foreignAssetof the contract OR attacker is constantly scanning the mempool formint()function calls.
Attacker detects an increase of balance of\_nativeAssetand\_foreignAssetOR attacker detects amint()function call in the mempool.
Attacker frontruns the mint call and retrieves the NFT. Gets a NFT that is worth 1000\_nativeAssetsand 1000\_foreignAssets.
User1 gets a NFT that is worth 0\_nativeAssetsand 0\_foreignAssets.
Attacker burns the NFT retrieving the corresponding\_nativeAssetand\_foreignAssetinitially deposited by the victim.
Tools Used
Manual testing
Recommended Mitigation Steps
Include in themint()function the transfer of\_nativeAssetsand\_foreignAssetsto the smart contract.
SamSteinGG (Vader) disputed:
The pool is meant to be utilized via the router or smart contracts and is not meant to be utilized directly.  The exact same “flaw” exists in Uniswap V2 whereby if you transfer assets directly someone else can claim them on your behalf.
alcueca (judge) commented:
Ah, so this how you prevent direct access to the pools. The issue is valid due to lack of documentation on the usage of the router.
SamSteinGG (Vader) commented:
Firstly, documentation related issues cannot constitute a high risk vulnerability. Secondly, this type of documentation does not exist in Uniswap V2 either. We advise this finding to be set to no risk.
[H-12] Attacker can get extremely cheap synth by front-running create Pool
Submitted by jonah1005, also found by defsec
Impact
createPoolis a permissionless transaction.
Anyone can create a token pool.Token price is set by the first lp provider.User can get a synthetic asset.
Assume a new popularcointhat the DAO decides to add to the protocol.
The attacker can create the pool and set it to be extremely cheap. (By depositing 1 weicoinand 10^18 wei Vader.) The attacker can mint a lot of synth by providing another 10^18 wei Vader.
There’s no way to revoke the pool. Thecoinpool would be invalid since the attacker can drain all the lp in the pool.
I consider this is a high-risk issue.
Proof of Concept
VaderPoolFactory.sol#L43-L89VaderPoolV2.sol#L115-L167
Tools Used
None
Recommended Mitigation Steps
Restrict users from minting synth from a new and illiquid pool.
Some thoughts about the fix:
Decide minimum liquidity for a synthetic asset (e.g 1M Vader in the pool)Once there’s enough liquidity pool, anyone can deploy a synthetic asset after a cool down. (e.g. 3 days
The pool can remain permissionless and safe.
SamSteinGG (Vader) disputed:
This is an invalid finding as creating pools is not a permissionless operation, the token must be in the supported list of assets.
alcueca (judge) commented:
I can’t see a check for a token to be in a supported list of assets.
SamSteinGG (Vader) commented:
@alcueca There seems to be some confusion. The submitted of the bounty links the Vader Pool Factory of DEX V1 and the Pool of DEX V2 which are not interacting between them. As such, the finding is invalid.
[H-13] Anyone Can Arbitrarily Mint Synthetic Assets InVaderPoolV2.mintSynth()
Submitted by leastwood
Impact
ThemintSynth()function is callable by any user and creates a synthetic asset againstforeignAssetif it does not already exist. The protocol expects a user to first approve the contract as a spender before callingmintSynth(). However, any arbitrary user could monitor the blockchain for contract approvals that matchVaderPoolV2.soland effectively frontrun their call tomintSynth()by setting thetoargument to their own address. As a result, thenativeDepositamount is transferred from the victim, and a synthetic asset is minted and finally transferred to the malicious user who is represented by thetoaddress.
Proof of Concept
https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex-v2/pool/VaderPoolV2.sol#L126-L167
Tools Used
Manual code review.
Discussions with dev.
Recommended Mitigation Steps
Consider removing thefromargument inmintSynth()and update thesafeTransferFrom()call to instead transfer frommsg.sender.
SamSteinGG (Vader) commented:
The pool contracts, similarly to Uniswap V2, are never meant to be interacted with directly.
[H-14] Anyone Can Arbitrarily Mint Fungible Tokens InVaderPoolV2.mintFungible()
Submitted by leastwood
Impact
ThemintFungible()function is callable by any user that wishes to mint liquidity pool fungible tokens. The protocol expects a user to first approve the contract as a spender before callingmintFungible(). However, any arbitrary user could monitor the blockchain for contract approvals that matchVaderPoolV2.soland effectively frontrun their call tomintFungible()by setting thetoargument to their own address. As a result, thenativeDepositandforeignDepositamounts are transferred from the victim, and LP tokens are minted and finally transferred to the malicious user who is represented by thetoaddress.
Proof of Concept
https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex-v2/pool/VaderPoolV2.sol#L284-L335
Tools Used
Manual code review.
Discussions with dev.
Recommended Mitigation Steps
Consider removing thefromargument inmintFungible()and update thesafeTransferFrom()calls to instead transfer frommsg.sender.
SamSteinGG (Vader) disputed:
The pool contracts, similarly to Uniswap V2, are never meant to be interacted with directly.
alcueca (judge) commented:
You need to enforce that somehow.
SamSteinGG (Vader) confirmed:
Upon second consideration, the functions relating to the minting of synths and wrapped tokens should have had the onlyRouter modifier and thus are indeed vulnerable. Issue accepted.
[H-15]VaderRouter._swapperforms wrong swap
Submitted by cmichel
The 3-path hop inVaderRouter._swapis supposed to first swapforeignassets to native assets, and then the received native assets to different foreign assets again.
Thepool.swap(nativeAmountIn, foreignAmountIn)accepts the foreign amount as thesecondargument.
The code however mixes these positional arguments up and tries to perform apool0foreign -> native swap by using theforeignamount as thenative amount:
function_swap(uint256amountIn,address[]calldatapath,addressto)privatereturns(uint256amountOut) {if(path.length==3) {// ...// @audit calls this with nativeAmountIn = amountIn. but should be foreignAmountIn (second arg)returnpool1.swap(0,pool0.swap(amountIn,0,address(pool1)),to);}}// @audit should be this insteadreturnpool1.swap(pool0.swap(0,amountIn,address(pool1)),0,to);
Impact
All 3-path swaps through theVaderRouterfail in the pool check whenrequire(nativeAmountIn = amountIn <= nativeBalance - nativeReserve = 0)is checked, as foreign amount is sent butnativeamount is specified.
Recommended Mitigation Steps
Usereturn pool1.swap(pool0.swap(0, amountIn, address(pool1)), 0, to);instead.
SamSteinGG (sponsor) confirmed
[H-16]VaderRouter.calculateOutGivenIncalculates wrong swap
Submitted by cmichel
The 3-path hop inVaderRouter.calculateOutGivenInis supposed to first swapforeignassets to native assetsin pool0, and then the received native assets to different foreign assets againin pool1.
The first argument ofVaderMath.calculateSwap(amountIn, reserveIn, reserveOut)must refer to the same token as the second argumentreserveIn.
The code however mixes these positions up and first performs a swap inpool1instead ofpool0:
functioncalculateOutGivenIn(uint256amountIn,address[]calldatapath)externalviewreturns(uint256amountOut){if(...) {}else{returnVaderMath.calculateSwap(VaderMath.calculateSwap(// @audit the inner trade should not be in pool1 for a forward swap. amountIn foreign => next param should be foreignReserve0amountIn,nativeReserve1,foreignReserve1),foreignReserve0,nativeReserve0);}/** @audit instead should first be trading in pool0!VaderMath.calculateSwap(VaderMath.calculateSwap(amountIn,foreignReserve0,nativeReserve0),nativeReserve1,foreignReserve1);*/
Impact
All 3-path swaps computations throughVaderRouter.calculateOutGivenInwill return the wrong result.
Smart contracts or off-chain scripts/frontends that rely on this value to trade will have their transaction reverted, or in the worst case lose funds.
Recommended Mitigation Steps
Return the following code instead which first trades inpool0and then inpool1:
returnVaderMath.calculateSwap(VaderMath.calculateSwap(amountIn,foreignReserve0,nativeReserve0),nativeReserve1,foreignReserve1);
SamSteinGG (Vader) confirmed
[H-17] TWAPOracle might register with wrong token order
Submitted by cmichel
TheTWAPOracle.registerPairfunction takes in afactoryand (token0, token1).
The function accepts a_factoryargument which means any Uniswap-like factory can be used.
When using the actual Uniswap factory’sIUniswapV2Factory(factory).getPair(token0, token1)call, it could be that thetoken0andtoken1are reversed as itignores the order.
Meaning, theprice0/1CumulativeLastcould also be reversed as it matches the internal order.
The code however pushes the_pairsassuming that the internalprice0CumulativeLast, price1CumulativeLastorder matches the order of the function argumentstoken0, token1.
_pairs.push(PairData({pair:pairAddr,token0:token0,token1:token1,price0CumulativeLast:price0CumulativeLast,price1CumulativeLast:price1CumulativeLast,blockTimestampLast:blockTimestampLast,price0Average:FixedPoint.uq112x112({_x:0}),price1Average:FixedPoint.uq112x112({_x:0})}));
Impact
The prices could be inverted which leads to the oracle providing wrong prices.
Recommended Mitigation Steps
It should be checked if Uniswap’s internal order matches the order of thetoken0/1function arguments.
If not, the cumulative prices must be swapped.
// pseudocodeIUniswapV2Pairpair=IUniswapV2Pair(IUniswapV2Factory(factory).getPair(token0,token1));pairAddr=address(pair);price0CumulativeLast=pair.price0CumulativeLast();price1CumulativeLast=pair.price1CumulativeLast();(price0CumulativeLast,price1CumulativeLast) =token0==pair.token0() ? (price0CumulativeLast,price1CumulativeLast) : (price1CumulativeLast,price0CumulativeLast);
The same issue exists inupdate
SamSteinGG (Vader) confirmed
The TWAP oracle module has been completely removed and redesigned from scratch as LBTwap that is subject of the new audit.
[H-18] Attacker can claim more IL by manipulating pool price thenremoveLiquidity
Submitted by gzeon
Impact
Vader reimburse user IL immediately when user withdraw from the pool (VaderRouterV2.sol:L227), an attacker can therefore manipulate the pool balance causing a high IL, remove liquidity and restore the pool balance such that he will receive a larger IL reimbursement.
Proof of Concept
Let’s assume our attacker own 100% of FOO-VADER
Attacker add 100 FOO and 100 VADER to the Poolwait some block, or 1 year for max IL protectionIn 1 transaction, attackerSwap 9900 FOO to 99 VaderPool now have 10000 FOO and 1 VADERBy VaderMath.sol:L84 the loss is 100*1/10000+100-2 = 98.01 VADERRemove liquidity and receive 10000 FOO and 99.01 VADERRestore the pool balanceSuch that the attacker will gain 98.01 VADER without risk
The profit is constrained by gas cost, pool fee, % of pool controlled by the attacker and % of IL protection.
Recommended Mitigation Steps
Use twap price to determine P1 in VaderMath.sol:L84 when calculating IL to reduce risk of manipulation
SamSteinGG (Vader) commented:
Duplicate of #2
alcueca (judge) commented:
Doesn’t seem like a duplicate to me, @SamSteinGG?
SamSteinGG (Vader) commented:
@alcueca The stated trade cannot occur as trades are inherently limited by the CLP design of the protocol to one third of the available pair liquidity. As such, the illustrated pair would actually result in almost zero units retrieved back.
[H-19] Governance veto can be bypassed
Submitted by gzeon
Impact
Sincevetoensure none of the actions in proposal being vetoed point to the contract (GovernorAlpha.sol:L562), a malicious proposal can be designed to have an action that point to governance and therefore effectively cannot be vetoed.
Proof of Concept
For any attacker who want to launch a governance attack using a malicious proposal, they simply need to add an action that point to governance that does nothing (or anything).
Recommended Mitigation Steps
Some other design can be proposal are vetoable whenever the differential is less than x%, even if it involves governance change, s.t. council can veto most malicious proposal while it is still possible to change council given high enough vote differential.
SamSteinGG (Vader) commented:
Duplicate of #61
alcueca (judge) commented:
Not a duplicate
[H-20] Early user can breakaddLiquidity
Submitted by WatchPug
https://github.com/code-423n4/2021-11-vader/blob/429970427b4dc65e37808d7116b9de27e395ce0c/contracts/dex/pool/BasePool.sol#L161-L163
uint256totalLiquidityUnits=totalSupply;if(totalLiquidityUnits==0)liquidity=nativeDeposit;// TODO: Contact ThorChain on proper approach
In the current implementation, the firstliquiditytakes thenativeDepositamount and uses it directly.
However, since this number (totalLiquidityUnits) will later be used for computing theliquidityissued for futureaddLiquidityusingcalculateLiquidityUnits.
A malicious user can add liquidity with only1 weiUSDV and making it nearly impossible for future users to add liquidity to the pool.
Recommendation
Uni v2 solved this problem by sending the first 1000 tokens to the zero address.
The same should work here, i.e., on first mint (totalLiquidityUnits == 0), lock some of the first minter’s tokens by minting ~1% of the initial amount to the zero address instead of to the first minter.
SamSteinGG (Vader) commented:
Duplicate of #24
alcueca (judge) commented:
Not a duplicate
[H-21] Lack of access control allow attacker tomintFungible()andmintSynth()with other user’s wallet balance
Submitted by WatchPug
https://github.com/code-423n4/2021-11-vader/blob/429970427b4dc65e37808d7116b9de27e395ce0c/contracts/dex-v2/pool/VaderPoolV2.sol#L284-L335
functionmintFungible(IERC20foreignAsset,uint256nativeDeposit,uint256foreignDeposit,addressfrom,addressto)externaloverridenonReentrantreturns(uint256liquidity) {IERC20Extendedlp=wrapper.tokens(foreignAsset);require(lp!=IERC20Extended(_ZERO_ADDRESS),"VaderPoolV2::mintFungible: Unsupported Token");(uint112reserveNative,uint112reserveForeign, ) =getReserves(foreignAsset);// gas savingsnativeAsset.safeTransferFrom(from,address(this),nativeDeposit);foreignAsset.safeTransferFrom(from,address(this),foreignDeposit);PairInfostoragepair=pairInfo[foreignAsset];uint256totalLiquidityUnits=pair.totalSupply;if(totalLiquidityUnits==0)liquidity=nativeDeposit;elseliquidity=VaderMath.calculateLiquidityUnits(nativeDeposit,reserveNative,foreignDeposit,reserveForeign,totalLiquidityUnits);require(liquidity>0,"VaderPoolV2::mintFungible: Insufficient Liquidity Provided");pair.totalSupply=totalLiquidityUnits+liquidity;_update(foreignAsset,reserveNative+nativeDeposit,reserveForeign+foreignDeposit,reserveNative,reserveForeign);lp.mint(to,liquidity);emitMint(from,to,nativeDeposit,foreignDeposit);}
https://github.com/code-423n4/2021-11-vader/blob/429970427b4dc65e37808d7116b9de27e395ce0c/contracts/dex-v2/pool/VaderPoolV2.sol#L126-L167
Funds are transferred from thefromparameter, and the output tokens are transferred to thetoparameter, both passed by the caller without proper access control.
Impact
This issue allows anyone to callmintFungible()andmintSynth()and steal almost all their wallet balances for all the users who have approved the contract before.
SamSteinGG (Vader) commented:
Duplicate #67
alcueca (judge) commented:
Not a duplicate.
SamSteinGG (Vader) commented:
@alcueca Can you elaborate as to why it is not a duplicate?
[H-22]mintSynth()andburnSynth()can be front run
Submitted by WatchPug
https://github.com/code-423n4/2021-11-vader/blob/429970427b4dc65e37808d7116b9de27e395ce0c/contracts/dex-v2/pool/VaderPoolV2.sol#L126-L155https://github.com/code-423n4/2021-11-vader/blob/429970427b4dc65e37808d7116b9de27e395ce0c/contracts/dex-v2/pool/VaderPoolV2.sol#L179-L197
Given thatmintSynth()andburnSynth()will issue and redeem assets based on the price of the pool (reserves), and they will create price impact based on the volume being minted and burnt.
However, the current implementation provides no parameter for slippage control, making them vulnerable to front-run attacks. Especially for transactions with rather large volumes.
Recommendation
Consider adding aminAmountOutparameter.
[H-23]Synthtokens can get over-minted
Submitted by WatchPug
Per the document:
It also is capable of using liquidity units as collateral for synthetic assets, of which it will always have guaranteed redemption liquidity for.
However, in the current implementation,Synthtokens are minted based on the calculation result. WhilenativeDepositbe added to the reserve,reserveForeignwill remain unchanged, not deducted nor locked.
Making it possible forSynthtokens to get over-minted.
Proof of Concept
The Vader pool for BTC-USDV is newly created, with nearly 0 liquidity.Alice add liquidity with100,000 USDVand1 BTC;BobmintSynth()with100,000 USDV, got0.25 BTC vSynth;Alice remove all the liquidity received at step 1, got all the200k USDVand1 BTC.
The0.25 BTC vSynthheld by Bob is now backed by nothing and unable to be redeemed.
This also makes it possible for a sophisticated attacker to steal funds from the Vader pool.
The attacker may do the following in one transaction:
Add liquidity with10 USDVand10,000 BTC(flash loan);CallmintSynth()with10 USDV, repeat for 10 times, got1461 BTC vSynth;Remove liquidity and repay flash loan, keep the1461 BTC vSynth;Wait for other users to add liquidity and when the BTC reserve is sufficient, callburnSynth()to stealUSDVfrom the pool.
SamSteinGG (Vader) confirmed
Given that the codebase attempts to implement the Thorchain rust code in a one-to-one fashion, findings that relate to the mathematical accuracy of the codebase will only be accepted in one of the following cases:The code deviates from the Thorchain implementationA test case is created that illustrates the problem
While intuition is a valid ground for novel implementations, we have re-implemented a battle-tested implementation in another language and as such it is considered secure by design unless proven otherwise.
[H-24] Wrong design/implementation ofaddLiquidity()allows attacker to steal funds from the liquidity pool
Submitted by WatchPug
The current design/implementation of Vader pool allows users toaddLiquidityusing arbitrary amounts instead of a fixed ratio of amounts in comparison to Uni v2.
We believe this design is flawed and it essentially allows anyone to manipulate the price of the pool easily and create an arbitrage opportunity at the cost of all other liquidity providers.
An attacker can exploit this by adding liquidity in extreme amounts and drain the funds from the pool.
https://github.com/code-423n4/2021-11-vader/blob/429970427b4dc65e37808d7116b9de27e395ce0c/contracts/dex-v2/pool/VaderPoolV2.sol#L284-L335
functionmintFungible(IERC20foreignAsset,uint256nativeDeposit,uint256foreignDeposit,addressfrom,addressto)externaloverridenonReentrantreturns(uint256liquidity) {IERC20Extendedlp=wrapper.tokens(foreignAsset);require(lp!=IERC20Extended(_ZERO_ADDRESS),"VaderPoolV2::mintFungible: Unsupported Token");(uint112reserveNative,uint112reserveForeign, ) =getReserves(foreignAsset);// gas savingsnativeAsset.safeTransferFrom(from,address(this),nativeDeposit);foreignAsset.safeTransferFrom(from,address(this),foreignDeposit);PairInfostoragepair=pairInfo[foreignAsset];uint256totalLiquidityUnits=pair.totalSupply;if(totalLiquidityUnits==0)liquidity=nativeDeposit;elseliquidity=VaderMath.calculateLiquidityUnits(nativeDeposit,reserveNative,foreignDeposit,reserveForeign,totalLiquidityUnits);require(liquidity>0,"VaderPoolV2::mintFungible: Insufficient Liquidity Provided");pair.totalSupply=totalLiquidityUnits+liquidity;_update(foreignAsset,reserveNative+nativeDeposit,reserveForeign+foreignDeposit,reserveNative,reserveForeign);lp.mint(to,liquidity);emitMint(from,to,nativeDeposit,foreignDeposit);}
Proof of Concept
Given:
A Vader pool with100,000 USDVand1 BTC;ThetotalPoolUnitsis100.
The attacker can do the following in one transaction:
Add liquidity with100,000 USDVand 0 BTC, get50 liquidityUnits, representing 1/3 shares of the pool;Swap0.1 BTCto USDV, repeat for 5 times; spent0.5 BTCand got62163.36 USDV;Remove liquidity, get back45945.54 USDVand0.5 BTC; profit for: 62163.36 + 45945.54 - 100000 = 8108.9 USDV.
SamSteinGG (Vader) disputed:
This is the intended design of the Thorchain CLP model. Can the warden provide a tangible attack vector in the form of a test?
alcueca (judge) commented:
Sponsor is acknowledging the issue.
SamSteinGG (Vader) commented:
@alcueca We do not acknowledge the issue. This is the intended design of the CLP model and the amount supplied for a trade is meant to be safeguarded off-chain. It is an inherent trait of the model.
[H-25] Wrong design ofswap()results in unexpected and unfavorable outputs
Submitted by WatchPug
The current formula to calculate theamountOutfor a swap is:
https://github.com/code-423n4/2021-11-vader/blob/429970427b4dc65e37808d7116b9de27e395ce0c/contracts/dex/math/VaderMath.sol#L99-L111
functioncalculateSwap(uint256amountIn,uint256reserveIn,uint256reserveOut)publicpurereturns(uint256amountOut) {// x * Y * Xuint256numerator=amountIn*reserveIn*reserveOut;// (x + X) ^ 2uint256denominator=pow(amountIn+reserveIn);amountOut=numerator/denominator;}
We believe the design (the formula) is wrong and it will result in unexpected and unfavorable outputs.
Specifically, if theamountInis larger than thereserveIn, theamountOutstarts to decrease.
Proof of Concept
Given:
A USDV-BTC Vader pool with the reserves of200,000 USDVand2 BTC.If Alice swap2 BTCfor USDV, will get50000 USDVas output;If Bob swap2.1 BTCfor USDV, will only get49970.25 USDVas output;If Carol swap2.2 BTCfor USDV, will only get49886.62 USDVas output.
For the same pool reserves, paying more for less output token is unexpected and unfavorable.
SamSteinGG (Vader) disputed:
This is the intended design of the Thorchain CLP model. Can the warden provide a tangible attack vector in the form of a test?
alcueca (judge) commented:
It is true that the effect will be surprising to the user, and the issue is acknowledged by the sponsor.
SamSteinGG (Vader) commented:
@alcueca We do not acknowledge the issue. This is the intended design of the CLP model and the amount supplied for a trade is meant to be safeguarded off-chain. It is an inherent trait of the model.
[H-26] All user assets which are approved to VaderPoolV2 may be stolen
Submitted by TomFrenchBlockchain, also found by cmichel
Impact
Total loss of funds which have been approved onVaderPoolV2
Proof of Concept
VaderPoolV2allows minting of fungible LP tokens with themintFungiblefunction
https://github.com/code-423n4/2021-11-vader/blob/607d2b9e253d59c782e921bfc2951184d3f65825/contracts/dex-v2/pool/VaderPoolV2.sol#L284-L290
Crucially this function allows a user supplied value forfromwhich specifies where thenativeAssetandforeignAssetshould be pulled from. An attacker can then provide any address which has a token approval ontoVaderPoolV2and mint themselves LP tokens - stealing the underlying tokens.
Recommended Mitigation Steps
Removefromargument and use msg.sender instead.
SamSteinGG (Vader) disputed):
pool is not meant to be interacted with
alcueca (judge) commented:
And how are you going to ensure that the pool is not interacted with, @SamSteinGG?
SamSteinGG (Vader) confirmed:
@alcueca Upon second consideration, the functions relating to the minting of synths and wrapped tokens should have had the onlyRouter modifier and thus are indeed vulnerable. Issue accepted.
[H-27] Unrestricted vestFor
Submitted by pauliax, also found by hack3r-0m
Impact
Anyone can call functionvestForand block any user with a tiny amount of Vader. This function has no auth checks so a malicious actor can front-run legitvestForcalls with insignificant amounts. This function locks the user for 365 days and does not allow updating the value, thus forbids legit conversions.
Recommended Mitigation Steps
Consider introducing a whitelist of callers that can vest on behalf of others (e.g. Converter).
SamSteinGG (Vader) confirmed
[H-28] Incorrect Price Consultation Results
Submitted by leastwood
Impact
TheTwapOracle.consult()function iterates over all token pairs which belong to eitherVADERor USDV` and then calculates the price of the respective asset by using both UniswapV2 and Chainlink price data. This helps to further protect against price manipulation attacks as the price is averaged out over the various registered token pairs.
Let’s say we wanted to query the price ofUSDV, we would sum up any token pair whereUSDV == pairData.token0.
The sum consists of the following:
Price ofUSDVdenominated in terms oftoken1(USDV/token1).Price of token1 denominated in terms ofUSD(token1/USD).
Consider the following example:
SUSHIis the only registered token pair that exists alongsideUSDV.Hence, calculatingsumNativegives us an exchange rate that is denominated asUSDV/SUSHI.Similarly,sumUSDgives us the following denominated pair,SUSHI/USD.I’d expect the result to equalsumUSD * token.decimals() * sumNativewhich should give us a USDV/USD denominated result.
However, the protocol calculates it as(sumUSD * token.decimals()) / sumNativewhich gives us aSUSHI^2 / (USD*USDV)denominated result. This seems incorrect.
I’d classify this issue as high risk as the oracle returns false results upon being consulted. This can lead to issues in other areas of the protocol that use this data in performing sensitive actions.
Proof of Concept
https://github.com/code-423n4/2021-11-vader/blob/main/contracts/twap/TwapOracle.sol#L115-L157
Similar working implementation listed below:
https://github.com/gg2001/dpx-oracle/blob/master/contracts/UniswapV2Oracle.sol#L184-L211https://github.com/gg2001/dpx-oracle/blob/master/contracts/UniswapV2Oracle.sol#L291-L304
Tools Used
Manual code review.
Recommended Mitigation Steps
To calculate the correct consultation of a given token, the result should returnsumUSD * token.decimals() * sumNativeinstead to ensure the target token to consult is denominated inUSDand contains the correct number of decimals.
SamSteinGG (Vader) confirmed:
The description seems slightly incorrect as it uses a power where multiplication is performed but the general idea is correct.
[H-29] VaderPoolV2.mintFungible exposes users to unlimited slippage
Submitted by TomFrenchBlockchain
Impact
Frontrunners can extract up to 100% of the value provided by LPs to VaderPoolV2.
Proof of Concept
Users can provide liquidity toVaderPoolV2through themintFungiblefunction.
https://github.com/code-423n4/2021-11-vader/blob/429970427b4dc65e37808d7116b9de27e395ce0c/contracts/dex-v2/pool/VaderPoolV2.sol#L271-L335
This allows users to provide tokens in any ratio and the pool will calculate what fraction of the value in the pool this makes up and mint the corresponding amount of liquidity units as an ERC20.
However there’s no way for users to specify the minimum number of liquidity units they will accept. As the number of liquidity units minted is calculated from the current reserves, this allows frontrunners to manipulate the pool’s reserves in such a way that the LP receives fewer liquidity units than they should. e.g. LP provides a lot ofnativeAssetbut very littleforeignAsset, the frontrunner can then sell a lot ofnativeAssetto the pool to devalue it.
Once this is done the attacker returns the pool’s reserves back to normal and pockets a fraction of the value which the LP meant to provide as liqudity.
Recommended Mitigation Steps
Add a user-specified minimum amount of LP tokens to mint.
SamSteinGG (Vader) confirmed
Given that the codebase attempts to implement the Thorchain rust code in a one-to-one fashion, findings that relate to the mathematical accuracy of the codebase will only be accepted in one of the following cases:The code deviates from the Thorchain implementationA test case is created that illustrates the problem
While intuition is a valid ground for novel implementations, we have re-implemented a battle-tested implementation in another language and as such it is considered secure by design unless proven otherwise.
An additional note on this point is that any behaviour that the Thorchain model applies is expected to be the intended design in our protocol as well.
An important example is the slippage a user incurs on joining a particular LP pool for which there is no check as there can’t be any. Enforcing an LP unit based check here is meaningless given that LP units represent a share that greatly fluctuates (1 unit of LP out of 100 units is different than 1 out of 1000, however, a slippage check for 100 units of DAI for example is valid).
[H-30] Newly Registered Assets Skew Consultation Results
Submitted by leastwood
Impact
TheTwapOracle.consult()function iterates over all token pairs which belong to eitherVADERor USDV` and then calculates the price of the respective asset by using both UniswapV2 and Chainlink price data. This helps to further protect against price manipulation attacks as the price is averaged out over the various registered token pairs.
If a new asset is added by first registering the token pair and aggregator, the consultation result for that token pair will remain skewed until the next update interval. This is due to the fact that the native asset amount will return0due to the defaultprice1Averagevalue being used. However, the Chainlink oracle will return a valid result. As a result, the query will be skewed in favour ofsumUSDresulting in incorrect consultations.
I’d classify this issue as high risk as the oracle returns false results upon being consulted. This can lead to issues in other areas of the protocol that use this data in performing sensitive actions.
Proof of Concept
https://github.com/code-423n4/2021-11-vader/blob/main/contracts/twap/TwapOracle.sol#L115-L157https://github.com/code-423n4/2021-11-vader/blob/main/contracts/twap/TwapOracle.sol#L314https://github.com/code-423n4/2021-11-vader/blob/main/contracts/twap/TwapOracle.sol#L322-L369
Tools Used
Manual code review.
Recommended Mitigation Steps
Consider performing proper checks to ensure that ifpairData.price1Average._x == 0, then the Chainlink aggregator is not queried and not added tosumUSD. Additionally, it may be useful to fix the current check to assert that thepairData.price1Average.mul(1).decode144()result is not0, foundhere.require(sumNative != 0)is used to assert this, however, this should berequire(pairData.price1Average.mul(1).decode144() != 0)instead.
SamSteinGG (Vader) confirmed
The TWAP oracle module has been completely removed and redesigned from scratch as LBTwap that is subject of the new audit.
[H-31] Unused slippage params
Submitted by pauliax, also found by TomFrenchBlockchain
Impact
Unused slippage params.
functionaddLiquidityin VaderRouter (both V1 and V2) do not use slippage parameters:
uint256,// amountAMin = unuseduint256,// amountBMin = unused
making it susceptible to sandwich attacks / MEV.
For a more detailed explanation, see:https://github.com/code-423n4/2021-09-bvecvx-findings/issues/57
Recommended Mitigation Steps
Consider paying some attention to the slippage to reduce possible manipulation attacks from mempool snipers.
SamSteinGG (Vader) disputed:
Slippage checks are impossible in the Thorchain CLP model.
alcueca (judge) commented:
Taking as main over #1 as it is a more general issue, but refer to #1 for a more detailed description and justification for the severity rating.
[H-32] Covering impermanent loss allows profiting off asymmetric liquidity provision at expense of reserve holdings
Submitted by hyh
Impact
Pool funds will be siphoned out over time as swaps and asymmetric LP provision are balancing each other economically, while with introduction of IL reimbursement a malicious user can profit immediately from out of balance pool with a swap and profit again from IL coverage. This requires locking liquidity to a pool, but still represents an additional profit without additional risk at expense of reserve funds.
Another variant of exploiting this is to add liquidity in two steps: deposit 1 with 0 slip adjustment, perfectly matching current market price, deposit 2 with more Vader than market price suggests, moving pool out of balance with Vader becoming cheaper, then exiting deposit 1 with profit because slip adjustment reduce deposit 2’s share issuance and deposit 1’s now has more asset claims than before. Deposit 2 then need to wait and exit after some time.
IL is calculated as((originalAsset * releasedVader) / releasedAsset) + originalVader - ((releasedAsset * releasedVader) / releasedAsset) + releasedVader, i.e. original deposit values without taking account of slip adjustment are used, so providing more Vader in deposit 2 leads to greater IL, which this way have 2 parts: market movements related and skewed liquidity provision related. IL covering compensates for slip adjustments this way.
Proof of Concept
The steps to reproduce are:
add asymmetric LP via mint (with NFT),either swap gathering profit from pool skew or do symmetric deposit beforehand and exit it nowwait for some period for IL protection to be enabled, then withdraw, having IL covered by reserve fund
Router addLiquidity:https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex-v2/router/VaderRouterV2.sol#L114
NFT mint:https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex-v2/pool/BasePoolV2.sol#L168
Router removeLiquidity:https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex-v2/router/VaderRouterV2.sol#L227
NFT burn:https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex-v2/pool/VaderPoolV2.sol#L237
IL calculation:https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex/math/VaderMath.sol#L73
Recommended Mitigation Steps
Asymmetric liquidity provision doesn’t provide much business value, introducing substantial attack surface, so the core recommendation here is to remove a possibility to add liquidity asymmetrically: instead of penalizing LP with slip adjustment do biggest liquidity addition with 0 slip adjustment that user provided funds allow, and return the remaining part.
This will also guard against cases when user added liquidity with big slip adjustment penalty without malicious intent, not realizing that this penalty will take place, an effect that poses reputational risk to any project using the approach.
Allowing only symmetric liquidity addition removes the described attack surface.
SamSteinGG (Vader) marked as duplicate
alcueca (judge) commented:
Duplicate of which other issue, @SamSteinGG?
[H-33] Mixing different types of LP shares can lead to losses for Synth holders
Submitted by hyh
Impact
Users that mint Synths do not get pool shares, so exiting of normal LP can lead to their losses as no funds can be left for retrieval.
Proof of Concept
3 types of mint/burn: NFT, Fungible and Synths. Synths are most vilnerable as they do not have share: LP own the pool, so Synth’s funds are lost in scenarios similar to:
LP deposit both sides to a poolSynth deposit and mint a SynthLP withdraws all as she owns all the pool liquidity, even when provided only part of itSynth can’t withdraw as no assets left
burn NFT LP:https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex-v2/pool/BasePoolV2.sol#L270
burn fungible LP:https://github.com/code-423n4/2021-11-vader/blob/main/contracts/dex-v2/pool/VaderPoolV2.sol#L374
Recommended Mitigation Steps
Take into account liquidity that was provided by Synth minting.
SamSteinGG (Vader) confirmed
[H-34] Incorrect Accrual OfsumNativeandsumUSDIn Producing Consultation Results
Submitted by leastwood
Impact
TheTwapOracle.consult()function iterates over all token pairs which belong to eitherVADERor USDV` and then calculates the price of the respective asset by using both UniswapV2 and Chainlink price data. This helps to further protect against price manipulation attacks as the price is averaged out over the various registered token pairs.
Let’s say we wanted to query the price ofUSDV, we would sum up any token pair whereUSDV == pairData.token0.
The sum consists of the following:
Price ofUSDVdenominated in terms oftoken1(USDV/token1).Price of token1 denominated in terms ofUSD(token1/USD).
Consider the following example:
SUSHIandUNISWAPare the only registered token pairs that exist alongsideUSDV.Hence, calculatingsumNativegives us an exchange rate that is denominated as the sum ofUSDV/SUSHIandUSDV/UNISWAP.Similarly,sumUSDgives us the following denominated pairs,SUSHI/USDandUNISWAP/USD.SummingsumUSDandsumNativeproduces an entirely incorrect result as compared to multiplying the two results first and then summing.The issue is equivalent to the same issue as performing(p1 + p2)*(q1 + q2)as compared to(p1*q1 + p2*q2). Obviously, these two results are not equivalent, however, theconsult()function treats them as such.If we multiply the native price and Chainlink oracle results, then we can correctly calculate the price as such;(SUSHI/USD * USDV/SUSHI + UNISWAP/USD * USDV/UNISWAP) / 2, which should correctly give us the correct denomination and average price.
However, the protocol calculates it as((SUSHI/USD + UNISWAP/USD) * token.decimals()) / (USDV/SUSHI + USDV/UNISWAP)which gives us an incorrectly denominated result.
I’d classify this issue as high risk as the oracle returns false results upon being consulted. This can lead to issues in other areas of the protocol that use this data in performing sensitive actions.
Proof of Concept
https://github.com/code-423n4/2021-11-vader/blob/main/contracts/twap/TwapOracle.sol#L115-L157
Similar working implementation listed below:
https://github.com/gg2001/dpx-oracle/blob/master/contracts/UniswapV2Oracle.sol#L184-L211https://github.com/gg2001/dpx-oracle/blob/master/contracts/UniswapV2Oracle.sol#L291-L304
Tools Used
Manual code review.
Recommended Mitigation Steps
To calculate the correct consultation of a given token, the returned result should consist of a sum ofpriceUSD * token.decimals() * priceNativedivided by the number of calculations. This should correctly take the average token pair price.
The following snippet of code details the relevant fix:
function consult(address token) public view returns (uint256 result) {uint256 pairCount = _pairs.length;for (uint256 i = 0; i < pairCount; i++) {PairData memory pairData = _pairs[i];if (token == pairData.token0) {//// TODO - Review://   Verify price1Average is amount of USDV against 1 unit of token1//priceNative = pairData.price1Average.mul(1).decode144(); // native asset amountif (pairData.price1Average._x != 0) {require(priceNative != 0);} else {continue; // should skip newly registered assets that have not been updated yet.}(uint80 roundID,int256 price,,,uint80 answeredInRound) = AggregatorV3Interface(_aggregators[pairData.token1]).latestRoundData();require(answeredInRound >= roundID,"TwapOracle::consult: stale chainlink price");require(price != 0,"TwapOracle::consult: chainlink malfunction");priceUSD = uint256(price) * (10**10);result += ((priceUSD * IERC20Metadata(token).decimals()) * priceNative);}}require(sumNative != 0, "TwapOracle::consult: Sum of native is zero");return result;}
SamSteinGG (Vader) confirmed
The TWAP oracle module has been completely removed and redesigned from scratch as LBTwap that is subject of the new audit.
