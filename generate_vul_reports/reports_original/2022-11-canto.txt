[H-01] User can redirect fees by using a proxy contract
Submitted byRuhum, also found byronnyx2017andhihen
https://github.com/code-423n4/2022-11-canto/blob/main/CIP-001/src/Turnstile.sol#L86-L101
https://github.com/code-423n4/2022-11-canto/blob/main/Canto/x/csr/keeper/evm_hooks.go#L51
Impact
For any given tx, the fees are sent to its recipient (To). Anybody can register an address using the Turnstile contract. Thus, a user is able to create a proxy contract with which they execute other smart contracts. That way, the fees are sent to their own contract instead of the actual application they are using. People who use smart contract wallets don’t even have to bother with setting up a proxy structure. They just add their own wallet to the Turnstile contract.
Also, there might be a possibility of someone setting up a proxy for high-usage contracts where the fees are sent back to the caller. So for contract $X$, we create $X'$ which calls $X$ for the caller. Since $X'$ is the recipient of the tx, it gets the gas refund. To incentivize the user to use $X'$ instead of $X$, $X'$ sends a percentage of the refund to the caller. The feasibility both technically and economically depends on the contract that is attacked. But, theoretically, it’s possible.
The incentive to take it for yourself instead of giving it to the app is pretty high. Since this causes a loss of funds for the app I rate it as HIGH.
Proof of Concept
Registering an address is permissionless:
functionregister(address_recipient)publiconlyUnregisteredreturns(uint256tokenId) {addresssmartContract=msg.sender;if(_recipient==address(0))revertInvalidRecipient();tokenId=_tokenIdTracker.current();_mint(_recipient,tokenId);_tokenIdTracker.increment();emitRegister(smartContract,_recipient,tokenId);feeRecipient[smartContract] =NftData({tokenId:tokenId,registered:true});}
Fees are sent to the recipient of the tx:
func(hHooks)PostTxProcessing(ctxsdk.Context,msgcore.Message,receipt*ethtypes.Receipt)error{// Check if the csr module has been enabledparams :=h.k.GetParams(ctx)if!params.EnableCsr{returnnil}// Check and process turnstile events if applicableh.processEvents(ctx,receipt)contract :=msg.To()ifcontract==nil{returnnil}// ...
Recommended Mitigation Steps
It’s pretty difficult to fix this properly. The ideal solution is to distribute fees according to each contract’s gas usage. That will be a little more complicated to implement. Also, you have to keep an eye on whether it incentivizes developers to make their contracts less efficient. Another solution is to make this feature permissioned so that only select contracts are allowed to participate. For example, you could say that an address has to be triggered $X$ amount of times before it is eligible for gas refunds.
tkkwon1998 (Canto) acknowledged and commented:
We acknowledge this as true, but it’s a drawback that was discussed during the design of CSR.

[H-02] A registered contract won’t earn fees if_recipientis a fresh address
Submitted byJeiwan, also found byronnyx2017
Users might become victims of a false positive: if they use a fresh account as an NFT recipient during contract registration, the transaction won’t revert, but the registered contract will never earn fees for the token holder. And since a contract can be registered only once, there won’t be a way for affected users to re-register contracts and start earning fees. This can affect both bigger and smaller projects that register their contracts with the Turnstile contract: the only condition for the bug to happen is that the recipient address that’s used during registration is a fresh address (i.e. an address that hasn’t been used yet).
Proof of Concept
Theregisterfunction allows the calling contract to specify the address that will receive the freshly minted NFT (Turnstile.sol#L86):
functionregister(address_recipient)publiconlyUnregisteredreturns(uint256tokenId) {addresssmartContract=msg.sender;if(_recipient==address(0))revertInvalidRecipient();tokenId=_tokenIdTracker.current();_mint(_recipient,tokenId);_tokenIdTracker.increment();emitRegister(smartContract,_recipient,tokenId);feeRecipient[smartContract] =NftData({tokenId:tokenId,registered:true});}
A recipient address can be any address besides the zero address. However, on the consensus layer, there’s a stricter requirement (event_handler.go#L31-L33): a recipient address cannot be afresh account, that is an address that:
hasn’t ever received native coins;hasn’t ever sent a transaction;hasn’t ever had contract code.
While, on the application layer, calling theregisterfunction with a fresh address will succeed, on the consensus layer a contract won’t be registered.
When aRegisterevent is processed on the consensus layer, there’s a check that requires that the recipient address is anexisting accountin the state database (event_handler.go#L31-L33):
// Check that the receiver account  exists in the evm storeifacct:= k.evmKeeper.GetAccount(ctx, event.Recipient); acct ==nil{returnsdkerrors.Wrapf(ErrNonexistentAcct,"EventHandler::RegisterEvent account does not exist: %s", event.Recipient)}
If the recipient account doesn’t exist, the function will return, but the register transaction won’t revert (errors during the events processing doesn’t result in a revert:evm_hooks.go#L123-L132,evm_hooks.go#L49).
TheGetAccountfunction above returnsnilwhen an address doesn’t exist in the state database. To see this, we need to unwind theGetAccountexecution:
TheGetAccountis called on anevmKeeper(event_handler.go#L31):ifacct:= k.evmKeeper.GetAccount(ctx, event.Recipient); acct ==nil{returnsdkerrors.Wrapf(ErrNonexistentAcct,"EventHandler::RegisterEvent account does not exist: %s", event.Recipient)}evmKeeperis set during the CSR Keeper initialization (keeper.go#L27):funcNewKeeper(cdc codec.BinaryCodec,storeKey sdk.StoreKey,ps paramtypes.Subspace,accountKeeper types.AccountKeeper,evmKeeper types.EVMKeeper,bankKeeper types.BankKeeper,FeeCollectorNamestring,) Keeper {// set KeyTable if it has not already been setif!ps.HasKeyTable() {ps= ps.WithKeyTable(types.ParamKeyTable())}returnKeeper{storeKey:         storeKey,cdc:              cdc,paramstore:       ps,accountKeeper:    accountKeeper,evmKeeper:        evmKeeper,bankKeeper:       bankKeeper,FeeCollectorName: FeeCollectorName,}}The CSR Keeper is initialized during the main app initialization (app.go#L473-L478), this is also when the EVM Keeper is initialized (app.go#L409-L413):app.EvmKeeper= evmkeeper.NewKeeper(appCodec, keys[evmtypes.StoreKey], tkeys[evmtypes.TransientKey], app.GetSubspace(evmtypes.ModuleName),app.AccountKeeper, app.BankKeeper, &stakingKeeper, app.FeeMarketKeeper,tracer,)The EVM Keeper is implemented and imported from Ethermint (keeper.go#L67);Here’s theGetAccountfunction (statedb.go#L25):func(k *Keeper)GetAccount(ctx sdk.Context, addr common.Address) *statedb.Account {acct:= k.GetAccountWithoutBalance(ctx, addr)ifacct ==nil{returnnil}acct.Balance= k.GetBalance(ctx, addr)returnacct}TheGetAccountWithoutBalancefunction callsGetAccountonaccountKeeper(keeper.go#L255-L258):acct:= k.accountKeeper.GetAccount(ctx, cosmosAddr)ifacct ==nil{returnnil}The Account Keeper is implemented in the Cosmos SDK (account.go#L41-L49):func(ak AccountKeeper)GetAccount(ctx sdk.Context, addr sdk.AccAddress) types.AccountI {store:= ctx.KVStore(ak.storeKey)bz:= store.Get(types.AddressStoreKey(addr))ifbz ==nil{returnnil}returnak.decodeAccount(bz)}It basically reads an account from the store passed in the context object (context.go#L280-L282);In the Account Keeper, there’s alsoSetAccountfunction (account.go#L72), and it’s called in Ethermint by the EVM Keeper (statedb.go#L126);The EVM Keeper’sSetAccountis called when transaction changes are committed to the state database (statedb.go#L449);The state database is a set of state objects, where keys are account addresses and values are accounts themselves;ThegetOrNewStateObjectfunction initializes new state objects (statedb.go#L221-L227);getOrNewStateObjectis only called by these functions:AddBalance,SubBalance,SetNonce,SetCode,SetState(statedb.go#L290-L328).
Thus, a new account object in the state database is only created when an address receives native coins, sends a transaction (which increases the nonce), or when contract code is deployed at it.
Example Exploit Scenario
Alice deploys a smart contract that attracts a lot of users.Alice registers the contract in Turnstile. As a recipient contract for the NFT, Alice decides to use a dedicated address that hasn’t been used for anything else before (hasn’t received coins, hasn’t sent a transaction, etc.).Theregisterfunction call succeeds and Alice’s contract gets registered in Turnstile.However, due to the “only existing recipient account” check on the consensus layer, Alice’s contract wasn’t registered on the consensus layer and doesn’t earn fees.Sinceregisterandassigncan only be called once (due to theonlyUnregisteredmodifier), Alice cannot re-register her contract. She can transfer the NFT to a different address, however this won’t make the contract registered on the consensus layer and the owner of the NFT will never receive fees.
Recommended Mitigation Steps
Consider removing the “only existing recipient account” check in theRegisterEventhandler since it creates a discrepancy between the application and the consensus layers. Otherwise, if it’s mandatory that receiver addresses are not fresh, consider returning an error in thePostTxProcessinghook (which will revert a transaction) if there was an error during events processing.
tkkwon1998 (Canto) confirmed and commented:
This is certainly an issue as there is a mismatch in checks between app and consensus layers.

