[H-01]ETHOracle.getLatestPriceneeds to convert to 18 decimals
Submitted bybin2chen
InETHOracle.sol,getPrecision()is defined as10 ** 18, but the actual oracle used is 8-decimals.
https://data.chain.link/feeds/arbitrum/mainnet/eth-usd
This data feeds’ decimals is 8.
/***  ETH/USD Oracle using chainlink data feeds**  For more information about the feed go to@> *  https://data.chain.link/feeds/arbitrum/mainnet/eth-usd***/contractETHOracleisIOracle{IChainlinkAggregatorprivateimmutable_ethPriceFeed;@>uint256privateconstant_PRECISION=10**18;....functiongetLatestPrice()publicviewoverridereturns(IOracle.Pricememoryprice) {(,int256answer,uint256startedAt,uint256updatedAt,) =_ethPriceFeed.latestRoundData();if(answer<=0)revertInvalidPriceFromOracle();if(startedAt==0||updatedAt==0)revertInvalidPriceUpdatedAt();@>price.price=uint256(answer);//@audit 8 decimalsprice.lastUpdate=updatedAt;}
PythOracleis used to get prices for other tokens, alsogetPrecision() == 18.
contractPythOracleisIOracle{...uint256privateconstant_PRECISION=18;function_getPriceInternal(uint256age)privateviewreturns(IOracle.PricememoryoutPrice) {PythStructs.Pricememoryprice=age==0?_pyth.getPriceUnsafe(_priceID):_pyth.getPriceNoOlderThan(_priceID,age);if(price.expo>=0) {outPrice.price=uint64(price.price) *uint256(10** (_PRECISION+uint32(price.expo)));}else{outPrice.price=uint64(price.price) *uint256(10** (_PRECISION-uint32(-price.expo)));}outPrice.lastUpdate=price.publishTime;}
Since a different precision is used, then the calculation oftotalCollateralInEthatStrategyLeveragewill be wrong.
function_getPosition(uint256priceMaxAge)internalviewreturns(uint256totalCollateralInEth,uint256totalDebtInEth) {...totalCollateralInEth=0;totalDebtInEth=0;(uint256collateralBalance,uint256debtBalance) =_getMMPosition();if(collateralBalance!=0) {IOracle.PricememoryethPrice=priceMaxAge==0?_ethUSDOracle.getLatestPrice():_ethUSDOracle.getSafeLatestPrice(priceMaxAge);IOracle.PricememorycollateralPrice=priceMaxAge==0?_collateralOracle.getLatestPrice():_collateralOracle.getSafeLatestPrice(priceMaxAge);if(!(priceMaxAge==0||(priceMaxAge>0&& (ethPrice.lastUpdate>= (block.timestamp-priceMaxAge))) ||(priceMaxAge>0&&(collateralPrice.lastUpdate>= (block.timestamp-priceMaxAge))))) {revertPriceOutdated();}@>totalCollateralInEth= (collateralBalance*collateralPrice.price) /ethPrice.price;}if(debtBalance!=0) {totalDebtInEth=debtBalance;}}
Impact
Incorrect calculation oftotalCollateralInEth, affecting borrowing judgment, e.g. overvaluation overborrowing, etc.
Recommended Mitigation
Convert to 18 decimals.
hvasconcelos (BakerFi) confirmed
ickas (BakerFi) commented:
Fixed →https://github.com/baker-fi/bakerfi-contracts/pull/40

[H-02] Vault is vulnerable to first depositor inflation attack
Submitted by0xStalin, also found bybin2chenandrvierdiiev
First depositor can manipulate the price of the shares at will, forcing new depositors to deposit more ETH for the same amount of shares that the first depositor paid.
Proof of Concept
Before diving into the details of how this attack is performed, let’s understand how the Vault determines the amount of shares to mint for a deposited amount of ETH.
When doing a deposit,the Vault creates a new variable ofRebasetype by passing the resultant values of calling_totalAssets()andtotalSupply()functions. By inspecting theRebasestruct, we know that thetotalAssets()will be theelasticportion, and thetotalSupply()will be thebase. Or in other words:assetsare elasticsharesare the baseNow, let’s see what values are returned on each of the two functions that are called when thetotalvariable ofRebasetype is created._totalAssets()represents the amount of assets owned by the strategy. Byownit means the difference between the collateral value in ETH and all the WETH debt. For example, if the total collateral value in ETH is 100 ETH, and the total WETH debt is 70 WETH, then, thetotalAssetswould return 30 ETH. See below the exact code that is used to calculate the totalAssets:
> Vault.solfunction _totalAssets(uint256 priceMaxAge) private view returns (uint256 amount) {//@audit-info => totalAssets is difference between totalCollateralInETh - totalDebtInEth owned by the Strategy!amount = _strategy.deployed(priceMaxAge);}> StrategyLeverage.solfunction deployed(uint256 priceMaxAge) public view returns (uint256 totalOwnedAssets) {//@audit-info => totalCollateralInEth is the value of the aTokenCollateral owned by the Strategy worth in ETH//@audit-info => totalDebtInETH is the WETH debt in Aave that was taken to repay the flashloans used for leverage!(uint256 totalCollateralInEth, uint256 totalDebtInEth) = _getPosition(priceMaxAge);//@audit-info => The returned value from the `deployed()` is the difference between totalCollateralInETh -totalDebtInEthtotalOwnedAssets = totalCollateralInEth > totalDebtInEth? (totalCollateralInEth - totalDebtInEth): 0;}function _getPosition(uint256 priceMaxAge) internal view returns (uint256 totalCollateralInEth, uint256 totalDebtInEth) {totalCollateralInEth = 0;totalDebtInEth = 0;//@audit-info => debtBalance is the amount of WETH DebtToken owned by the Strategy contract!//@audit-info => collateralBalance is the amount of Collateral aToken owned by the Strategy contract(uint256 collateralBalance,  uint256 debtBalance ) = _getMMPosition();if (collateralBalance != 0) {...//@audit-info => Computes the value of the aTokenCollateral worth in ETHtotalCollateralInEth = (collateralBalance * collateralPrice.price) / ethPrice.price;}if (debtBalance != 0) {totalDebtInEth = debtBalance;}}> StrategyAAVEv3.solfunction _getMMPosition() internal virtual override view returns ( uint256 collateralBalance, uint256 debtBalance ) {DataTypes.ReserveData memory wethReserve = (aaveV3().getReserveData(wETHA()));DataTypes.ReserveData memory colleteralReserve = (aaveV3().getReserveData(ierc20A()));//@audit-info => debtBalance is the amount of WETH DebtToken owned by the Strategy contract!debtBalance = IERC20(wethReserve.variableDebtTokenAddress).balanceOf(address(this));//@audit-info => collateralBalance is the amount of Collateral aToken owned by the Strategy contractcollateralBalance = IERC20(colleteralReserve.aTokenAddress).balanceOf(address(this));}
totalSupply()represents all the existing shares that have been minted for all the deposits that have been made in the Vault.Then, the execution runs a couple of checks to verify that thetotalRebase variable’s state is correct, and then it proceeds to call theStrategyLeverage.deploy() function, where it will do a leveraged deposit of the Strategy’s collatelar (wstETH, rETH, cbETH) in Aave. To leverage the deposit, the Strategy requests a WETH flashloan on Balancer, swaps the borrowed and original deposit funds for collateral, deposits all the swapped collateral into Aave, and then it opens a WETH borrow for the exact amount to repay the flashloan to Balancer.The strategy returns to the vault the value in ETH of the funds that were deployed after the leverage.Finally, with the returned value of theStrategyLeverage.deploy() function, the Vault computes the amount of shares to mint to the receiver for the deposited funds.The formula that is used to determine the sharesisshares = (assets * totalSupply()) / totalAssets(), whereassetsis the amount of collateral in ETH deployed after leverage.
> Vault.solfunction deposit(address receiver)...{...//@audit-info => Step 1, creates a variable of Rebase type by passing as parameters the totalAssets() and totalSupply() of the Vault!Rebase memory total = Rebase(_totalAssets(maxPriceAge), totalSupply());...//@audit-info => Step 3, the deposited amount is deployed on the Strategy!bytes memory result = (address(_strategy)).functionCallWithValue(abi.encodeWithSignature("deploy()"),msg.value);uint256 amount = abi.decode(result, (uint256));//@audit-info => Step 4, Computes the amount of shares to mint for the amount that was deployed after leverage on the Strategyshares = total.toBase(amount, false);_mint(receiver, shares);emit Deposit(msg.sender, receiver, msg.value, shares);}
Now, time to analyze how the attack is performed:
Alice is the first depositor in the Vault;Alice deposits 10 wei of ETHSince Alice is the first depositor (totalSupply is 0 && totalAssets is 0), she gets 10 weis of a share (10 wei)Alice then sends 99999999999999999999 (100e18 - 1) aCollateralToken to the Strategy; WhereaCollateralTokenis the aToken that Aave mints when the strategy deploys/supplies collateral to it.There are now 10 weis of shares and a total of 100e18 aCollateralToken as totalAssets: Alice is the only depositor in the vault, she’s holding 10 weis of shares, and thetotalAssetsis 100e18 aCollateralToken. For ease of calculations, suppose collateral per ETH is 1:1.Bob deposits 19 ETH and gets only 1 sharedue to the rounding down in the calculation to compute the shares:19e18 * 10 / 100e18 == 10;Each Share will redeem:totalAssets / totalShares== 119e18 / 11 =>10.81e18 ETH in aCollateralTokenThe 10 wei of shares owned by Alice can claim: 108.1e18 ETH. Meaning, Alice can steal ~8 ETH from Bob’s deposit.The 1 wei of Shares owned by Bob can only claim: 10.81 ETH. Meaning, Bob automatically lost ~8 ETH from the 19 ETH he just deposited.
The root cause that makes this attack possible is that the Vault’s shares and assets are not initialized/seeded when the Vault is created & the fact that the totalAssets is dependant on the total aCollateralTokens the associated Strategy to the Vault is holding on its balance.
This allows an attacker to inflate the share-assets rate by transfering aCollateralToken directly to the Strategy. By doing this direct transfer, those aCollateralTokens will inflate the rate of the initial deposit made by the attacker, causing real depositors to deposit at an inflated rate, from which an attacker will profit by withdrawing the initial shares he minted for himself and withdrawing all his deposited (and direct transfered) aCollateralTokens + a portion of the deposited value from real depositors.
Recommended Mitigation Steps
Consider either of these options:
Consider seeding the pools during deployment. This needs to be done in the deployment transactions to avoiding front-running attacks. The amount needs to be high enough to reduce the rounding error.Consider sending first 1000 wei of shares to the zero address. This will significantly increase the cost of the attack by forcing an attacker to pay 1000 times of the share price they want to set. For a well-intended user, 1000 wei of shares is a negligible amount that won’t diminish their share significantly.Implement the concept ofvirtual shares, similar to the ERC4626 OZ contract.More info about this concept here.
hvasconcelos (BakerFi) confirmed
ickas (BakerFi) commented:
Fixed →https://github.com/baker-fi/bakerfi-contracts/pull/45

[H-03] When harvesting a strategy and adjusting the debt, all the leftover collateral that is not used to swap the withdrawn collateral from Aave for WETH to repay the flashloan will be locked and lost in the Strategy contract
Submitted by0xStalin, also found bybin2chenandrvierdiiev
Impact
Collateral can be locked and lost in the Strategy contract.
Proof of Concept
When harvesting a strategy and adjusting the debt to maintain the loan to value of the strategy, the strategy does the following steps:
Computes the deltaDebt required to readjust the loan to value within the accepted boundaries.Takes a WETH flashloan on Balancer for the exact deltaDebt amount.Repays WETH on Aave for the exact amount that was flashloaned borrowed on Balancer.Uses the UniQuoterV2 to compute the amount of collateral needed to repay the flashloan (including the flashloan fees).Withdraws collateral from Aave for exact amount computed by the UniQuoterV2.Does anEXACT_OUTPUTswap on Uniswap. It requests to receive the exactdebtAmount + fees(to repay the flashloan) in exchange for at most the withdrawn amount of collateral from Aave.Does a couple of extra checks and finally the flashloan is repaid.
The problem identified on this report is caused due to some issues in the steps 4 & 6. Let’s dive into it.
Thefirst part of the problemis caused due to how the UniQuoter is invoked.Thefeeof the pool that is sent to the UniQuoter is hardcoded to be500, which represents a pool of (0.05% fee). This can cause two problems:
The execution can be reverted if there is not an existing pool for the COLLATERAL/WETH at a 0.05% fee. The UniQuoter will receive the call and will derive the address of the pool based on the tokenIn, tokenOut and fee.If there is not a pool for the 0.05% fee (500), the call will be reverted and the whole harvesting execution will blown up.The second problem is when theswapFeeTieris different than 500, or in other words, that the fee of the UniPool that is configured for the strategy is different than 500 (0.05%), for example, if the strategy is configured to work with a pool with a fee of 0.01% (100).In this case, the execution won’t revert, but the computed amount will be bigger than what is really required. For example:ThedebtAmount + feeto repay the flashloan is 100WETH.The UniQuoter will compute how much collateral is required to get 100WETH by swapping the collateral on a UniPool with a 0.05% fee. to make calculations easier, assume collateral and weth have a 1:1 conversion.100 collateral + 0.05% fee charged by the pool ===> 100 + 0.5 ===> 100.5 Collateral.Then, the execution will withdraw from Aave the computed amount by the UniQutoer (100.5).Now, once the Strategy has the 100.5 collateral on its balance, the execution will do a swap requesting 100 WETH to repay the flashloan. When requesting the swap, the fees of the pool where the swap will be actually executed is set by using theswapFeeTier. Assume the Strategy is configured to work with the UniPool with the lowest fee available (0.01%).To do anEXACT_OUTPUTswap on a pool with 0.01% fee for 100 WETH, the required amount of tokenIn (collateral) will be:100 WETH + 0.01% fee charged by the pool ===> 100 + 0.1 ===> 100.1 Collateral.This means,after doing the swap for WETH to repay the flashloan, the Strategy will have on its balance a total of 0.4 leftover collateral that was not used during the swap.
StrategyLeverage._payDebt() function
function _payDebt(uint256 debtAmount, uint256 fee) internal {...// Get a Quote to know how much collateral i require to pay debt(uint256 amountIn, , , ) = uniQuoter().quoteExactOutputSingle(//@audit-issue => The computed `amountIn` is based on a pool with fees of 0.05%!IQuoterV2.QuoteExactOutputSingleParams(ierc20A(), wETHA(), debtAmount + fee, 500, 0));//@audit-info => Withdraws the exact computed `amountIn` by the UniQuoter_withdraw(ierc20A(), amountIn, address(this) );uint256 output = _swap(ISwapHandler.SwapParams(ierc20A(),wETHA(),ISwapHandler.SwapType.EXACT_OUTPUT,amountIn,debtAmount + fee,//@audit-info => The swap is performed on a pool with this fees//@audit-issue => When this value is lower than 500 (Using a pool with a lower fee), not all the withdrawn collateral will be used for the swap!_swapFeeTier,bytes("")));...}
Now comes thesecond part of the problem,the Strategy checks if there is any leftover collateral after the swap, and if there is any, it does a self transfer for the leftover amount. This can cause one of these two problems:
The most problematic is that the leftover collateral will simply be left in the Strategy, it won’t be re-supplied to Aave, neither pull out of the Strategy, it will be simply left in the Strategy’s balance, from where it will be irrecoverable. Meaning, the leftover collateral will be locked in the Strategy contract.Depending on the Collateral’s contract, there are some ERC20s that reverts the execution if they receive a self-transfer of tokens.
UseSwapper._swap() function
function _swap(ISwapHandler.SwapParams memory params) internal override returns (uint256 amountOut) {...// Exact Inputif (params.mode == ISwapHandler.SwapType.EXACT_INPUT) {...// Exact Output} else if (params.mode == ISwapHandler.SwapType.EXACT_OUTPUT) {//@audit-info => Does an EXACT_OUTPUT swap//@audit-info => `amountIn` represents the exact amount of collateral that was required to swap the requested amount of WETH to repay the flashloan!uint256 amountIn = _uniRouter.exactOutputSingle(IV3SwapRouter.ExactOutputSingleParams({tokenIn: params.underlyingIn,tokenOut: params.underlyingOut,fee: fee,recipient: address(this),amountOut: params.amountOut,amountInMaximum: params.amountIn,sqrtPriceLimitX96: 0}));//@audit-issue => Self transfering the leftover collateral after the swap. This leftover collateral will be left in the Strategy's balance, causing it to be unnusable.if (amountIn < params.amountIn) {IERC20(params.underlyingIn).safeTransfer(address(this), params.amountIn - amountIn);}...}}
To recapitulate the most important points, the biggest impact because of the two problems on steps 4 & 6 is when the UniPool configured for the strategy uses a lower fee than 0.05% (500). In this case, the leftover collateral after doing theEXACT_OUTPUTswap for the required amount of WETH to repay the flashloan will be left and locked in the Strategy.
Tools Used
Manual Audit,Uniswap Pool’s Explorer, &UniV2Quoter contract
Recommended Mitigation Steps
To address this problem, I’d recommend to apply the two below suggestions.
Do not set a hardcoded value for the pool fee when calling the UniQuoter, instead, send the same value of the configured pool (swapFeeTier).Instead of doing the self transfer of the leftover collateral after the swap, opt to re-supply it to Aave. In this way, that leftover collateral can still be managed by the Strategy.
0xleastwood (judge) decreased severity to Medium and commented:
This seems to predominantly impact yield in two ways:Harvest function fails to be callable, but users can still withdraw collateral.Harvest does not fail but there is some value leakage that happens over time.Neither of these impact user’s funds directly somediumseverity seems right.
0xStalin (warden) commented:
Hello Judge @0xleastwood - I’d like to clarify the second point raised in your comment to downgrade the severity of this report to medium:Harvest does not fail but there is some value leakage that happens over time.Neither of these impact user’s funds directly so medium severity seems right.Actually, when harvest does not fail, and causes the leftover collateral to be left sitting on the protocol, those funds are actually the funds deposited by the users. While it is true that the leakage happens over time, those funds are user funds, not only yield.I’d like to ask if you could take a second look at your verdict for the severity of this report and if you would consider re-assigning the original severity based on this clarification.
0xleastwood (judge) increased severity to Medium and commented:
@0xStalin - I see what you mean, even though the amount is somewhat on the smaller side, a debt adjustment will leave some excess collateral stuck as it rebalances to maintain a target LTV.
hvasconcelos (BakerFi) confirmed
ickas (BakerFi) commented:
Fixed →https://github.com/baker-fi/bakerfi-contracts/pull/42

[H-04] Multiple swap lack slippage protection
Submitted bybin2chen, also found bybin2chen,0xStalin,rvierdiiev, andt0x1c
The current protocol requires swapping tokens in multiple places, such asweth -> ierc20Aorierc20A -> weth.
Primarily, these swaps are executed using the_swap()method.
function_swap(ISwapHandler.SwapParamsmemoryparams)internaloverridereturns(uint256amountOut) {if(params.underlyingIn==address(0))revertInvalidInputToken();if(params.underlyingOut==address(0))revertInvalidOutputToken();uint24fee=params.feeTier;if(fee==0)revertInvalidFeeTier();// Exact Inputif(params.mode==ISwapHandler.SwapType.EXACT_INPUT) {amountOut=_uniRouter.exactInputSingle(IV3SwapRouter.ExactInputSingleParams({tokenIn:params.underlyingIn,tokenOut:params.underlyingOut,amountIn:params.amountIn,@>amountOutMinimum:0,//@audit miss set params.amountOutfee:fee,recipient:address(this),sqrtPriceLimitX96:0}));if(amountOut==0) {revertSwapFailed();}emitSwap(params.underlyingIn,params.underlyingOut,params.amountIn,amountOut);// Exact Output}elseif(params.mode==ISwapHandler.SwapType.EXACT_OUTPUT) {uint256amountIn=_uniRouter.exactOutputSingle(IV3SwapRouter.ExactOutputSingleParams({tokenIn:params.underlyingIn,tokenOut:params.underlyingOut,fee:fee,recipient:address(this),amountOut:params.amountOut,amountInMaximum:params.amountIn,sqrtPriceLimitX96:0}));if(amountIn<params.amountIn) {IERC20(params.underlyingIn).safeTransfer(address(this),params.amountIn-amountIn);}emitSwap(params.underlyingIn,params.underlyingOut,amountIn,params.amountOut);amountOut=params.amountOut;}}
This method does not setamountOutMinimum.
And when call same miss setAmount Out.
abstractcontractStrategyLeverageisfunction_convertFromWETH(uint256amount)internalvirtualreturns(uint256) {// 1. Swap WETH -> cbETH/wstETH/rETHreturn_swap(ISwapHandler.SwapParams(wETHA(),// Asset Inierc20A(),// Asset OutISwapHandler.SwapType.EXACT_INPUT,// Swap Modeamount,// Amount In//@audit miss slippage protection@>0,// Amount Out_swapFeeTier,// Fee Pair Tierbytes("")// User Payload));}
These methods do not have slippage protection.
https://docs.uniswap.org/contracts/v3/guides/swaps/single-swaps
amountOutMinimum: we are setting to zero, but this is a significant risk in production. For a real deployment, this value should be calculated using our SDK or an onchain price oracle - this helps protect against getting an unusually bad price for a trade due to a front running sandwich or another type of price manipulation
Include：UseSwapper._swap()/_convertFromWETH()/_convertToWETH()/_payDebt()
Impact
Front running sandwich or another type of price manipulation.
Recommended Mitigation
_swap()need setamountOutMinimum = params.amountOut
function _swap(ISwapHandler.SwapParams memory params) internal override returns (uint256 amountOut) {if (params.underlyingIn == address(0)) revert InvalidInputToken();if (params.underlyingOut == address(0)) revert InvalidOutputToken();uint24 fee = params.feeTier;if (fee == 0) revert InvalidFeeTier();// Exact Inputif (params.mode == ISwapHandler.SwapType.EXACT_INPUT) {amountOut = _uniRouter.exactInputSingle(IV3SwapRouter.ExactInputSingleParams({tokenIn: params.underlyingIn,tokenOut: params.underlyingOut,amountIn: params.amountIn,-                   amountOutMinimum: 0,+                  amountOutMinimum: params.amountOutfee: fee,recipient: address(this),sqrtPriceLimitX96: 0}));if (amountOut == 0) {revert SwapFailed();}
Call_swap()need setparams.amountOutcalculating the allowed slippage value accurately.
hvasconcelos (BakerFi) confirmed
ickas (BakerFi) commented:
Fixed →https://github.com/baker-fi/bakerfi-contracts/pull/41

