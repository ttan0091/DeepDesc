[H-04] SwingTraderManager.addSwingTrader will push traderId withactive = falseto activeTraders
Submitted bycccz, also found byhansfriese
In SwingTraderManager.addSwingTrader, ifactive = false, the traderId is also pushed to activeTraders.
functionaddSwingTrader(uint256traderId,address_swingTrader,boolactive,stringcalldataname)externalonlyRoleMalt(ADMIN_ROLE,"Must have admin privs") {SwingTraderDatastoragetrader=swingTraders[traderId];require(traderId>2&&trader.id==0,"TraderId already used");require(_swingTrader!=address(0),"addr(0)");swingTraders[traderId] =SwingTraderData({id:traderId,index:activeTraders.length,traderContract:_swingTrader,name:name,active:active});activeTraders.push(traderId);emitAddSwingTrader(traderId,name,active,_swingTrader);}
Afterwards, if toggleTraderActive is called on the traderId, the traderId will be pushed to activeTraders again.
functiontoggleTraderActive(uint256traderId)externalonlyRoleMalt(ADMIN_ROLE,"Must have admin privs"){SwingTraderDatastoragetrader=swingTraders[traderId];require(trader.id==traderId,"Unknown trader");boolactive= !trader.active;trader.active=active;if(active) {// setting it to active so add to activeTraderstrader.index=activeTraders.length;activeTraders.push(traderId);}else{
This means that ingetTokenBalances()/calculateSwingTraderMaltRatio(), since there are two identical traderIds in activeTraders, the data in this trader will be calculated twice.
WronggetTokenBalances()will result in wrong data whensyncGlobalCollateral().
functiongetTokenBalances()externalviewreturns(uint256maltBalance,uint256collateralBalance){uint256[]memorytraderIds=activeTraders;uint256length=traderIds.length;for(uint256i;i<length; ++i) {SwingTraderDatamemorytrader=swingTraders[activeTraders[i]];maltBalance+=malt.balanceOf(trader.traderContract);collateralBalance+=collateralToken.balanceOf(trader.traderContract);}}
WrongcalculateSwingTraderMaltRatio()will causeMaltDataLab.getRealBurnBudget()/getSwingTraderEntryPrice()to be wrong.
functioncalculateSwingTraderMaltRatio()publicviewreturns(uint256maltRatio){uint256[]memorytraderIds=activeTraders;uint256length=traderIds.length;uint256decimals=collateralToken.decimals();uint256maltDecimals=malt.decimals();uint256totalMaltBalance;uint256totalCollateralBalance;for(uint256i;i<length; ++i) {SwingTraderDatamemorytrader=swingTraders[activeTraders[i]];totalMaltBalance+=malt.balanceOf(trader.traderContract);totalCollateralBalance+=collateralToken.balanceOf(trader.traderContract);}totalMaltBalance=maltDataLab.maltToRewardDecimals(totalMaltBalance);uint256stMaltValue= ((totalMaltBalance*maltDataLab.priceTarget()) /(10**decimals));uint256netBalance=totalCollateralBalance+stMaltValue;if(netBalance>0) {maltRatio= ((stMaltValue* (10**decimals)) /netBalance);}else{maltRatio=0;}}
What’s more serious is that even if toggleTraderActive is called again, only one traderId will pop up from activeTraders, and the other traderId cannot be popped up.
}else{// Becoming inactive so remove from activePoolsuint256index=trader.index;uint256lastTrader=activeTraders[activeTraders.length-1];activeTraders[index] =lastTrader;activeTraders.pop();swingTraders[lastTrader].index=index;trader.index=0;}
This causes the trade to participate in the calculation ofgetTokenBalances()/calculateSwingTraderMaltRatio()even if the trade is deactive.
Considering that the active parameter is likely to be false when addSwingTrader is called and cannot be recovered, this vulnerability should be High risk.
Proof of Concept
functiontestAddSwingTrader(addressnewSwingTrader)public{_setupContract();vm.assume(newSwingTrader!=address(0));vm.prank(admin);swingTraderManager.addSwingTrader(3,newSwingTrader,false,"Test");(uint256id,uint256index,addresstraderContract,stringmemoryname,boolactive) =swingTraderManager.swingTraders(3);assertEq(id,3);assertEq(index,2);assertEq(traderContract,newSwingTrader);assertEq(name,"Test");assertEq(active,false);vm.prank(admin);swingTraderManager.toggleTraderActive(3);assertEq(swingTraderManager.activeTraders(2),3);assertEq(swingTraderManager.activeTraders(3),3);// @audit:activeTraders[2] = activeTraders[3] = 3vm.prank(admin);swingTraderManager.toggleTraderActive(3);assertEq(swingTraderManager.activeTraders(2),3);}
https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/SwingTraderManager.sol#L397-L447
Recommended Mitigation Steps
Change to:
function addSwingTrader(uint256 traderId,address _swingTrader,bool active,string calldata name) external onlyRoleMalt(ADMIN_ROLE, "Must have admin privs") {SwingTraderData storage trader = swingTraders[traderId];require(traderId > 2 && trader.id == 0, "TraderId already used");require(_swingTrader != address(0), "addr(0)");swingTraders[traderId] = SwingTraderData({id: traderId,-     index: activeTraders.length,+     index: active ? activeTraders.length : 0,traderContract: _swingTrader,name: name,active: active});+  if(active) activeTraders.push(traderId);-   activeTraders.push(traderId);emit AddSwingTrader(traderId, name, active, _swingTrader);}
0xScotch (Malt) confirmed