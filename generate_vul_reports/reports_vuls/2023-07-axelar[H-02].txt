[H-02] ERC777 and similar token implementations allow a stealing of funds when transferring tokens
Submitted byJeiwan, also found bynobody2018
A malicious actor can trick aTokenManagerinto thinking that a bigger amount of tokens were transferred. On the destination chain, the malicious actor will be able to receive more tokens than they sent on the source chain.
Proof of Concept
TokenManagerLockUnlockandTokenManagerLiquidityPoolareTokenManagerimplementations that transfer tokens from/to users when sending tokens cross-chain. The low-level_takeTokenfunction (TokenManagerLiquidityPool._takeToken,TokenManagerLockUnlock._takeToken) is used to take tokens from a user on the source chain before emitting a cross-chain message, e.g. via theTokenManager.sendTokenfunction. The function computes the difference in the balance of the liquidity pool or the token manager before and after the transfer, to track the actual amount of tokens transferred. The amount is thenpassed in the cross-chain messageto tell theInterchainTokenServicecontract on the destination chainhow many tokens to give to the recipient.
The_takeTokenfunction, however, is not protected from reentrance, which opens up the following attack scenario:
A malicious contract initiates transferring of 100 ERC777 tokens by callingTokenManager.sendToken.The_takeTokenfunction callstransferFromon the ERC777 token contract, which calls thetokensToSendhook on the malicious contract (the sender).In the hook, the malicious contract makes another call toTokenManager.sendTokenand sends 100 more tokens.In the nested_takeTokencall, the balance change will equal 100 since, in ERC777, the balance state is updated only after thetokensToSendhook, so only the re-entered token transfer will be counted.The re-entered call toTokenManager.sendTokenwill result in 100 tokens transferred cross-chain.In the first_takeTokencall, the balance change will equal 200 because the balance of the receiver will increase twice during thetransferFromcall; once for the first call and once for the re-entered call.As a result, the malicious contract will transfer 100+100 = 200 tokens, but theTokenManagercontract will emit two cross-chain messages; one will transfer 100 tokens (the re-entered call) and the other will transfer 200 tokens (the first call). This will let the malicious actor to receive 300 tokens on the destination chain, while spending only 200 tokens on the source chain.
Since the protocol is expected to support different implementations of ERC20 tokens, including custom ones, the attack scenario is valid for any token implementation that uses hooks during transfers.
Recommended Mitigation Steps
Consider adding re-entrancy protection to theTokenManagerLiquidityPool._takeTokenandTokenManagerLockUnlock._takeTokenfunctions, for example by using theReentrancyGuardfrom OpenZeppelin.
Assessed type
Reentrancy
deanamiel (Axelar) confirmed and commented:
We have added a separate token manager for fee on transfer tokens, which is protected from reentrancy.Link to the public PR:https://github.com/axelarnetwork/interchain-token-service/pull/96.