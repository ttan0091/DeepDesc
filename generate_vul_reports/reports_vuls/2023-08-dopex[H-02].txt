[H-02] Put settlement can be anticipated and lead to user losses and bonding DoS
Submitted byLokiThe5th, also found by__141345__,peakbolt,rvierdiiev,Nikki,mahdikarimi, andwintermute
https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVault.sol#L278-L281
https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L118-L135
https://github.com/code-423n4/2023-08-dopex/blob/eb4d4a201b3a75dd4bddc74a34e9c42c71d0d12f/contracts/perp-vault/PerpetualAtlanticVaultLP.sol#L145-L175
The liquidity providers depositWETHinto thePerpetualAtlanticVaultLPwhich in turn provides the required collateral for put options writing. Writing puts locks collateral and to write more puts excess collateral is needed. Once a put isin the moneyit can be exercised by theRdpxCoreV2contract, which forces the liquidity providers to take onrdpxat above market prices (i.e. they take a loss).
The issue is that liquidity providers to thePerpetualAtlanticVaultLPcan anticipate when they might take losses. Users may then take the precautionary action to avoid losses by exiting the LP prior to put settlements. By doing this, the users who are not as fast, or as technically sophisticated, are forced to take on more losses (as losses are then spread among less LPs).
Importantly, this is not dependent on MEV and will also happen on chains where MEV is not possible.
This issue has two root causes:
The price-threshold for settlement is knownPerpetualAtlanticVaultLPallows redemptions at any time as long as there is excess collateral available
This has a second order effect: by having the ability to anticipate when settlements will happen, if any puts are in the money, there is likely to be redemptions from thePerpetualAtlanticVaultLPwhich will drain all the available collateral. If all the available collateral is drained from the vault, then other users will not be able to bond using theRdpxV2Corecontracts, as calls topurchasewillrevertdue to insufficient collateral in the put options vault.
The issue has been classified as high for the following reasons:
The depositors who are either too slow, or are not as technically sophisticated, are forced to take more of the losses related to settlement of put options (as losses are spread among less participants).The token economic incentive is to anticipate calls tosettleand avoid taking losses, anddepositagain thereafter. Thiswillcreate market-related periods of insufficient collateral, leading to regular (albeit temporary) DoS of the bonding mechanism which can impact theETHpeg of theDpxEthToken(not to mention the poor optics for the project).
Proof of Concept
As the price-threshold for settlement is known, depositors into thePerpetualAtlanticVaultLPhave a few options to avoid this loss:
Users can simply monitor therdpxPriceInEthand, once the price is close to the strike price, remove their liquidity throughredeem(). They can then deposit after settlement to take up a greater number of shares.Users can monitor the mempool (may be an issue in later versions of Arbitrum or other chains) for calls toPerpetualAtlanticVault::settle()and front-run this with a call toredeemto avoid losses.Assettle()is a manual call from the Dopex multisig, this may take the form of a weekly process. Users may come to anticipate this and pull the available assets from the LP at those regular intervals.
Regardless of the method, the end result is the same.
The below coded PoC demonstrates the issue. One of the users, Bob (address(1)), anticipates a call tosettle()- either through front-running or a market-related decision. Bob then enters and exits the pool right before and after thesettlecall. Dave (address(2)), who is another liquidity provider, does not anticipate thesettle()call. We note the differences in PnL this creates in the console output.
Note: The PoC was created using theperp-vault/Integration.t.solfile, and should be placed in thetests/perp-vaultdirectory in a.solfile. The PoC can then be run withforge test --match-test testPoCHigh3 -vvv
Apologies for the extended setup code at the start, this is needed for an accurate test, the PoC start point is marked clearly.
// SPDX-License-Identifier: UNLICENSEDpragma solidity 0.8.19;import { Test } from "forge-std/Test.sol";import "forge-std/console.sol";import { ERC721Holder } from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";import { Setup } from "./Setup.t.sol";import { PerpetualAtlanticVault } from "contracts/perp-vault/PerpetualAtlanticVault.sol";contract PoC is ERC721Holder, Setup {// ================================ HELPERS ================================ //function mintWeth(uint256 _amount, address _to) public {weth.mint(_to, _amount);}function mintRdpx(uint256 _amount, address _to) public {rdpx.mint(_to, _amount);}function deposit(uint256 _amount, address _from) public {vm.startPrank(_from, _from);vaultLp.deposit(_amount, _from);vm.stopPrank();}function purchase(uint256 _amount, address _as) public returns (uint256 id) {vm.startPrank(_as, _as);(, id) = vault.purchase(_amount, _as);vm.stopPrank();}function setApprovals(address _as) public {vm.startPrank(_as, _as);rdpx.approve(address(vault), type(uint256).max);rdpx.approve(address(vaultLp), type(uint256).max);weth.approve(address(vault), type(uint256).max);weth.approve(address(vaultLp), type(uint256).max);vm.stopPrank();}// ================================ CORE ================================ ///**Assumptions & config:- address(this) is impersonating the rdpxV2Core contract- premium per option: 0.05 weth- epoch duration: 1 day; 86400 seconds- initial price of rdpx: 0.2 weth- pricing precision is in 0.1 gwei- premium precision is in 0.1 gwei- rdpx and weth denomination in wei**/function testPoCHigh3() external {// Setup starts here ----------------------------->setApprovals(address(1));setApprovals(address(2));setApprovals(address(3));mintWeth(5 ether, address(1));mintWeth(5 ether, address(2));mintWeth(25 ether, address(3));/// The users depositdeposit(5 ether, address(1));deposit(5 ether, address(2));deposit(25 ether, address(3));uint256 userBalance = vaultLp.balanceOf(address(1));assertEq(userBalance, 5 ether);userBalance = vaultLp.balanceOf(address(2));assertEq(userBalance, 5 ether);userBalance = vaultLp.balanceOf(address(3));assertEq(userBalance, 25 ether);// premium = 100 * 0.05 weth = 5 wethuint256 tokenId = purchase(100 ether, address(this)); // 0.015 gwei * 100 ether / 0.1 gwei = 15 ether collateral activatedskip(86500); // expires epoch 1vault.updateFunding();vault.updateFundingPaymentPointer();uint256[] memory strikes = new uint256[](1);strikes[0] = 0.015 gwei;uint256 fundingAccrued = vault.calculateFunding(strikes);assertEq(fundingAccrued, 5 ether);uint256[] memory tokenIds = new uint256[](1);tokenIds[0] = tokenId;/// ---------------- POC STARTS HERE ---------------------------------------------------///// At this point the Core contract has purchased options to sell 100 rdpx tokens// The market moves against `rdpx` and the puts are now in the moneypriceOracle.updateRdpxPrice(0.010 gwei);// Bob, a savvy user, sees there is collateral available to withdraw, and// because he monitors the price he knows the vault is about to take a loss// thus, he withdraws his capital, expecting a call to settle.userBalance = vaultLp.balanceOf(address(1));vm.startPrank(address(1));vaultLp.redeem(userBalance, address(1), address(1));vm.stopPrank();vm.startPrank(address(this), address(this));(uint256 ethAmount, uint256 rdpxAmount) = vault.settle(tokenIds);vm.stopPrank();// Bob now re-enters the LP Vaultvm.startPrank(address(1));vaultLp.deposit(weth.balanceOf(address(1)), address(1));vm.stopPrank();// Now we tally up the scoresconsole.log("User Bob ends with (WETH, RDPX, Shares):");userBalance = vaultLp.balanceOf(address(1));(uint256 aBob, uint256 bBob) = vaultLp.redeemPreview(userBalance);console.log(aBob, bBob, userBalance);userBalance = vaultLp.balanceOf(address(2));(uint256 aDave, uint256 bDave) = vaultLp.redeemPreview(userBalance);console.log("User Dave ends with (WETH, RDPX, Shares):");console.log(aDave, bDave, userBalance);/**Bob and Dave both started with 5 ether deposited into the vault LP.Bob ends up with shares worth 4.08 WETH + 16.32 RDPXDave ends up with shares worth 3.48 WETH + 13.94 RDPXThus we can conclude that by anticipating calls to `settle`,either by monitoring the market or through front-running,Bob has forced Dave to take on more of the losses.*/}}
The result is that even though Bob and Dave both started with 5 WETH deposited, by anticipating the call tosettle(), Bob was able to force Dave to take more of the losses while Bob was able to reenter and gain more shares than he started with. He has twisted the knife, so to speak.
Importantly, because the economic incentive is to exit and enter the pool in this way, it is likely to create a race condition where all the available collateral becomes withdrawn the moment the puts are in the money, meaning no user can bond (as options purchasing will revertdue to this check). This leads to temporary DoS of the bonding mechanism, until either the team takes direct action (settingputsRequiredtofalse) or new deposits come back into the vault
Tools Used
Foundry.
Recommended Mitigation Steps
One option would be to rework the deposits to allow a “cooling off period” after deposits, meaning that assets can’t be withdrawn until a set date in the future.
Another option would be to mint more shares to the vault itself in response to calls tosettle()which accrue to users. These shares can then be distributed to the users as they redeem based on their time in the vault (in effect rewarding the hodlers).
This is not a trivial change, as it will impact the token economics of the project.
psytama (Dopex) confirmed
Alex the Entreprenerd (Judge) commented:
I’m understanding that LPs are able to indeed able to redeem up tototalAvailableCollateral.For this reason, I agree with the validity of the finding.Conflicted on severity as total loss is capped, however, am thinking High is correct because new depositors are effectively guaranteed a loss, and there seems to be no rational way to avoid this scenario.