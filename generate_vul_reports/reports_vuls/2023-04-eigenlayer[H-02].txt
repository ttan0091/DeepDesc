[H-02] It is impossible to slash queued withdrawals that contain a malicious strategy due to a misplacement of the ++i increment
Submitted byjuancito, also found byyjrwkk,pontifex,evmboi32,bin2chen,sashik_eth,Ruhum,MiloTruck,SpicyMeatball, andvolodya.
StrategyManager::slashQueuedWithdrawal()contains anindicesToSkipparameter to skip malicious strategies, as documented in thefunction definition:
so that, e.g., if the slashedQueuedWithdrawalcontains a malicious strategy in thestrategiesarray which always reverts on calls to its ‘withdraw’ function, then the malicious strategy can be skipped (with the shares in effect “burned”), while the non-malicious strategies are still called as normal.
The problem is, the function does not work as expected, andindicesToSkipis ignored. If the queued withdrawal contains a malicious strategy, it will make the slash always revert.
Owners won’t be able to slash queued withdrawals that contain a malicious strategy.
An adversary can take advantage of this and create withdrawal queues that won’t be able to be slashed, completely defeating the slash system. The adversary can later complete the withdrawal.
Proof of Concept
The++i;statement inStrategyManager::slashQueuedWithdrawal()is misplaced. It is only executed on theelsestatement:
// keeps track of the index in the `indicesToSkip` arrayuint256indicesToSkipIndex=0;uint256strategiesLength=queuedWithdrawal.strategies.length;for(uint256i=0;i<strategiesLength;) {// check if the index i matches one of the indices specified in the `indicesToSkip` arrayif(indicesToSkipIndex<indicesToSkip.length&&indicesToSkip[indicesToSkipIndex] ==i) {unchecked{++indicesToSkipIndex;}}else{if(queuedWithdrawal.strategies[i] ==beaconChainETHStrategy){//withdraw the beaconChainETH to the recipient_withdrawBeaconChainETH(queuedWithdrawal.depositor,recipient,queuedWithdrawal.shares[i]);}else{// tell the strategy to send the appropriate amount of funds to the recipientqueuedWithdrawal.strategies[i].withdraw(recipient,tokens[i],queuedWithdrawal.shares[i]);}unchecked{++i;// @audit}}}
Link to code
Let’s suppose that the owner tries to slash a queued withdrawal, and wants to skip the first strategy (index0) because it is malicious and makes the whole transaction revert.
1 . It definesindicesToSkipIndex = 0.2 . It enters theforloop starting ati = 0.3 .if (indicesToSkipIndex < indicesToSkip.length && indicesToSkip[indicesToSkipIndex] == i)will be true:0 < 1 && 0 == 0.4 . It increments++indicesToSkipIndex;to “skip” the malicious strategy, so nowindicesToSkipIndex = 1.5 . It goes back to theforloop. Butihasn’t been modified, so stilli = 0.6 .if (indicesToSkipIndex < indicesToSkip.length && indicesToSkip[indicesToSkipIndex] == i)will be false now:1 < 1 && 0 == 0.7 . It will enter theelsestatement and attempt to slash the strategy anyway.8 . If the strategy is malicious, it will revert, making it impossible to slash.9 . The adversary can later complete the withdrawal.
POC Test
This test shows how theindicesToSkipparameter is completely ignored.
For the sake of simplicity of the test, it uses a normal strategy; which will be slashed, proving that it ignores theindicesToSkipparameter and it indeed callsqueuedWithdrawal.strategies[i].withdraw().
A malicious strategy that makeswithdraw()revert, would be to make the whole transaction revert (not shown on this test but easily checkable as thefunction won’t catch it).
Add this test tosrc/tests/StrategyManagerUnit.t.soland runforge test -m "testSlashQueuedWithdrawal_IgnoresIndicesToSkip".
functiontestSlashQueuedWithdrawal_IgnoresIndicesToSkip()external{addressrecipient=address(this);uint256depositAmount=1e18;uint256withdrawalAmount=depositAmount;boolundelegateIfPossible=false;// Deposit into strategy and queue a withdrawal(IStrategyManager.QueuedWithdrawalmemoryqueuedWithdrawal,,) =testQueueWithdrawal_ToSelf_NotBeaconChainETH(depositAmount,withdrawalAmount,undelegateIfPossible);// Slash the delegatedOperatorslasherMock.freezeOperator(queuedWithdrawal.delegatedAddress);// Keep track of the balance before the slash attemptuint256balanceBefore=dummyToken.balanceOf(address(recipient));// Assert that the strategies array only has one elementassertEq(queuedWithdrawal.strategies.length,1);// Set `indicesToSkip` so that it should ignore the only strategy// As it's the only element, its index is `0`uint256[]memoryindicesToSkip=newuint256[](1);indicesToSkip[0] =0;// Call `slashQueuedWithdrawal()`// This should not try to slash the only strategy the queue has, because of the defined `indicesToSkip`// But in fact it ignores `indicesToSkip` and attempts to do it anywaycheats.startPrank(strategyManager.owner());strategyManager.slashQueuedWithdrawal(recipient,queuedWithdrawal,_arrayWithJustDummyToken(),indicesToSkip);cheats.stopPrank();uint256balanceAfter=dummyToken.balanceOf(address(recipient));// The `indicesToSkip` was completely ignored, and the function attempted the slash anyway// It can be asserted due to the fact that it increased the balancerequire(balanceAfter==balanceBefore+withdrawalAmount,"balanceAfter != balanceBefore + withdrawalAmount");}
Recommended Mitigation Steps
Place the++ioutside of the if/else statement. This way, it will increment each time the loop runs.
for (uint256 i = 0; i < strategiesLength;) {// check if the index i matches one of the indices specified in the `indicesToSkip` arrayif (indicesToSkipIndex < indicesToSkip.length && indicesToSkip[indicesToSkipIndex] == i) {unchecked {++indicesToSkipIndex;}} else {if (queuedWithdrawal.strategies[i] == beaconChainETHStrategy){//withdraw the beaconChainETH to the recipient_withdrawBeaconChainETH(queuedWithdrawal.depositor, recipient, queuedWithdrawal.shares[i]);} else {// tell the strategy to send the appropriate amount of funds to the recipientqueuedWithdrawal.strategies[i].withdraw(recipient, tokens[i], queuedWithdrawal.shares[i]);}-           unchecked {-               ++i;-           }}+       unchecked {+           ++i;+       }}
Assessed type
Loop
sorrynotsorry (lookout) commented:
The issue is well demonstrated, properly formatted, and contains a coded POC.
Marking as HQ.
Sidu28 (EigenLayer) confirmed
Alex the Entreprenerd (judge) commented:
The Warden has shown how, due to incorrect placement of the loop increment, malicious strategies cannot be skipped when slashing queued withdrawals.Because this breaks a core functionality of the contracts, which will also cause a loss of funds, I agree with High Severity.Mitigation is straightforward.