[H-19] An attacker can exploit the “deposit” to drain theUlysess Liquidity Pool
Submitted byxuwinnie
Users have two methods to add liquidity to theUlysses Pool: “mint” and “deposit”. However, the latter may return an inaccurate output, which could be exploited to drain the pool.
Proof of Concept
In the process to mint theamountof shares, the state change isA:(band, supply * weight) -> B:(band+update, (supply+amount) * weight). The user paysamount-sum(posFee)+sum(negFee)of the underlying to acquire theamountof shares. This approach is precise.
In the process to deposit theamountof underlying, the simulated state change isA:(band, supply * weight) -> B:(band+update, (supply+amount) * weight). Then,(posFee, negFee)is derived from the simulation ofA -> B. The actual state change isA:(band, supply * weight) -> B':(band+update+posFee, (supply+amount+sum(posFee)-sum(negFee)) * weight). We denote the actual fee ofA -> B'as(posFee', negFee'). The user pays theamountof underlying to acquireamount+sum(posFee)-sum(negFee)of shares. This approach would be acceptable ifsum(pos')-sum(neg') >= sum(pos), but this inequality doesn’t always hold. Ifsum(pos')-sum(neg') < sum(pos)insolvency occurs; and ifsum(pos')-sum(neg') < sum(pos)-sum(neg), the user could take profit.
An example is given below:
amount = 10000000supply = 1000000000000000013287555072weight = [1, 59, 47]band = [99452334745147595191585509, 4253569467850027815346666, 216725069177793291903286517]
When Alice deposits10000000underlying, they will get36215776shares. However, the pool actually worsens.
oldRebalancingFee = [0, 10519971631761767037843097, 18152377668510835770992]newRebalancingFee = [0, 10519971631761767000804564, 18152377668510882599904]oldMinusNew = [0, +37038533, -46828912]
Actually, there should be a systemic approach to construct states ofsum(pos')-sum(neg') < sum(pos)-sum(neg)for attacks. However, due to limited time, I have only conducted random tests. By continuously searching for profitable states and modifying the pool state accordingly, attackers can eventually drain the pool.
FAQ
Here are several questions that readers may have:
Q: Why there are three different scenarios? Why could insolvency and user loss happen simultaneously?A: Imagine when you deposit$100 to the bank, the bank increases your balance by$80 and claims it has got$120.
Q: Why cansum(pos')-sum(neg') >= sum(pos)not hold?A: Difficult question! Roughly this could happen when the amount is significantly smaller thansupplyandposFeeis excessively large.
Q: How can the pool be modified to a target state?A: There are several methods including “mint”, “redeem” and “swap” but the “deposit” method should not be used until we reach the target state because the attacker will mostly experience losses from that.
Q: Why can the attacker eventually drain the pool?A: When calling “mint”, “redeem” or “swap”, the attacker pays exactly the delta value of_calculateRebalancingFee. However, when making a “deposit”, the attacker receives more than what they deserve. At last, by adding liquidity,_calculateRebalancingFeecan be reduced, so the pool will be drained.
Q: Why don’t you provide a coded POC of attack?A: We know “deposit” is dangerous and we deprecate it, that’s enough.
Tools Used
Python
# -*- coding: utf-8 -*-"""Created on Mon Jun 19 10:24:56 2023@author: xuwinnie"""from random import *def getBandwidthUpdateAmounts(roundUp, positiveTransfer, amount, _totalWeights, _totalSupply):# Get the bandwidth state list lengthglobal length, weightArray, bandwithArray# Initialize bandwidth update amountsbandwidthUpdateAmounts = [0] * length# Initialize bandwidth differences from target bandwidthdiffs = [0] * length# Total difference from target bandwidth of all bandwidth statestotalDiff = 0# Total difference from target bandwidth of all bandwidth statestransfered = 0# Total amount to be distributed according to each bandwidth weightstransferedChange = 0for i in range(length):# Load bandwidth and weight from storage# Bandwidth is the first 248 bits of the slotbandwidth = bandwithArray[i]# Weight is the last 8 bits of the slotweight = weightArray[i]# Calculate the target bandwidthtargetBandwidth = (_totalSupply * weight) // _totalWeights# Calculate the difference from the target bandwidthif positiveTransfer:# If the transfer is positive, calculate deficit from target bandwidthif targetBandwidth > bandwidth:# Calculate the differencediff = targetBandwidth - bandwidth# Add the difference to the total differencetotalDiff += diff# Store the difference in the diffs arraydiffs[i] = diffelse:# If the transfer is negative, calculate surplus from target bandwidthif bandwidth > targetBandwidth:# Calculate the differencediff = bandwidth - targetBandwidth# Add the difference to the total differencetotalDiff += diff# Store the difference in the diffs arraydiffs[i] = diff# Calculate the amount to be distributed according deficit/surplus# and/or the amount to be distributed according to each bandwidth weightsif amount > totalDiff:# If the amount is greater than the total deficit/surplus# Total deficit/surplus is distributedtransfered = totalDiff# Set rest to be distributed according to each bandwidth weightstransferedChange = amount - totalDiffelse:# If the amount is less than the total deficit/surplus# Amount will be distributed according to deficit/surplustransfered = amountfor i in range(length):# Increase/decrease amount of bandwidth for each bandwidth statebandwidthUpdate = 0# If there is a deficit/surplus, calculate the amount to be distributedif transfered > 0:# Load the difference from the diffs arraydiff = diffs[i]# Calculate the amount to be distributed according to deficit/surplusif roundUp:bandwidthUpdate = (transfered * diff + totalDiff - 1) // totalDiffelse:bandwidthUpdate = (transfered * diff) // totalDiff# If there is a rest, calculate the amount to be distributed according to each bandwidth weightsif transferedChange > 0:# Load weight from storageweight = weightArray[i]# Calculate the amount to be distributed according to each bandwidth weightsif roundUp:bandwidthUpdate += (transferedChange * weight + _totalWeights - 1) // _totalWeightselse:bandwidthUpdate += (transferedChange * weight) // _totalWeights# If there is an update in bandwidthif bandwidthUpdate > 0:# Store the amount to be updated in the bandwidthUpdateAmounts arraybandwidthUpdateAmounts[i] = bandwidthUpdatereturn (bandwidthUpdateAmounts, length)def updateBandwidth(depositFees, positiveTransfer, destinationState, difference, _totalWeights, _totalSupply, _newTotalSupply):global weightArray, bandwithArrayprint("  updating "+str(destinationState)+" with diffrence "+str(difference))bandwidth = bandwithArray[destinationState]print("    old bandwith "+str(bandwidth))weight = weightArray[destinationState]# Get the target bandwidthtargetBandwidth = (_totalSupply * weight) // _totalWeights# Get the rebalancing fee prior to updating the bandwidtholdRebalancingFee = calculateRebalancingFee(bandwidth, targetBandwidth, positiveTransfer)if positiveTransfer:# If the transfer is positive# Add the difference to the bandwidthbandwidth += differenceelse:# If the transfer is negative# Subtract the difference from the bandwidthbandwidth -= differenceif _newTotalSupply > 0:# True on deposit, mint and redeem# Get the new target bandwidth after total supply changetargetBandwidth = (_newTotalSupply * weight) // _totalWeights# Get the rebalancing fee after updating the bandwidthnewRebalancingFee = calculateRebalancingFee(bandwidth, targetBandwidth, positiveTransfer)positiveFee, negativeFee = 0, 0if newRebalancingFee < oldRebalancingFee:# If new fee is lower than old fee# Calculate the positive feepositiveFee = oldRebalancingFee - newRebalancingFeeprint("    positiveFee "+str(positiveFee))if depositFees:# If depositFees is true, add the positive fee to the bandwidthbandwidth += positiveFeeelse:# If new fee is higher than old feeif newRebalancingFee > oldRebalancingFee:# Calculate the negative feenegativeFee = newRebalancingFee - oldRebalancingFeeprint("    negativeFee "+str(negativeFee))#raise Exception("good")else: print("    no fee")# Update storage with the new bandwidthbandwithArray[destinationState] = bandwidthprint("    new bandwith "+str(bandwidth))return (positiveFee, negativeFee)def calculateRebalancingFee(bandwidth, targetBandwidth, roundDown):# If the bandwidth is larger or equal to the target bandwidth, return 0if bandwidth >= targetBandwidth:return 0# Fee tier 1 (fee % divided by 2)lambda1 = int(20e14)# Fee tier 2 (fee % divided by 2)lambda2 = int(4980e14)# Get sigma2 from the first 8 bytes of the fee slotsigma2 = int(500e14)# Get sigma1 from the next 8 bytes of the fee slotsigma1 = int(6000e14)# Calculate the upper bound for the first feeupperBound1 = (targetBandwidth * sigma1) // DIVISIONER# Calculate the upper bound for the second feeupperBound2 = (targetBandwidth * sigma2) // DIVISIONERif bandwidth >= upperBound1:return 0maxWidth = upperBound1 - upperBound2# If the bandwidth is smaller than upperBound2if bandwidth >= upperBound2:# Calculate the fee for the first intervalfee = calcFee(lambda1, maxWidth, upperBound1, bandwidth, 0, roundDown)else:# Calculate the fee for the first intervalfee = calcFee(lambda1, maxWidth, upperBound1, upperBound2, 0, roundDown)# offset = lambda1 * 2lambda1 *= 2# Calculate the fee for the second intervalfee2 = calcFee(lambda2, upperBound2, upperBound2, bandwidth, lambda1, roundDown)# Add the two fees togetherfee += fee2return feedef calcFee(feeTier, maxWidth, upperBound, bandwidth, offset, roundDown):# Calculate the height of the trapeziumheight = upperBound - bandwidth# Calculate the width of the trapezium, rounded upwidth = ((height * feeTier + maxWidth - 1) // maxWidth) + offset# Calculate the fee for this tierif roundDown:fee = (width * height) // DIVISIONERelse:fee = (width * height + DIVISIONER - 1) // DIVISIONERreturn feedef mint(amount):print("minting "+str(amount)+" underlying")global LPBalance, UnderBalance, totalWeights, totalSupply, poolBalance_totalWeights = totalWeights_totalSupply = totalSupply_newTotalSupply = _totalSupply + amountbandwidthUpdateAmounts, length = getBandwidthUpdateAmounts(True, True, amount, _totalWeights, _newTotalSupply)output = 0negativeFee = 0i = 0while i < length:updateAmount = bandwidthUpdateAmounts[i]if updateAmount > 0:output += updateAmount_positiveFee, _negativeFee = updateBandwidth(False, True, i, updateAmount, _totalWeights, _totalSupply, _newTotalSupply)if _positiveFee > 0:negativeFee += _positiveFeeelse:output += _negativeFeei += 1if negativeFee > output:#raise Exception("Underflow()")passoutput -= negativeFeeLPBalance += outputif output > UnderBalance:raise Exception("Underflow()")UnderBalance -= outputtotalSupply += amountpoolBalance += outputprint("receiving "+str(output)+" lp")print()def deposit(amount):print("depositing "+str(amount)+" underlying")global LPBalance, UnderBalance, totalWeights, totalSupply, poolBalance_totalWeights = totalWeights_totalSupply = totalSupply_newTotalSupply = _totalSupply + amountbandwidthUpdateAmounts, length = getBandwidthUpdateAmounts(False, True, amount, _totalWeights, _newTotalSupply)output = 0negativeFee = 0i = 0while i < length:updateAmount = bandwidthUpdateAmounts[i]if updateAmount > 0:output += updateAmount_positiveFee, _negativeFee = updateBandwidth(True, True, i, updateAmount, _totalWeights, _totalSupply, _newTotalSupply)if _positiveFee > 0:output += _positiveFeeelse:negativeFee += _negativeFeei += 1if negativeFee > output:raise Exception("Underflow()")output -= negativeFeeLPBalance += outputif amount > UnderBalance:raise Exception("Underflow()")UnderBalance -= amounttotalSupply += outputpoolBalance += amountprint("receiving "+str(output)+" lp")print()def redeem(amount):print("redeeming "+str(amount)+" lp")global LPBalance, UnderBalance, totalWeights, totalSupply, poolBalancetotalSupply -= amountif amount > LPBalance:raise Exception("Underflow()")LPBalance -= amount_totalWeights = totalWeights_newTotalSupply = totalSupply_totalSupply = _newTotalSupply + amountbandwidthUpdateAmounts, length = getBandwidthUpdateAmounts(False, False, amount, _totalWeights, _totalSupply)output = 0negativeFee = 0i = 0while i < length:updateAmount = bandwidthUpdateAmounts[i]if updateAmount > 0:output += updateAmount_positiveFee, _negativeFee = updateBandwidth(False, False, i, updateAmount, _totalWeights, _totalSupply, _newTotalSupply)#if _positiveFee > 0:#raise Exception("nooooo()")negativeFee += _negativeFeei += 1if negativeFee > output:raise Exception("Underflow()")output -= negativeFeeUnderBalance += outputpoolBalance -= outputprint("receiving "+str(output)+" underlying")print()def getIdealPoolBalance():global length, bandwithArray, weightArray, totalWeights, totalSupplyassets = 0for i in range(length):targetBandwidth = totalSupply * weightArray[i] // totalWeightsassets += calculateRebalancingFee(bandwithArray[i], targetBandwidth, False)#print(calculateRebalancingFee(bandwithArray[i], targetBandwidth, False))assets += bandwithArray[i]#print(bandwithArray[i])return assetsdef getFeeStatus():global length, bandwithArray, weightArray, totalWeights, totalSupplyassets = 0for i in range(length):targetBandwidth = totalSupply * weightArray[i] // totalWeightsassets += calculateRebalancingFee(bandwithArray[i], targetBandwidth, False)print(i)print(calculateRebalancingFee(bandwithArray[i], targetBandwidth, False))return assets'''cnt = 0cnttt = 0recordinso = []recordluck = []for i in range(100000):DIVISIONER = int(1e18)length = 3bandwithArray = [randint(0, int(1e27)) for _ in range(length)]weightArray = [1] + [randint(1, 100) for _ in range(length - 1)]#weightArray = [1, 1000]totalWeights = sum(weightArray)totalSupply = int(1e27)poolBalance = getIdealPoolBalance()UnderBalance = 0beforeFee = getFeeStatus()#amount = randint(0, int(1e25))amount = 10000000000LPBalance = amountredeem(amount)afterFee = getFeeStatus()if poolBalance < getIdealPoolBalance():print(str(poolBalance)+" insolvency! "+str(getIdealPoolBalance()))cnt += 1recordinso.append(getIdealPoolBalance() - poolBalance)raise Exception("Strange()")if UnderBalance + afterFee > amount + beforeFee :print("lucky!")recordluck.append(UnderBalance + afterFee - amount - beforeFee)cnttt += 1print(i)print(cnt)print(cnttt)'''cnt = 0cnttt = 0recordinso = []recordluck = []recordcomp = []for i in range(1):DIVISIONER = int(1e18)length = 3#bandwithArray = [randint(0, int(1e27)) for _ in range(length)]bandwithArray = [99452334745147595191585509, 4253569467850027815346666, 216725069177793291903286517]#weightArray = [1] + [randint(1, 100) for _ in range(length - 1)]weightArray = [1, 59, 47]totalWeights = sum(weightArray)totalSupply = int(1e27)poolBalance = getIdealPoolBalance()LPBalance = 0UnderBalance = int(1e26)beforeFee = getFeeStatus()#amount = randint(0, int(1e10))amount = 10000000deposit(amount)afterFee = getFeeStatus()if poolBalance < getIdealPoolBalance():print(str(poolBalance)+" insolvency! "+str(getIdealPoolBalance()))cnt += 1recordinso.append(getIdealPoolBalance() - poolBalance)recordcomp.append(LPBalance + afterFee - amount - beforeFee)#raise Exception("good")if LPBalance + afterFee > amount + beforeFee:print("lucky!")cnttt += 1recordluck.append(LPBalance + afterFee - amount - beforeFee)#breakprint(i)print(cnt)print(cnttt)
Recommended Mitigation Steps
Deprecate the “deposit” method. It is hard to find a correct way to handle this.
Assessed type
Context
0xLightt (Maia) confirmed and commented:
I was able to recreate this issue in solidity. But finding the actual issue is essential to make sure this is actually being addressed and there isn’t any more issue due to this. Blindly removing thedepositfunction and hoping this fully fixes this is not a sensible approach.Added these mock functions toUlyssesPoolto help recreate this issue:functionsetTotalSupply(uint256_totalSupply)external{totalSupply=_totalSupply;}functionaddBandwidthTest(uint248bandwidth,uint8weight)external{totalWeights+=weight;bandwidthStateList.push(BandwidthState({bandwidth:bandwidth,destination:UlyssesPool(address(0)),weight:weight}));}functiongetRebalancingFee(uint256index)externalviewreturns(uint256) {return_calculateRebalancingFee(bandwidthStateList[index].bandwidth,totalSupply.mulDiv(bandwidthStateList[index].weight,totalWeights),false);}Then added this test toInvariantUlyssesPoolBoundedto recreate your example:functiontest_435()public{setUpHandler();vm.startPrank(handler);UlyssesPool[]memorypools=createPools(1);UlyssesPoolpool1=UlyssesPool(pools[0]);MockERC20(pool1.asset()).mint(address(handler),type(uint256).max/2);MockERC20(pool1.asset()).mint(address(pool1),100000000000ether);MockERC20(pool1.asset()).approve(address(pool1),type(uint256).max);pool1.setTotalSupply(1000000000000000013287555072);pool1.addBandwidthTest(99452334745147595191585509,1);pool1.addBandwidthTest(4253569467850027815346666,59);pool1.addBandwidthTest(216725069177793291903286517,47);console2.log(pool1.getRebalancingFee(1),pool1.getRebalancingFee(2),pool1.getRebalancingFee(3));uint256feeBefore=pool1.getRebalancingFee(1) +pool1.getRebalancingFee(2) +pool1.getRebalancingFee(3);pool1.deposit(10000000,address(handler));console2.log(pool1.getRebalancingFee(1),pool1.getRebalancingFee(2),pool1.getRebalancingFee(3));uint256feeAfter=pool1.getRebalancingFee(1) +pool1.getRebalancingFee(2) +pool1.getRebalancingFee(3);// Should revert but doesn'tconsole2.log(feeAfter-feeBefore);}
xuwinnie (warden) commented:
Hey, was able to recreate this issue in solidity. But finding the actual issue is essential to make sure this is actually being addressed and there isn’t any more issue due to this. Blindly removing thedepositfunction and hoping this fully fixes this is not a sensible approach.Whenredeemingandminting, the calculation is share->amount. But when depositing, the calculation is amount->share, so I believe removingdepositis the best way. In the equation,amount = share + rebalancingfee(before) - rebalancingfee(after), if we know share, it’s straight forward to get the amount, but it’s hard to get shares from the amount. The current approach indepositis just an approximation and that’s why it can be exploited.
0xLightt (Maia) commented:
Thanks for giving more context, I understand why you are suggesting to remove thedepositfunction as a fix, especially due to the time constraints you mentioned. I just want to make sure this is not being caused by any underlying issue that can still affect other functions.After looking into it more, it is exactly what you suggested; the issue comes from siphoning the_newTotalSupplywhen doing calculations because we are not accounting for shares minted due to rebalancing fees. A possible solution could be to overestimate the new total supply, but it would lead to users overpaying in certain situations. Because of this, thedepositfunction wouldn’t make sense to be used overmint, so it is safer to just remove it.
0xLightt (Maia) commented:
We recognize the audit’s findings on Ulysses AMM. These will not be rectified due to the upcoming migration of this section to Balancer Stable Pools.