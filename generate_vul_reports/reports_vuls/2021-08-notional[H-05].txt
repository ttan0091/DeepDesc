[H-05] Access restrictions onNotionalV1ToNotionalV2.notionalCallbackcan be bypassed
Submitted by cmichel, also found by pauliax
TheNotionalV1ToNotionalV2.notionalCallbackis supposed to only be called from the verified contract that calls this callback but the access restrictions can be circumvented by simply providingsender = thisassenderis a parameter of the function that can be chosen by the attacker.
functionnotionalCallback(addresssender,addressaccount,bytescalldatacallbackData)externalreturns(uint256) {require(sender==address(this),"Unauthorized callback");
An attacker can call the function passing in an arbitraryaccountwhose tokens can then be stolen.
Theaccountfirst has to approve this contract but this can happen with accounts that legitimately want to migrate their tokens and therefore have to send a first transaction to approve the contract, but then an attacker frontruns the actual migration transaction.
The attacker can steal the tokens by performing an attack similar to the following:
first transaction is used to withdraw the victim’s funds to the contract. This can be done by choosingaccount=victim,v1RepayAmount=0,v1CollateralId=WBTC,v2CollateralId=DAI. TheNotionalV1Erc1155.batchOperationWithdraw(not part of this contest) will withdraw the victim’s funds to this contract. Note that the attacker has to deposit the samev2CollateralBalance = uint256(collateralBalance)for the victim into the V2 version, but they can choose different cheaper collateral (for example, withdraw WBTC, deposit same amount of DAI).second transaction is now used to deposit the victim funds in the contract into the user’s account. They useaccount=attacker,v1DebtCurrencyId=WBTC,v1RepayAmount=amountto deposit it into Notional V1. (They need to have a smallcollateralBalance, etc. to pass all checks).
Recommend fixing the authorization check.