[H-06] StabilizerNode.stabilize uses stale GlobalImpliedCollateralService data, which will make stabilize incorrect
Submitted bycccz
In StabilizerNode.stabilize,impliedCollateralService.syncGlobalCollateral()is called only at the end of the function to synchronize the GlobalImpliedCollateralService data.
if(!_shouldAdjustSupply(exchangeRate,stabilizeToPeg)) {lastStabilize=block.timestamp;impliedCollateralService.syncGlobalCollateral();return;}...if(trackAfterStabilize) {maltDataLab.trackPool();}impliedCollateralService.syncGlobalCollateral();lastStabilize=block.timestamp;}
syncGlobalCollateral will use the data ingetCollateralizedMalt(), which includes the collateralToken balance in overflowPool/swingTraderManager/liquidityExtension and the malt balance in swingTraderManager.
functionsyncGlobalCollateral()publiconlyActive{globalIC.sync(getCollateralizedMalt());}...functiongetCollateralizedMalt()publicviewreturns(PoolCollateralmemory) {uint256target=maltDataLab.priceTarget();uint256unity=10**collateralToken.decimals();// Convert all balances to be denominated in units of Malt target priceuint256overflowBalance=maltDataLab.rewardToMaltDecimals((collateralToken.balanceOf(address(overflowPool)) *unity) /target);uint256liquidityExtensionBalance= (collateralToken.balanceOf(address(liquidityExtension)) *unity) /target;(uint256swingTraderMaltBalance,uint256swingTraderBalance) =swingTraderManager.getTokenBalances();swingTraderBalance= (swingTraderBalance*unity) /target;
Since StabilizerNode.stabilize will use the results of maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice to stabilize, and maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice will useGlobalImpliedCollateralService.collateralRatio, to ensure correct stabilization, the data in GlobalServiceImpliedCollateralService should be the latest.
functiongetActualPriceTarget()externalviewreturns(uint256) {uint256unity=10**collateralToken.decimals();uint256icTotal=maltToRewardDecimals(globalIC.collateralRatio());...functiongetSwingTraderEntryPrice()externalviewreturns(uint256stEntryPrice){uint256unity=10**collateralToken.decimals();uint256icTotal=maltToRewardDecimals(globalIC.collateralRatio());
But sinceimpliedCollateralService.syncGlobalCollateral()is not called before StabilizerNode.stabilize calls maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice, this will cause StabilizerNode.stabilize to use stale GlobalImpliedCollateralService data, which will make stabilize incorrect.
A simple example would be:
impliedCollateralService.syncGlobalCollateral()is called to synchronize the latest dataSwingTraderManager.delegateCapital is called, and the collateralToken is taken out from SwingTrader, which will make theGlobalImpliedCollateralService.collateralRatiolarger than the actual collateralRatio.
functiondelegateCapital(uint256amount,addressdestination)externalonlyRoleMalt(CAPITAL_DELEGATE_ROLE,"Must have capital delegation privs")onlyActive{collateralToken.safeTransfer(destination,amount);emitDelegation(amount,destination,msg.sender);}...functioncollateralRatio()publicviewreturns(uint256) {uint256decimals=malt.decimals();uint256totalSupply=malt.totalSupply();if(totalSupply==0) {return0;}return(collateral.total* (10**decimals)) /totalSupply;// @audit: collateral.total is larger than the actual}
When StabilizerNode.stabilize is called, it will use the stale collateralRatio for calculation. If the collateralRatio is too large, the results of maltDataLab.getActualPriceTarget/getSwingTraderEntryPrice will be incorrect, thus making stabilize incorrect.
Since stabilize is a core function of the protocol, stabilizing with the wrong data is likely to cause malt to be depegged, so the vulnerability should be High risk.
Proof of Concept
https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/StabilizerNode.sol#L161-L237
https://github.com/code-423n4/2023-02-malt/blob/700f9b468f9cf8c9c5cffaa1eba1b8dea40503f9/contracts/StabilityPod/ImpliedCollateralService.sol#L89-L131
Recommended Mitigation Steps
CallimpliedCollateralService.syncGlobalCollateral()before StabilizerNode.stabilize calls maltDataLab.getActualPriceTarget.
function stabilize() external nonReentrant onlyEOA onlyActive whenNotPaused {// Ensure data consistencymaltDataLab.trackPool();// Finalize auction if possible before potentially starting a new oneauction.checkAuctionFinalization();+  impliedCollateralService.syncGlobalCollateral();require(block.timestamp >= stabilizeWindowEnd || _stabilityWindowOverride(),"Can't call stabilize");stabilizeWindowEnd = block.timestamp + stabilizeBackoffPeriod;// used in 3 location.uint256 exchangeRate = maltDataLab.maltPriceAverage(priceAveragePeriod);bool stabilizeToPeg = onlyStabilizeToPeg; // gasif (!_shouldAdjustSupply(exchangeRate, stabilizeToPeg)) {lastStabilize = block.timestamp;impliedCollateralService.syncGlobalCollateral();return;}emit Stabilize(block.timestamp, exchangeRate);(uint256 livePrice, ) = dexHandler.maltMarketPrice();uint256 priceTarget = maltDataLab.getActualPriceTarget();
0xScotch (Malt) confirmed