[H-08] Incorrect calculation ofusedFundsin LiquidityPool leads to lower than expected token price
Submitted bypeakbolt, also found byauditor0517andKIntern_NA
InLiquidityPool.sol, the functionsopenLong(),closeLong(),openShort()andcloseShort()do not deducthedgingFeesfromusedFundsto offset thehedgingFeesthat was added due to_hedge().
Impact
The missing deduction ofhedgingFeeswill increase theusedFundsinLiquidityPool, thus reducing theavailableFunds. This leads to a lower token price, causingLiquidityPooltoken holders to be shortchanged, losing a portion of their token value.
Detailed Explanation
Passive users can provide liquidity to the Liquidity Pool to earn exchange fees, while traders can take long or short position against the Exchange.
The trade functionsopenLong(),closeLong(),openShort()andcloseShort()inLiquidityPool.solwill call_hedgeto hedge the liquidity poolâ€™s exposure during a trade.
Thehedge()will actually increaseusedFundsby the margin required, which includeshedgingFeesas these are transfered over to theperpMarketfor the hedging.
uint256 marginRequired = _calculateMargin(hedgingSize) + hedgingFees;usedFunds += int256(marginRequired);require(usedFunds <= 0 || totalFunds >= uint256(usedFunds));perpMarket.transferMargin(int256(marginRequired));
Using theOpenLong()trade as an example, the trader transfers thetradeCost + feestoLiquidityPool, which includes the premium,hedgingFees,feesCollectedandexternalFee.  That means thehedgingFeesthat was transfered in_hedge()is actually provided by the trader and not theLiquidityPool.
Hence, theusedFundsshould be reduced byhedgingFeesto offset the addition in_hedge().
uint256 fees = orderFee(int256(amount));totalCost = tradeCost + fees;SUSD.safeTransferFrom(user, address(this), totalCost);uint256 hedgingFees = _hedge(int256(amount), false);uint256 feesCollected = fees - hedgingFees;uint256 externalFee = feesCollected.mulWadDown(devFee);SUSD.safeTransfer(feeReceipient, externalFee);usedFunds -= int256(tradeCost);totalFunds += feesCollected - externalFee;
Proof of Concept
Then add the following imports and test case totest/LiquidityPool.Trades.t.sol
import {wadMul} from "solmate/utils/SignedWadMath.sol";import {IPerpsV2Market} from "../src/interfaces/synthetix/IPerpsV2Market.sol";function testLiquidityPoolFundCalculation() public {uint256 longAmount = 1e18;(uint256 markPrice, bool isInvalid) = pool.getMarkPrice();uint256 tradeCost = longAmount.mulWadDown(markPrice);uint256 fees = pool.orderFee(int256(longAmount));uint256 delta = pool.getDelta();int256 hedgingSize = wadMul(int256(longAmount), int256(delta));IPerpsV2Market perp = pool.perpMarket();(uint256 hedgingFees, ) = perp.orderFee(hedgingSize, IPerpsV2MarketBaseTypes.OrderType.Delayed);uint256 feesCollected = fees - hedgingFees;uint256 externalFee = feesCollected.mulWadDown(pool.devFee());uint256 totalFundsBefore = pool.totalFunds();int256 usedFundsBefore = pool.usedFunds();// Open a Long tradeopenLong(longAmount, longAmount * 1000, user_1);// Calculated expected totalFunds and usedFundsuint256 expectedTotalFunds = totalFundsBefore + feesCollected - externalFee;uint256 marginRequired = tradeCost + hedgingFees;int256 expectedUsedFunds = usedFundsBefore - int256(tradeCost) - int256(hedgingFees) + int256(marginRequired);// This is correct as the pool will increase by net fee (feesCollected - externalFee)assertEq(pool.totalFunds(), expectedTotalFunds);// LiquidityPool's UsedFunds is wrong and is higher than expected as it included hedgingFees.assertGt(pool.usedFunds(), expectedUsedFunds);uint256 poolAvailableFunds = pool.totalFunds() - uint256(pool.usedFunds());uint256 expectedAvailableFunds = expectedTotalFunds - uint256(expectedUsedFunds);// LiquidityPool's available funds is wrong and is less than expected as it factored in hedgingFeesassertLt(poolAvailableFunds, expectedAvailableFunds);assertEq(poolAvailableFunds, expectedAvailableFunds - hedgingFees);// LiquidityPool's available funds is wrong and is also less than SUSD balanceassertLt(poolAvailableFunds, susd.balanceOf(address(pool)));// LiquidityPool's available fund is expected to be the same as Pool's SUSD balanceassertEq(expectedAvailableFunds, susd.balanceOf(address(pool)));// LiquidityPool Token price is less than expected.assertLt(pool.getTokenPrice(), getExpectedTokenPrice(expectedTotalFunds, expectedUsedFunds, perp));}function getExpectedTokenPrice(uint256 expectedTotalFunds, int256 expectedUsedFunds, IPerpsV2Market perp) public returns (uint256 expectedTokenPrice) {(uint256 markPrice,) = pool.getMarkPrice();uint256 totalValue = expectedTotalFunds;uint256 totalSupply = lqToken.totalSupply() + pool.totalQueuedWithdrawals();uint256 amountOwed = markPrice.mulWadDown(powerPerp.totalSupply());uint256 amountToCollect = markPrice.mulWadDown(shortToken.totalShorts());//uint256 totalMargin = _getTotalMargin();(uint256 totalMargin,) = perp.remainingMargin(address(pool));totalValue += totalMargin + amountToCollect;totalValue -= uint256((int256(amountOwed) + expectedUsedFunds));expectedTokenPrice = totalValue.divWadDown(totalSupply);}
Recommended Mitigation Steps
DeducthedgingFeesfromusedFundsto offset thehedgingFeesadded in_hedge().
For example, in openLong change
usedFunds -= int256(tradeCost);
to
usedFunds -= int256(tradeCost) - int256(hedgingFees);
mubaris (Polynomial) confirmed