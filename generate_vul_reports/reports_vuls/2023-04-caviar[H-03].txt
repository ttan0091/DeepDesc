[H-03] Risk of silent overflow in reserves update
Submitted bysashik_eth, also found bycodeslide,Kaysoft,W0RR1O,georgits,btk,lukris02,0x6980,tnevler,0xAgro,matrix_0wl,catellatech,Sathish9098,ayden,0x4non,adriro,Madalad,Kenshin,giovannidisiena,devscrooge,sayan,SaeedAlipoor01988,tsvetanovv,Cryptor, andmatrix_0wl
https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L230-L231
https://github.com/code-423n4/2023-04-caviar/blob/main/src/PrivatePool.sol#L323-L324
Vulnerability details
Thebuy()andsell()functions update thevirtualBaseTokenReservesandvirtualNftReservesvariables during each trade. However, these two variables are of typeuint128, while the values that update them are of typeuint256. This means that casting to a lower type is necessary, but this casting is performed without first checking that the values being cast can fit into the lower type. As a result, there is a risk of a silent overflow occurring during the casting process.
functionbuy(uint256[]calldatatokenIds,uint256[]calldatatokenWeights,MerkleMultiProofcalldataproof)publicpayablereturns(uint256netInputAmount,uint256feeAmount,uint256protocolFeeAmount){// ~~~ Checks ~~~ //// calculate the sum of weights of the NFTs to buyuint256weightSum=sumWeightsAndValidateProof(tokenIds,tokenWeights,proof);// calculate the required net input amount and fee amount(netInputAmount,feeAmount,protocolFeeAmount) =buyQuote(weightSum);...// update the virtual reservesvirtualBaseTokenReserves+=uint128(netInputAmount-feeAmount-protocolFeeAmount);virtualNftReserves-=uint128(weightSum);...
Impact
If the reserves variables are updated with a silent overflow, it can lead to a breakdown of the xy=k equation. This, in turn, would result in a totally incorrect price calculation, causing potential financial losses for users or pool owners.
Proof of Concept
Consider the scenario with a base token that has high decimals number described in the next test (add it to thetest/PrivatePool/Buy.t.sol):
functiontest_Overflow()public{// Setting up pool and base token HDT with high decimals number - 30// Initial balance of pool - 10 NFT and 100_000_000 HDTHighDecimalsTokenbaseToken=newHighDecimalsToken();privatePool=newPrivatePool(address(factory),address(royaltyRegistry),address(stolenNftOracle));privatePool.initialize(address(baseToken),nft,100_000_000*1e30,10*1e18,changeFee,feeRate,merkleRoot,true,false);// Minting NFT on pool addressfor(uint256i=100;i<110;i++) {milady.mint(address(privatePool),i);}// Adding 8 NFT ids into the buying arrayfor(uint256i=100;i<108;i++) {tokenIds.push(i);}// Saving K constant (xy) value before the tradeuint256kBefore=uint256(privatePool.virtualBaseTokenReserves()) *uint256(privatePool.virtualNftReserves());// Minting enough HDT tokens and approving them for pool address(uint256netInputAmount,,uint256protocolFeeAmount) =privatePool.buyQuote(8*1e18);deal(address(baseToken),address(this),netInputAmount);baseToken.approve(address(privatePool),netInputAmount);privatePool.buy(tokenIds,tokenWeights,proofs);// Saving K constant (xy) value after the tradeuint256kAfter=uint256(privatePool.virtualBaseTokenReserves()) *uint256(privatePool.virtualNftReserves());// Checking that K constant succesfully was changed due to silent overflowassertEq(kBefore,kAfter,"K constant was changed");}
Also add this contract into the end ofBuy.t.solfile for proper test work:
contractHighDecimalsTokenisERC20{constructor()ERC20("High Decimals Token","HDT",30) {}}
Recommended Mitigation Steps
Add checks that the casting value is not greater than theuint128type max value:
File:PrivatePool.sol229:// update the virtual reserves+if(netInputAmount-feeAmount-protocolFeeAmount>type(uint128).max)revertOverflow();230:virtualBaseTokenReserves+=uint128(netInputAmount-feeAmount-protocolFeeAmount);+if(weightSum>type(uint128).max)revertOverflow();231:virtualNftReserves-=uint128(weightSum);File:PrivatePool.sol322:// update the virtual reserves+if(netOutputAmount+protocolFeeAmount+feeAmount>type(uint128).max)revertOverflow();323:virtualBaseTokenReserves-=uint128(netOutputAmount+protocolFeeAmount+feeAmount);+if(weightSum>type(uint128).max)revertOverflow();324:virtualNftReserves+=uint128(weightSum);
outdoteth (Caviar) acknowledged
Alex the Entreprenerd (judge) commented:
The Warden has identified a risky underflow due to unsafe casting, the underflow would cause the invariants of the protocol to be broken, causing it to behave in undefined ways, most likely allowing to discount tokens (principal)I have considered downgrading to Medium SeverityHowever, I believe that in multiple cases the subtractionsnetInputAmount - feeAmount - protocolFeeAmountwhich could start withnetInputAmount > type(uint128).maxwould not necessarily fall within auint128For this reason, I believe the finding to be of High Severity.
outdoteth (Caviar) mitigated:
Fixed inhttps://github.com/outdoteth/caviar-private-pools/pull/10.
Status:Mitigation confirmed. Full details in reports fromrbserver,KrisApostolov, andrvierdiiev.