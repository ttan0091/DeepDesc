[H-18]PublicVault.processEpochcalculateswithdrawReserveincorrectly; Users can lose funds
Submitted byrvierdiiev
PublicVault.processEpoch calculates withdrawReserve incorrectly. As result user can receive less funds when totalAssets() <= expected from auction.
Proof of Concept
When users wants to withdraw fromPublicVaultthenWithdrawProxyis deployed andPublicVault.processEpochfunction is responsible to calculates.withdrawReserve.
This amount depends on how many shares should be redeemed and if there is auction for the epoch.
https://github.com/code-423n4/2023-01-astaria/blob/main/src/PublicVault.sol#L275-L343
solidityfunction processEpoch() public {// check to make sure epoch is overif (timeToEpochEnd() > 0) {revert InvalidState(InvalidStates.EPOCH_NOT_OVER);}VaultData storage s = _loadStorageSlot();if (s.withdrawReserve > 0) {revert InvalidState(InvalidStates.WITHDRAW_RESERVE_NOT_ZERO);}WithdrawProxy currentWithdrawProxy = WithdrawProxy(s.epochData[s.currentEpoch].withdrawProxy);// split funds from previous WithdrawProxy with PublicVault if hasn't been alreadyif (s.currentEpoch != 0) {WithdrawProxy previousWithdrawProxy = WithdrawProxy(s.epochData[s.currentEpoch - 1].withdrawProxy);if (address(previousWithdrawProxy) != address(0) &&previousWithdrawProxy.getFinalAuctionEnd() != 0) {previousWithdrawProxy.claim();}}if (s.epochData[s.currentEpoch].liensOpenForEpoch > 0) {revert InvalidState(InvalidStates.LIENS_OPEN_FOR_EPOCH_NOT_ZERO);}// reset liquidationWithdrawRatio to prepare for re calcualtions.liquidationWithdrawRatio = 0;// check if there are LPs withdrawing this epochif ((address(currentWithdrawProxy) != address(0))) {uint256 proxySupply = currentWithdrawProxy.totalSupply();s.liquidationWithdrawRatio = proxySupply.mulDivDown(1e18, totalSupply()).safeCastTo88();currentWithdrawProxy.setWithdrawRatio(s.liquidationWithdrawRatio);uint256 expected = currentWithdrawProxy.getExpected();unchecked {if (totalAssets() > expected) {s.withdrawReserve = (totalAssets() - expected).mulWadDown(s.liquidationWithdrawRatio).safeCastTo88();} else {s.withdrawReserve = 0;}}_setYIntercept(s,s.yIntercept -totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18));// burn the tokens of the LPs withdrawing_burn(address(this), proxySupply);}// increment epochunchecked {s.currentEpoch++;}}
s.liquidationWithdrawRatiodepends on how many shares exists inside WithdrawProxy. In case if amount of shares insideWithdrawProxyequal to amount of shares insidePublicVaultthat means that withdraw ratio is 100% and all funds from Vault should be sent toWithdrawProxy.
In case if auction is in progress thenWithdrawProxy.getExpectedis not 0 and some amount of funds is expected from auction.
unchecked{if(totalAssets() >expected) {s.withdrawReserve= (totalAssets() -expected).mulWadDown(s.liquidationWithdrawRatio).safeCastTo88();}else{s.withdrawReserve=0;}}
This iss.withdrawReservecalculation. As you can see in case iftotalAssets() <= expectedthens.withdrawReserveis set to 0 and no funds will be sent to proxy. This is incorrect though.
For example in the case when withdraw ratio is 100% all funds should be sent to the withdraw proxy, but because of that check, some part of funds will be still inside the vault and depositors will lose their funds. If for example totalAssets is 5eth and expected is 5 eth, then depositors will lose all 5 eth.
This check is done in such way, because ofcalculations insideWithdrawProxy. But itâ€™s not correct.
Tools Used
VsCode
Recommended Mitigation Steps
You need to check this logic again. Maybe you need to always sends.withdrawReserve = totalAssets().mulWadDown(s.liquidationWithdrawRatio).safeCastTo88()amount to the withdraw proxy. But then you need to rethink, how WithdrawProxy will handle yIntercept increase/decrease.