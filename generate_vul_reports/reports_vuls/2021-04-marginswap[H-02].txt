[H-02] MissingfromToken != toTokencheck
Attacker callsMarginRouter.crossSwapExactTokensForTokenswith a fake pair and the same token[0] == token[1].crossSwapExactTokensForTokens(1000 WETH, 0, [ATTACKER_CONTRACT], [WETH, WETH]). When the amounts are computed by theamounts = UniswapStyleLib.getAmountsOut(amountIn - fees, pairs, tokens);call, the attacker contract returns fake reserves that yield 0 output. When_swapExactT4Tis called, the funds are sent to the fake contract and doing nothing passes all checks in_swapcall that follows because thestartingBalanceis storedafterthe initial Fund withdraw to the pair.
function_swapExactT4T() {// withdraw happens hereFund(fund()).withdraw(tokens[0],pairs[0],amounts[0]);_swap(amounts,pairs,tokens,fund());}function_swap() {uint256startingBalance=IERC20(outToken).balanceOf(_to);uint256endingBalance=IERC20(outToken).balanceOf(_to);// passes as startingBalance == endingBalance + 0require(endingBalance>=startingBalance+amounts[amounts.length-1],"Defective AMM route; balances don't match");}
The full impact is not yet known asregisterTradecould still fail when subtracting theinAmountand adding 0outAmount.
At least, this attack is similar to a withdrawal which is supposed to only occur after a certaincoolingOffPeriodhas passed, but this time-lock is circumvented with this attack.
Recommend moving the fund withdrawal to the first pairafterthestartingBalanceassignment. CheckfromToken != toTokenas cyclical trades (arbitrages) are likely not what margin traders are after. Consider if the same check is required forregisterTradeAndBorrow/adjustAmountsfunctions.