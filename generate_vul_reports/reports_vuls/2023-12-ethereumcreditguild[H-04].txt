[H-04] Users staking via theSurplusGuildMintercan be immediately slashed when staking into a gauge that had previously incurred a loss
Submitted byJCN, also found bycarrotsmuggler,Chinmay,beber89,XDZIBECX,serial-coder,Varun_05,Infect3d,stackachu,AlexCzm,0xdice91,jasonxiale,HighDuty,imare,cats,developerjordy,0xaltego,0xadrii,DanielArmstrong,cccz,sl1,wangxx2026,Akali,SECURITISE,smiling_heretic,Timeless,KupiaSec,PENGUN,alexzoid,Stormreckson,0xpiken,SweetDream,whitehat-boys,klau5,btk,0xivas,santipu_,asui,grearlake,TheSchnilch,kaden,Inference, andether_sky
User’s can stake into a gauge directly via theGuildTokenor indirectly via theSurplusGuildMinter. When a user stakes into a new gauge (i.e. their weight goes from0to> 0) viaGuildToken::incrementGauge, theirlastGaugeLossAppliedmapping for this gauge, which is how the system keeps track of whether or not the user deserves to be slashed, is set to the current timestamp:
GuildToken.sol#L247-L256
247:uint256_lastGaugeLoss=lastGaugeLoss[gauge];248:uint256_lastGaugeLossApplied=lastGaugeLossApplied[gauge][user];249:if(getUserGaugeWeight[user][gauge] ==0) {250:lastGaugeLossApplied[gauge][user] =block.timestamp;251:        }else{252:require(253:_lastGaugeLossApplied>=_lastGaugeLoss,254:"GuildToken: pending loss"255:            );256:        }
This ensures that any loss that occurred in the gauge, before the user staked, will result in the following condition:lastGaugeLossApplied[gauge][user] > lastGaugeLoss[gauge]. This means the user staked into the gauge after the gauge experienced a loss and therefore, they can not be slashed:
GuildToken.sol#L133-L140
133:functionapplyGaugeLoss(addressgauge,addresswho)external{134:// check preconditions135:uint256_lastGaugeLoss=lastGaugeLoss[gauge];136:uint256_lastGaugeLossApplied=lastGaugeLossApplied[gauge][who];137:require(138:_lastGaugeLoss!=0&&_lastGaugeLossApplied<_lastGaugeLoss,139:"GuildToken: no loss to apply"140:        );
The above function showcases the requirements that need to be met in order for a user to be slashed: the user must have been staked in the gauge when the gauge experienced a loss in order for the user to be slashed. With this in mind, let us observe the process that occurs when users stake via theSurplusGuildMinter:
When a user stakes into a gauge via theSurpluGuildMinter::stakefunction theSurplusGuildMinter::getRewardsfunction is invoked:
SurplusGuildMinter.sol#L216-L236
216:functiongetRewards(217:addressuser,218:addressterm219:    )220:public221:returns(222:uint256lastGaugeLoss,// GuildToken.lastGaugeLoss(term)223:UserStakememoryuserStake,// stake state after execution of getRewards()224:boolslashed// true if the user has been slashed225:        )226:    {227:boolupdateState;228:lastGaugeLoss=GuildToken(guild).lastGaugeLoss(term);229:if(lastGaugeLoss>uint256(userStake.lastGaugeLoss)) {230:slashed=true;231:        }232:233:// if the user is not staking, do nothing234:userStake=_stakes[user][term];235:if(userStake.stakeTime==0)236:return(lastGaugeLoss,userStake,slashed);
As seen above, this function will retrieve thelastGaugeLossfor the specified gauge (term) the user is staking into and will identify this user as being slashed, i.e.slashed = true, iflastGaugeLoss > userStake.lastGaugeLoss. The issue lies in the fact that, at this point in the code execution, theuserStakestruct is a freshly initialized memory struct and therefore, all of the struct’s fields are set to0. Thus, the check on lines 229-230 are really doing the following:
if(lastGaugeLoss>uint256(0)) {slashed=true;}
The above code will always setslashedtotrueif the specified gauge has experienced any loss in its history. Therefore, a gauge can have experienced a loss, been off-boarded, and then been re-onboarded at a future time and TheSurplusGuildMinterwill consider any user who stakes into this gauge to beslashed.
The code execution will then continue to lines 235-236, where the user’s stake is retrieved from storage (it is initialized to all0’s since the user has not staked yet) and if thestakeTimefield is0(it is), the execution returns to theGuildToken::stakefunction:
SurplusGuildMinter.sol#L114-L125
114:functionstake(addressterm,uint256amount)externalwhenNotPaused{115:// apply pending rewards116:        (uint256lastGaugeLoss,UserStakememoryuserStake, ) =getRewards(117:msg.sender,118:term119:        );120:121:require(122:lastGaugeLoss!=block.timestamp,123:"SurplusGuildMinter: loss in block"124:        );125:require(amount>=MIN_STAKE,"SurplusGuildMinter: min stake");
The above code illustrates the only validation checks that are performed in thisstakefunction. As long as the user is not attempting to stake into a gauge in the same block that the gauge experienced a loss, and the user is staking at least1e18, the user’sstakeposition will be initialized (the user will be allowed to stake theirCredit):
SurplusGuildMinter.sol#L114-L125
139:userStake=UserStake({140:stakeTime:SafeCastLib.safeCastTo48(block.timestamp),141:lastGaugeLoss:SafeCastLib.safeCastTo48(lastGaugeLoss),142:profitIndex:SafeCastLib.safeCastTo160(143:ProfitManager(profitManager).userGaugeProfitIndex(144:address(this),145:term146:                )147:            ),148:credit:userStake.credit+SafeCastLib.safeCastTo128(amount),149:guild:userStake.guild+SafeCastLib.safeCastTo128(guildAmount)150:        });151:_stakes[msg.sender][term] =userStake;
The user would naturally perform the next actions: They can callSurplusGuildMinter::getRewardswhen they want to receive rewards and they can callSurplusGuildMinter::unstakewhen they want to unstake from their position, i.e. withdraw their depositedCredit. It is important to note that when theunstakefunction is called, similar to thestakefunction, thegetRewardsfunction will first be invoked. As we previously observed, thegetRewardsfunction will consider the userslashedif the gauge had previously experienced any loss in its history. Therefore, after a user has staked, any call togetRewardswill result in the following logic to execute:
SurplusGuildMinter.sol#L274-L289
274:if(slashed) {275:emitUnstake(block.timestamp,term,uint256(userStake.credit));276:userStake=UserStake({277:stakeTime:uint48(0),278:lastGaugeLoss:uint48(0),279:profitIndex:uint160(0),280:credit:uint128(0),281:guild:uint128(0)282:            });283:updateState=true;284:        }285:286:// store the updated stake, if needed287:if(updateState) {288:_stakes[user][term] =userStake;289:        }
As we can see above, when a user callsgetRewardsorunstakeafter staking into a gauge that has experienced a loss sometime in its history, the user’sstakeposition will be deleted (slashed). If the user is attempting to unstake then the execution flow will continue in theunstakefunction:
SurplusGuildMinter.sol#L158-L166C25
158:functionunstake(addressterm,uint256amount)external{159:// apply pending rewards160:        (,UserStakememoryuserStake,boolslashed) =getRewards(161:msg.sender,162:term163:        );164:165:// if the user has been slashed, there is nothing to do166:if(slashed)return;
Since the user has been consideredslashed, the execution will return on line 166 and the user will not be allowed to withdraw their stakedCredit.
I would also like to note that the user will still have a chance to receive someearned Creditafter the gauge experiences a profit. However, since the user is consideredslashed, they will not be given anyguild rewards:
SurplusGuildMinter.sol#L247-L264
247:uint256deltaIndex=_profitIndex-_userProfitIndex;248:249:if(deltaIndex!=0) {250:uint256creditReward= (uint256(userStake.guild) *deltaIndex) /251:1e18;252:uint256guildReward= (creditReward*rewardRatio) /1e18;253:if(slashed) {254:guildReward=0;255:            }256:257:// forward rewards to user258:if(guildReward!=0) {259:RateLimitedMinter(rlgm).mint(user,guildReward);260:emitGuildReward(block.timestamp,user,guildReward);261:            }262:if(creditReward!=0) {263:CreditToken(credit).transfer(user,creditReward);264:            }
As seen above, if the user is eligible to claim rewards (the gauge they staked into has experienced a profit), then they will be sentcreditRewardofCredit. However, since they are consideredslashed, theirguildRewardis set to0. This scenario will only occur if no one callsgetRewardfor this user before the gauge generates a profit. If any call togetRewardfor this user is invoked before that, the user will not be able to receive any rewards and in both situations they will lose their stakedCredit.
An additional, lesser effect, is that theGuildwhich was minted on behalf of the user who staked will not be unstaked from the gauge, it will not be burned, and theRateLimitedGuildMinter’s buffer will not be replenished. I.e. the following code from theunstakefunction will not execute:
SurplusGuildMinter.sol#L205-L208
205:// burn GUILD206:GuildToken(guild).decrementGauge(term,guildAmount);207:RateLimitedMinter(rlgm).replenishBuffer(guildAmount);208:GuildToken(guild).burn(guildAmount);
Impact
User’s utilizing theSurplusGuildMinterto stake into a gauge, which has previously experienced a loss sometime in its history, can be immediately slashed. This will result in the user losing out on any guild rewards (if they were staked into the gauge while it experienced a profit), but most importantly this will result in the user losing their staked principle (Credit).
To further illustrate the impact of this vulnerability, lets consider the following scenario:
A gauge experiences a loss. The gauge is then off-boarded. The gauge is re-onboarded in the future. A user stakes into this gauge via theSurplusGuildMinter. A malicious actor immediately callsgetRewards(gauge, user)and the user isslashedand loses their stakedCredit.
Proof of Concept
The following test describes the main impact highlighted above, in which a user stakes into a previously lossy gauge and is immediately slashed:
Place the following test inside oftest/unit/loan/SurplusGuildMinter.t.sol:
functiontestUserImmediatelySlashed()public{// initial stateassertEq(guild.getGaugeWeight(term),50e18);// add credit to surplus buffercredit.mint(address(this),100e18);credit.approve(address(profitManager),50e18);profitManager.donateToSurplusBuffer(50e18);// term incurs lossprofitManager.notifyPnL(term, -50e18);assertEq(guild.lastGaugeLoss(term),block.timestamp);// term offboardedguild.removeGauge(term);assertEq(guild.isGauge(term),false);// time passes and term is re-onboardedvm.roll(block.number+100);vm.warp(block.timestamp+ (100*13));guild.addGauge(1,term);assertEq(guild.isGauge(term),true);// user stakes into term directlyaddressuser=address(0x01010101);guild.mint(user,10e18);vm.startPrank(user);guild.incrementGauge(term,10e18);vm.stopPrank();// user can un-stake from termvm.startPrank(user);guild.decrementGauge(term,10e18);vm.stopPrank();// user stakes into term via sgmcredit.mint(user,10e18);vm.startPrank(user);credit.approve(address(sgm),10e18);sgm.stake(term,10e18);vm.stopPrank();// check after-stake stateassertEq(credit.balanceOf(user),0);assertEq(profitManager.termSurplusBuffer(term),10e18);assertEq(guild.getGaugeWeight(term),70e18);SurplusGuildMinter.UserStakememoryuserStake=sgm.getUserStake(user,term);assertEq(uint256(userStake.stakeTime),block.timestamp);assertEq(userStake.lastGaugeLoss,guild.lastGaugeLoss(term));assertEq(userStake.profitIndex,0);assertEq(userStake.credit,10e18);assertEq(userStake.guild,20e18);// malicious actor is aware of bug and slashes the user's stake immediately, despite no loss occurring in the gaugesgm.getRewards(user,term);// check after-getReward state (user was slashed even though no loss has occurred since term was re-onboarded)assertEq(credit.balanceOf(user),0);assertEq(profitManager.termSurplusBuffer(term),10e18);assertEq(guild.getGaugeWeight(term),70e18);userStake=sgm.getUserStake(user,term);assertEq(uint256(userStake.stakeTime),0);assertEq(userStake.lastGaugeLoss,0);assertEq(userStake.profitIndex,0);assertEq(userStake.credit,0);assertEq(userStake.guild,0);// user tries to unstake but will not receive anythinguint256userBalanceBefore=credit.balanceOf(user);vm.startPrank(user);sgm.unstake(term,10e18);vm.stopPrank();uint256userAfterBalance=credit.balanceOf(user);assertEq(userBalanceBefore,0);assertEq(userAfterBalance,0);}
Recommended Mitigation Steps
Similar to how theGuildToken::incrementGaugefunction initializes a user’slastGaugeLossAppliedvalue, theSurplusGuildMintershould initialize a user’suserStake.lastGaugeLosstoblock.timestamp. It should then compare thelastGaugeLossto the user’s storeduserStake.lastGaugeLossinstead of comparing thelastGaugeLossto a freshly initializeduserStakememory struct, whose fields are all0.
eswak (Ethereum Credit Guild) confirmed via duplicate issue #1164
Note: For full discussion, seehere.