[H-31] On Ulysses omnichain -RetrieveDepositmight never be able to trigger theFallbackfunction
Submitted byzzebra83, also found byxuwinnie
The purpose of theretrieveDepositfunction is to enable a user to be able to redeem a deposit they entered into the system. The mechanism works based on the promise that this function will be able to forcefully make the root bridge agent trigger thefallbackfunction.
if (!executionHistory[fromChainId][uint32(bytes4(data[1:5]))]) {//Toggle Nonce as executedexecutionHistory[fromChainId][nonce] = true;//Retry failed fallback(success, result) = (false, "")
By returning false, theanycallcontract will attempt to trigger thefallbackfunction in the branch bridge, which would in turn set the status of the deposit as failed. The user can then redeem their deposit because its status is now failed.
function redeemDeposit(uint32 _depositNonce) external lock {//Update Depositif (getDeposit[_depositNonce].status != DepositStatus.Failed) {revert DepositRedeemUnavailable();}
The problem is, according to how theanycallprotocol works, it is completely feasible that the execution in the root bridge completes successfully, but thefallbackin the branch might still fail to execute.
uint256 internal constant MIN_FALLBACK_RESERVE = 185_000; // 100_000 for anycall + 85_000 fallback execution overhead
For example, theanycallto the root bridge might succeed due to enough gas stipend, while thefallbackexecution fails due to a low gas stipend.
If this is the case, then the deposit nonce would be stored in theexecutionHistoryduring the initial call, so when theretrievedepositcall is made, it would think that the transaction is already completed, which would trigger this block instead:
_forceRevert();//Return true to avoid triggering anyFallback in case of `_forceRevert()` failurereturn (true, "already executed tx");
The impact of this, is that if the deposit transaction is recorded in the root side as completed. A user will never be able to use theretrievedepositfunction to redeem their deposit from the system.
Proof of Concept
function testRetrieveDeposit() public {//Set uptestAddLocalTokenArbitrum();//Prepare databytes memory packedData;{Multicall2.Call[] memory calls = new Multicall2.Call[](1);//Mock actioncalls[0] = Multicall2.Call({target: 0x0000000000000000000000000000000000000000, callData:   ""});//Output ParamsOutputParams memory outputParams = OutputParams(address(this), newAvaxAssetGlobalAddress, 150 ether, 0);//RLP Encode Calldata Call with no gas to bridge out and we top up.bytes memory data = abi.encode(calls, outputParams, ftmChainId);//Pack FuncIdpackedData = abi.encodePacked(bytes1(0x02), data);}address _user = address(this);//Get some gas.hevm.deal(_user, 100 ether);hevm.deal(address(ftmPort), 1 ether);//assure there is enough balance for mock actionhevm.prank(address(rootPort));ERC20hTokenRoot(newAvaxAssetGlobalAddress).mint(address(rootPort), 50 ether, rootChainId);hevm.prank(address(avaxPort));ERC20hTokenBranch(avaxMockAssethToken).mint(_user, 50 ether);//Mint Underlying Token.avaxMockAssetToken.mint(_user, 100 ether);//Prepare deposit info//Prepare deposit infoDepositParams memory depositParams = DepositParams({hToken: address(avaxMockAssethToken),token: address(avaxMockAssetToken),amount: 150 ether,deposit: 100 ether,toChain: ftmChainId,depositNonce: 1,depositedGas: 1 ether});DepositInput memory depositInput = DepositInput({hToken: address(avaxMockAssethToken),token: address(avaxMockAssetToken),amount: 150 ether,deposit: 100 ether,toChain: ftmChainId});// Encode AnyFallback messagebytes memory anyFallbackData = abi.encodePacked(bytes1(0x01),depositParams.depositNonce,depositParams.hToken,depositParams.token,depositParams.amount,depositParams.deposit,depositParams.toChain,bytes("testdata"),depositParams.depositedGas,depositParams.depositedGas / 2);console2.log("BALANCE BEFORE:");console2.log("User avaxMockAssetToken Balance:", MockERC20(avaxMockAssetToken).balanceOf(_user));console2.log("User avaxMockAssethToken Balance:",  MockERC20(avaxMockAssethToken).balanceOf(_user));require(avaxMockAssetToken.balanceOf(address(avaxPort)) == 0, "balance of port is not zero");//Call Deposit functionavaxMockAssetToken.approve(address(avaxPort), 100 ether);ERC20hTokenRoot(avaxMockAssethToken).approve(address(avaxPort), 50 ether);avaxMulticallBridgeAgent.callOutSignedAndBridge{value: 50 ether}(packedData, depositInput, 0.5 ether);;avaxMulticallBridgeAgent.retrieveDeposit{value: 1 ether}(depositParams.depositNonce);// fallback is not triggered.// @audit Redeem Deposit, will fail with   DepositRedeemUnavailable()avaxMulticallBridgeAgent.redeemDeposit(depositParams.depositNonce);}
Recommended Mitigation Steps
Make the root bridge return(false, ""), regardless of whether the transaction linked to the original deposit was completed or not.
/// DEPOSIT FLAG: 8 (retrieveDeposit)else if (flag == 0x08) {(success, result) = (false, "");
To avoid also spamming the usage of theretrievedepositfunction, it is advisable to add a check in theretrieveDepositfunction to see whether the deposit still exists. It doesnâ€™t make sense to try and retrieve a deposit that has already been redeemed.
function retrieveDeposit(uint32 _depositNonce) external payable lock requiresFallbackGas {address depositOwner = getDeposit[_depositNonce].owner;if (depositOwner == address(0)) {revert RetrieveDepositUnavailable();}
0xBugsy (Maia) confirmed and commented:
This is true, but the mitigation would introduce a race condition allowing users to redeem and retry the same deposit. As such, we will introduce aredemptionHistoryin the root, allowing deposits with redemption and execution set to true to be re-retrieved forfallbackbut not executed again in the root.
0xBugsy (Maia) commented:
For further context, the issue that is being described is that in some cases a retrieve may fail on the branch, due to a lack of gas for branch execution. At that point, the deposit the would have been given has been executed in the root blocking re-retrieval of said deposit.CallingretryDepositshould only be allowed until the first successfulanyFallbackis triggered andretrieveDepositshould always be callable.In addition, in your example when executing the initial request that fails, we should always set theexecutionHistoryto true since afallbackwill be in fact triggered (avoids double spending). But we should also set the deposit as retrievable, via a mapping (or save a uint8 instead of bool for deposit state). And when runninganyExecutein Root for a deposit retrieval, we simply check if the deposit is retrievable; meaning the deposit has never run successfully without triggeringanyFallback.In short, the retry, retrieve and redeem pattern works as expected. But in order to accommodate for off-cases like the one described in this issue,retrieveDepositshould be callable indefinite times for a deposit that never executed successfully in the root, since whenever the deposit is redeemed from the branch it will be deleted.
0xLightt (Maia) commented:
Addressedhere.