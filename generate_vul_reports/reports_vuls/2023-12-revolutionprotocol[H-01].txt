[H-01] Incorrect amounts of ETH are transferred to the DAO treasury inERC20TokenEmitter::buyToken(), causing a value leak in every transaction
Submitted byosmanozdemir1, also found byshaka,SovaSlava,KupiaSec,MrPotatoMagic,ast3ros,BARW,0xDING99YA,0xCiphky,bart1e,ktg,AS,SpicyMeatball,hakymulla,plasmablocks,Abdessamed,0xlemon,twcctop,0xluckhu, andn1punp
While users buying governance tokens withERC20TokenEmitter::buyTokenfunction, some portion of the provided ETH is reserved for creators according to thecreatorRateBps.
A part of this creator’s reserved ETH is directly sent to the creators according toentropyRateBps, and the remaining part is used to buy governance tokens for creators.
That remaining part, which is used to buy governance tokens, is never sent to the DAO treasury. It is locked in theERC20Emittercontract, causing value leaks for treasury in everybuyTokenfunction call.
https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/ERC20TokenEmitter.sol#L190C1-L198C10
functionbuyToken(address[]calldataaddresses,uint[]calldatabasisPointSplits,ProtocolRewardAddressescalldataprotocolRewardsRecipients)publicpayablenonReentrantwhenNotPausedreturns(uint256tokensSoldWad) {// ...// Get value left after protocol rewardsuint256msgValueRemaining=_handleRewardsAndGetValueToSend(msg.value,protocolRewardsRecipients.builder,protocolRewardsRecipients.purchaseReferral,protocolRewardsRecipients.deployer);//Share of purchase amount to send to treasuryuint256toPayTreasury= (msgValueRemaining* (10_000-creatorRateBps)) /10_000;//Share of purchase amount to reserve for creators//Ether directly sent to creatorsuint256creatorDirectPayment= ((msgValueRemaining-toPayTreasury) *entropyRateBps) /10_000;//Tokens to emit to creatorsinttotalTokensForCreators= ((msgValueRemaining-toPayTreasury) -creatorDirectPayment) >0?getTokenQuoteForEther((msgValueRemaining-toPayTreasury) -creatorDirectPayment):int(0);// Tokens to emit to buyersinttotalTokensForBuyers=toPayTreasury>0?getTokenQuoteForEther(toPayTreasury) :int(0);//Transfer ETH to treasury and update emittedemittedTokenWad+=totalTokensForBuyers;if(totalTokensForCreators>0)emittedTokenWad+=totalTokensForCreators;//Deposit funds to treasury-->     (boolsuccess, ) =treasury.call{ value:toPayTreasury}(newbytes(0));//@audit-issue Treasury is not paid correctly. Only the buyers share is sent. Creators share to buy governance tokens are not sent to treasuryrequire(success,"Transfer failed.");//@audit `creators total share` - `creatorDirectPayment` should also be sent to treasury. ==> Which is "((msgValueRemaining - toPayTreasury) - creatorDirectPayment)"//Transfer ETH to creatorsif(creatorDirectPayment>0) {(success, ) =creatorsAddress.call{ value:creatorDirectPayment}(newbytes(0));require(success,"Transfer failed.");}// ... rest of the code}
In the code above:
toPayTreasuryis the buyer’s portion of the sent ether.(msgValueRemaining - toPayTreasury)is the creator’s portion of the sent ether.((msgValueRemaining - toPayTreasury) - creatorDirectPayment)is the remaining part of the creator’s share after direct payment(which is used to buy the governance token).
As we can see above, the part that is used to buy governance tokens is not sent to the treasury. Only the buyer’s portion is sent.
Impact
DAO treasury is not properly paid even though the corresponding governance tokens are minted.EverybuyTokentransaction will cause a value leak to the DAO treasury. The leaked ETH amounts are stuck in theERC20TokenEmittercontract.
Proof of Concept
Coded PoC
You can use the protocol’s own test suite to run this PoC.
-Copy and paste the snippet below into theERC20TokenEmitter.t.soltest file.-Run it withforge test --match-test testBuyToken_ValueLeak -vvv
functiontestBuyToken_ValueLeak()public{// Set creator and entropy rates.// Creator rate will be 10% and entropy rate will be 40%uint256creatorRate=1000;uint256entropyRate=5000;vm.startPrank(address(dao));erc20TokenEmitter.setCreatorRateBps(creatorRate);erc20TokenEmitter.setEntropyRateBps(entropyRate);// Check dao treasury and erc20TokenEmitter balances. Balance of both of them should be 0.uint256treasuryETHBalance_BeforePurchase=address(erc20TokenEmitter.treasury()).balance;uint256emitterContractETHBalance_BeforePurchase=address(erc20TokenEmitter).balance;assertEq(treasuryETHBalance_BeforePurchase,0);assertEq(emitterContractETHBalance_BeforePurchase,0);// Create token purchase parametersaddress[]memoryrecipients=newaddress[](1);recipients[0] =address(1);uint256[]memorybps=newuint256[](1);bps[0] =10_000;// Give some ETH to user and buy governance token.vm.startPrank(address(0));vm.deal(address(0),100000ether);erc20TokenEmitter.buyToken{ value:100ether}(recipients,bps,IERC20TokenEmitter.ProtocolRewardAddresses({builder:address(0),purchaseReferral:address(0),deployer:address(0)}));// User bought 100 ether worth of tokens.// Normally with 2.5% fixed protocol rewards, 10% creator share and 50% entropy share://  ->  2.5 ether is protocol rewards.//  ->  87.75 ether is buyer share (90% of the 97.5)//  ->  9.75 of the ether is creators share//          - 4.875 ether directly sent to creators//          - 4.875 ether should be used to buy governance token and should be sent to the treasury.// However, the 4.875 ether is never sent to the treasury even though it is used to buy governance tokens. It is stuck in the Emitter contract.// Check balances after purchase.uint256treasuryETHBalance_AfterPurchase=address(erc20TokenEmitter.treasury()).balance;uint256emitterContractETHBalance_AfterPurchase=address(erc20TokenEmitter).balance;uint256creatorETHBalance_AfterPurchase=address(erc20TokenEmitter.creatorsAddress()).balance;// Creator direct payment amount is 4.875 as expectedassertEq(creatorETHBalance_AfterPurchase,4.875ether);// Dao treasury has 87.75 ether instead of 92.625 ether.// 4.875 ether that is used to buy governance tokens for creators is never sent to treasury and still in the emitter contract.assertEq(treasuryETHBalance_AfterPurchase,87.75ether);assertEq(emitterContractETHBalance_AfterPurchase,4.875ether);}
Results after running the test:
Running1testfortest/token-emitter/ERC20TokenEmitter.t.sol:ERC20TokenEmitterTest[PASS]testBuyToken_ValueLeak() (gas:459490)Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 11.25msRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1totaltests)
Tools Used
Foundry
Recommended Mitigation Steps
I would recommend transferring the remaining ETH used to buy governance tokens to the treasury.
+       uint256 creatorsEthAfterDirectPayment = ((msgValueRemaining - toPayTreasury) - creatorDirectPayment);//Deposit funds to treasury-       (bool success, ) = treasury.call{ value: toPayTreasury }(new bytes(0));+       (bool success, ) = treasury.call{ value: toPayTreasury + creatorsEthAfterDirectPayment }(new bytes(0));require(success, "Transfer failed.");
rocketman-21 (Revolution) confirmed