[H-06] Discrepency in the Uniswap V3 position price calculation because of decimals
Submitted byFranfran, also found by__141345__andpoirots
When the squared root of the Uniswap V3 position is calculated from the_getOracleData()function, the price may return a very high number (in the case that the token1 decimals are strictly superior to the token0 decimals). See:https://github.com/code-423n4/2022-11-paraspace/blob/main/paraspace-core/contracts/misc/UniswapV3OracleWrapper.sol#L249-L260
The reason is that at the denominator, the1E9(10**9) value is hard-coded, but should take into account the delta between both decimals.As a result, in the case oftoken1Decimal > token0Decimal, thegetAmountsForLiquidity()is going to return a huge value for the amount of token0 and token1 as the user position liquidity.
ThegetTokenPrice(), using this amount of liquidity tocalculate the token priceis as its turn going to return a huge value.
Proof of Concept
This POC demonstrates in which case the returned squared root price of the position is over inflated
// SPDX-License-Identifier: UNLISENCEDpragmasolidity0.8.10;import{SqrtLib}from"../contracts/dependencies/math/SqrtLib.sol";import"forge-std/Test.sol";contractAuditisTest{functiontestSqrtPriceX96()public{// okuint160price1=getSqrtPriceX96(1e18,5*1e18,18,18);// okuint160price2=getSqrtPriceX96(1e18,5*1e18,18,9);// Has an over-inflated squared root price by 9 magnitudes as token0Decimal < token1Decimaluint160price3=getSqrtPriceX96(1e18,5*1e18,9,18);}functiongetSqrtPriceX96(uint256token0Price,uint256token1Price,uint256token0Decimal,uint256token1Decimal)privateviewreturns(uint160sqrtPriceX96) {if(oracleData.token1Decimal==oracleData.token0Decimal) {// multiply by 10^18 then divide by 10^9 to preserve price in weisqrtPriceX96=uint160((SqrtLib.sqrt(((token0Price* (10**18)) / (token1Price))) *2**96) /1E9);}elseif(token1Decimal>token0Decimal) {// multiple by 10^(decimalB - decimalA) to preserve price in weisqrtPriceX96=uint160((SqrtLib.sqrt((token0Price* (10**(18+token1Decimal-token0Decimal))) /(token1Price)) *2**96) /1E9);}else{// multiple by 10^(decimalA - decimalB) to preserve price in wei then divide by the same numbersqrtPriceX96=uint160((SqrtLib.sqrt((token0Price* (10**(18+token0Decimal-token1Decimal))) /(token1Price)) *2**96) /10**(9+token0Decimal-token1Decimal));}}}
Recommended Mitigation Steps
if(oracleData.token1Decimal==oracleData.token0Decimal) {// multiply by 10^18 then divide by 10^9 to preserve price in weioracleData.sqrtPriceX96=uint160((SqrtLib.sqrt(((oracleData.token0Price* (10**18)) /(oracleData.token1Price))) *2**96) /1E9);}elseif(oracleData.token1Decimal>oracleData.token0Decimal) {// multiple by 10^(decimalB - decimalA) to preserve price in weioracleData.sqrtPriceX96=uint160((SqrtLib.sqrt((oracleData.token0Price*(10**(18+oracleData.token1Decimal-oracleData.token0Decimal))) /(oracleData.token1Price)) *2**96) /10**(9+oracleData.token1Decimal-oracleData.token0Decimal));}else{// multiple by 10^(decimalA - decimalB) to preserve price in wei then divide by the same numberoracleData.sqrtPriceX96=uint160((SqrtLib.sqrt((oracleData.token0Price*(10**(18+oracleData.token0Decimal-oracleData.token1Decimal))) /(oracleData.token1Price)) *2**96) /10**(9+oracleData.token0Decimal-oracleData.token1Decimal));}