[H-17] Second per liquidity inside could overflowuint256causing the LP position to be locked inUniswapV3Staker
Submitted byminhquanym
UniswapV3Stakerdepends on the second per liquidity inside values from theUniswap V3 Poolto calculate the amount of rewards a position should receive. This value represents the amount of second liquidity inside a tick range that is “active” (tickLower < currentTick < tickUpper). The second per liquidity inside a specific tick range is supposed to always increase over time.
In theRewardMathlibrary, the seconds inside are calculated by taking the current timestamp value and subtracting the value at the moment the position is staked. Since this value increases over time, it should be normal. Additionally, this implementation is similar toUniswap Team’s implementation.
functioncomputeBoostedSecondsInsideX128(uint256stakedDuration,uint128liquidity,uint128boostAmount,uint128boostTotalSupply,uint160secondsPerLiquidityInsideInitialX128,uint160secondsPerLiquidityInsideX128)internalpurereturns(uint160boostedSecondsInsideX128) {// this operation is safe, as the difference cannot be greater than 1/stake.liquidityuint160secondsInsideX128= (secondsPerLiquidityInsideX128-secondsPerLiquidityInsideInitialX128) *liquidity;// @audit secondPerLiquidityInsideX128 could smaller than secondsPerLiquidityInsideInitialX128...}
However, even though the second per liquidity inside value increases over time, it could overflowuint256, resulting in the calculation reverting. WhencomputeBoostedSecondsInsideX128()reverts, function_unstake()will also revert, locking the LP position in the contract forever.
Proof of Concept
Consider the value of the second per liquidity in three different timestamps:t1 < t2 < t3
secondPerLiquidity_t1= -10=2**256-10secondPerLiquidity_t2=100secondPerLiquidity_t3=300
As we can see, its value always increases over time, but the initial value could be smaller than 0. When calculatingcomputeBoostedSecondsInsideX128()for a period fromt1 -> t2, it will revert.
Additionally, as I mentioned earlier, this implementation is similar to the one from Uniswap team. However, please note that the Uniswap team used Solidity 0.7, which won’t revert on overflow and the formula works as expected while Maia uses Solidity 0.8.
For more information on how a tick is initialized, please refer tothis code
if(liquidityGrossBefore==0) {// by convention, we assume that all growth before a tick was initialized happened _below_ the tickif(tick<=tickCurrent) {info.feeGrowthOutside0X128=feeGrowthGlobal0X128;info.feeGrowthOutside1X128=feeGrowthGlobal1X128;info.secondsPerLiquidityOutsideX128=secondsPerLiquidityCumulativeX128;info.tickCumulativeOutside=tickCumulative;info.secondsOutside=time;}info.initialized=true;}
The second per liquidity inside a range that hastickLower < currentTick < tickUpperiscalculated as:
secondsPerLiquidityCumulativeX128-tickLower.secondsPerLiquidityOutsideX128-tickUpper.secondsPerLiquidityOutsideX128// If lower tick is just init,// Then: secondsPerLiquidityCumulativeX128 = tickLower.secondsPerLiquidityOutsideX128// And: tickUpper.secondsPerLiquidityOutsideX128 != 0// => Result will be overflow
Recommended Mitigation Steps
Consider using anuncheckedblock to calculate this value.
Assessed type
Under/Overflow
minhquanym (warden) commented:
I received permission to add the PoC from the judge.This is modified fromtestFullIncentiveNoBoost(). Please add this to the end ofUniswapV3StakerTest.t.sol.There are comments describing each step to simulate the issues in the code:structSwapCallbackData{boolzeroForOne;}functionuniswapV3SwapCallback(int256amount0,int256amount1,bytescalldata_data)external{require(msg.sender==address(pool),"FP");require(amount0>0||amount1>0,"LEZ");// swaps entirely within 0-liquidity regions are not supportedSwapCallbackDatamemorydata=abi.decode(_data, (SwapCallbackData));boolzeroForOne=data.zeroForOne;if(zeroForOne) {token0.mint(address(this),uint256(amount0));token0.transfer(msg.sender,uint256(amount0));}else{token1.mint(address(this),uint256(amount1));token1.transfer(msg.sender,uint256(amount1));}}// Test minting a position and transferring it to Uniswap V3 Staker, after creating a gaugefunctiontestAudit1()public{// Create a Uniswap V3 pool(pool,poolContract) =UniswapV3Assistant.createPool(uniswapV3Factory,address(token0),address(token1),poolFee);// Initialize 1:1 0.3% fee poolUniswapV3Assistant.initializeBalanced(poolContract);hevm.warp(block.timestamp+100);// 3338502497096994491500 to give 1 ether per token with 0.3% fee and -60,60 ticksuint256_tokenId0=newNFT(-180,180,3338502497096994491500);uint256_tokenId1=newNFT(-60,60,3338502497096994491500);hevm.warp(block.timestamp+100);// @audit Step 1: Swap to make currentTick go to (60, 180) rangeuint256amountSpecified=30ether;boolzeroForOne=false;pool.swap(address(this),zeroForOne,int256(amountSpecified),1461446703485210103287273052203988822378723970342-1,// MAX_SQRT_RATIO - 1abi.encode(SwapCallbackData({zeroForOne:zeroForOne})));(,int24_currentTick, , , , ,) =pool.slot0();console2.logInt(int256(_currentTick));hevm.warp(block.timestamp+100);// @audit Step 2: Swap back to make currentTick go back to (-60, 60) rangezeroForOne=true;pool.swap(address(this),zeroForOne,int256(amountSpecified),4295128739+1,// MIN_SQRT_RATIO + 1abi.encode(SwapCallbackData({zeroForOne:zeroForOne})));(,_currentTick, , , , ,) =pool.slot0();console2.logInt(int256(_currentTick));hevm.warp(block.timestamp+100);// @audit Step 3: Create normal Incentiveuint256minWidth=10;// Create a gaugegauge=createGaugeAndAddToGaugeBoost(pool,minWidth);// Create a Uniswap V3 Staker incentivekey=IUniswapV3Staker.IncentiveKey({pool:pool,startTime:IncentiveTime.computeEnd(block.timestamp)});uint256rewardAmount=1000ether;rewardToken.mint(address(this),rewardAmount);rewardToken.approve(address(uniswapV3Staker),rewardAmount);createIncentive(key,rewardAmount);// @audit Step 4: Now we have secondsPerLiquidity of tick 60 is not equal to 0.//        We just need to create a position with range [-120, 60],//        then secondsPerLiquidityInside of this position will be overflowhevm.warp(key.startTime+1);int24tickLower= -120;int24tickUpper=60;uint256tokenId=newNFT(tickLower,tickUpper,3338502497096994491500);(,uint160secondsPerLiquidityInsideX128,) =pool.snapshotCumulativesInside(tickLower,tickUpper);console2.logUint(uint256(secondsPerLiquidityInsideX128));// @audit Step 5: Stake the position// Transfer and stake the position in Uniswap V3 StakernonfungiblePositionManager.safeTransferFrom(address(this),address(uniswapV3Staker),tokenId);(addressowner,,,uint256stakedTimestamp) =uniswapV3Staker.deposits(tokenId);// @audit Step 6: Increase time to make `secondsPerLiquidity` go from negative to positive value//        Then `unstakeToken` will reverthevm.warp(block.timestamp+5weeks);(,secondsPerLiquidityInsideX128,) =pool.snapshotCumulativesInside(tickLower,tickUpper);console2.logUint(uint256(secondsPerLiquidityInsideX128));uniswapV3Staker.unstakeToken(tokenId);}
0xLightt (Maia) confirmed
0xLightt (Maia) commented:
Addressedhere.