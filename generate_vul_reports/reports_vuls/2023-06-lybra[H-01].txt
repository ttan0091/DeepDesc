[H-01] There is a vulnerability in theexecuteFlashloanfunction of thePeUSDMainnetcontract. Hackers can use this vulnerability to burn other people’s eUSD token balance without permission
Submitted byNeon2835, also found byMohammedRizwan,Arz,DedOhWale,0xcm,0xRobocop,azhar,HE1M,zaevlad, andkankodu
Lines of code
https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/token/PeUSDMainnetStableVision.sol#L129-L139
https://github.com/code-423n4/2023-06-lybra/blob/7b73ef2fbb542b569e182d9abf79be643ca883ee/contracts/lybra/token/EUSD.sol#L228-L230
Impact
TheexecuteFlashloanfunction of thePeUSDMainnetcontract is used to provide users with the flash loan function. There is a loophole in the logic and hackers can use this loophole to burn other people’s eUSD token balance without permission.
Proof of Concept
Since the parameterFlashBorrower receiverof theexecuteFlashloanfunction can be designated as anyone, the flash loan system will charge a certain percentage of the loan fee (up to 10%) toreceiverfor each flash loan. The code is as follows:
EUSD.burnShares(address(receiver), burnShare);
When a hacker maliciously initiates a flash loan for areceivercontract, and the value of theeusdAmountparameter passed in is large enough, thereceiverwill be deducted a large amount of loan fees; the hacker can burn a large amount of other people’s eUSD without permissioning the amount.
Let us analyze the design logic of the system itself step by step for discussion:
The flashloan fee of thePeUSDMainnetcontract is collected by calling theburnSharesfunction of theEUSDcontract. Continue to read the code to find that theburnSharesfunction of theEUSDcontract has a very criticalmodifier onlyMintVaultcondition Judgment, so it is obvious that thePeUSDMainnetcontract is the minter role of theEUSDcontract (otherwise it will not be able to charge the flashloan fee).Usually, when thetransferFromfunction is called, the ERC20 token needs to be approved by the spender before it can be used. But thetransferFromfunction in theEUSDcontract is implemented like this:
function transferFrom(address from, address to, uint256 amount) public returns (bool) {address spender = _msgSender();if (!configurator. mintVault(spender)) {_spendAllowance(from, spender, amount);}_transfer(from, to, amount);return true;}
The above code indicates that the miner of EUSD can calltransferFromarbitrarily, without the user callingincreaseAllowancefor approval. ThePeUSDMainnetcontract is the minter of theEUSDcontract, so line 133 of thePeUSDMainnetcontract code:bool success = EUSD.transferFrom(address(receiver), address(this), EUSD.getMintedEUSDByShares(shareAmount));can be executed without user approval.
In line 132 of theexecuteFlashloanfunction of thePeUSDMainnetcontract:receiver.onFlashLoan(shareAmount, data);, if thereceiverdoes not implement theonFlashLoanmethod, the EVM will revert and the hacker will not be able to maliciously execute the attack. However, if the receiver contract simply declares thefallback()function, or itsfallback()logic does not have a very robust judgment, then line 132 of the code can be easily bypassed. So is there really such a contract that just satisfies this condition? The answer is yes, for example this address:0x32034276343de43844993979e5384d4b7e030934(etherscan:https://etherscan.io/address/0x32034276343de43844993979e5384d4b7e030934#code), has 200,000 eUSD tokens and declared thefallbackfunction, its source code excerpts are as follows:
contractGnosisSafeProxy{// singleton always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.// To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`addressinternalsingleton;/// @dev Constructor function sets address of singleton contract./// @param _singleton Singleton address.constructor(address_singleton) {require(_singleton!=address(0),"Invalid singleton address provided");singleton=_singleton;}/// @dev Fallback function forwards all transactions and returns all received return data.fallback()externalpayable{// solhint-disable-next-line no-inline-assemblyassembly{let_singleton:=and(sload(0),0xffffffffffffffffffffffffffffffffffffffff)// 0xa619486e == keccak("masterCopy()"). The value is right padded to 32-bytes with 0sifeq(calldataload(0),0xa619486e00000000000000000000000000000000000000000000000000000000) {mstore(0,_singleton)return(0,0x20)}calldatacopy(0,0,calldatasize())letsuccess:=delegatecall(gas(),_singleton,0,calldatasize(),0,0)returndatacopy(0,0,returndatasize())ifeq(success,0) {revert(0,returndatasize())}return(0,returndatasize())}}}
Assuming that thePeUSDMainnetcontract flash loan fee rate is 5% at this time, the hacker maliciously calls theexecuteFlashloanfunction to initiate a flash loan with the address:0x32034276343de43844993979e5384d4b7e030934, the function parameteruint256 eusdAmount = 4_000_000, and the calculated loan fee  is4_000_000 * 5% = 200_000, the 200_000 eUSD balance of the address0x32034276343de43844993979e5384d4b7e030934will be maliciously burned by hackers!
The following is the forge test situation I simulated locally:
[PASS] testGnosisSafeProxy() (gas: 10044)Traces:[10044] AttackTest::testGnosisSafeProxy()â”œâ”€ [4844] GnosisSafeProxy::onFlashLoan()â”‚   â”œâ”€ [0] 0xd9Db270c1B5E3Bd161E8c8503c55cEABeE709552::onFlashLoan() [delegatecall]â”‚   â”‚   â””â”€ â† ()â”‚   â””â”€ â† ()â””â”€ â† ()Test result: ok. 1 passed; 0 failed; finished in 972.63Âµs
Thefallbackfunction of theGnosisSafeProxycontract is allowed to be called without revert.
Tools Used
Visual Studio Code
Foundry
Recommended Mitigation Steps
Optimize the flash loan logic of theexecuteFlashloanfunction of thePeUSDMainnetcontract, remove theFlashBorrower receiverparameter, and setreceivertomsg.sender; which means that a user can only initiate a flash loan for themselves.
LybraFinance confirmed