[H-01]TimeswapPair.sol#borrow()Improper implementation allows attacker to increasepool.state.zto a large value
Submitted by WatchPug
In the current implementation,borrow()takes a user input value ofzIncrease, while the actual collateral asset transferred in is calculated at L319, the state ofpool.state.zstill increased by the value of the userâ€™s input at L332.
Even though a large number ofzIncreasemeans that the user needs to add more collateral, the attacker can use a dust amountxDecrease(1 wei for example) so that the total collateral needed is rather small.
Plus, the attacker can alwayspay()the dust amount of loan to get back the rather large amount of collateral added.
https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/TimeswapPair.sol#L299-L338
functionborrow(uint256maturity,addressassetTo,addressdueTo,uint112xDecrease,uint112yIncrease,uint112zIncrease,bytescalldatadata)externaloverridelockreturns(uint256id,DuememorydueOut) {require(block.timestamp<maturity,'E202');require(assetTo!=address(0) &&dueTo!=address(0),'E201');require(assetTo!=address(this) &&dueTo!=address(this),'E204');require(xDecrease>0,'E205');Poolstoragepool=pools[maturity];require(pool.state.totalLiquidity>0,'E206');BorrowMath.check(pool.state,xDecrease,yIncrease,zIncrease,fee);dueOut.debt=BorrowMath.getDebt(maturity,xDecrease,yIncrease);dueOut.collateral=BorrowMath.getCollateral(maturity,pool.state,xDecrease,zIncrease);dueOut.startBlock=BlockNumber.get();Callback.borrow(collateral,dueOut.collateral,data);id=pool.dues[dueTo].insert(dueOut);pool.state.reserves.asset-=xDecrease;pool.state.reserves.collateral+=dueOut.collateral;pool.state.totalDebtCreated+=dueOut.debt;pool.state.x-=xDecrease;pool.state.y+=yIncrease;pool.state.z+=zIncrease;asset.safeTransfer(assetTo,xDecrease);emitSync(maturity,pool.state.x,pool.state.y,pool.state.z);emitBorrow(maturity,msg.sender,assetTo,dueTo,xDecrease,id,dueOut);}
https://github.com/code-423n4/2022-01-timeswap/blob/bf50d2a8bb93a5571f35f96bd74af54d9c92a210/Timeswap/Timeswap-V1-Core/contracts/libraries/BorrowMath.sol#L62-L79
functiongetCollateral(uint256maturity,IPair.Statememorystate,uint112xDecrease,uint112zIncrease)internalviewreturns(uint112collateralIn) {uint256_collateralIn=maturity;_collateralIn-=block.timestamp;_collateralIn*=zIncrease;_collateralIn=_collateralIn.shiftRightUp(25);uint256minimum=state.z;minimum*=xDecrease;uint256denominator=state.x;denominator-=xDecrease;minimum=minimum.divUp(denominator);_collateralIn+=minimum;collateralIn=_collateralIn.toUint112();}
Proof of Concept
Near the maturity time, the attacker can do the following:
borrow()a dust amount of assets (xDecrease= 1 wei) and increasepool.state.zto an extremely large value (20x of previousstate.zin our tests);pay()the loan and get back the collateral;lend()a regular amount ofstate.x, get a large amount of insurance token;burn()the insurance token and get a large portion of the collateral assets from the defaulted loans.
Recommendation
Consider makingpair.borrow()to beonlyConvenience, so thatzIncreasewill be a computed value (based onxDecreaseand current state) rather than a user input value.
Mathepreneur (Timeswap) confirmed