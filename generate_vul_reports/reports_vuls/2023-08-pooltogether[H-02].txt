[H-02]rngCompletefunction should only be called byrngAuctionRelayer
Submitted byAymen0909, also found byjosephdara,trachev,Arz, seerether (1,2),D_Auditor,shirochan,dirk_y,0xbepresent,Jorgect,bin2chen,0xStalin,ptsanev,T1MOH, andrvierdiiev
TherngCompletefunction is supposed to be called by the relayer to complete the Rng relay auction and send auction rewards to the recipient, but because the function doesnâ€™t have any access control it can be called by anyone, an attacker can call the function before the relayer and give a different_rewardRecipientand thus he can collect all the rewards and the true auction reward recipient will not get any.
Proof of Concept
The issue occurs in therngCompletefunction below:
functionrngComplete(uint256_randomNumber,uint256_rngCompletedAt,address_rewardRecipient,// @audit can set any addressuint32_sequenceId,AuctionResultcalldata_rngAuctionResult)externalreturns(bytes32) {// @audit should only be callable by rngAuctionRelayerif(_sequenceHasCompleted(_sequenceId))revertSequenceAlreadyCompleted();uint64_auctionElapsedSeconds=uint64(block.timestamp<_rngCompletedAt?0:block.timestamp-_rngCompletedAt);if(_auctionElapsedSeconds> (_auctionDurationSeconds-1))revertAuctionExpired();// Calculate the reward fraction and set the draw auction resultsUD2x18rewardFraction=_fractionalReward(_auctionElapsedSeconds);_auctionResults.rewardFraction=rewardFraction;_auctionResults.recipient=_rewardRecipient;_lastSequenceId=_sequenceId;AuctionResult[]memoryauctionResults=newAuctionResult[](2);auctionResults[0] =_rngAuctionResult;auctionResults[1] =AuctionResult({rewardFraction:rewardFraction,recipient:_rewardRecipient});uint32drawId=prizePool.closeDraw(_randomNumber);uint256futureReserve=prizePool.reserve() +prizePool.reserveForOpenDraw();uint256[]memory_rewards=RewardLib.rewards(auctionResults,futureReserve);emitRngSequenceCompleted(_sequenceId,drawId,_rewardRecipient,_auctionElapsedSeconds,rewardFraction);for(uint8i=0;i<_rewards.length;i++) {uint104_reward=uint104(_rewards[i]);if(_reward>0) {prizePool.withdrawReserve(auctionResults[i].recipient,_reward);emitAuctionRewardDistributed(_sequenceId,auctionResults[i].recipient,i,_reward);}}returnbytes32(uint(drawId));}
As we can see the function does not have any access control (modifier or check on the msg.sender), so any user can call it and you can also notice that the_rewardRecipient(the address that receives the rewards) is given as argument to the function and there is no check to verify that it is the correct auction reward receiver.
Hence an attacker can call the function before the relayer does, he can thus complete the auction and give another address for_rewardRecipientwhich will receive all the rewards.
The result is in the end that the true auction reward recipient will get his reward stolen by other users.
Recommended Mitigation Steps
Add a check in therngCompletefunction to make sure that only the relayer can call it, the function can be modified as follows:
functionrngComplete(uint256_randomNumber,uint256_rngCompletedAt,address_rewardRecipient,uint32_sequenceId,AuctionResultcalldata_rngAuctionResult)externalreturns(bytes32) {// @audit only called by rngAuctionRelayerif(msg.sender!=rngAuctionRelayer)revertNotRelayer();...}
Assessed type
Access Control
asselstine (PoolTogether) confirmed