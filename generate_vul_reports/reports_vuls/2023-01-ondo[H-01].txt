[H-01] Loss of user funds when completing CASH redemptions
Submitted byadriro, also found byminhquanym,minhquanym,zaskoh,cccz, andpeanuts
The functioncompleteRedemptionspresent in theCashManagercontract is used by the manager to complete redemptions requested by users and also to process refunds.
https://github.com/code-423n4/2023-01-ondo/blob/main/contracts/cash/CashManager.sol#L707-L727
functioncompleteRedemptions(address[]calldataredeemers,address[]calldatarefundees,uint256collateralAmountToDist,uint256epochToService,uint256fees)externaloverrideupdateEpochonlyRole(MANAGER_ADMIN) {_checkAddressesKYC(redeemers);_checkAddressesKYC(refundees);if(epochToService>=currentEpoch) {revertMustServicePastEpoch();}// Calculate the total quantity of shares tokens burned w/n an epochuint256refundedAmt=_processRefund(refundees,epochToService);uint256quantityBurned=redemptionInfoPerEpoch[epochToService].totalBurned-refundedAmt;uint256amountToDist=collateralAmountToDist-fees;_processRedemption(redeemers,amountToDist,quantityBurned,epochToService);collateral.safeTransferFrom(assetSender,feeRecipient,fees);emitRedemptionFeesCollected(feeRecipient,fees,epochToService);}
The total refunded amount that is returned from the internal call to_processRefundis then used to calculate the effective amount of CASH burned (redemptionInfoPerEpoch[epochToService].totalBurned - refundedAmt). This resulting value is then used to calculate how much each user should receive based on how much CASH they redeemed and the total amount that was burned.
The main issue here is that the refunded amount is not updated in thetotalBurnedstorage variable for the given epoch. Any subsequent call to this function won’t take into account refunds from previous calls.
Impact
If the manager completes the refunds and redemptions at different steps or stages for a given epoch, using multiple calls to thecompleteRedemptions, then any refunded amount won’t be considered in subsequent calls to the function.
Any redemption that is serviced in a call after a refund will be calculated using the total burned without subtracting the previous refunds. The functioncompleteRedemptionswill call the internal function_processRedemptionpassing the burned amount as thequantityBurnedargument, the value is calculated in line 755:
https://github.com/code-423n4/2023-01-ondo/blob/main/contracts/cash/CashManager.sol#L755
uint256collateralAmountDue= (amountToDist*cashAmountReturned) /quantityBurned;
This means that redemptions that are processed after one or more previous refunds will receive less collateral tokens even if they redeemed the same amount of CASH tokens (i.e. greaterquantityBurned, lesscollateralAmountDue), causing loss of funds for the users.
Proof of Concept
In the following test, Alice, Bob and Charlie request a redemption. The admin first callscompleteRedemptionsto process Alice’s request and refund Charlie. The admin then makes a second call tocompleteRedemptionsto process Bob’s request. Even though they redeemed the same amount of CASH (each200e18), Alice gets150e6tokens while Bob is sent~133e6.
contractTestAuditisBasicDeployment{functionsetUp()public{createDeploymentCash();// Grant Settervm.startPrank(managerAdmin);cashManager.grantRole(cashManager.SETTER_ADMIN(),address(this));cashManager.grantRole(cashManager.SETTER_ADMIN(),managerAdmin);vm.stopPrank();// Seed address with 1000000 USDCvm.prank(USDC_WHALE);USDC.transfer(address(this),INIT_BALANCE_USDC);}functiontest_CashManager_completeRedemptions_BadReedem()public{_setupKYCStatus();// Seed alice and bob with 200 cash tokens_seed(200e18,200e18,50e18);// Have alice request to withdraw 200 cash tokensvm.startPrank(alice);tokenProxied.approve(address(cashManager),200e18);cashManager.requestRedemption(200e18);vm.stopPrank();// Have bob request to withdraw 200 cash tokensvm.startPrank(bob);tokenProxied.approve(address(cashManager),200e18);cashManager.requestRedemption(200e18);vm.stopPrank();// Have charlie request to withdraw his tokensvm.startPrank(charlie);tokenProxied.approve(address(cashManager),50e18);cashManager.requestRedemption(50e18);vm.stopPrank();// Move forward to the next epochvm.warp(block.timestamp+1days);vm.prank(managerAdmin);cashManager.setMintExchangeRate(2e6,0);// Approve the cashMinter contract from the assetSender account_seedSenderWithCollateral(300e6);// First call, withdraw Alice and refund Charlieaddress[]memorywithdrawFirstCall=newaddress[](1);withdrawFirstCall[0] =alice;address[]memoryrefundFirstCall=newaddress[](1);refundFirstCall[0] =charlie;vm.prank(managerAdmin);cashManager.completeRedemptions(withdrawFirstCall,// Addresses to issue collateral torefundFirstCall,// Addresses to refund cash300e6,// Total amount of money to dist incl fees0,// Epoch we wish to process0// Fee amount to be transferred to ondo);// Alice redemption is calculated taking the refund into accountuint256aliceExpectedBalance=200e18*300e6/ ((200e18+200e18+50e18) -50e18);assertEq(USDC.balanceOf(alice),aliceExpectedBalance);assertEq(USDC.balanceOf(bob),0);assertEq(tokenProxied.balanceOf(charlie),50e18);// Second call, withdraw Bobaddress[]memorywithdrawSecondCall=newaddress[](1);withdrawSecondCall[0] =bob;address[]memoryrefundSecondCall=newaddress[](0);vm.prank(managerAdmin);cashManager.completeRedemptions(withdrawSecondCall,// Addresses to issue collateral torefundSecondCall,// Addresses to refund cash300e6,// Total amount of money to dist incl fees0,// Epoch we wish to process0// Fee amount to be transferred to ondo);// But here, Bob's redemption doesn't consider the previous refund.uint256bobBadBalance=uint256(200e18*300e6) / (200e18+200e18+50e18);assertEq(USDC.balanceOf(bob),bobBadBalance);}function_setupKYCStatus()internal{// Add KYC addressesaddress[]memoryaddressesToKYC=newaddress[](5);addressesToKYC[0] =guardian;addressesToKYC[1] =address(cashManager);addressesToKYC[2] =alice;addressesToKYC[3] =bob;addressesToKYC[4] =charlie;registry.addKYCAddresses(kycRequirementGroup,addressesToKYC);}function_seed(uint256aliceAmt,uint256bobAmt,uint256charlieAmt)internal{vm.startPrank(guardian);tokenProxied.mint(alice,aliceAmt);tokenProxied.mint(bob,bobAmt);tokenProxied.mint(charlie,charlieAmt);vm.stopPrank();}function_seedSenderWithCollateral(uint256usdcAmount)internal{vm.prank(USDC_WHALE);USDC.transfer(assetSender,usdcAmount);vm.prank(assetSender);USDC.approve(address(cashManager),usdcAmount);}}
Recommended Mitigation Steps
Update thetotalBurnedamount to consider refunds resulting from the call to_processRefund:
functioncompleteRedemptions(address[]calldataredeemers,address[]calldatarefundees,uint256collateralAmountToDist,uint256epochToService,uint256fees)externaloverrideupdateEpochonlyRole(MANAGER_ADMIN) {_checkAddressesKYC(redeemers);_checkAddressesKYC(refundees);if(epochToService>=currentEpoch) {revertMustServicePastEpoch();}// Calculate the total quantity of shares tokens burned w/n an epochuint256refundedAmt=_processRefund(refundees,epochToService);uint256quantityBurned=redemptionInfoPerEpoch[epochToService].totalBurned-refundedAmt;+redemptionInfoPerEpoch[epochToService].totalBurned=quantityBurned;uint256amountToDist=collateralAmountToDist-fees;_processRedemption(redeemers,amountToDist,quantityBurned,epochToService);collateral.safeTransferFrom(assetSender,feeRecipient,fees);emitRedemptionFeesCollected(feeRecipient,fees,epochToService);}
ali2251 (Ondo Finance) confirmed
ypatil12 (Ondo Finance) resolved