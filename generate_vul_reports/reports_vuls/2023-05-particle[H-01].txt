[H-01]ParticleExchange.auctionBuyNftandParticleExchange.withdrawEthWithInterestfunction calls can be DOS’ed
Submitted byrbserver, also found byd3e4,adriro,bin2chen, andminhquanym
Whenlien.borroweris a contract, itsreceivefunction can be coded to conditionally revert based on a state boolean variable controlled bylien.borrower’s owner. As long aspayback > 0is true,lien.borrower’sreceivefunction would be called when calling the followingParticleExchange.auctionBuyNftfunction. In this situation, if the owner oflien.borrowerintends to DOS theParticleExchange.auctionBuyNftfunction call, especially whenlien.creditis low or 0, she or he would makelien.borrower’sreceivefunction revert.
https://github.com/code-423n4/2023-05-particle/blob/bbd1c01407a017046c86fdb483bbabfb1fb085d8/contracts/protocol/ParticleExchange.sol#L688-L748
functionauctionBuyNft(Liencalldatalien,uint256lienId,uint256tokenId,uint256amount)externaloverridevalidateLien(lien,lienId)auctionLive(lien) {...// pay PnL to borroweruint256payback=lien.credit+lien.price-payableInterest-amount;if(payback>0) {payable(lien.borrower).transfer(payback);}...}
Moreover, after the auction of the lien is concluded, calling the followingParticleExchange.withdrawEthWithInterestfunction can calllien.borrower’sreceivefunction, as long aslien.credit > payableInterestis true. In this case, the owner oflien.borrowercan also makelien.borrower’sreceivefunction revert to DOS, theParticleExchange.withdrawEthWithInterestfunction call.
https://github.com/code-423n4/2023-05-particle/blob/bbd1c01407a017046c86fdb483bbabfb1fb085d8/contracts/protocol/ParticleExchange.sol#L192-L223
functionwithdrawEthWithInterest(Liencalldatalien,uint256lienId)externaloverridevalidateLien(lien,lienId) {...uint256payableInterest=_calculateCurrentPayableInterest(lien);// verify that the liquidation condition has met (borrower insolvent or auction concluded)if(payableInterest<lien.credit&& !_auctionConcluded(lien.auctionStartTime)) {revertErrors.LiquidationHasNotReached();}// delete lien (delete first to prevent reentrancy)deleteliens[lienId];// transfer ETH with interest back to lenderpayable(lien.lender).transfer(lien.price+payableInterest);// transfer PnL to borrowerif(lien.credit>payableInterest) {payable(lien.borrower).transfer(lien.credit-payableInterest);}...}
Similar situations can happen iflien.borrowerdoes not implement thereceiveorfallbackfunction intentionally; in whichlien.borrower’s owner is willing to pay some position margin, which can be a low amount depending on the corresponding lien, to DOS theParticleExchange.auctionBuyNftandParticleExchange.withdrawEthWithInterestfunction calls.
Proof of Concept
The following steps can occur for the described scenario for theParticleExchange.auctionBuyNftfunction. The situation for theParticleExchange.withdrawEthWithInterestfunction is similar:
Alice is the owner oflien.borrowerfor a lien.The lender of the lien starts the auction for the lien.Alice does not want the auction to succeed, so she makeslien.borrower’sreceivefunction revert by changing the controlled state boolean variable for launching the DOS attack to true.For a couple of times during the auction period, some other users are willing to win the auction by supplying an NFT from the same collection, but theirParticleExchange.auctionBuyNftfunction calls all revert.Since no one’sParticleExchange.auctionBuyNfttransaction is executed at the last second of the auction period, the auction is DOS’ed.
Recommended Mitigation Steps
TheParticleExchange.auctionBuyNftandParticleExchange.withdrawEthWithInterestfunctions can be updated to record thepaybackandlien.credit - payableInterestamounts that should belong tolien.borrower, instead of directly sending these amounts tolien.borrower. Then, a function can be added to letlien.borrowercall and receive these recorded amounts.
Assessed type
DoS
hansfriese (judge) increased severity to High and commented:
PoC -> Marked as primary
wukong-particle (Particle) confirmed, disagreed with severity and commented:
Acknowledged the issue and agreed with the suggestion. But this might be medium severity since it’s contained with only this borrower’s asset and fund, not speared to the protocol level.
hansfriese (judge) commented:
@wukong-particle - For the severity, I suggest High is appropriate.According to C4 guideline:High: Assets can be stolen/lost/compromised directly (or indirectly if there is a valid attack path that does not have hand-wavy hypotheticals).For this vulnerability, a malicious borrower can prevent the lender from taking action for defaulted lien.
So a borrower can wait as long as he wants and the lender can not claim NFT or ETH.
The likelihood and the impact are both high. I would like to note that there is no cost to the borrower for this exploit.
wukong-particle (Particle) commented:
@hansfriese - thanks for the suggestion, I agree. We can mark this issue as high severity.
wukong-particle (Particle) commented:
Fixed. Want to check with you about the changes we made. There are three major modifications here:(1) As suggested, we put the trader earning into a pull based approach — we created amapping(address => uint256) public accountBalance;, and doaccountBalance[account] += gainedAmountfor trader profit. In addition, besidesauctionBuyNftandwithdrawEthWithInterest, we default all trader profit (i.e., frombuyNftFromMarket,repayWithNft) intoaccountBalance, as opposed to a direct transfer back, for consistency.(2) We mergedaccruedInterestintoaccountBalancetoo, for simplicity. So this is like each account has a wallet in the contract. For treasury calculation, we move all calculations into interest accrual time as opposed toaccountBalancewithdrawal time, so that treasury still only takes the interest part, but not the trader gain as before.(3) AtsellNftToMarket, by default the trader will use the balance from the contract as their margin. If the balance is not enough, the trader can choose to top up the margin. Thus, the margin will be an input into the function, as opposed tomsg.value. The logic is as follows:if (margin > msg.value + accountBalance[msg.sender]) {revert Errors.Overspend();}if (margin > msg.value) {// newly deposited value not enough, use from account balanceaccountBalance[msg.sender] -= (margin - msg.value);} else if (margin < msg.value) {// newly deposited value more than enough, top up account balanceaccountBalance[msg.sender] += (msg.value - margin);}