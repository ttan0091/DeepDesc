[H-09] Callingunstake()can cause locked funds
Submitted by Ruhum, also found by 0xDjango, auditor0517, dipp, GimelSec, GreyArt, p4st13r4, and wagmi
Following scenario:
Alice has staked X token for 6 months that have vested. She stakes Y tokens for another three months. If she now callsunstake(X)to take out the tokens that have vested, the Y tokens she staked for three months will be locked up.
Proof of Concept
First, here’s a test showcasing the issue:
describe('should cause trouble', ()=>{it('should lock up funds',asyncfunction() {awaitapproveERC20(signer1.address,token.address,amountStaked,signer1,infinityStaker.address);awaitinfinityStaker.connect(signer1).stake(amountStaked,2);awaitnetwork.provider.send("evm_increaseTime", [181*DAY]);awaitnetwork.provider.send('evm_mine', []);// The funds we staked for 6 months have vestedexpect(awaitinfinityStaker.getUserTotalVested(signer1.address)).to.eq(amountStaked);// Now we want to stake funds for three monthsawaitapproveERC20(signer1.address,token.address,amountStaked2,signer1,infinityStaker.address);awaitinfinityStaker.connect(signer1).stake(amountStaked2,1);// total staked is now the funds staked for three & six months// total vested stays the sameexpect(awaitinfinityStaker.getUserTotalStaked(signer1.address)).to.eq(amountStaked.add(amountStaked2));expect(awaitinfinityStaker.getUserTotalVested(signer1.address)).to.eq(amountStaked);// we unstake the funds that are already vested.constuserBalanceBefore=awaittoken.balanceOf(signer1.address);awaitinfinityStaker.connect(signer1).unstake(amountStaked);constuserBalanceAfter=awaittoken.balanceOf(signer1.address);expect(userBalanceAfter).to.eq(userBalanceBefore.add(amountStaked));expect(awaitinfinityStaker.getUserTotalStaked(signer1.address)).to.eq(ethers.BigNumber.from(0));expect(awaitinfinityStaker.getUserTotalVested(signer1.address)).to.eq(ethers.BigNumber.from(0));});});
The test implements the scenario I’ve described above. In the end, the user got back theiramountStakedtokens with theamountStaked2tokens being locked up in the contract. The user has no tokens staked at the end.
The issue is in the_updateUserStakedAmounts()function:
if(amount>noVesting) {userstakedAmounts[user][Duration.NONE].amount=0;userstakedAmounts[user][Duration.NONE].timestamp=0;amount=amount-noVesting;if(amount>vestedThreeMonths) {// MAIN ISSUE:// here `vestedThreeMonths` is 0. The current staked tokens are set to `0` and `amount` is decreased by `0`.// Since `vestedThreeMonths` is `0` we shouldn't decrease `userstakedAmounts` at all here.userstakedAmounts[user][Duration.THREE_MONTHS].amount=0;userstakedAmounts[user][Duration.THREE_MONTHS].timestamp=0;amount=amount-vestedThreeMonths;// `amount == vestedSixMonths` so we enter the else blockif(amount>vestedSixMonths) {userstakedAmounts[user][Duration.SIX_MONTHS].amount=0;userstakedAmounts[user][Duration.SIX_MONTHS].timestamp=0;amount=amount-vestedSixMonths;if(amount>vestedTwelveMonths) {userstakedAmounts[user][Duration.TWELVE_MONTHS].amount=0;userstakedAmounts[user][Duration.TWELVE_MONTHS].timestamp=0;}else{userstakedAmounts[user][Duration.TWELVE_MONTHS].amount-=amount;}}else{// the staked amount is set to `0`.userstakedAmounts[user][Duration.SIX_MONTHS].amount-=amount;}}else{userstakedAmounts[user][Duration.THREE_MONTHS].amount-=amount;}}else{userstakedAmounts[user][Duration.NONE].amount-=amount;}
Recommended Mitigation Steps
Don’t setuserstakedAmounts.amountto0if none of its tokens are removed (vestedAmount == 0)
nneverlander (Infinity) confirmed
HardlyDifficult (judge) commented:
When unstaking, unvested tokens may become locked in the contract forever.Accepting this as a High risk issue.