[H-20] Possibly reentrancy attacks in_distributeETHRewardsToUserForTokenfunction
Submitted byrotcivegaf, also found bydatapunk,0x4non, andclems4ever
https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L51-L73https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantMevAndFeesPool.sol#L146-L167https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/GiantPoolBase.sol#L66-L90https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L66-L104https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L110-L143https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L314-L340
The root of the problem is in the_distributeETHRewardsToUserForTokenwhich makes a call to distribute the ether rewards. With this call, the recipient can execute an reentrancy attack calling several times the different function to steal founds or take advantage of other users/protocol.
Proof of Concept
This functions use the_distributeETHRewardsToUserForToken:
beforeTokenTransfer,GiantMevAndFeesPoolcontract:
The contractGiantLPuse theGiantMevAndFeesPoolcontract astransferHookProcessorand when use the functions_mint,_burn,transferFromandtransferof the ERC20, the functionbeforeTokenTransferimplemented in theGiantMevAndFeesPoolbring a possibility to make a reentrancy attack because in the function_distributeETHRewardsToUserForTokenimplemented in theGiantMevAndFeesPoolmake acallto the_recipient
A contract can call the functiontransferofGiantLPcontract several time, transfer anamountfrom and to self, as the update of theclaimedwould not be done until, it is executed the function_afterTokenTransferof theGiantLPcontract, thedueamount calculated in_distributeETHRewardsToUserForTokenofSyndicateRewardsProcessorcontract and thelastInteractedTimestampofGiantLPcontract will be incorrect
withdrawLPTokens,GiantPoolBasecontract:
The possibility of the reentrancy is given when call function_onWithdraw, this function implemented inGiantMevAndFeesPoolcontractuses_distributeETHRewardsToUserForTokenand this one call the recipient making the possibility of the reentrancy, breaking the code ofL76-L89
batchDepositETHForStaking,StakingFundsVaultcontract:
The possibility of the reentrancy is given when call function_distributeETHRewardsToUserForToken, this function call the recipient making the possibility of the reentrancy, breaking the code ofL76-L89
depositETHForStaking,StakingFundsVaultcontract:
The possibility of the reentrancy is given when call function_distributeETHRewardsToUserForToken, this function call the recipient making the possibility of the reentrancy, breaking the code ofL136-L142
beforeTokenTransfer,StakingFundsVaultcontract:
The possibility of the reentrancy is given when call function_distributeETHRewardsToUserForTokeninL333andL337, this function call the recipient making the possibility of the reentrancy, breaking the code ofL343-L351
Recommended Mitigation Steps
One possibility is to wrap(deposit) ether in WETH and transfer as ERC20 token.
Another is to addnonReentrantguard to the functions:
beforeTokenTransfer,GiantMevAndFeesPoolcontractwithdrawLPTokens,GiantPoolBasecontractbatchDepositETHForStaking,StakingFundsVaultcontractdepositETHForStaking,StakingFundsVaultcontractbeforeTokenTransfer,StakingFundsVaultcontract
File: contracts/liquid-staking/GiantMevAndFeesPool.sol@@ -143,7 +143,7 @@ contract GiantMevAndFeesPool is ITransferHookProcessor, GiantPoolBase, Syndicate}/// @notice Allow giant LP token to notify pool about transfers so the claimed amounts can be processed-    function beforeTokenTransfer(address _from, address _to, uint256) external {+    function beforeTokenTransfer(address _from, address _to, uint256) external nonReentrant {require(msg.sender == address(lpTokenETH), "Caller is not giant LP");updateAccumulatedETHPerLP();
File: contracts/liquid-staking/GiantPoolBase.sol@@ -66,7 +66,7 @@ contract GiantPoolBase is ReentrancyGuard {/// @notice Allow a user to chose to withdraw vault LP tokens by burning their giant LP tokens. 1 Giant LP == 1 vault LP/// @param _lpTokens List of LP tokens being owned and being withdrawn from the giant pool/// @param _amounts List of amounts of giant LP being burnt in exchange for vault LP-    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external {+    function withdrawLPTokens(LPToken[] calldata _lpTokens, uint256[] calldata _amounts) external nonReentrant {uint256 amountOfTokens = _lpTokens.length;require(amountOfTokens > 0, "Empty arrays");require(amountOfTokens == _amounts.length, "Inconsistent array lengths");
File: contracts/liquid-staking/StakingFundsVault.sol@@ -66,7 +66,7 @@ contract StakingFundsVault is/// @notice Batch deposit ETH for staking against multiple BLS public keys/// @param _blsPublicKeyOfKnots List of BLS public keys being staked/// @param _amounts Amounts of ETH being staked for each BLS public key-    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable {+    function batchDepositETHForStaking(bytes[] calldata _blsPublicKeyOfKnots, uint256[] calldata _amounts) external payable nonReentrant {uint256 numOfValidators = _blsPublicKeyOfKnots.length;require(numOfValidators > 0, "Empty arrays");require(numOfValidators == _amounts.length, "Inconsistent array lengths");@@ -110,7 +110,7 @@ contract StakingFundsVault is/// @notice Deposit ETH against a BLS public key for staking/// @param _blsPublicKeyOfKnot BLS public key of validator registered by a node runner/// @param _amount Amount of ETH being staked-    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable returns (uint256) {+    function depositETHForStaking(bytes calldata _blsPublicKeyOfKnot, uint256 _amount) public payable nonReentrant returns (uint256) {require(liquidStakingNetworkManager.isBLSPublicKeyBanned(_blsPublicKeyOfKnot) == false, "BLS public key is banned or not a part of LSD network");require(getAccountManager().blsPublicKeyToLifecycleStatus(_blsPublicKeyOfKnot) == IDataStructures.LifecycleStatus.INITIALS_REGISTERED,@@ -312,7 +312,7 @@ contract StakingFundsVault is}/// @notice before an LP token is transferred, pay the user any unclaimed ETH rewards-    function beforeTokenTransfer(address _from, address _to, uint256) external override {+    function beforeTokenTransfer(address _from, address _to, uint256) external override nonReentrant {address syndicate = liquidStakingNetworkManager.syndicate();if (syndicate != address(0)) {LPToken token = LPToken(msg.sender);
vince0656 (Stakehouse) confirmed