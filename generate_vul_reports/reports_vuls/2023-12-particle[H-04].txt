[H-04] Underflow could happened when calculating Uniswap V3 position’s fee growth and can cause operations to revert
Submitted bysaid
When operations need to calculate Uniswap V3 position’s fee growth, it used similar function implemented byuniswap v3. However, according to this known issue :https://github.com/Uniswap/v3-core/issues/573.  The contract is implicitly relies on underflow/overflow when calculating the fee growth, if underflow is prevented, some operations that rely on fee growth will revert.
Proof of Concept
It can be observed that current implementation ofgetFeeGrowthInsidenot allow underflow/overflow to happen when calculatingfeeGrowthInside0X128andfeeGrowthInside1X128, because the contract used solidity 0.8.23.
https://github.com/code-423n4/2023-12-particle/blob/main/contracts/libraries/Base.sol#L318-L342
functiongetFeeGrowthInside(addresstoken0,addresstoken1,uint24fee,int24tickLower,int24tickUpper)internalviewreturns(uint256feeGrowthInside0X128,uint256feeGrowthInside1X128) {IUniswapV3Poolpool=IUniswapV3Pool(UNI_FACTORY.getPool(token0,token1,fee));(,int24tickCurrent, , , , , ) =pool.slot0();(, ,uint256lowerFeeGrowthOutside0X128,uint256lowerFeeGrowthOutside1X128, , , , ) =pool.ticks(tickLower);(, ,uint256upperFeeGrowthOutside0X128,uint256upperFeeGrowthOutside1X128, , , , ) =pool.ticks(tickUpper);if(tickCurrent<tickLower) {feeGrowthInside0X128=lowerFeeGrowthOutside0X128-upperFeeGrowthOutside0X128;feeGrowthInside1X128=lowerFeeGrowthOutside1X128-upperFeeGrowthOutside1X128;}elseif(tickCurrent<tickUpper) {uint256feeGrowthGlobal0X128=pool.feeGrowthGlobal0X128();uint256feeGrowthGlobal1X128=pool.feeGrowthGlobal1X128();feeGrowthInside0X128=feeGrowthGlobal0X128-lowerFeeGrowthOutside0X128-upperFeeGrowthOutside0X128;feeGrowthInside1X128=feeGrowthGlobal1X128-lowerFeeGrowthOutside1X128-upperFeeGrowthOutside1X128;}else{feeGrowthInside0X128=upperFeeGrowthOutside0X128-lowerFeeGrowthOutside0X128;feeGrowthInside1X128=upperFeeGrowthOutside1X128-lowerFeeGrowthOutside1X128;}}
This could impact crucial operation that rely on this call, such as liquidation, could revert unexpectedly. This behavior is quite often especially for pools that use lower fee.
Coded PoC :
Add the following test to/test/OpenPosition.t.sol:
functiontestLiquidationRevert()public{addressLIQUIDATOR=payable(address(0x7777));uint128REPAY_LIQUIDITY_PORTION=1000;_setupLowerOutOfRange();testBaseOpenLongPosition();// get lien info(,uint128liquidityInside, , , , , , ) =particlePositionManager.liens(keccak256(abi.encodePacked(SWAPPER,uint96(0))));// start reclaimvm.startPrank(LP);vm.warp(block.timestamp+1);particlePositionManager.reclaimLiquidity(_tokenId);vm.stopPrank();// add back liquidity requirementvm.warp(block.timestamp+7days);IUniswapV3Pool_pool=IUniswapV3Pool(uniswapV3Factory.getPool(address(USDC),address(WETH),FEE));(uint160currSqrtRatioX96, , , , , , ) =_pool.slot0();(uint256amount0ToReturn,uint256amount1ToReturn) =LiquidityAmounts.getAmountsForLiquidity(currSqrtRatioX96,_sqrtRatioAX96,_sqrtRatioBX96,liquidityInside);(uint256usdCollateral,uint256ethCollateral) =particleInfoReader.getRequiredCollateral(liquidityInside,_tickLower,_tickUpper);// get swap datauint160currentPrice=particleInfoReader.getCurrentPrice(address(USDC),address(WETH),FEE);uint256amountSwap=ethCollateral-amount1ToReturn;ISwapRouter.ExactInputSingleParamsmemoryparams=ISwapRouter.ExactInputSingleParams({tokenIn:address(WETH),tokenOut:address(USDC),fee:FEE,recipient:address(particlePositionManager),deadline:block.timestamp,amountIn:amountSwap,amountOutMinimum:0,sqrtPriceLimitX96:currentPrice+currentPrice/SLIPPAGE_FACTOR});bytesmemorydata=abi.encodeWithSelector(ISwapRouter.exactInputSingle.selector,params);// liquidate positionvm.startPrank(LIQUIDATOR);vm.expectRevert(abi.encodeWithSelector(Errors.InsufficientRepay.selector));particlePositionManager.liquidatePosition(DataStruct.ClosePositionParams({lienId:uint96(0),amountSwap:amountSwap,data:data}),SWAPPER);vm.stopPrank();}
Also modifyFEEinside/test/Base.t.solto500:
contract ParticlePositionManagerTestBase is Test {using Lien for mapping(bytes32 => Lien.Info);IERC20 public constant WETH = IERC20(0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2);IERC20 public constant USDC = IERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48);IERC20 public constant DAI = IERC20(0x6B175474E89094C44Da98b954EedeAC495271d0F);uint256 public constant USDC_AMOUNT = 50000000 * 1e6;uint256 public constant DAI_AMOUNT = 50000000 * 1e18;uint256 public constant WETH_AMOUNT = 50000 * 1e18;address payable public constant ADMIN = payable(address(0x4269));address payable public constant LP = payable(address(0x1001));address payable public constant SWAPPER = payable(address(0x1002));address payable public constant WHALE = payable(address(0x6666));IQuoter public constant QUOTER = IQuoter(0xb27308f9F90D607463bb33eA1BeBb41C27CE5AB6);int24 public constant TICK_SPACING = 60;uint256 public constant BASIS_POINT = 1_000_000;-    uint24 public constant FEE = 3000; // uniswap swap fee+    uint24 public constant FEE = 500; // uniswap swap fee..}
Run the test :
forge test --fork-url $MAINNET_RPC_URL --fork-block-number 18750931 --match-contract OpenPositionTest --match-test testRevertUnderflow -vvvv
Log output :

It can be observed that the liquidation revert due to the underflow.
Recommended Mitigation Steps
Use unchecked when calculatingfeeGrowthInside0X128andfeeGrowthInside1X128.
wukong-particle (Particle) confirmed and commented:
Oh this one is great. Will update the code to uncheckfeeGrowthInside0X128andfeeGrowthInside1X128calculations.