[H-05]addFeewill stop accumulating fee oncerewardTokenhas reached max supply
Submitted by shenwilly, also found by 0x52, berndartmueller, GimelSec, GiveMeTestEther, kaden, Lambda, M0ndoHEHE, obront, Picodes, rbserver, reassor, rokinot, and scaraven
RewardDistributorwill stop accumulating fees for staker rewards oncerewardTokensupply has reached the maximum supply (1 billion).
Vulnerability Details
RewardDistributor.sol#L98-L138
function addFee(address[2] memory addr, uint256 fee) public onlyTrader {if (rewardToken.totalSupply() > 1000000000 * 10**18) {// if supply is greater then a billion dont mint anything, dont add tradesreturn;}...feesTrader[addr[0]][epoch] = feesTrader[addr[0]][epoch] + fee;feesExchange[addr[1]][epoch] = feesExchange[addr[1]][epoch] + fee;epochTotalFee[epoch] = epochTotalFee[epoch] + fee;}
The check at the beginning ofaddFeeis supposed to stopRewardDistributorfrom minting additional rewardToken once it has reached 1 billion supply. However, the current implementation has a side effect of causing the function to skip recording accumulated trading fees (the last 3 lines of the function). This will cause stakers to lose their trading fee rewards once the max supply has been reached, and the funds will be permanently locked in the contract.
Proof of Concept
Alice stakedGOLOMto receive fee rewards fromRewardDistributor.GOLOMsupply reaches 1 billion token.Traders keep trading onGolomTrader, sending protocol fees toRewardDistributor. However,RewardDistributor.addFeedoes not update the fee accounting.Alice won’t receive any fee reward and protocol fees are stuck in the contract.
Recommended Mitigation Steps
ModifyaddFeeso that the check won’t skip accruing trade fees:
function addFee(address[2] memory addr, uint256 fee) public onlyTrader {if (block.timestamp > startTime + (epoch) * secsInDay) {uint256 previousEpochFee = epochTotalFee[epoch];epoch = epoch + 1;if (rewardToken.totalSupply() > 1000000000 * 10**18) {emit NewEpoch(epoch, 0, 0, previousEpochFee);} else {uint256 tokenToEmit = (dailyEmission * (rewardToken.totalSupply() - rewardToken.balanceOf(address(ve)))) /rewardToken.totalSupply();uint256 stakerReward = (tokenToEmit * rewardToken.balanceOf(address(ve))) / rewardToken.totalSupply();rewardStaker[epoch] = stakerReward;rewardTrader[epoch] = ((tokenToEmit - stakerReward) * 67) / 100;rewardExchange[epoch] = ((tokenToEmit - stakerReward) * 33) / 100;rewardToken.mint(address(this), tokenToEmit);epochBeginTime[epoch] = block.number;if (previousEpochFee > 0) {if (epoch == 1){epochTotalFee[0] =  address(this).balance; // staking and trading rewards start at epoch 1, for epoch 0 all contract ETH balance is converted to staker rewards rewards.weth.deposit{value: address(this).balance}();}else{weth.deposit{value: previousEpochFee}();}}emit NewEpoch(epoch, tokenToEmit, stakerReward, previousEpochFee);}}feesTrader[addr[0]][epoch] = feesTrader[addr[0]][epoch] + fee;feesExchange[addr[1]][epoch] = feesExchange[addr[1]][epoch] + fee;epochTotalFee[epoch] = epochTotalFee[epoch] + fee;return;}
0xsaruman (Golom) confirmed
0xsaruman (Golom) resolved and commented:
Resolved inhttps://github.com/golom-protocol/contracts/commit/192e152dde2eed6c01a3945aa5fd223ff786ca5e