[H-17] FunctionprocessEpoch()in PublicVault would revert when most of the users withdraw their funds because of the underflow for new yIntercept calculation
Submitted byunforgiven, also found byevanand0xbepresent
https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L314-L335https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L479-L493
When users withdraw their vault tokens PublicVault mint WithdrawProxy’s shares token for them and at the end of the epoch PublicVault would calculated WithdrawProxy’s assets and update PublicVault assets and start the next epoch. if a lot of users withdraws their funds then the value of thetotalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18)(the amount belongs to the WithdrawProxy) would be higher thanyInterceptand code would revert because of the underflow when setting the new value of theyIntercept. This would cause last users to not be able to withdraw their funds and contract epoch system to be broken for a while.
Proof of Concept
This is part ofprocessEpoch()code that calculates ratio between WithdrawProxy and PublicVault:
function processEpoch() public {..........// reset liquidationWithdrawRatio to prepare for re calcualtions.liquidationWithdrawRatio = 0;// check if there are LPs withdrawing this epochif ((address(currentWithdrawProxy) != address(0))) {uint256 proxySupply = currentWithdrawProxy.totalSupply();s.liquidationWithdrawRatio = proxySupply.mulDivDown(1e18, totalSupply()).safeCastTo88();currentWithdrawProxy.setWithdrawRatio(s.liquidationWithdrawRatio);uint256 expected = currentWithdrawProxy.getExpected();unchecked {if (totalAssets() > expected) {s.withdrawReserve = (totalAssets() - expected).mulWadDown(s.liquidationWithdrawRatio).safeCastTo88();} else {s.withdrawReserve = 0;}}_setYIntercept(s,s.yIntercept -totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18));// burn the tokens of the LPs withdrawing_burn(address(this), proxySupply);}
As you can see in the line_setYIntercept(s, s.yIntercept - totalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18))code tries to set new value foryInterceptbut This istotalAssets()code:
function totalAssets()publicviewvirtualoverride(ERC4626Cloned)returns (uint256){VaultData storage s = _loadStorageSlot();return _totalAssets(s);}function _totalAssets(VaultData storage s) internal view returns (uint256) {uint256 delta_t = block.timestamp - s.last;return uint256(s.slope).mulDivDown(delta_t, 1) + uint256(s.yIntercept);}
So as you can seetotalAssets()can be higher thanyInterceptand if most of the user withdraw their funds(for example the last user) then the value ofliquidationWithdrawRatiowould be near1too and the value oftotalAssets().mulDivDown(s.liquidationWithdrawRatio, 1e18)would be bigger thanyInterceptand call toprocessEpoch()would revert and code can’t start the next epoch and user withdraw process can’t be finished and funds would stuck in the contract.
Tools Used
VIM
Recommended Mitigation Steps
Prevent underflow by callingaccrue()in the begining of theprocessEpoch().
SantiagoGregory (Astaria) confirmed via duplicate issue#408
Picodes (judge) increased severity to High