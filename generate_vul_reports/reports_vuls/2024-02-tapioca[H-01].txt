[H-01]MagnetarMintXChainModule.sol:mintBBLendXChainSGLcan be used to manipulate user positions by abusing whitelist privileges
Submitted bycarrotsmuggler, also found bycarrotsmuggler,GalloDaSballo, and cccz (1,2)
The Magnetar functions use_checkSenderfunction to check if the caller should be allowed to perform operations on the account. The function allows operations if the caller is the owner, or if the caller is a whitelisted trusted address.
function_checkSender(address_from)internalview{if(_from!=msg.sender&& !cluster.isWhitelisted(0,msg.sender)) {revertMagnetar_NotAuthorized(msg.sender,_from);}}
However, this means that if a malicious user is able to make a whitelisted contract call magnetar functions with their own payload, they can steal tokens and wreak havoc on other user’s accounts!
The functiondepositYBLendSGLLockXchainTOLPin theMagnetarAssetXChainModulecontract uses a similar check. This function deposits and lends into markets, for the account passed in asdata.user. Crucially, it also extracts tokens fromdata.userfor these operations. So if a malicious user was able to get this function called by a whitelisted contract and pass in a maliciousdata.user, they can cause the target user to lose tokens and manipulate their market positions. This is a high severity issue and the path to attack is demonstrated below.
Proof of Concept
The entry point is theMagnetarMintXChainModulecontract’smintBBLendXChainSGLfunction for the attacker. This is a special function, in the sense that this sets up the system for multiple cross chain calls. This function calls theUSDOfunction which then does an lzcompose call on another chain to the Magnetar contract again. This is a complex function and the attacker can use this to manipulate the system.
The flow of control of this function is shown below:
flowchart LRCaller --mintBBLendXChainSGL--> MA["Magnetar\n(chain A)"];MA -- sendPacket() --> USDOA["USDO\n(chain A)"];USDOA -- lzSend --> EA["Endpoint\n(chain A)"];EB["Endpoint\n(chain B)"] -- lzReceive (1) --> USDOB["USDO\n(chain B)"];USDOB -- sendCompose (2) --> EB;EB -- lzcompose (3) --> USDOB;USDOB --depositYBLendSGLLockXchainTOLP--> MB["Magnetar\n(chain B)"];MB --> Markets["Markets\n(chain B)"];
As shown in the above diagram, the caller initiates the call to the Magnetar contract. The Magnetar contract then does a cross-chain call via theUSDOcontract. It also sends along a lzcompose message which will be executed on chainB. On chainB, theUSDOcontract receives the call and initiates the lzcompose execution. Due to how the system is designed, this lzcompose message being executed by theUSDOcontract is actually a call to the Magnetar contract on chainB, specifically thedepositYBLendSGLLockXchainTOLPfunction.
This can be shown by the fact that on chainA, the Magnetar encodes the lzcompose message into a struct.
DepositAndSendForLockingDatamemorylendData=abi.decode(tapComposeMsg_, (DepositAndSendForLockingData));lendData.lendAmount=data.mintData.mintAmount;data.lendSendParams.lzParams.sendParam.composeMsg=TapiocaOmnichainEngineCodec.encodeToeComposeMsg(abi.encode(lendData),msgType_,msgIndex_,nextMsg_);
Then this sameDepositAndSendForLockingDatastruct is accepted as an input on chainBdepositYBLendSGLLockXchainTOLPfunction.
functiondepositYBLendSGLLockXchainTOLP(DepositAndSendForLockingDatamemorydata)publicpayable
On chainB, thedata.useris the target of the operation. Since the caller is theUSDOcontract, which is not thedata.uservalue, for this to work, theUSDOcontract must have been whitelisted by the system.
This means the malicious user can send in anydata.userin theirdata.lendSendParams.lzParams.sendParam.composeMsgfield, and theUSDOcontract will execute it on their behalf. No access checks will be performed, since theUSDOcontract is whitelisted. The target just needs to have given allowance to the Magnetar contract itself to perform market operations on their behalf. There are no checks onDepositAndSendForLockingData.userfield in themintBBLendXChainSGLfunction on chainA, so the malicious user can send in practically any address they want, and the whitelistedUSDOcontract will carry out the transaction.
This skips a crucial user check and manipulates other user positions; hence, it is a high severity issue.
Recommended Mitigation Steps
The architecture of this crosschain call is quite vulnerable. Due to the whitelist, any function call that can be done viaUSDOcontract is risky since it can override the Magnetar checks. ThemintBBLendXChainSGLfunction on chainA should make sure the lzcomposedata.useris the same as the currentdata.user, but this only blocks a single attack vector.USDOcontract is crosschain compatible and allows lzcompose message, so any other methods which can be used to trigger such a cross chain call can abuse the whitelist.
0xRektora (Tapioca) confirmed via duplicate Issue #124
cryptotechmaker (Tapioca) commented via duplicate Issue #124:
PRhere.