[H-03] Interest rates are incorrect on Liquidation
Submitted bycsanuragjain, also found byunforgivenandcccz
The debt tokens are being transferred before calculating the interest rates. But the interest rate calculation function assumes that debt token has not yet been sent thus the outcomecurrentLiquidityRatewill be incorrect
Proof of Concept
Liquidator L1 callsexecuteLiquidateERC20for a position whose health factor <1
function executeLiquidateERC20(mapping(address => DataTypes.ReserveData) storage reservesData,mapping(uint256 => address) storage reservesList,mapping(address => DataTypes.UserConfigurationMap) storage usersConfig,DataTypes.ExecuteLiquidateParams memory params) external returns (uint256) {..._burnDebtTokens(liquidationAssetReserve, params, vars);...}
This internally calls_burnDebtTokens
function _burnDebtTokens(DataTypes.ReserveData storage liquidationAssetReserve,DataTypes.ExecuteLiquidateParams memory params,ExecuteLiquidateLocalVars memory vars) internal {...// Transfers the debt asset being repaid to the xToken, where the liquidity is keptIERC20(params.liquidationAsset).safeTransferFrom(vars.payer,vars.liquidationAssetReserveCache.xTokenAddress,vars.actualLiquidationAmount);...// Update borrow & supply rateliquidationAssetReserve.updateInterestRates(vars.liquidationAssetReserveCache,params.liquidationAsset,vars.actualLiquidationAmount,0);}
Basically first it transfers the debt asset to xToken using below. This increases the balance of xTokenAddress for liquidationAsset
IERC20(params.liquidationAsset).safeTransferFrom(vars.payer,vars.liquidationAssetReserveCache.xTokenAddress,vars.actualLiquidationAmount);
NowupdateInterestRatesfunction is called on ReserveLogic.sol#L169
function updateInterestRates(DataTypes.ReserveData storage reserve,DataTypes.ReserveCache memory reserveCache,address reserveAddress,uint256 liquidityAdded,uint256 liquidityTaken) internal {...(vars.nextLiquidityRate,vars.nextVariableRate) = IReserveInterestRateStrategy(reserve.interestRateStrategyAddress).calculateInterestRates(DataTypes.CalculateInterestRatesParams({liquidityAdded: liquidityAdded,liquidityTaken: liquidityTaken,totalVariableDebt: vars.totalVariableDebt,reserveFactor: reserveCache.reserveFactor,reserve: reserveAddress,xToken: reserveCache.xTokenAddress}));...}
Finally call tocalculateInterestRatesfunction on DefaultReserveInterestRateStrategy#L127 contract is made which calculates the interest rate
function calculateInterestRates(DataTypes.CalculateInterestRatesParams calldata params) external view override returns (uint256, uint256) {...if (vars.totalDebt != 0) {vars.availableLiquidity =IToken(params.reserve).balanceOf(params.xToken) +params.liquidityAdded -params.liquidityTaken;vars.availableLiquidityPlusDebt =vars.availableLiquidity +vars.totalDebt;vars.borrowUsageRatio = vars.totalDebt.rayDiv(vars.availableLiquidityPlusDebt);vars.supplyUsageRatio = vars.totalDebt.rayDiv(vars.availableLiquidityPlusDebt);}...vars.currentLiquidityRate = vars.currentVariableBorrowRate.rayMul(vars.supplyUsageRatio).percentMul(PercentageMath.PERCENTAGE_FACTOR - params.reserveFactor);return (vars.currentLiquidityRate, vars.currentVariableBorrowRate);}
As we can see in above code,vars.availableLiquidityis calculated asIToken(params.reserve).balanceOf(params.xToken) +params.liquidityAdded - params.liquidityTakenBut the problem is that debt token is already transferred toxTokenwhich meansxTokenalready consist ofparams.liquidityAdded. Hence the calculation ultimately becomes(xTokenBeforeBalance+params.liquidityAdded) +params.liquidityAdded - params.liquidityTakenThis is incorrect and would lead to highervars.availableLiquiditywhich ultimately impacts thecurrentLiquidityRate
Recommended Mitigation Steps
Transfer the debt asset post interest calculation
function _burnDebtTokens(DataTypes.ReserveData storage liquidationAssetReserve,DataTypes.ExecuteLiquidateParams memory params,ExecuteLiquidateLocalVars memory vars) internal {IPToken(vars.liquidationAssetReserveCache.xTokenAddress).handleRepayment(params.liquidator, vars.actualLiquidationAmount);// Burn borrower's debt tokenvars.liquidationAssetReserveCache.nextScaledVariableDebt = IVariableDebtToken(vars.liquidationAssetReserveCache.variableDebtTokenAddress).burn(params.borrower,vars.actualLiquidationAmount,vars.liquidationAssetReserveCache.nextVariableBorrowIndex);liquidationAssetReserve.updateInterestRates(vars.liquidationAssetReserveCache,params.liquidationAsset,vars.actualLiquidationAmount,0);IERC20(params.liquidationAsset).safeTransferFrom(vars.payer,vars.liquidationAssetReserveCache.xTokenAddress,vars.actualLiquidationAmount);......}