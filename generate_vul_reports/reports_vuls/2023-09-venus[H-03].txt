[H-03] Incorrect decimal usage in score calculation leads to reduced user reward earnings
Submitted byBrenzee, also found byTesterbot,0xDetermination,santipu_,ast3ros,ether_sky,sces60107,pep7siup,Breeje,tapir, 0xTheC0der (1,2), andSpicyMeatball
Users earned rewards are calculated incorrectly because of the incorrect decimals value used to calculate user’sscoreand marketssumOfMembersScore, which impacts thedeltathat is added to market’srewardIndexwhenPrime.accrueInterestfunction is called.
Proof of Concept
All users rewards are calculated with the following formula:
rewards = (rewardIndex - userRewardIndex) * scoreOfUser;
This means that for user to earn rewards, market’srewardIndexneeds to periodically increase.
markets[vToken].rewardIndexis updated (increased), whenPrime.accrueInterestis called.
Prime.sol:L583-L588
uint256delta;if(markets[vToken].sumOfMembersScore>0) {delta= ((distributionIncome*EXP_SCALE) /markets[vToken].sumOfMembersScore);}markets[vToken].rewardIndex=markets[vToken].rewardIndex+delta;
From the code snippet above it is assumed thatmarkets[vToken].sumOfMembersScoreis precision of 18 decimals.
To ensure that user’sscoreand marketssumOfMemberScoreare correctly calculated, inPrime._calculateScorefunctioncapitalis adjusted to 18 decimals. After thatcapitalis used inScores.calculateScorefunction.
Note:capitalprecision from_capitalForScorefunction is in precision ofunderlying token decimals.
Prime.sol:660-L663
(uint256capital, , ) =_capitalForScore(xvsBalanceForScore,borrow,supply,market);capital=capital* (10** (18-vToken.decimals()));returnScores.calculateScore(xvsBalanceForScore,capital,alphaNumerator,alphaDenominator);
The mistake is made whenvToken.decimals()is used instead ofvToken.underlying().decimals().
To prove that this is the case, here are vTokens deployed on Binance Smart chain, their decimals and underlying token decimals:
vTokenvToken decimalsUnderlying token decimalsvUSDC818vETH818vBNB818vBTC818vUSDT818
SincevToken.decimals()is used, this means the precision ofcapitalis18 + (18 - 8) = 28decimals instead of 18 decimals, which makes thescorecalculation fromScore.calculateScorefunction incorrect, since the function expectscapitalto be in precision of 18 decimals.
As a result,deltafor market’srewardIndexis incorrectly calculated and it can be 0 even though it shouldn’t be, which means that users will not accrue any rewards.
Update current test with correct decimals for vTokens
Developers have made a mistake when writing the tests forPrime.sol- in the tests they have set vToken decimals to 18 instead of 8, which makes the tests pass, but on the Binance Smart Chain all of the vToken decimals are 8.
If the decimal value of vToken is set to 8 in the tests, then the tests will fail.
Change thevusdt,vethandvbnbdecimals to 8 and run:
npx hardhattesttests/hardhat/Prime/*.ts tests/hardhat/integration/index.ts
This will make the current tests fail.
PoC Test
Here is a test where it shows, thatrewardIndexis still 0 afterPrime.accrueInterestis called, even though it should be > 0.
PoC testTo run the following test:CreatePoC.tsfile under thetests/hardhat/Primepath.Copy the code below and paste it into thePoC.tsfile.Runnpx hardhat test tests/hardhat/Prime/PoC.tsimport{FakeContract,MockContract,smock}from"@defi-wonderland/smock";import{loadFixture,mine}from"@nomicfoundation/hardhat-network-helpers";importchaifrom"chai";import{BigNumber,Signer}from"ethers";import{ethers,upgrades}from"hardhat";import{convertToUnit}from"../../../helpers/utils";import{BEP20Harness,ComptrollerLens,ComptrollerLens__factory,ComptrollerMock,ComptrollerMock__factory,IAccessControlManager,IProtocolShareReserve,InterestRateModelHarness,PrimeLiquidityProvider,PrimeScenario,ResilientOracleInterface,VBep20Harness,XVS,XVSStore,XVSVault,XVSVaultScenario,}from"../../../typechain";const{expect} =chai;chai.use(smock.matchers);exportconstbigNumber18=BigNumber.from("1000000000000000000");// 1e18exportconstbigNumber16=BigNumber.from("10000000000000000");// 1e16exportconstvTokenDecimals=BigNumber.from(8);typeSetupProtocolFixture= {oracle:FakeContract<ResilientOracleInterface>;accessControl:FakeContract<IAccessControlManager>;comptrollerLens:MockContract<ComptrollerLens>;comptroller:MockContract<ComptrollerMock>;usdt:BEP20Harness;vusdt:VBep20Harness;eth:BEP20Harness;veth:VBep20Harness;xvsVault:XVSVaultScenario;xvs:XVS;xvsStore:XVSStore;prime:PrimeScenario;protocolShareReserve:FakeContract<IProtocolShareReserve>;primeLiquidityProvider:PrimeLiquidityProvider;};asyncfunctiondeployProtocol():Promise<SetupProtocolFixture> {const[wallet,user1,user2,user3] =awaitethers.getSigners();constoracle=awaitsmock.fake<ResilientOracleInterface>("ResilientOracleInterface");constprotocolShareReserve=awaitsmock.fake<IProtocolShareReserve>("IProtocolShareReserve");constaccessControl=awaitsmock.fake<IAccessControlManager>("AccessControlManager");accessControl.isAllowedToCall.returns(true);constComptrollerLensFactory=awaitsmock.mock<ComptrollerLens__factory>("ComptrollerLens");constComptrollerFactory=awaitsmock.mock<ComptrollerMock__factory>("ComptrollerMock");constcomptroller=awaitComptrollerFactory.deploy();constcomptrollerLens=awaitComptrollerLensFactory.deploy();awaitcomptroller._setAccessControl(accessControl.address);awaitcomptroller._setComptrollerLens(comptrollerLens.address);awaitcomptroller._setPriceOracle(oracle.address);awaitcomptroller._setLiquidationIncentive(convertToUnit("1",18));awaitprotocolShareReserve.MAX_PERCENT.returns("100");consttokenFactory=awaitethers.getContractFactory("BEP20Harness");constusdt= (awaittokenFactory.deploy(bigNumber18.mul(100000000),"usdt",BigNumber.from(18),"BEP20 usdt",))asBEP20Harness;consteth= (awaittokenFactory.deploy(bigNumber18.mul(100000000),"eth",BigNumber.from(18),"BEP20 eth",))asBEP20Harness;constwbnb= (awaittokenFactory.deploy(bigNumber18.mul(100000000),"wbnb",BigNumber.from(18),"BEP20 wbnb",))asBEP20Harness;constinterestRateModelHarnessFactory=awaitethers.getContractFactory("InterestRateModelHarness");constInterestRateModelHarness= (awaitinterestRateModelHarnessFactory.deploy(BigNumber.from(18).mul(5),))asInterestRateModelHarness;constvTokenFactory=awaitethers.getContractFactory("VBep20Harness");constvusdt= (awaitvTokenFactory.deploy(usdt.address,comptroller.address,InterestRateModelHarness.address,bigNumber18,"VToken usdt","vusdt",vTokenDecimals,wallet.address,))asVBep20Harness;constveth= (awaitvTokenFactory.deploy(eth.address,comptroller.address,InterestRateModelHarness.address,bigNumber18,"VToken eth","veth",vTokenDecimals,wallet.address,))asVBep20Harness;constvbnb= (awaitvTokenFactory.deploy(wbnb.address,comptroller.address,InterestRateModelHarness.address,bigNumber18,"VToken bnb","vbnb",vTokenDecimals,wallet.address,))asVBep20Harness;//0.2 reserve factorawaitveth._setReserveFactor(bigNumber16.mul(20));awaitvusdt._setReserveFactor(bigNumber16.mul(20));oracle.getUnderlyingPrice.returns((vToken:string)=>{if(vToken==vusdt.address) {returnconvertToUnit(1,18);}elseif(vToken==veth.address) {returnconvertToUnit(1200,18);}});oracle.getPrice.returns((token:string)=>{if(token==xvs.address) {returnconvertToUnit(3,18);}});consthalf=convertToUnit("0.5",18);awaitcomptroller._supportMarket(vusdt.address);awaitcomptroller._setCollateralFactor(vusdt.address,half);awaitcomptroller._supportMarket(veth.address);awaitcomptroller._setCollateralFactor(veth.address,half);awaiteth.transfer(user1.address,bigNumber18.mul(100));awaitusdt.transfer(user2.address,bigNumber18.mul(10000));awaitcomptroller._setMarketSupplyCaps([vusdt.address,veth.address], [bigNumber18.mul(10000),bigNumber18.mul(100)]);awaitcomptroller._setMarketBorrowCaps([vusdt.address,veth.address], [bigNumber18.mul(10000),bigNumber18.mul(100)]);constxvsFactory=awaitethers.getContractFactory("XVS");constxvs:XVS= (awaitxvsFactory.deploy(wallet.address))asXVS;constxvsStoreFactory=awaitethers.getContractFactory("XVSStore");constxvsStore:XVSStore= (awaitxvsStoreFactory.deploy())asXVSStore;constxvsVaultFactory=awaitethers.getContractFactory("XVSVaultScenario");constxvsVault:XVSVaultScenario= (awaitxvsVaultFactory.deploy())asXVSVaultScenario;awaitxvsStore.setNewOwner(xvsVault.address);awaitxvsVault.setXvsStore(xvs.address,xvsStore.address);awaitxvsVault.setAccessControl(accessControl.address);awaitxvs.transfer(xvsStore.address,bigNumber18.mul(1000));awaitxvs.transfer(user1.address,bigNumber18.mul(1000000));awaitxvs.transfer(user2.address,bigNumber18.mul(1000000));awaitxvs.transfer(user3.address,bigNumber18.mul(1000000));awaitxvsStore.setRewardToken(xvs.address,true);constlockPeriod=300;constallocPoint=100;constpoolId=0;constrewardPerBlock=bigNumber18.mul(1);awaitxvsVault.add(xvs.address,allocPoint,xvs.address,rewardPerBlock,lockPeriod);constprimeLiquidityProviderFactory=awaitethers.getContractFactory("PrimeLiquidityProvider");constprimeLiquidityProvider=awaitupgrades.deployProxy(primeLiquidityProviderFactory,[accessControl.address, [xvs.address,usdt.address,eth.address], [10,10,10]],{},);constprimeFactory=awaitethers.getContractFactory("PrimeScenario");constprime:PrimeScenario=awaitupgrades.deployProxy(primeFactory,[xvsVault.address,xvs.address,0,1,2,accessControl.address,protocolShareReserve.address,primeLiquidityProvider.address,comptroller.address,oracle.address,10,],{constructorArgs:[wbnb.address,vbnb.address,10512000],unsafeAllow:["constructor"],},);awaitxvsVault.setPrimeToken(prime.address,xvs.address,poolId);awaitprime.setLimit(1000,1000);awaitprime.addMarket(vusdt.address,bigNumber18.mul("1"),bigNumber18.mul("1"));awaitprime.addMarket(veth.address,bigNumber18.mul("1"),bigNumber18.mul("1"));awaitcomptroller._setPrimeToken(prime.address);awaitprime.togglePause();return{oracle,comptroller,comptrollerLens,accessControl,usdt,vusdt,eth,veth,xvsVault,xvs,xvsStore,prime,protocolShareReserve,primeLiquidityProvider,};}describe("PoC", ()=>{letdeployer:Signer;letuser1:Signer;letuser2:Signer;letuser3:Signer;letcomptroller:MockContract<ComptrollerMock>;letprime:PrimeScenario;letvusdt:VBep20Harness;letveth:VBep20Harness;letusdt:BEP20Harness;leteth:BEP20Harness;letxvsVault:XVSVault;letxvs:XVS;letoracle:FakeContract<ResilientOracleInterface>;letprotocolShareReserve:FakeContract<IProtocolShareReserve>;letprimeLiquidityProvider:PrimeLiquidityProvider;letvbnb:VBep20Harness;letbnb:BEP20Harness;before(async()=>{[deployer,user1,user2,user3] =awaitethers.getSigners();({comptroller,prime,vusdt,veth,usdt,eth,xvsVault,xvs,oracle,protocolShareReserve,primeLiquidityProvider,} =awaitloadFixture(deployProtocol));awaitprotocolShareReserve.getUnreleasedFunds.returns("0");awaitprotocolShareReserve.getPercentageDistribution.returns("100");awaitxvs.connect(user1).approve(xvsVault.address,bigNumber18.mul(10000));awaitxvsVault.connect(user1).deposit(xvs.address,0,bigNumber18.mul(10000));awaitmine(90*24*60*60);awaitprime.connect(user1).claim();awaitxvs.connect(user2).approve(xvsVault.address,bigNumber18.mul(100));awaitxvsVault.connect(user2).deposit(xvs.address,0,bigNumber18.mul(100));awaiteth.connect(user1).approve(veth.address,bigNumber18.mul(90));awaitveth.connect(user1).mint(bigNumber18.mul(90));awaitusdt.connect(user2).approve(vusdt.address,bigNumber18.mul(9000));awaitvusdt.connect(user2).mint(bigNumber18.mul(9000));awaitcomptroller.connect(user1).enterMarkets([vusdt.address,veth.address]);awaitcomptroller.connect(user2).enterMarkets([vusdt.address,veth.address]);awaitvusdt.connect(user1).borrow(bigNumber18.mul(5));awaitveth.connect(user2).borrow(bigNumber18.mul(1));consttokenFactory=awaitethers.getContractFactory("BEP20Harness");bnb= (awaittokenFactory.deploy(bigNumber18.mul(100000000),"bnb",BigNumber.from(18),"BEP20 bnb",))asBEP20Harness;constinterestRateModelHarnessFactory=awaitethers.getContractFactory("InterestRateModelHarness");constInterestRateModelHarness= (awaitinterestRateModelHarnessFactory.deploy(BigNumber.from(18).mul(5),))asInterestRateModelHarness;constvTokenFactory=awaitethers.getContractFactory("VBep20Harness");vbnb= (awaitvTokenFactory.deploy(bnb.address,comptroller.address,InterestRateModelHarness.address,bigNumber18,"VToken bnb","vbnb",BigNumber.from(8),deployer.getAddress(),))asVBep20Harness;awaitvbnb._setReserveFactor(bigNumber16.mul(20));awaitprimeLiquidityProvider.initializeTokens([bnb.address]);oracle.getUnderlyingPrice.returns((vToken:string)=>{if(vToken==vusdt.address) {returnconvertToUnit(1,18);}elseif(vToken==veth.address) {returnconvertToUnit(1200,18);}elseif(vToken==vbnb.address) {returnconvertToUnit(300,18);}});oracle.getPrice.returns((token:string)=>{if(token==xvs.address) {returnconvertToUnit(3,18);}});consthalf=convertToUnit("0.5",8);awaitcomptroller._supportMarket(vbnb.address);awaitcomptroller._setCollateralFactor(vbnb.address,half);bnb.transfer(user3.getAddress(),bigNumber18.mul(100));awaitcomptroller._setMarketSupplyCaps([vbnb.address], [bigNumber18.mul(100)]);awaitcomptroller._setMarketBorrowCaps([vbnb.address], [bigNumber18.mul(100)]);awaitbnb.connect(user3).approve(vbnb.address,bigNumber18.mul(90));awaitvbnb.connect(user3).mint(bigNumber18.mul(90));awaitvbnb.connect(user2).borrow(bigNumber18.mul(1));awaitcomptroller._setPrimeToken(prime.address);});it("PoC",async()=>{constbob=user3;// Bob deposits XVS in the vaultawaitxvs.connect(bob).approve(xvsVault.address,bigNumber18.mul(2000));awaitxvsVault.connect(bob).deposit(xvs.address,0,bigNumber18.mul(2000));awaitprime.issue(false, [bob.getAddress()]);awaitprime.addMarket(vbnb.address,bigNumber18.mul(1),bigNumber18.mul(1));// Bob mints vBNB/deposits BNB. This calls Prime.accrueInterestAndUpdateScoreawaitbnb.connect(bob).approve(vbnb.address,bigNumber18.mul(90));awaitvbnb.connect(bob).mint(bigNumber18.mul(1));letmarket=awaitprime.markets(vbnb.address);// Expect that market.sumOfMembersScore is not 0. This means that the score was updatedexpect(market.sumOfMembersScore).to.not.equal(0);// We make the PSR.getUnreleasedFunds to return 103683. This lets Prime contract know that// there are unreleased funds and rewardIndex should be updated.awaitprotocolShareReserve.getUnreleasedFunds.returns(103683);// Call accrueInterest manually.//// Since there are unreleased funds AND the sumOfMembersScore !== 0,// the reward index should be updated.awaitprime.accrueInterest(vbnb.address);market=awaitprime.markets(vbnb.address);// The reward index should be > 0, but it is not updated.expect(market.rewardIndex).to.equal(0);});});
Recommended Mitigation Steps
Make sure that underlying token decimals are used instead of vToken decimals when calculatingcapitalinPrime._calculateScorefunction.
(uint256capital, , ) =_capitalForScore(xvsBalanceForScore,borrow,supply,market);capital=capital* (10** (18-IERC20Upgradeable(_getUnderlying(market)).decimals()));
chechu (Venus) confirmed via duplicate issue 588 and commented:
Fixed. Seehereandhere
0xDjango (Judge) commented:
Agree with high severity as the core mechanic of interest calculation is incorrect.