[H-50] CompoundStrategy attempts to transfer out a greater amount of ETH than will actually be withdrawn, leading to DoS
Submitted bykaden
Withdrawals will revert whenever there is not sufficient wrapped native tokens to cover loss from integer truncation.
Proof of Concept
CompoundStrategy._withdrawcalculates the amount of cETH to redeem withcToken.exchangeRateStoredbased on a provided amount of ETH to receive from the withdrawal.
function_withdraw(addressto,uint256amount)internaloverridenonReentrant{uint256available=_currentBalance();require(available>=amount,"CompoundStrategy: amount not valid");uint256queued=wrappedNative.balanceOf(address(this));if(amount>queued) {uint256pricePerShare=cToken.exchangeRateStored();uint256toWithdraw= (((amount-queued) * (10**18)) /pricePerShare);cToken.redeem(toWithdraw);
To understand the vulnerability, we look at theCEthercontract which we are attempting to withdraw from.
/***@noticeSender redeems cTokens in exchange for the underlying asset*@devAccrues interest whether or not the operation succeeds, unless reverted*@paramredeemTokensThe number of cTokens to redeem into underlying*@returnuint 0=success, otherwise a failure (see ErrorReporter.sol for details)*/functionredeem(uintredeemTokens)externalreturns(uint) {returnredeemInternal(redeemTokens);}
redeemreturns the result fromredeemInternal
/***@noticeSender redeems cTokens in exchange for the underlying asset*@devAccrues interest whether or not the operation succeeds, unless reverted*@paramredeemTokensThe number of cTokens to redeem into underlying*@returnuint 0=success, otherwise a failure (see ErrorReporter.sol for details)*/functionredeemInternal(uintredeemTokens)internalnonReentrantreturns(uint) {uinterror=accrueInterest();if(error!=uint(Error.NO_ERROR)) {// accrueInterest emits logs on errors, but we still want to log the fact that an attempted redeem failedreturnfail(Error(error),FailureInfo.REDEEM_ACCRUE_INTEREST_FAILED);}// redeemFresh emits redeem-specific logs on errors, so we don't need toreturnredeemFresh(msg.sender,redeemTokens,0);}
After accruing interest and checking for errors,redeemInternalreturns the result fromredeemFreshwith the amount of tokens to redeem passed as the second param.
functionredeemFresh(addresspayableredeemer,uintredeemTokensIn,uintredeemAmountIn)internalreturns(uint) {.../* exchangeRate = invoke Exchange Rate Stored() */(vars.mathErr,vars.exchangeRateMantissa) =exchangeRateStoredInternal();.../* If redeemTokensIn > 0: */if(redeemTokensIn>0) {/** We calculate the exchange rate and the amount of underlying to be redeemed:*  redeemTokens = redeemTokensIn*  redeemAmount = redeemTokensIn x exchangeRateCurrent*/vars.redeemTokens=redeemTokensIn;(vars.mathErr,vars.redeemAmount) =mulScalarTruncate(Exp({mantissa:vars.exchangeRateMantissa}),redeemTokensIn);if(vars.mathErr!=MathError.NO_ERROR) {returnfailOpaque(Error.MATH_ERROR,FailureInfo.REDEEM_EXCHANGE_TOKENS_CALCULATION_FAILED,uint(vars.mathErr));}...vars.err=doTransferOut(redeemer,vars.redeemAmount);...}
redeemFreshretrieves the exchange rate (the same one thatCompoundStrategy._withdrawuses to calculate the amount to redeem), and uses it to calculatevars.redeemAmountwhich is later transferred to theredeemer. This is the amount of underlying ETH that we are redeeming theCEthertokens for.
We can carefully copy over the logic used inCEtherto calculate the amount of underlying ETH to receive, as well as the logic used inCompoundStrategy._withdrawto determine how manyCEtherto redeem for the desired output amount of underlying ETH, creating the following test contract in Remix.
pragma solidity 0.8.19;contract MatchCalcs {uint constant expScale = 1e18;struct Exp {uint mantissa;}function mulScalarTruncate(Exp memory a, uint scalar) pure external returns (uint) {return truncate(mulScalar(a, scalar));}function mulScalar(Exp memory a, uint scalar) pure internal returns (Exp memory) {uint256 scaledMantissa = mulUInt(a.mantissa, scalar);return Exp({mantissa: scaledMantissa});}function mulUInt(uint a, uint b) internal pure returns (uint) {if (a == 0) {return 0;}uint c = a * b;if (c / a != b) {return 0;} else {return c;}}function truncate(Exp memory exp) pure internal returns (uint) {// Note: We are not using careful math here as we're performing a division that cannot failreturn exp.mantissa / expScale;}function getToWithdraw(uint256 amount, uint256 exchangeRate) pure external returns (uint) {return amount * (10 ** 18) / exchangeRate;}}
We run the following example with the currentexchangeRateStored(at the time of writing) of200877136531571418792530957and an output amount of underlying ETH to receive of 1e18 on the functiongetToWithdraw, receiving an output of4978167337CEther. This is the amount ofCEtherthat would be passed toCEther.redeem.
Next we can see the output amount of underlying ETH according toCEthers logic. We pass the sameexchangeRateStoredvalue and the amount ofCEtherto redeem:4978167337, receiving an output amount of999999999831558306, less than the intended amount of 1e18.
Since we receive less than intended to receive fromCEther.redeem, the_withdrawcall likely fails at the following check:
require(wrappedNative.balanceOf(address(this)) >=amount,"CompoundStrategy: not enough");
Recommended Mitigation Steps
Rather than computing an amount ofCEtherto redeem, we can instead use theCEther.redeemUnderlyingfunction to receive our intended amount of underlying ETH.
cryptotechmaker (Tapioca) confirmed