[H-02] A registered contract won’t earn fees if_recipientis a fresh address
Submitted byJeiwan, also found byronnyx2017
Users might become victims of a false positive: if they use a fresh account as an NFT recipient during contract registration, the transaction won’t revert, but the registered contract will never earn fees for the token holder. And since a contract can be registered only once, there won’t be a way for affected users to re-register contracts and start earning fees. This can affect both bigger and smaller projects that register their contracts with the Turnstile contract: the only condition for the bug to happen is that the recipient address that’s used during registration is a fresh address (i.e. an address that hasn’t been used yet).
Proof of Concept
Theregisterfunction allows the calling contract to specify the address that will receive the freshly minted NFT (Turnstile.sol#L86):
functionregister(address_recipient)publiconlyUnregisteredreturns(uint256tokenId) {addresssmartContract=msg.sender;if(_recipient==address(0))revertInvalidRecipient();tokenId=_tokenIdTracker.current();_mint(_recipient,tokenId);_tokenIdTracker.increment();emitRegister(smartContract,_recipient,tokenId);feeRecipient[smartContract] =NftData({tokenId:tokenId,registered:true});}
A recipient address can be any address besides the zero address. However, on the consensus layer, there’s a stricter requirement (event_handler.go#L31-L33): a recipient address cannot be afresh account, that is an address that:
hasn’t ever received native coins;hasn’t ever sent a transaction;hasn’t ever had contract code.
While, on the application layer, calling theregisterfunction with a fresh address will succeed, on the consensus layer a contract won’t be registered.
When aRegisterevent is processed on the consensus layer, there’s a check that requires that the recipient address is anexisting accountin the state database (event_handler.go#L31-L33):
// Check that the receiver account  exists in the evm storeifacct:= k.evmKeeper.GetAccount(ctx, event.Recipient); acct ==nil{returnsdkerrors.Wrapf(ErrNonexistentAcct,"EventHandler::RegisterEvent account does not exist: %s", event.Recipient)}
If the recipient account doesn’t exist, the function will return, but the register transaction won’t revert (errors during the events processing doesn’t result in a revert:evm_hooks.go#L123-L132,evm_hooks.go#L49).
TheGetAccountfunction above returnsnilwhen an address doesn’t exist in the state database. To see this, we need to unwind theGetAccountexecution:
TheGetAccountis called on anevmKeeper(event_handler.go#L31):ifacct:= k.evmKeeper.GetAccount(ctx, event.Recipient); acct ==nil{returnsdkerrors.Wrapf(ErrNonexistentAcct,"EventHandler::RegisterEvent account does not exist: %s", event.Recipient)}evmKeeperis set during the CSR Keeper initialization (keeper.go#L27):funcNewKeeper(cdc codec.BinaryCodec,storeKey sdk.StoreKey,ps paramtypes.Subspace,accountKeeper types.AccountKeeper,evmKeeper types.EVMKeeper,bankKeeper types.BankKeeper,FeeCollectorNamestring,) Keeper {// set KeyTable if it has not already been setif!ps.HasKeyTable() {ps= ps.WithKeyTable(types.ParamKeyTable())}returnKeeper{storeKey:         storeKey,cdc:              cdc,paramstore:       ps,accountKeeper:    accountKeeper,evmKeeper:        evmKeeper,bankKeeper:       bankKeeper,FeeCollectorName: FeeCollectorName,}}The CSR Keeper is initialized during the main app initialization (app.go#L473-L478), this is also when the EVM Keeper is initialized (app.go#L409-L413):app.EvmKeeper= evmkeeper.NewKeeper(appCodec, keys[evmtypes.StoreKey], tkeys[evmtypes.TransientKey], app.GetSubspace(evmtypes.ModuleName),app.AccountKeeper, app.BankKeeper, &stakingKeeper, app.FeeMarketKeeper,tracer,)The EVM Keeper is implemented and imported from Ethermint (keeper.go#L67);Here’s theGetAccountfunction (statedb.go#L25):func(k *Keeper)GetAccount(ctx sdk.Context, addr common.Address) *statedb.Account {acct:= k.GetAccountWithoutBalance(ctx, addr)ifacct ==nil{returnnil}acct.Balance= k.GetBalance(ctx, addr)returnacct}TheGetAccountWithoutBalancefunction callsGetAccountonaccountKeeper(keeper.go#L255-L258):acct:= k.accountKeeper.GetAccount(ctx, cosmosAddr)ifacct ==nil{returnnil}The Account Keeper is implemented in the Cosmos SDK (account.go#L41-L49):func(ak AccountKeeper)GetAccount(ctx sdk.Context, addr sdk.AccAddress) types.AccountI {store:= ctx.KVStore(ak.storeKey)bz:= store.Get(types.AddressStoreKey(addr))ifbz ==nil{returnnil}returnak.decodeAccount(bz)}It basically reads an account from the store passed in the context object (context.go#L280-L282);In the Account Keeper, there’s alsoSetAccountfunction (account.go#L72), and it’s called in Ethermint by the EVM Keeper (statedb.go#L126);The EVM Keeper’sSetAccountis called when transaction changes are committed to the state database (statedb.go#L449);The state database is a set of state objects, where keys are account addresses and values are accounts themselves;ThegetOrNewStateObjectfunction initializes new state objects (statedb.go#L221-L227);getOrNewStateObjectis only called by these functions:AddBalance,SubBalance,SetNonce,SetCode,SetState(statedb.go#L290-L328).
Thus, a new account object in the state database is only created when an address receives native coins, sends a transaction (which increases the nonce), or when contract code is deployed at it.
Example Exploit Scenario
Alice deploys a smart contract that attracts a lot of users.Alice registers the contract in Turnstile. As a recipient contract for the NFT, Alice decides to use a dedicated address that hasn’t been used for anything else before (hasn’t received coins, hasn’t sent a transaction, etc.).Theregisterfunction call succeeds and Alice’s contract gets registered in Turnstile.However, due to the “only existing recipient account” check on the consensus layer, Alice’s contract wasn’t registered on the consensus layer and doesn’t earn fees.Sinceregisterandassigncan only be called once (due to theonlyUnregisteredmodifier), Alice cannot re-register her contract. She can transfer the NFT to a different address, however this won’t make the contract registered on the consensus layer and the owner of the NFT will never receive fees.
Recommended Mitigation Steps
Consider removing the “only existing recipient account” check in theRegisterEventhandler since it creates a discrepancy between the application and the consensus layers. Otherwise, if it’s mandatory that receiver addresses are not fresh, consider returning an error in thePostTxProcessinghook (which will revert a transaction) if there was an error during events processing.
tkkwon1998 (Canto) confirmed and commented:
This is certainly an issue as there is a mismatch in checks between app and consensus layers.