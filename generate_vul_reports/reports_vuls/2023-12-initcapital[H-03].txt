[H-03]_handleRepayofMoneyMarketHookdoes not consider the actual debt shares of theposIdinside the position manager and could lead to a user’s tokens getting stuck inside the hook
Submitted bysaid
When users construct repay operations viaMoneyMarketHook, it doesn’t consider the actual debt shares of the position inside theInitCoreandPosManager. This could lead to users’ tokens getting stuck inside theMoneyMarketHookcontract.
Proof of Concept
When users want to repay his positions inMoneyMarketHook, they can provide the parameters insiderepayParams, andMoneyMarketHookwill construct the operation via_handleRepayfunction.
https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/hook/MoneyMarketHook.sol#L145-L159
function_handleRepay(uint_offset,bytes[]memory_data,uint_initPosId,RepayParams[]memory_params)internalreturns(uint,bytes[]memory){for(uinti;i<_params.length;i=i.uinc()) {addressuToken=ILendingPool(_params[i].pool).underlyingToken();>>>uintrepayAmt=ILendingPool(_params[i].pool).debtShareToAmtCurrent(_params[i].shares);_ensureApprove(uToken,repayAmt);>>>IERC20(uToken).safeTransferFrom(msg.sender,address(this),repayAmt);_data[_offset] =abi.encodeWithSelector(IInitCore.repay.selector,_params[i].pool,_params[i].shares,_initPosId);_offset=_offset.uinc();}return(_offset,_data);}
It can be observed that it calculates therepayAmtbased on the shares provided by the users and transfers the corresponding amount of tokens from the sender to the hook. However, the actual debt shares of the position can be less than the_params[i].sharesprovided by users. This means that the actual repay amount of tokens needed could be less than the calculatedrepayAmt.
https://github.com/code-423n4/2023-12-initcapital/blob/main/contracts/core/InitCore.sol#L530-L551
function_repay(IConfig_config,uint16_mode,uint_posId,address_pool,uint_shares)internalreturns(addresstokenToRepay,uintamt){// check status_require(_config.getPoolConfig(_pool).canRepay&&_config.getModeStatus(_mode).canRepay,Errors.REPAY_PAUSED);// get position debt share>>>uintpositionDebtShares=IPosManager(POS_MANAGER).getPosDebtShares(_posId,_pool);>>>uintsharesToRepay=_shares<positionDebtShares?_shares:positionDebtShares;// get amtToRepay (accrue interest)>>>uintamtToRepay=ILendingPool(_pool).debtShareToAmtCurrent(sharesToRepay);// take token from msg.sender to pooltokenToRepay=ILendingPool(_pool).underlyingToken();>>>IERC20(tokenToRepay).safeTransferFrom(msg.sender,_pool,amtToRepay);// update debt on the positionIPosManager(POS_MANAGER).updatePosDebtShares(_posId,_pool, -sharesToRepay.toInt256());// call repay on the poolamt=ILendingPool(_pool).repay(sharesToRepay);// update debt on modeIRiskManager(riskManager).updateModeDebtShares(_mode,_pool, -sharesToRepay.toInt256());emitRepay(_pool,_posId,msg.sender,_shares,amt);}
Consider a scenario where the user’s positions are currently liquidatable, and the user wishes to repay all of the position’s debt inside theMoneyMarketHook. However, a liquidator front-runs the operation by liquidating the user’s position. Now, when the repayment operation executes fromMoneyMarketHook, it transfers therepayAmtto theMoneyMarketHookbut the amount is not used/fully utilized and becomes stuck inside the contract.
Recommended Mitigation Steps
Consider to also check the provided shares against the actual debt shares inside theInitCore/PosManager.
fez-init (INIT) confirmed, but disagreed with severity and commented:
The issue should be medium, since the funds cannot be retrieved by someone else. The hook will be upgradeable, so if funds actually get stuck, it is still retrievable.
hansfriese (Judge) commented:
I agree that this issue is in the middle of Medium and High.
Users might face a temporary lock on their funds, and the hook should be upgraded every time to unlock them.Given the high probability of this scenario occurring, I will keep this issue as a valid High.