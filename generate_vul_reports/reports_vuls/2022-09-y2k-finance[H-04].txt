[H-04] Users who deposit in one vault can lose all deposits and receive nothing when counterparty vault has no deposits
Submitted by rbserver, also found by 0x52, carrotsmuggler, Ch_301, imare, Jeiwan, ladboy233, Lambda, Tointer, unforgiven, and wagmi
https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L148-L192
https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L350-L352
https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L203-L234
https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L378-L426
Impact
For a market, if users only deposit in the hedge vault or only deposit in the risk vault but not in both, then these users will lose their deposits and receive nothing when they call the followingwithdrawfunction after the depeg event occurs.
If the vault that has deposits is called Vault A, and the counterparty vault that has no deposit is called Vault B, then:
As shown by thetriggerDepegfunction below, when executinginsrVault.sendTokens(epochEnd, address(riskVault))andriskVault.sendTokens(epochEnd, address(insrVault)), the deposits of Vault A are transferred to Vault B but nothing is transferred to Vault A since Vault B has no deposit;WhentriggerDepegexecutesinsrVault.setClaimTVL(epochEnd, riskVault.idFinalTVL(epochEnd))andriskVault.setClaimTVL(epochEnd, insrVault.idFinalTVL(epochEnd)), Vault B’sidClaimTVL[id]is set to Vault A’sidFinalTVL(epochEnd))but Vault A’sidClaimTVL[id]is set to 0 because Vault B’sidFinalTVL(epochEnd)is 0.
Because of these, calling thebeforeWithdrawfunction below will return a 0entitledAmount, and callingwithdrawthen transfers that 0 amount to the user who has deposited. As a result, these users’ deposits are transferred to the counterparty vault, and they receive nothing at all.
https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Controller.sol#L148-L192
functiontriggerDepeg(uint256marketIndex,uint256epochEnd)publicisDisaster(marketIndex,epochEnd){address[]memoryvaultsAddress=vaultFactory.getVaults(marketIndex);VaultinsrVault=Vault(vaultsAddress[0]);VaultriskVault=Vault(vaultsAddress[1]);//require this function cannot be called twice in the same epoch for the same vaultif(insrVault.idFinalTVL(epochEnd) !=0)revertNotZeroTVL();if(riskVault.idFinalTVL(epochEnd) !=0)revertNotZeroTVL();insrVault.endEpoch(epochEnd,true);riskVault.endEpoch(epochEnd,true);insrVault.setClaimTVL(epochEnd,riskVault.idFinalTVL(epochEnd));riskVault.setClaimTVL(epochEnd,insrVault.idFinalTVL(epochEnd));insrVault.sendTokens(epochEnd,address(riskVault));riskVault.sendTokens(epochEnd,address(insrVault));VaultTVLmemorytvl=VaultTVL(riskVault.idClaimTVL(epochEnd),insrVault.idClaimTVL(epochEnd),riskVault.idFinalTVL(epochEnd),insrVault.idFinalTVL(epochEnd));emitDepegInsurance(keccak256(abi.encodePacked(marketIndex,insrVault.idEpochBegin(epochEnd),epochEnd)),tvl,true,epochEnd,block.timestamp,getLatestPrice(insrVault.tokenInsured()));}
https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L350-L352
functionsetClaimTVL(uint256id,uint256claimTVL)publiconlyController{idClaimTVL[id] =claimTVL;}
https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L203-L234
functionwithdraw(uint256id,uint256assets,addressreceiver,addressowner)externaloverrideepochHasEnded(id)marketExists(id)returns(uint256shares){if(msg.sender!=owner&&isApprovedForAll(owner,receiver) ==false)revertOwnerDidNotAuthorize(msg.sender,owner);shares=previewWithdraw(id,assets);// No need to check for rounding error, previewWithdraw rounds up.uint256entitledShares=beforeWithdraw(id,shares);_burn(owner,id,shares);//Taking fee from the amountuint256feeValue=calculateWithdrawalFeeValue(entitledShares,id);entitledShares=entitledShares-feeValue;asset.transfer(treasury,feeValue);emitWithdraw(msg.sender,receiver,owner,id,assets,entitledShares);asset.transfer(receiver,entitledShares);returnentitledShares;}
https://github.com/code-423n4/2022-09-y2k-finance/blob/main/src/Vault.sol#L378-L426
functionbeforeWithdraw(uint256id,uint256amount)publicviewreturns(uint256entitledAmount){// in case the risk wins aka no depeg event// risk users can withdraw the hedge (that is paid by the hedge buyers) and risk; withdraw = (risk + hedge)// hedge pay for each hedge seller = ( risk / tvl before the hedge payouts ) * tvl in hedge pool// in case there is a depeg event, the risk users can only withdraw the hedgeif(keccak256(abi.encodePacked(symbol)) ==keccak256(abi.encodePacked("rY2K"))) {if(!idDepegged[id]) {//depeg event did not happen/*entitledAmount =(amount / idFinalTVL[id]) *idClaimTVL[id] +amount;*/entitledAmount=amount.divWadDown(idFinalTVL[id]).mulDivDown(idClaimTVL[id],1ether) +amount;}else{//depeg event did happenentitledAmount=amount.divWadDown(idFinalTVL[id]).mulDivDown(idClaimTVL[id],1ether);}}// in case the hedge wins aka depegging// hedge users pay the hedge to risk users anyway,// hedge guy can withdraw risk (that is transfered from the risk pool),// withdraw = % tvl that hedge buyer owns// otherwise hedge users cannot withdraw any Ethelse{entitledAmount=amount.divWadDown(idFinalTVL[id]).mulDivDown(idClaimTVL[id],1ether);}returnentitledAmount;}
Proof of Concept
Please append the following tests intest\AssertTest.t.sol. These tests will pass to demonstrate the described scenarios.
functiontestWithdrawFromRiskAfterDepegWhenThereIsNoCounterparty()public{vm.deal(chad,AMOUNT*CHAD_MULTIPLIER);vm.startPrank(admin);FakeOraclefakeOracle=newFakeOracle(oracleFRAX,STRIKE_PRICE_FAKE_ORACLE);vaultFactory.createNewMarket(FEE,tokenFRAX,DEPEG_AAA,beginEpoch,endEpoch,address(fakeOracle),"y2kFRAX_99*");vm.stopPrank();addresshedge=vaultFactory.getVaults(1)[0];addressrisk=vaultFactory.getVaults(1)[1];VaultvHedge=Vault(hedge);VaultvRisk=Vault(risk);// chad deposits in risk vault, and no one deposits in hedge vaultvm.startPrank(chad);ERC20(WETH).approve(risk,AMOUNT*CHAD_MULTIPLIER);vRisk.depositETH{value:AMOUNT*CHAD_MULTIPLIER}(endEpoch,chad);assertTrue(vRisk.balanceOf(chad,endEpoch) == (AMOUNT*CHAD_MULTIPLIER));vm.stopPrank();vm.warp(beginEpoch+10days);// depeg occurscontroller.triggerDepeg(SINGLE_MARKET_INDEX,endEpoch);vm.startPrank(chad);// chad withdraws from risk vaultuint256assets=vRisk.balanceOf(chad,endEpoch);vRisk.withdraw(endEpoch,assets,chad,chad);assertTrue(vRisk.balanceOf(chad,endEpoch) ==NULL_BALANCE);uint256entitledShares=vRisk.beforeWithdraw(endEpoch,assets);assertTrue(entitledShares-vRisk.calculateWithdrawalFeeValue(entitledShares,endEpoch) ==ERC20(WETH).balanceOf(chad));// chad receives nothingassertEq(entitledShares,0);assertEq(ERC20(WETH).balanceOf(chad),0);vm.stopPrank();}
functiontestWithdrawFromHedgeAfterDepegWhenThereIsNoCounterparty()public{vm.deal(alice,AMOUNT);vm.startPrank(admin);FakeOraclefakeOracle=newFakeOracle(oracleFRAX,STRIKE_PRICE_FAKE_ORACLE);vaultFactory.createNewMarket(FEE,tokenFRAX,DEPEG_AAA,beginEpoch,endEpoch,address(fakeOracle),"y2kFRAX_99*");vm.stopPrank();addresshedge=vaultFactory.getVaults(1)[0];addressrisk=vaultFactory.getVaults(1)[1];VaultvHedge=Vault(hedge);VaultvRisk=Vault(risk);// alice deposits in hedge vault, and no one deposits in risk vaultvm.startPrank(alice);ERC20(WETH).approve(hedge,AMOUNT);vHedge.depositETH{value:AMOUNT}(endEpoch,alice);assertTrue(vHedge.balanceOf(alice,endEpoch) == (AMOUNT));vm.stopPrank();vm.warp(beginEpoch+10days);// depeg occurscontroller.triggerDepeg(SINGLE_MARKET_INDEX,endEpoch);vm.startPrank(alice);// alice withdraws from hedge vaultuint256assets=vHedge.balanceOf(alice,endEpoch);vHedge.withdraw(endEpoch,assets,alice,alice);assertTrue(vHedge.balanceOf(alice,endEpoch) ==NULL_BALANCE);uint256entitledShares=vHedge.beforeWithdraw(endEpoch,assets);assertTrue(entitledShares-vHedge.calculateWithdrawalFeeValue(entitledShares,endEpoch) ==ERC20(WETH).balanceOf(alice));// alice receives nothingassertEq(entitledShares,0);assertEq(ERC20(WETH).balanceOf(alice),0);vm.stopPrank();}
Tools Used
VSCode
Recommended Mitigation Steps
When users only deposit in one vault, and no one deposits in the counterparty vault, the insurance practice of hedging and risking actually does not exist. In this situation, after the epoch is started, the users, who have deposited, should be allowed to withdraw their full deposit amounts.
3xHarry (Y2K Finance) confirmed