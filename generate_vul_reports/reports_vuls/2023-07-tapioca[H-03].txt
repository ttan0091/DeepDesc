[H-03] The amount of debt removed duringliquidationmay be worth more than the account’s collateral
Submitted byItsNio
The contract decreases user’s debts but may not take the full worth in collateral from the user, leading to the contract losing potential funds from the missing collateral.
Proof of concept
During theliquidate()function call, the function_updateBorrowAndCollateralShare()is eventually invoked. This function liquidates a user’s debt and collateral based on the value of thecollateralthey own.
In particular, the equivalent amount of debt,availableBorrowPartis calculated from the user’s collateral on line 225 through thecomputeClosingFactor()function call.
Then, an additional fee through theliquidationBonusAmountis applied to the debt, which is then compared to the user’s debt on line 240. The minimum of the two is assignedborrowPart, which intuitively means the maximum amount of debt that can be removed from the user’s debt.
borrowPartis then increased by a bonus throughliquidationMultiplier, and then converted to generatecollateralShare, which represents the amount of collateral equivalent in value toborrowPart(plus some fees and bonus).
This newcollateralSharemay be more than the collateral that the user owns. In that case, thecollateralShareis simply decreased to the user’s collateral.
collateralShareis then removed from the user’s collateral.
The problem lies in that although thecollateralShareis equivalent to theborrowPart, or the debt removed from the user’s account, it could be worth more than the collateral that the user owns in the first place. Hence, the contract loses out on funds, as debt is removed for less than it is actually worth.
To demonstrate, we provide a runnable POC.
Preconditions
...if(collateralShare>userCollateralShare[user]) {require(false,"collateralShare and borrowPart not worth the same");//@audit add this linecollateralShare=userCollateralShare[user];}userCollateralShare[user] -=collateralShare;...
Add therequirestatement to line261. This require statement essentially reverts the contract when theifcondition satisfies. Theifcondition holds true when thecollateralShareis greater that the user’s collateral, which is the target bug.
Once the changes have been made, add the following test into thesingularity.test.tstest intapioca-bar-audit/test
Code
it('POC',async()=>{const{usdc,wbtc,yieldBox,wbtcDepositAndAddAsset,usdcDepositAndAddCollateralWbtcSingularity,eoa1,approveTokensAndSetBarApproval,deployer,wbtcUsdcSingularity,multiSwapper,wbtcUsdcOracle,__wbtcUsdcPrice,} =awaitloadFixture(register);constassetId=awaitwbtcUsdcSingularity.assetId();constcollateralId=awaitwbtcUsdcSingularity.collateralId();constwbtcMintVal=ethers.BigNumber.from((1e8).toString()).mul(1);constusdcMintVal=wbtcMintVal.mul(1e10).mul(__wbtcUsdcPrice.div((1e18).toString()));// We get assetawaitwbtc.freeMint(wbtcMintVal);awaitusdc.connect(eoa1).freeMint(usdcMintVal);// We approve external operatorsawaitapproveTokensAndSetBarApproval();awaitapproveTokensAndSetBarApproval(eoa1);// We lend WBTC as deployerawaitwbtcDepositAndAddAsset(wbtcMintVal);expect(awaitwbtcUsdcSingularity.balanceOf(deployer.address),).to.be.equal(awaityieldBox.toShare(assetId,wbtcMintVal,false));// We deposit USDC collateralawaitusdcDepositAndAddCollateralWbtcSingularity(usdcMintVal,eoa1);expect(awaitwbtcUsdcSingularity.userCollateralShare(eoa1.address),).equal(awaityieldBox.toShare(collateralId,usdcMintVal,false));// We borrow 74% collateral, max is 75%console.log("Collateral amt: ",usdcMintVal);constwbtcBorrowVal=usdcMintVal.mul(74).div(100).div(__wbtcUsdcPrice.div((1e18).toString())).div(1e10);console.log("WBTC borrow val: ",wbtcBorrowVal);console.log("[$] Original price: ",__wbtcUsdcPrice.div((1e18).toString()));awaitwbtcUsdcSingularity.connect(eoa1).borrow(eoa1.address,eoa1.address,wbtcBorrowVal.toString());awaityieldBox.connect(eoa1).withdraw(assetId,eoa1.address,eoa1.address,wbtcBorrowVal,0,);constdata=newethers.utils.AbiCoder().encode(['uint256'], [1]);// Can't liquidateawaitexpect(wbtcUsdcSingularity.liquidate([eoa1.address],[wbtcBorrowVal],multiSwapper.address,data,data,),).to.be.reverted;console.log("Price Drop: 120%");constpriceDrop=__wbtcUsdcPrice.mul(40).div(100);awaitwbtcUsdcOracle.set(__wbtcUsdcPrice.add(priceDrop));awaitwbtcUsdcSingularity.updateExchangeRate()console.log("Running liquidation... ");awaitexpect(wbtcUsdcSingularity.liquidate([eoa1.address],[wbtcBorrowVal],multiSwapper.address,data,data,),).to.be.revertedWith("collateralShare and borrowPart not worth the same");console.log("[*] Reverted with reason: collateralShare and borrowPart not worth the same [Bug]");//console.log("Collateral Share after liquidation: ", (await wbtcUsdcSingularity.userCollateralShare(eoa1.address)));//console.log("Borrow part after liquidation: ", (await wbtcUsdcSingularity.userBorrowPart(eoa1.address)));});
Expected Result
Collateral amt:  BigNumber { value:"10000000000000000000000"}WBTC borrow val:  BigNumber { value:"74000000"}[$] Original price:  BigNumber { value:"10000"}Price Drop: 120%Running liquidation...[*] Reverted with reason: collateralShare and borrowPart not worth the same [Bug]✔ POC (2289ms)
As demonstrated, the function call reverts due to therequirestatement added in the preconditions.
Recommended Mitigation
One potential mitigation for this issue would be to calculate theborrowPartdepending on the existing users’ collateral factoring in the fees and bonuses. ThecollateralSharewith the fees and bonuses should not exceed the user’s collateral.
cryptotechmaker (Tapioca) confirmed