[H-03] Freeze The Bridge Via Large ERC20 Names/Symbols/Denoms
Submitted by nascent
Ethereum Oracles watch for events on theGravity.solcontract on the Ethereum blockchain. This is performed in thecheck_for_eventsfunction, and run in theeth_oracle_main_loop.
In this function, there isthe following code snippet:
leterc20_deployed = web3.check_for_events(starting_block.clone(),Some(latest_block.clone()),vec![gravity_contract_address],vec![ERC20_DEPLOYED_EVENT_SIG],).await;
This snippet leverages theweb30library to check for events from thestarting_blockto thelatest_block. Inside theweb30library this nets out to calling:
pubasyncfneth_get_logs(&self, new_filter: NewFilter) ->Result<Vec<Log>, Web3Error> {self.jsonrpc_client.request_method("eth_getLogs",vec![new_filter],self.timeout,Some(10_000_000),).await}
The10_000_000specifies the maximum size of the return in bytes and returns an error if the return is larger:
letres: Response<R> =matchres.json().limit(limit).await{Ok(val) => val,Err(e) =>returnErr(Web3Error::BadResponse(format!("Web3 Error {}", e))),};
This can be triggered at will and keep the loop in a perpetual state of returning theGravityError::EthereumRestError(Web3Error::BadResponse( "Failed to get logs!".to_string()))error. To force the node into this state, you just have to deploy ERC20s generated by thepublic function inGravity.sol:
functiondeployERC20(stringmemory_cosmosDenom,stringmemory_name,stringmemory_symbol,uint8_decimals)public{// Deploy an ERC20 with entire supply granted to Gravity.solCosmosERC20erc20=newCosmosERC20(address(this),_name,_symbol,_decimals);// Fire an event to let the Cosmos module knowstate_lastEventNonce=state_lastEventNonce.add(1);emitERC20DeployedEvent(_cosmosDenom,address(erc20),_name,_symbol,_decimals,state_lastEventNonce);}
And specify a large string as the denom, name, or symbol.
If an attacker uses the denom as the attack vector, they save significant gas costing just 256 per additional 32 bytes. For other cases, to avoid gas overhead, you can have the string be mostly 0s resulting in just 584 gas per additional 32 bytes. This leaves it feasible to surpass the 10mb response data in the 6 block buffer. This would throw every ethereum oracle into a state of perpetual errors and all would fall out of sync with the ethereum blockchain. This would result in the batches, logic calls, deposits, ERC20 creations, andvalsetupdates to never receive attestations from other validators because their ethereum oracles would be down; the bridge would be frozen and remain frozen until the bug is fixed due toget_last_checked_block.
This will freeze the bridge by disallowing attestations to take place.
This requires a patch to reenable the bridge.
Recommendation
Handle the error more concretely and check if you got a byte limit error. If you did, chunk the search size into 2 and try again. Repeat as necessary, and combine the results.
Additionally, you could require that validators sign ERC20 creation requests.
jkilpatr (Althea) confirmed:
Excellent bug report.I just ran into the buffer limit issue this morning with an Ethereum block. I agree handling this error correctly is essential to long term reliability.
albertchon (judge) commented:
Nice :)