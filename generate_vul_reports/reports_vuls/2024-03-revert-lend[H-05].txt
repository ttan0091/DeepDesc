[H-05]_getReferencePoolPriceX96()will show incorrect price for negative tick deltas in current implementation cause it doesn’t round up for them
Submitted byBauchibred, also found by grearlake (1,2),Giorgio, andkodyvim
Take a lookhere.
function_getReferencePoolPriceX96(IUniswapV3Poolpool,uint32twapSeconds)internalviewreturns(uint256) {uint160sqrtPriceX96;// if twap seconds set to 0 just use pool priceif(twapSeconds==0) {(sqrtPriceX96,,,,,,) =pool.slot0();}else{uint32[]memorysecondsAgos=newuint32[](2);secondsAgos[0] =0;// from (before)secondsAgos[1] =twapSeconds;// from (before)(int56[]memorytickCumulatives,) =pool.observe(secondsAgos);// pool observe may fail when there is not enough history available (only use pool with enough history!)//@auditint24tick=int24((tickCumulatives[0] -tickCumulatives[1]) /int56(uint56(twapSeconds)));sqrtPriceX96=TickMath.getSqrtRatioAtTick(tick);}returnFullMath.mulDiv(sqrtPriceX96,sqrtPriceX96,Q96);}
This function is used to calculate the reference pool price. It uses either the latest slot price or TWAP based on twapSeconds.
Now note thatunlike the original uniswap implementation, here the delta of the tick cumulative is being calculated in a different manner, i.eprotocol implements (tickCumulatives[0] -tickCumulatives[1]instead oftickCumulatives[1] - (tickCumulatives[0]which is because here,secondsAgos[0] = 0;andsecondsAgos[1] = twapSeconds;; unlikein Uniswap OracleLibrarywheresecondsAgos[0] = secondsAgo;andsecondsAgos[1] = 0;, so everything checks out and the tick deltas are calculated accurately, i.e in our casetickCumulativesDelta = tickCumulatives[0] - tickCumulatives[1].
The problem now is that in the case if ourtickCumulativesDeltais negative, i.eint24(tickCumulatives[0] - tickCumulatives[1] < 0), then the tick should be rounded down, as it’s done in theuniswap library.
But this is not being done and as a result, in the case ifint24(tickCumulatives[0] - tickCumulatives[1])is negative and(tickCumulatives[0] - tickCumulatives[1]) % secondsAgo != 0, then the returned tick will be bigger then it should be; which opens possibility for some price manipulations and arbitrage opportunities.
Impact
In this case, ifint24(tickCumulatives[0] - tickCumulatives[1])is negative and((tickCumulatives[0] - tickCumulatives[1]) % secondsAgo != 0, then returned tick will be bigger than it should be which places protocol wanting prices to be right not be able to achieve this goal. Note that whereas protocol in some cases relies on multiple sources of price, they still come down and end on weighing the differences between the prices and reverting if a certain limit is passed (MIN_PRICE_DIFFERENCE) between both the Chainlink price and Uniswap twap price.Now in the case where the implementedpricing mode is onlyTWAP, then the protocol would work with a flawed price since the returned price would be different than it really is; potentially leading to say, for example, some positions that should be liquidatable not being liquidated. Before liquidation, there isa check to see if the loan is healthy. Now this checkqueries the value of this asset via getValue()and if returned price is wrong then unhealthy loans could be pronounced as healthy and vice versa.Also, this indirectly curbs the access to functions likeborrow(),transform()anddecreaseLiquidityAndCollect(), since they all make a call to_requireLoanIsHealthy(), which would be unavailable due to it’s dependence on_checkLoanIsHealthy().This bug case causes the Automator’s_getTWAPTick()function to also return a wrong tick, which then leads to_hasMaxTWAPTickDifference()returning false data, since the difference would now be bigger eventually leading towronglydisabling/enabling of swaps inAutoCompound.sol, whereas, it should be otherwise.
Note that for the second/third case, the call route to get to_getReferencePoolPriceX96()is:"_checkLoanIsHealthy() -> getValue() -> _getReferenceTokenPriceX96 -> _getTWAPPriceX96 -> _getReferencePoolPriceX96() "as can be seenhere.
Tools Used
Uniswap V3’s OracleLibrary.And a similar finding onCode4renafrom Q1 2024.
Recommended Mitigation Steps
Add this line:if (tickCumulatives[0] - tickCumulatives[1] < 0 && (tickCumulatives[0] - tickCumulatives[1]) % secondsAgo != 0) timeWeightedTick --;.
Assessed type
Uniswap
kalinbas (Revert) confirmed
Revert mitigated:
PRhere- fixed calculation.
Status:Mitigation confirmed. Full details in reports fromthank_you,b0g0andktg.