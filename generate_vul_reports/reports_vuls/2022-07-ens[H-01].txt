[H-01] It is possible to create fake ERC1155NameWrappertoken for subdomain, which is not owned byNameWrapper
Submitted by panprog, also found by Aussie_Battlers, brgltd, cryptphi, peritoflores, and wastewa
NameWrapper.sol#L820-L821NameWrapper.sol#L524NameWrapper.sol#L572
Due to re-entrancy possibility inNameWrapper._transferAndBurnFuses(called fromsetSubnodeOwnerandsetSubnodeRecord), it is possible to do some stuff inonERC1155Receivedright after transfer but before new owner and new fuses are set. This makes it possible, for example, to unwrap the subdomain, but owner and fuses will still be set even for unwrapped domain, creating fakeERC1155NameWrappertoken for domain, which is not owned byNameWrapper.
Fake token creation scenario:
Account1registers and wrapstest.ethdomainAccount1callsNameWrapper.setSubnodeOwnerforsub.test.ethsubdomain withAccount1as owner (to make NameWrapper owner of subdomain)Contract1smart contract is created, which calls unwrap in itsonERC1155Receivedfunction, and a function to sendsub.test.ethERC1155 NameWrapper token back toAccount1Account1callsNameWrapper.setSubnodeOwnerforsub.test.ethwithContract1as new owner, which unwraps domain back toAccount1but due to re-entrancy, NameWrapper sets fuses and ownership toContract1Account1calls function to send ERC1155 token fromContract1back to self.
After this sequence of events,sub.test.ethsubdomain is owned byAccount1both inENSregistry and inNameWrapper(with fuses and expiry correctly set to the future date). Lots (but not all) of functions inNameWrapperwill fail to execute for this subdomain, because they expectNameWrapperto have ownership of the domain inENS, but some functions will still work, making it possible to make the impression of good domain.
At this point, ownership inNameWrapperis “detached” from ownership inENSandAccount1can do all kinds of malcious stuff with its ERC1155 token. For example:
Sell subdomain to the other user, transferingERC1155to that user and burningPARENT_CANNOT_CONTROLto create impression that he can’t control the domain. After receiving the payment,Account1can wrap the domain again, which burns existing ownership record and replaces with the new one with clear fuses andAccount1ownership, effectively stealing domain back from unsuspecting user, who thought thatERC1155gives him the right to the domain (and didn’t expect that parent can clear fuses whenPARENT_CANNOT_CONTROLis set).Transfer subdomain to some other smart contract, which implementsonERC1155Received, then take it back, fooling smart contract into believing that it has received the domain.
Proof of Concept
Copy these to test/wrapper and run:yarn test test/wrapper/NameWrapperReentrancy.js
https://gist.github.com/panprog/3cd94e3fbb0c52410a4c6609e55b863e
Recommended Mitigation Steps
Consider addingnonReentrantmodifiers withReentrancyGuardimplementation fromopenzeppelin. Alternatively just fix this individual re-entrancy issue. There are multiple ways to fix it depending on expected behaviour, for example savingERC1155data and requiring it to match the data after transfer (restrictingonERC1155Receivedto not change any data for the token received):
function _transferAndBurnFuses(bytes32 node,address newOwner,uint32 fuses,uint64 expiry) internal {(address owner, uint32 saveFuses, uint64 saveExpiry) = getData(uint256(node));_transfer(owner, newOwner, uint256(node), 1, "");uint32 curFuses;uint64 curExpiry;(owner, curFuses, curExpiry) = getData(uint256(node));require(owner == newOwner && saveFuses == curFuses && saveExpiry == curExpiry);_setFuses(node, newOwner, fuses, expiry);}
Arachnid (ENS) confirmed