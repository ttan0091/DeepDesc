[H-14] Fund will be stuck if a buyout is started while there are pending migration proposals
Submitted by shenwilly, also found by 0x52, codexploder, dipp, kenzo, Lambda, MEP, panprog, smiling_heretic, Treasure-Seeker, TrungOre, xiaoming90, and zzzitron
Funds in migration proposals could potentially be stuck forever if a buyout auction on the same vault is started by other party.
Most of the functions withinMigration.solcan only be executed depending on the state of buyout auction inBuyout.sol. When there is no buyout happening, a migration proposal can be made and anyone can contribute to the proposal. However, it is possible that a buyout auction is started by another party while a pending proposal is not commited yet.
When this scenario happens, there is no action that could be taken to interact with the pending proposal. All funds that have been contributed cannot be withdrawn. This is because the functions only check for the state of the buyout auction, instead of also considering whether the buyout auction’s proposer isMigration.sol:
(address token, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);if (id == 0) revert NotVault(_vault);// Reverts if buyout state is not inactive(, , State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);State required = State.INACTIVE;if (current != required) revert IBuyout.InvalidState(required, current);
Proposal contributors have to wait until the buyout failed before they can withdraw their funds. In case the buyout succeeded, their funds will be stuck forever.
Proof of Concept
Bob made a migration proposal and contributed0.5 eth.Alice individually started a buyout auction. Buyout state is nowACTIVE.Bob can’t leave the proposal.Alice successfully ended the buyout auction. Buyout state is nowSUCCESS.Bob can’t withdraw the funds.
Below are the test cases that show the scenarios described above.
function testLeaveBuyoutStarted() public {initializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY, true);(nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();// Migrate to a vault with no permissions (just to test out migration)address[] memory modules = new address[](1);modules[0] = address(mockModule);// Bob makes the proposalbob.migrationModule.propose(vault,modules,nftReceiverPlugins,nftReceiverSelectors,TOTAL_SUPPLY * 2,1 ether);// Bob joins the proposalbob.migrationModule.join{value: 0.5 ether}(vault, 1, HALF_SUPPLY);// Alice started buyoutalice.buyoutModule.start{value: 1 ether}(vault);(, , State current, , , ) = alice.buyoutModule.buyoutInfo(vault);assert(current == State.LIVE);vm.expectRevert(abi.encodeWithSelector(IBuyout.InvalidState.selector, 0, 1));// Bob cannot leavebob.migrationModule.leave(vault, 1);}function testLeaveBuyoutSuccess() public {// Send Bob a smaller amount so Alice can win the auctioninitializeMigration(alice, bob, TOTAL_SUPPLY, HALF_SUPPLY/2, true);(nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();// Migrate to a vault with no permissions (just to test out migration)address[] memory modules = new address[](1);modules[0] = address(mockModule);// Bob makes the proposalbob.migrationModule.propose(vault,modules,nftReceiverPlugins,nftReceiverSelectors,TOTAL_SUPPLY * 2,1 ether);// Bob joins the proposalbob.migrationModule.join{value: 0.5 ether}(vault, 1, HALF_SUPPLY/2);// Alice did a buyoutalice.buyoutModule.start{value: 1 ether}(vault);vm.warp(rejectionPeriod + 1);alice.buyoutModule.end(vault, burnProof);(, , State current, , , ) = alice.buyoutModule.buyoutInfo(vault);assert(current == State.SUCCESS);vm.expectRevert(abi.encodeWithSelector(IBuyout.InvalidState.selector, 0, 2));// Bob cannot leavebob.migrationModule.leave(vault, 1);}
Recommended Mitigation Steps
Modify the checks for the following functions:
leavewithdrawContribution
So users can withdraw their funds from the proposal when the buyout auction proposer is notMigration.sol.
In addition, it’s also possible that there are multiple ongoing proposals on the same vault and the buyout is started by one of them. To allow other proposals’ contributors to withdraw their fund, consider tracking the latestproposalIdthat started the buyout on a vault:
mapping(address => uint256) public latestCommit;function commit(address _vault, uint256 _proposalId) {...if (currentPrice > proposal.targetPrice) {...latestCommit[_vault] = _proposalId;}}
Forleave:
(, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);// if buyout is started by this proposal, check that state is inactive. Else allow leaving.if (proposer == address(this) && latestCommit[_vault] == _proposalId) {State required = State.INACTIVE;if (current != required) revert IBuyout.InvalidState(required, current);}
ForwithdrawContribution:
(, address proposer, State current, , , ) = IBuyout(buyout).buyoutInfo(_vault);// if buyout is started by this proposal, check that state is inactive. Else allow withdrawing.if (proposer == address(this) && latestCommit[_vault] == _proposalId) {State required = State.INACTIVE;if (current != required) revert IBuyout.InvalidState(required, current);}if (migrationInfo[_vault][_proposalId].newVault != address(0)) revert NoContributionToWithdraw();
stevennevins (Fractional) confirmed
HardlyDifficult (judge) commented:
Starting a buyout can cause migration funds to become stuck in the contract. Agree this is High risk.Selecting this submission as the primary for including POC code and including clear recs.