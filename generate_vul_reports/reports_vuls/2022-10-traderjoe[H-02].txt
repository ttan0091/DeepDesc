[H-02] Incorrect output amount calculation for Trader Joe V1 pools
Submitted byJeiwan, also found byKIntern_NAandcccz
https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L891https://github.com/code-423n4/2022-10-traderjoe/blob/main/src/LBRouter.sol#L896
Output amount is calculated incorrectly for a Trader Joe V1 pool when swapping tokens across multiple pools and some of the pools in the chain are V1 ones. Calculated amounts will always be smaller than expected ones, which will always affect chained swaps that include V1 pools.
Proof of Concept
LBRouteris a high-level contract that serves as the main contract users will interact with. The contract implements a lot of security checks and helper functions that make usage of LBPair contracts easier and more user-friendly. Some examples of such functions:
swapExactTokensForTokensSupportingFeeOnTransferTokens, which makes chained swaps (i.e. swaps between tokens that don’t have a pair) of tokens implementing fee on transfer (i.e. there’s fee reduced from every transferred amount);swapExactTokensForAVAXSupportingFeeOnTransferTokens, which is the variation of the above function which takes AVAX as the output token;swapExactAVAXForTokensSupportingFeeOnTransferTokens, which is the variation of the previous function which takes AVA as the input token.
Under the hood, these three functions call_swapSupportingFeeOnTransferTokens, which is the function that actually performs swaps. The function supports both Trader Joe V1 and V2 pools: when_binStepis 0 (which is never true in V2 pools), it’s assumed that the current pool is a V1 one. For V1 pools, the function calculates output amounts based on pools’ reserves and balances:
if(_binStep==0) {(uint256_reserve0,uint256_reserve1, ) =IJoePair(_pair).getReserves();if(_token<_tokenNext) {uint256_balance=_token.balanceOf(_pair);uint256_amountOut= (_reserve1* (_balance-_reserve0) *997) / (_balance*1_000);IJoePair(_pair).swap(0,_amountOut,_recipient,"");}else{uint256_balance=_token.balanceOf(_pair);uint256_amountOut= (_reserve0* (_balance-_reserve1) *997) / (_balance*1_000);IJoePair(_pair).swap(_amountOut,0,_recipient,"");}}else{ILBPair(_pair).swap(_tokenNext==ILBPair(_pair).tokenY(),_recipient);}
However, these calculations are incorrect. Here’s the difference:
@@ -888,12 +888,14 @@ contract LBRouter is ILBRouter {(uint256 _reserve0, uint256 _reserve1, ) = IJoePair(_pair).getReserves();if (_token < _tokenNext) {uint256 _balance = _token.balanceOf(_pair);-                        uint256 _amountOut = (_reserve1 * (_balance - _reserve0) * 997) / (_balance * 1_000);+                        uint256 amountInWithFee = (_balance - _reserve0) * 997;+                        uint256 _amountOut = (_reserve1 * amountInWithFee) / (_reserve0 * 1_000 + amountInWithFee);IJoePair(_pair).swap(0, _amountOut, _recipient, "");} else {uint256 _balance = _token.balanceOf(_pair);-                        uint256 _amountOut = (_reserve0 * (_balance - _reserve1) * 997) / (_balance * 1_000);+                        uint256 amountInWithFee = (_balance - _reserve1) * 997;+                        uint256 _amountOut = (_reserve0 * amountInWithFee) / (_reserve1 * 1_000 + amountInWithFee);IJoePair(_pair).swap(_amountOut, 0, _recipient, "");}
These calculations are implemented correctly inJoeLibrary.getAmountOut, which is used inLBQuoter.  Also it’s used in Trader Joe V1 to calculate output amounts in similar functions:
https://github.com/traderjoe-xyz/joe-core/blob/main/contracts/traderjoe/JoeRouter02.sol#L375
// test/audit/RouterMath2.t.sol// SPDX-License-Identifier: UNLICENSEDpragmasolidity^0.8.7;import"../TestHelper.sol";import"../../src/LBRouter.sol";import"../../src/interfaces/IJoePair.sol";contractRouterMath2TestisTestHelper{IERC20internaltoken;uint256internalactualAmountOut;functionsetUp()public{token=newERC20MockDecimals(18);ERC20MockDecimals(address(token)).mint(address(this),100e18);router=newLBRouter(ILBFactory(address(0x00)),IJoeFactory(address(this)),IWAVAX(address(0x02)));}// Imitates V1 factory.functiongetPair(address,/*tokenX*/address/*tokenY*/)publicviewreturns(address) {returnaddress(this);}// Imitates V1 pool.functiongetReserves()publicpurereturns(uint112,uint112,uint32) {return(1e18,1e18,0);}// Imitates V1 pool.functionbalanceOf(address/*acc*/)publicpurereturns(uint256) {return0.0001e18;}// Imitates V1 pool.functionswap(uint256amount0,uint256amount1,addressto,bytesmemorydata)public{actualAmountOut=amount0==0?amount1:amount0;}functiontestScenario()public{// Setting up a swap via one V1 pool.uint256[]memorysteps=newuint256[](1);steps[0] =0;IERC20[]memorypath=newIERC20[](2);path[0] =IERC20(address(token));path[1] =IERC20(address(this));uint256amountIn=0.0001e18;token.approve(address(router),1e18);router.swapExactTokensForTokensSupportingFeeOnTransferTokens(amountIn,0,steps,path,address(this),block.timestamp+1000);// This amount was calculated incorrectly.assertEq(actualAmountOut,987030000000000000);// Equals to 989970211528238869 when fixed.address_pair=address(this);uint256expectedAmountOut;// Reproduce the calculations using JoeLibrary.getAmountIn. This piece:(uint256_reserve0,uint256_reserve1, ) =IJoePair(_pair).getReserves();if(address(token) <address(this)) {uint256_balance=token.balanceOf(_pair);expectedAmountOut=JoeLibrary.getAmountOut(_balance-_reserve0,_reserve0,_reserve1);}else{uint256_balance=token.balanceOf(_pair);expectedAmountOut=JoeLibrary.getAmountOut(_balance-_reserve1,_reserve1,_reserve0);}// This is the correct amount.assertEq(expectedAmountOut,989970211528238869);// The wrong amount is smaller than the expected one.assertEq(expectedAmountOut-actualAmountOut,2940211528238869);}}
Recommended Mitigation Steps
Consider using theJoeLibrary.getAmountOutfunction in the_swapSupportingFeeOnTransferTokensfunction ofLBRouterwhen computing output amounts for V1 pools.
0x0Louis (Trader Joe) confirmed
Alex the Entreprenerd (judge) commented:
The warden has shown how, due to incorrect calculations, swaps routed through V1 functions may cause losses to end users.Because the issue is with a core mechanism of the protocol, and the warden has shown (via coded POC) how a loss can happen, I agree with High Severity.While this finding is similar to H-01, at this time I think it’s different enough to keep it separate as the internals and code paths are distinct.