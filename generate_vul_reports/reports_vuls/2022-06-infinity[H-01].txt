[H-01] Maker buy order with no specified NFT tokenIds may get fulfilled inmatchOneToManyOrderswithout receiving any NFT
Submitted by WatchPug, also found by 0xsanson, PwnedNoMore, and unforgiven
The call stack: matchOneToManyOrders() -> _matchOneMakerSellToManyMakerBuys() -> _execMatchOneMakerSellToManyMakerBuys() -> _execMatchOneToManyOrders() -> _transferMultipleNFTs()
Based on the context, a maker buy order can setOrderItem.tokensas an empty array to indicate that they can accept any tokenId in this collection, in that case,InfinityOrderBookComplication.doTokenIdsIntersect()will always returntrue.
However, when the system matching a sell order with many buy orders, theInfinityOrderBookComplicationcontract only ensures that the specified tokenIds intersect with the sell order, and the total count of specified tokenIds equals the sell order’s quantity (makerOrder.constraints[0]).
This allows any maker buy order with same collection andempty tokenIdsto be added tomanyMakerOrdersas long as there is another maker buy order with specified tokenIds that matched the sell order’s tokenIds.
https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116
functioncanExecMatchOneToMany(OrderTypes.MakerOrdercalldatamakerOrder,OrderTypes.MakerOrder[]calldatamanyMakerOrders)externalviewoverridereturns(bool) {uint256numItems;boolisOrdersTimeValid=true;boolitemsIntersect=true;uint256ordersLength=manyMakerOrders.length;for(uint256i=0;i<ordersLength; ) {if(!isOrdersTimeValid|| !itemsIntersect) {returnfalse;// short circuit}uint256nftsLength=manyMakerOrders[i].nfts.length;for(uint256j=0;j<nftsLength; ) {numItems+=manyMakerOrders[i].nfts[j].tokens.length;unchecked{++j;}}isOrdersTimeValid=isOrdersTimeValid&&manyMakerOrders[i].constraints[3] <=block.timestamp&&manyMakerOrders[i].constraints[4] >=block.timestamp;itemsIntersect=itemsIntersect&&doItemsIntersect(makerOrder.nfts,manyMakerOrders[i].nfts);unchecked{++i;}}bool_isTimeValid=isOrdersTimeValid&&makerOrder.constraints[3] <=block.timestamp&&makerOrder.constraints[4] >=block.timestamp;uint256currentMakerOrderPrice=_getCurrentPrice(makerOrder);uint256sumCurrentOrderPrices=_sumCurrentPrices(manyMakerOrders);bool_isPriceValid=false;if(makerOrder.isSellOrder) {_isPriceValid=sumCurrentOrderPrices>=currentMakerOrderPrice;}else{_isPriceValid=sumCurrentOrderPrices<=currentMakerOrderPrice;}return(numItems==makerOrder.constraints[0]) &&_isTimeValid&&itemsIntersect&&_isPriceValid;}
However, becausebuy.nftsis used asOrderItemto transfer the nfts from seller to buyer, and there are no tokenIds specified in the matched maker buy order, the buyer wont receive any nft (_transferERC721sdoes nothing, 0 transfers) despite the buyer paid full in price.
https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L763-L786
function_execMatchOneMakerSellToManyMakerBuys(bytes32sellOrderHash,bytes32buyOrderHash,OrderTypes.MakerOrdercalldatasell,OrderTypes.MakerOrdercalldatabuy,uint256startGasPerOrder,uint256execPrice,uint16protocolFeeBps,uint32wethTransferGasUnits,addressweth)internal{isUserOrderNonceExecutedOrCancelled[buy.signer][buy.constraints[5]] =true;uint256protocolFee= (protocolFeeBps*execPrice) /10000;uint256remainingAmount=execPrice-protocolFee;_execMatchOneToManyOrders(sell.signer,buy.signer,buy.nfts,buy.execParams[1],remainingAmount);_emitMatchEvent(sellOrderHash,buyOrderHash,sell.signer,buy.signer,buy.execParams[0],buy.execParams[1],execPrice);
https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L1080-L1092
function_transferERC721s(addressfrom,addressto,OrderTypes.OrderItemcalldataitem)internal{uint256numTokens=item.tokens.length;for(uint256i=0;i<numTokens; ) {IERC721(item.collection).safeTransferFrom(from,to,item.tokens[i].tokenId);unchecked{++i;}}}
Proof of Concept
Alice signed and submitted a maker buy order #1, to buy2Punk with2 WETHand specified tokenIds =1,2Bob signed and submitted a maker buy order #2, to buy1Punk with1 WETHand with no specified tokenIds.Charlie signed and submitted a maker sell order #3, ask for3 WETHfor2Punk and specified tokenIds =1,2The match executor calledmatchOneToManyOrders()match Charlie’s sell order #3 with buy order #1 and #2, Alice received2Punk, Charlie received3 WETH, Bob paid1 WETHand get nothing in return.
Recommendation
Change to:
functioncanExecMatchOneToMany(OrderTypes.MakerOrdercalldatamakerOrder,OrderTypes.MakerOrder[]calldatamanyMakerOrders)externalviewoverridereturns(bool) {uint256numItems;uint256numConstructedItems;boolisOrdersTimeValid=true;boolitemsIntersect=true;uint256ordersLength=manyMakerOrders.length;for(uint256i=0;i<ordersLength; ) {if(!isOrdersTimeValid|| !itemsIntersect) {returnfalse;// short circuit}numConstructedItems+=manyMakerOrders[i].constraints[0];uint256nftsLength=manyMakerOrders[i].nfts.length;for(uint256j=0;j<nftsLength; ) {numItems+=manyMakerOrders[i].nfts[j].tokens.length;unchecked{++j;}}isOrdersTimeValid=isOrdersTimeValid&&manyMakerOrders[i].constraints[3] <=block.timestamp&&manyMakerOrders[i].constraints[4] >=block.timestamp;itemsIntersect=itemsIntersect&&doItemsIntersect(makerOrder.nfts,manyMakerOrders[i].nfts);unchecked{++i;}}bool_isTimeValid=isOrdersTimeValid&&makerOrder.constraints[3] <=block.timestamp&&makerOrder.constraints[4] >=block.timestamp;uint256currentMakerOrderPrice=_getCurrentPrice(makerOrder);uint256sumCurrentOrderPrices=_sumCurrentPrices(manyMakerOrders);bool_isPriceValid=false;if(makerOrder.isSellOrder) {_isPriceValid=sumCurrentOrderPrices>=currentMakerOrderPrice;}else{_isPriceValid=sumCurrentOrderPrices<=currentMakerOrderPrice;}return(numItems==makerOrder.constraints[0]) && (numConstructedItems==numItems) &&_isTimeValid&&itemsIntersect&&_isPriceValid;}
nneverlander (Infinity) confirmed and resolved:
Fixed inhttps://github.com/infinitydotxyz/exchange-contracts-v2/commit/7f0e195d52165853281b971b8610b27140da6e41
HardlyDifficult (judge) commented:
Confirmed the scenario as described.Buyers specifying just a collection and no specific tokens is a basically a floor sweep which has become common for NFTs. In this scenario, the warden shows how a buyer can end up spending money and get nothing in return. This is a High risk issue.Issue#314is very similar but flips the impact to explore how a seller’s offer could be attacked and how it applies to an allow list of tokenIds. (It has been grouped with H-01)