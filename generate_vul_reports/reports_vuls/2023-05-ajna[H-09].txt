[H-09] User can avoid bankrupting by callingPositionManager.moveLiquiditywhere to index is bankrupted index
Submitted byrvierdiiev, also found byJ4de,SpicyMeatball, andvolodya
Bucket could become insolvent and in that case all LP within the bucket are zeroed out (lenders lose all their LP). Because of that,PositionManager.reedemPositionswill not allow to redeem index that is bankrupted.
When user wants to move his LPs from one bucket to another he can callPositionManager.moveLiquiditywhere he will provide from and to indexes.
https://github.com/code-423n4/2023-05-ajna/blob/main/ajna-core/src/PositionManager.sol#L262-L333
functionmoveLiquidity(MoveLiquidityParamscalldataparams_)externaloverridemayInteract(params_.pool, params_.tokenId)nonReentrant{PositionstoragefromPosition=positions[params_.tokenId][params_.fromIndex];MoveLiquidityLocalVarsmemoryvars;vars.depositTime=fromPosition.depositTime;// handle the case where owner attempts to move liquidity after they've already done soif(vars.depositTime==0)revertRemovePositionFailed();// ensure bucketDeposit accounts for accrued interestIPool(params_.pool).updateInterest();// retrieve info of bucket from which liquidity is moved(vars.bucketLP,vars.bucketCollateral,vars.bankruptcyTime,vars.bucketDeposit,) =IPool(params_.pool).bucketInfo(params_.fromIndex);// check that bucket hasn't gone bankrupt since memorializationif(vars.depositTime<=vars.bankruptcyTime)revertBucketBankrupt();// calculate the max amount of quote tokens that can be moved, given the tracked LPvars.maxQuote=_lpToQuoteToken(vars.bucketLP,vars.bucketCollateral,vars.bucketDeposit,fromPosition.lps,vars.bucketDeposit,_priceAt(params_.fromIndex));EnumerableSet.UintSetstoragepositionIndex=positionIndexes[params_.tokenId];// remove bucket index from which liquidity is moved from tracked positionsif(!positionIndex.remove(params_.fromIndex))revertRemovePositionFailed();// update bucket set at which a position has liquidity// slither-disable-next-line unused-returnpositionIndex.add(params_.toIndex);// move quote tokens in pool(vars.lpbAmountFrom,vars.lpbAmountTo,) =IPool(params_.pool).moveQuoteToken(vars.maxQuote,params_.fromIndex,params_.toIndex,params_.expiry);PositionstoragetoPosition=positions[params_.tokenId][params_.toIndex];// update position LP statefromPosition.lps-=vars.lpbAmountFrom;toPosition.lps+=vars.lpbAmountTo;// update position deposit time to the from bucket deposit timetoPosition.depositTime=vars.depositTime;emitMoveLiquidity(ownerOf(params_.tokenId),params_.tokenId,params_.fromIndex,params_.toIndex,vars.lpbAmountFrom,vars.lpbAmountTo);}
As you can seefrombucket is checked to be not bankrupted before the moving.And after the move, LPs offromandtobuckets are updated.AlsodepositTimeoftobucket is updated tofrom.depositTime.
The problem here is thattobucket was never checked to be not bankrupted.Because of that itâ€™s possible that bankruptedtobucket now becomes not bankrupted as their depositTime is updated now.
This is how this can be used by attacker.
Attacker has lp shares in the bucket, linked to token and this bucket became bankrupt.Then attacker mints small amount of LP in the Pool and then memorizes this index to the token.Attacker callsmoveLiquiditywithfrom: new bucket andto: bankrupt bucket.Now attacker can redeem his lp shares from bankrupt bucket as depositedTime is updated now.
As result, attacker was able to steal LPs of another people fromPositionManagercontract.
Tools Used
VsCode
Recommended Mitigation Steps
In case iftobucket is bankrupt, then clear LP for it before adding moved lp shares.
MikeHathaway (Ajna) confirmed