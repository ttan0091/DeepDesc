[H-02] Missing check on helper contract allows arbitrary actions and theft of assets
Submitted bycarrotsmuggler, also found byladboy233
TheMagnetarOptionModulecontract implements theexitPositionAndRemoveCollateralfunction which allows users to do a series of operations which is irrelevant to the issue. The user passes in the variabledata, and later,data.externalDatais used to extract out relevant contract addresses. These are then checked against a whitelist.
if(data.externalData.bigBang!=address(0)) {if(!cluster.isWhitelisted(0,data.externalData.bigBang)) {revertMagnetar_TargetNotWhitelisted(data.externalData.bigBang);}}if(data.externalData.singularity!=address(0)) {if(!cluster.isWhitelisted(0,data.externalData.singularity)) {revertMagnetar_TargetNotWhitelisted(data.externalData.singularity);}}
The main issue is that thedata.externalDataalso has amarketHelperfield which is not checked against a whitelist and ends up being used.
(Module[]memorymodules,bytes[]memorycalls) =IMarketHelper(data.externalData.marketHelper).repay(address(this),data.user,false,data.removeAndRepayData.repayAmount);(bool[]memorysuccesses,bytes[]memoryresults) =bigBang_.execute(modules,calls,true);
The helper contracts are used to construct the calldata for market operations. In the above snippet, the helper contract is passed in some data, and it is expected to create a calldata out of the passed in data. The expected output is the repay module and acallvalue which when executed, will repay for thedata.user’s account.
However, since themarketHelpercontract is never checked against a whitelist, malicious user can pass in any address in that place. So the above call can return any data payload, and thebigBang_.executewill execute it without any checks. This means the malicious helper contract can return aborrowpayload of some random user, and the contract will end up borrowing USDO against that user’s position. The Magnetar contract is assumed to have approval for market operations, and thus the Magnetar’s approval is essentially exploited by the attacker to perform arbitrary actions on any user’s account.
This can be used by any user to steal collateral from other user’s bigbang position, or borrow out usdo tokens on their position. Since this is direct theft, this is a high severity issue.
Proof of Concept
The absence of checks is evident from the code snippet. AssumingmarketHelpercontract is malicious, we see that is used in 2 places to create payloads, which must also be deemed malicious.
(Module[]memorymodules,bytes[]memorycalls) =IMarketHelper(data.externalData.marketHelper).repay(address(this),data.user,false,data.removeAndRepayData.repayAmount);
(Module[]memorymodules,bytes[]memorycalls) =IMarketHelper(data.externalData.marketHelper).removeCollateral(data.user,removeCollateralTo,collateralShare);
These are then executed, and the Magnetar is assumed to have approvals from users, so these are obviously malicious interactions.
In the other module contracts, themarketHelperis checked against a whitelist, but not in this module. This is a clear oversight. Below is the example from theMagnetarMintCommonModule:
if(!cluster.isWhitelisted(0,marketHelper)) {revertMagnetar_TargetNotWhitelisted(marketHelper);}
Recommended Mitigation Steps
Check the helper contract against a whitelist.
cryptotechmaker (Tapioca) disagreed with severity and commented:
Low/Invalid; even if the market helper is not checked (and I agree it’s ok to add that verification) the module which is going to be executed is checked on the BB/SGL side and the action that’s being performed also checks the allowances
ladboy233 (warden) commented:
I think the severity is not inflated and the severity is high and the issue clearly leads to theft of fund.Magnatar is a like a router contract and help user compose multicall.User calls magnetar function ->delegate calls Option Module./// @dev Modules will not return result data.if(_action.id==MagnetarAction.OptionModule) {_executeModule(MagnetarModule.OptionModule,_action.call);continue;// skip the rest of the loop}User needs to give a lot of approve for magnetar contract to allow magnetar contract pull fund out of user’s account to complete transaction.To prevent abuse of allowance, this check ismade in-place.functionexitPositionAndRemoveCollateral(ExitPositionAndRemoveCollateralDatamemorydata)publicpayable{// Check sender_checkSender(data.user);Which calls:function_checkSender(address_from)internalview{if(_from!=msg.sender&& !cluster.isWhitelisted(0,msg.sender)) {revertMagnetar_NotAuthorized(msg.sender,_from);}}The from!= msg.senderis super important, otherwise.If user A gives allowance to magnetar contract, user B can setdata.userto user A and steal fund from user A directly.Lack of validation of market helper allows malicious actor executes arbitrary multicall. Seehere.(Module[]memorymodules,bytes[]memorycalls) =IMarketHelper(data.externalData.marketHelper).repay(address(this),data.user,false,data.removeAndRepayData.repayAmount);(bool[]memorysuccesses,bytes[]memoryresults) =bigBang_.execute(modules,calls,true);As for sponsor comments:The module which is going to be executed is checked on the BB/SGL side and the action that’s being performed also checks the allowances.This is the code in BBCollateral module:bigBang_.executemulticall tobigBangmodule and one of the module is BBCollateral module:function removeCollateral(address from, address to, uint256 share)externaloptionNotPaused(PauseType.RemoveCollateral)solvent(from, false)notSelf(to)allowedBorrow(from, share){_removeCollateral(from, to, share);}The validation that sponsor mentions is in the modifier:allowedBorrow(from,share)Which calls:function_allowedBorrow(addressfrom,uint256share)internalvirtualoverride{if(from!=msg.sender) {// TODO review risk of using this(uint256pearlmitAllowed,) =penrose.pearlmit().allowance(from,msg.sender,address(yieldBox),collateralId);require(allowanceBorrow[from][msg.sender] >=share||pearlmitAllowed>=share,"Market: not approved");if(allowanceBorrow[from][msg.sender] !=type(uint256).max) {allowanceBorrow[from][msg.sender] -=share;}}}Obviously “from” is notmsg.sender, butmsg.senderis the magnetar contract that hold user’s allowance.Protocol fix the lack of market helper validation in the other part of the codebase, seehere. The exact same issue should be fixed in Option module as well.Other way to abuse pending allowance is marked as high severityhere.Abuse this issue is not fixedhere.This type of exploit can occur:User approves spending allowance to sushi router.Funds sit idle in users wallet.Attacker triggerstransferFromfrom victim address to hacker address -> exploit.In this case:User approves spending allowance to magnetar.Funds sit idle in users wallet.Attacker bypasses the_checkSenderand constructs multicall to remove collateral from user’s account directly.
carrotsmuggler (warden) commented:
This should be valid. According to the sponsor,even if the market helper is not checked the module which is going to be executed is checked on the BB/SGL side.This is true. However the bigbang/sgl markets do the check onmsg.sender, which is the magnetar contract itself, which is expected to have allowance from the users. Checks are not done on the initiator of this transaction. This is highlightedhereand below.function_allowedBorrow(addressfrom,uint256share)internalvirtualoverride{if(from!=msg.sender) {if(share==0)revertAllowanceNotValid();// TODO review risk of using this(uint256pearlmitAllowed,) =penrose.pearlmit().allowance(from,msg.sender,address(yieldBox),collateralId);require(allowanceBorrow[from][msg.sender] >=share||pearlmitAllowed>=share,"Market: not approved");if(allowanceBorrow[from][msg.sender] !=type(uint256).max) {allowanceBorrow[from][msg.sender] -=share;}}}Magnetar is a privileged contract, and this function allows other users to abuse this privilege. This is basically approval hijacking, and so is high severity.
0xRektora (Tapioca) commented:
@LSDan, this can be approved as a high risk.While we switched the model to use “atomic” approvals using Pearlmit, it’s better to be safe than sorry. The reviewed code also still has an obsoleteallowanceBorrowwhich could help initiate this attack.
0xWeiss (Tapioca) confirmed