[H-06] fee loss in AutoPxGmx and AutoPxGlp and reward loss in AutoPxGlp by callingPirexRewards.claim(pxGmx/pxGpl, AutoPx*)directly which transfers rewards to  AutoPx* pool without compound logic get executed and fee calculation logic and pxGmx wouldn’t be executed for those rewards
Submitted byunforgiven, also found bybin2chenand0x52
https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGlp.sol#L197-L296
https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/AutoPxGmx.sol#L230-L313
Impact
Functioncompound()inAutoPxGmxandAutoPxGlpcontracts is for compoundingpxGLP(and additionallypxGMX) rewards. it works by callingPirexGmx.claim(px*, this)to collect the rewards of the vault and then swap the received amount (to calculate the reward, contract save the balance of a contract in that reward token before and after the call to theclaim()and by subtracting them finds the received reward amount) and deposit them inPirexGmxagain for compounding and in doing so it calculates fee based on what it received and inAutoPxGlpcase it calculatespxGMXrewards too based on the extra amount contract receives during the execution ofclaim(). But attacker can callPirexGmx.claim(px*, PirexGlp)directly and makePirexGmxcontract to transfer (gmxBaseRewardandpxGmx) rewards toAutoPxGlpand in this case the logics of fee calculation and reward calculation incompound()function won’t get executed and contract won’t get it’s fee from rewards and users won’t get theirpxGmxreward. So this bug would cause fee loss inAutoPxGmxandAutoPxGlpfor contract andpxGmx’s reward loss for users inAutoPxGlp.
Proof of Concept
The bug inAutoPxGmxis similar toAutoPxGlp, so we only give Proof of Concept forAutoPxGlp.
This iscompound()function code inAutoPxGlpcontract:
function compound(uint256 minUsdg,uint256 minGlp,bool optOutIncentive)publicreturns (uint256 gmxBaseRewardAmountIn,uint256 pxGmxAmountOut,uint256 pxGlpAmountOut,uint256 totalPxGlpFee,uint256 totalPxGmxFee,uint256 pxGlpIncentive,uint256 pxGmxIncentive){if (minUsdg == 0) revert InvalidParam();if (minGlp == 0) revert InvalidParam();uint256 preClaimTotalAssets = asset.balanceOf(address(this));uint256 preClaimPxGmxAmount = pxGmx.balanceOf(address(this));PirexRewards(rewardsModule).claim(asset, address(this));PirexRewards(rewardsModule).claim(pxGmx, address(this));// Track the amount of rewards receivedgmxBaseRewardAmountIn = gmxBaseReward.balanceOf(address(this));if (gmxBaseRewardAmountIn != 0) {// Deposit received rewards for pxGLP(, pxGlpAmountOut, ) = PirexGmx(platform).depositGlp(address(gmxBaseReward),gmxBaseRewardAmountIn,minUsdg,minGlp,address(this));}// Distribute fees if the amount of vault assets increaseduint256 newAssets = totalAssets() - preClaimTotalAssets;if (newAssets != 0) {totalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;pxGlpIncentive = optOutIncentive? 0: (totalPxGlpFee * compoundIncentive) / FEE_DENOMINATOR;if (pxGlpIncentive != 0)asset.safeTransfer(msg.sender, pxGlpIncentive);asset.safeTransfer(owner, totalPxGlpFee - pxGlpIncentive);}// Track the amount of pxGMX receivedpxGmxAmountOut = pxGmx.balanceOf(address(this)) - preClaimPxGmxAmount;if (pxGmxAmountOut != 0) {// Calculate and distribute pxGMX fees if the amount of pxGMX increasedtotalPxGmxFee = (pxGmxAmountOut * platformFee) / FEE_DENOMINATOR;pxGmxIncentive = optOutIncentive? 0: (totalPxGmxFee * compoundIncentive) / FEE_DENOMINATOR;if (pxGmxIncentive != 0)pxGmx.safeTransfer(msg.sender, pxGmxIncentive);pxGmx.safeTransfer(owner, totalPxGmxFee - pxGmxIncentive);// Update the pxGmx reward accrual_harvest(pxGmxAmountOut - totalPxGmxFee);} else {// Required to keep the globalState up-to-date_globalAccrue();}emit Compounded(msg.sender,minGlp,gmxBaseRewardAmountIn,pxGmxAmountOut,pxGlpAmountOut,totalPxGlpFee,totalPxGmxFee,pxGlpIncentive,pxGmxIncentive);}
As you can see contract collects rewards by callingPirexRewards.claim()and in the lineuint256 newAssets = totalAssets() - preClaimTotalAssets;contract calculates the received amount of rewards (by subtracting the balance after and before reward claim) and then calculates fee based on this amounttotalPxGlpFee = (newAssets * platformFee) / FEE_DENOMINATOR;and then sends the fee in the lineasset.safeTransfer(owner, totalPxGlpFee - pxGlpIncentive)forowner.
The logic forpxGmxrewards are the same. As you can see the calculation of the fee is based on the rewards received, and there is no other logic in the contract to calculate and transfer the fee of protocol. So ifAutoPxGplreceives rewards withoutcompound()getting called then for those rewards fee won’t be calculated and transferred and protocol would lose it’s fee.
In the line_harvest(pxGmxAmountOut - totalPxGmxFee)contract calls_harvest()function to update thepxGmxreward accrual and there is no call to_harvest()in any other place and this is the only place wherepxGmxreward accrual gets updated. The contract usespxGmxAmountOutwhich is the amount ofgmxcontract received during the call (code calculates it by subtracting the balance after and before reward claim:pxGmxAmountOut = pxGmx.balanceOf(address(this)) - preClaimPxGmxAmount;) so contract only handles accrual rewards in this function call and if somepxGmxrewards claimed for contract withoutcompund()logic execution then those rewards won’t be used in_harvest()and_globalAccrue()calculation and users won’t receive those rewards.
As mentioned attacker can callPirexRewards.claim(pxGmx, AutoPxGpl)directly and makePirexRewadscontract to transferAutoPxGplrewards. This isclaim()code inPirexRewards:
function claim(ERC20 producerToken, address user) external {if (address(producerToken) == address(0)) revert ZeroAddress();if (user == address(0)) revert ZeroAddress();harvest();userAccrue(producerToken, user);ProducerToken storage p = producerTokens[producerToken];uint256 globalRewards = p.globalState.rewards;uint256 userRewards = p.userStates[user].rewards;// Claim should be skipped and not reverted on zero global/user rewardif (globalRewards != 0 && userRewards != 0) {ERC20[] memory rewardTokens = p.rewardTokens;uint256 rLen = rewardTokens.length;// Update global and user reward states to reflect the claimp.globalState.rewards = globalRewards - userRewards;p.userStates[user].rewards = 0;emit Claim(producerToken, user);// Transfer the proportionate reward token amounts to the recipientfor (uint256 i; i < rLen; ++i) {ERC20 rewardToken = rewardTokens[i];address rewardRecipient = p.rewardRecipients[user][rewardToken];address recipient = rewardRecipient != address(0)? rewardRecipient: user;uint256 rewardState = p.rewardStates[rewardToken];uint256 amount = (rewardState * userRewards) / globalRewards;if (amount != 0) {// Update reward state (i.e. amount) to reflect reward tokens transferred outp.rewardStates[rewardToken] = rewardState - amount;producer.claimUserReward(address(rewardToken),amount,recipient);}}}}
As you can see it can be called by anyone for any user. So to perform this attack, attacker would perform these steps:
SupposeAutoPxGplhas pending rewards, for example 100pxGmxand 100weth.Attacker would callPirexRewards.claim(pxGmx, AutoPxGpl)andPirexRewards.claim(pxGpl, AutoPxGpl)andPirexRewardscontract would calculate and claim and transferpxGmxrewards andwethrewards ofAutoPxGpladdress.ThenAutoPxGplhas no pending rewards but the balance ofpxGmxandwethof contract has been increased.If anyone callsAutoPxGpl.compound()because there is no pending rewards contract would receive no rewards and because contract only calculates fee and rewards based on received rewards during the call tocompound()so contract wouldn’t calculate any fee or reward accrual for those 1000pxGmxandwethrewards.ownerofAutoPxGplwould lose his fee for those rewards and users ofAutoPxGplwould lose their claims for those 1000pxGmxrewards (because the calculation for them didn’t happen).
This bug is because of the fact that the only logic handling rewards is incompound()function which is only handling receiving rewards by callingclaim()during the call tocompound()but it’s possible to callclaim()directly (PirexRewardscontract allows this) andAutoPxGplwon’t get notified about this new rewards and the related logics won’t get executed.
Tools Used
VIM
Recommended Mitigation Steps
Contract should keep track of it’s previous balance whencompound()get executed and update this balance in deposits and withdraws and claims so it can detect rewards that directly transferred to contract without call tocompound().
kphed (Redacted Cartel) confirmed