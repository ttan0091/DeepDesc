[H-04] Bribe Rewards Struck In Contract If Deposited During First Epoch
Submitted by xiaoming90
Bribe rewards added to theBribecontract in the first epoch will not be claimable by any voters, and the rewards will struck in theBribecontract.
Proof-of-Concept
Assume that the current epoch isepoch 0, and start date ofepoch 0isDay 0.
When a briber adds a new rewards by callingBribe.notifyRewardAmount(), theBribe.getEpochStart()will return thestart date of current epoch (epoch 0) + 1 day (Bribe Lag)
Thus,adjustedTstampwill be set toDay 1.tokenRewardsPerEpoch[token][adjustedTstamp]will evaluate totokenRewardsPerEpoch[DAI][Day 1]and the briber’s rewards will be stored intokenRewardsPerEpoch[DAI][Day 1]
Bribe.sol#L35
functiongetEpochStart(uinttimestamp)publicviewreturns(uint) {uintbribeStart=timestamp- (timestamp% (7days)) +BRIBE_LAG;uintbribeEnd=bribeStart+DURATION-COOLDOWN;returntimestamp<bribeEnd?bribeStart:bribeStart+7days;}
Bribe.sol#L41
functionnotifyRewardAmount(addresstoken,uintamount)externallock{require(amount>0);if(!isReward[token]) {require(rewards.length<MAX_REWARD_TOKENS,"too many rewards tokens");}// bribes kick in at the start of next bribe perioduintadjustedTstamp=getEpochStart(block.timestamp);uintepochRewards=tokenRewardsPerEpoch[token][adjustedTstamp];_safeTransferFrom(token,msg.sender,address(this),amount);tokenRewardsPerEpoch[token][adjustedTstamp] =epochRewards+amount;if(!isReward[token]) {isReward[token] =true;rewards.push(token);IGauge(gauge).addBribeRewardToken(token);}emitNotifyReward(msg.sender,token,adjustedTstamp,amount);}
OnDay 6, thevotingphase has ended and the state is currently in therewardphase. Alice decided to call theVoter.distributeto trigger the distribution of bribe rewards.
However, the main issue is that calling theVoter.distributefunction on Epoch 0’s Day 6 (Reward Phase) will not executed theGauge.deliverBribes()becauseclaimable[_gauge]or_claimableis currently0.
Gauge.deliverBribes()is the main function responsible for distributing bribe rewards. SinceGauge.deliverBribes()cannot be triggered, the bribe rewards are forever struck in theBribeContract.
claimable[_gauge]will always be zero on the first epoch because the gauge rewards will only come in the later epoch. The value ofclaimable[_gauge]will only increase when theMinter.update_period()function starts minting VELO and distribute them to the gauges. Per the source code ofMintercontract, the VELO emission will only start from third epoch onwards (active_period = ((block.timestamp + (2 * WEEK)) / WEEK) * WEEK;). Thus, before the VELO emission,claimable[_gauge]will always remain at0.
Voter.sol#L315
functiondistribute(address_gauge)publiclock{require(isAlive[_gauge]);// killed gauges cannot distributeuintdayCalc=block.timestamp% (7days);require((dayCalc<BRIBE_LAG) || (dayCalc> (DURATION+BRIBE_LAG)),"cannot claim during votes period");IMinter(minter).update_period();_updateFor(_gauge);uint_claimable=claimable[_gauge];if(_claimable>IGauge(_gauge).left(base) &&_claimable/DURATION>0) {claimable[_gauge] =0;IGauge(_gauge).notifyRewardAmount(base,_claimable);emitDistributeReward(msg.sender,_gauge,_claimable);// distribute bribes & fees tooIGauge(_gauge).deliverBribes();}}
If someone attempt to callVoter.distribute()on epoch 1 or subsequent epoch, it will fetch the bribe rewards in their respective epoch.
In theGauge.deliverBribesfunction, the codeuint bribeStart = block.timestamp - (block.timestamp % (7 days)) + BRIBE_LAG;will calculate the start date of current epoch + BRIBE_LAG (1 day). So, if someone callGauge.deliverBribesin epoch 1, thebribeStartvariable will be set to theEpoch 1 + 1 day, which is equivalent to Day 9. There is no way to fetch the bribe rewards struck in epoch 0.
Gauge.sol#L173
functiondeliverBribes()externallock{require(msg.sender==voter);IBribesb=IBribe(bribe);uintbribeStart=block.timestamp- (block.timestamp% (7days)) +BRIBE_LAG;uintnumRewards=sb.rewardsListLength();for(uinti=0;i<numRewards;i++) {addresstoken=sb.rewards(i);uintepochRewards=sb.deliverReward(token,bribeStart);if(epochRewards>0) {_notifyBribeAmount(token,epochRewards,bribeStart);}}}
Bribe.sol#L83
functiondeliverReward(addresstoken,uintepochStart)externallockreturns(uint) {require(msg.sender==gauge);uintrewardPerEpoch=tokenRewardsPerEpoch[token][epochStart];if(rewardPerEpoch>0) {_safeTransfer(token,address(gauge),rewardPerEpoch);}returnrewardPerEpoch;}
Recommended Mitigation Steps
Implement logic to handle the edge case where bribe rewards are added during first epoch. Consider aligning the start of bribe period with VELO emission period.
pooltypes (Velodrome) acknowledged
Alex the Entreprenerd (judge) commented:
The warden has shown how tokens can be stuck in the Bribes Contract indefinitely.This is because bribes can be added at the beginning (day 0), while rewards can be received only after a delay (7 days), due to the need for a minimum amount of rewards to be available in order for bribes to be claimable, the logic will prevent the bribes deposited on day 0 to be claimable.I’m conflicted on the severity as technically this can only happen for the first week, however the loss of tokens is irreversible as there’s no code that would allow rescuing them.On further consideration, because thedeployment of new Bribes and Gauges is mostly permissioneless, this bug will be present for every new pair of deployed contract, and it is highly likely that a new protocol would want to add rewards immediately.For those reasons, I believe High Severity to be appropriate.