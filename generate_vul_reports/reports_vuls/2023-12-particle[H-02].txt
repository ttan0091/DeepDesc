[H-02] openPosition() use stale feeGrowthInside0LastX128/feeGrowthInside1LastX128
Submitted bybin2chen, also found byadriro
WhenopenPosition(), we need to record the currentfeeGrowthInside0LastX128/feeGrowthInside1LastX128.
And when closing the position, we useBase.getOwedFee()to calculate the possible fees generated during the borrowing period, which are used to pay theLP.
openPosition()->Base.prepareLeverage()
functionopenPosition(DataStruct.OpenPositionParamscalldataparams)publicoverridenonReentrantreturns(uint96lienId,uint256collateralTo) {if(params.liquidity==0)revertErrors.InsufficientBorrow();// local cache to avoid stack too deepDataCache.OpenPositionCachememorycache;// prepare data for swap(cache.tokenFrom,cache.tokenTo,cache.feeGrowthInside0LastX128,cache.feeGrowthInside1LastX128,cache.collateralFrom,collateralTo) =Base.prepareLeverage(params.tokenId,params.liquidity,params.zeroForOne);...liens[keccak256(abi.encodePacked(msg.sender,lienId=_nextRecordId++))] =Lien.Info({tokenId:uint40(params.tokenId),liquidity:params.liquidity,token0PremiumPortion:cache.token0PremiumPortion,token1PremiumPortion:cache.token1PremiumPortion,startTime:uint32(block.timestamp),@>feeGrowthInside0LastX128:cache.feeGrowthInside0LastX128,@>feeGrowthInside1LastX128:cache.feeGrowthInside1LastX128,zeroForOne:params.zeroForOne});functionprepareLeverage(uint256tokenId,uint128liquidity,boolzeroForOne)internalviewreturns(addresstokenFrom,addresstokenTo,uint256feeGrowthInside0LastX128,uint256feeGrowthInside1LastX128,uint256collateralFrom,uint256collateralTo){...,@>feeGrowthInside0LastX128,@>feeGrowthInside1LastX128,,) =UNI_POSITION_MANAGER.positions(tokenId);}
From the above code, we can see that the final value saved toliens[].feeGrowthInside0LastX128/feeGrowthInside1LastX128is directly taken fromUNI_POSITION_MANAGER.positions(tokenId).
The problem is: The value inUNI_POSITION_MANAGER.positions(tokenId)is not the latest.
Only when executingUNI_POSITION_MANAGER.increaseLiquidity()/decreaseLiquidity()/collect()will it synchronize thepoolâ€™sfeeGrowthInside0LastX128/feeGrowthInside1LastX128.
Because of using the stale value, it leads to a smaller value relative to the actual value. WhenclosePosition(), the calculated difference will be larger, and theborrowerwill pay extra fees.
Impact
Due to use stalefeeGrowthInside0LastX128/feeGrowthInside1LastX128, theborrowerwill pay extra fees.
Proof of Concept
The following test  code demonstrates that afterswap(),UNI_POSITION_MANAGER.positions(tokenId)is not the latest unless actively executingUNI_POSITION_MANAGER.collect().
Add toSwap.t.sol:
functiontestShowCache()public{(,,,,,,,,uint256feeGrowthInside0LastX128,uint256feeGrowthInside1LastX128,,) =nonfungiblePositionManager.positions(_tokenId);console.log("feeGrowthInside0LastX128(first):",feeGrowthInside0LastX128);console.log("feeGrowthInside1LastX128(first):",feeGrowthInside1LastX128);_swap();(,,,,,,,,uint256feeGrowthInside0LastX128Swap,uintfeeGrowthInside1LastX128Swap,,) =nonfungiblePositionManager.positions(_tokenId);console.log("equal 0 (after swap):",feeGrowthInside0LastX128Swap==feeGrowthInside0LastX128);console.log("equal 1 (after swap):",feeGrowthInside1LastX128Swap==feeGrowthInside1LastX128);vm.startPrank(LP);particlePositionManager.collectLiquidity(_tokenId);vm.stopPrank();(,,,,,,,,uint256feeGrowthInside0LastX128After,uint256feeGrowthInside1LastX128After,,) =nonfungiblePositionManager.positions(_tokenId);console.log("feeGrowthInside0LastX128(after collect):",feeGrowthInside0LastX128After);console.log("feeGrowthInside1LastX128(after collect):",feeGrowthInside1LastX128After);console.log("feeGrowthInside0LastX128(more):",feeGrowthInside0LastX128After-feeGrowthInside0LastX128);console.log("feeGrowthInside1LastX128(more):",feeGrowthInside1LastX128After-feeGrowthInside1LastX128);}
forge test -vvv --match-test testShowCache --fork-url https://eth-mainnet.g.alchemy.com/v2/xxxxx --fork-block-number 18750931Logs:feeGrowthInside0LastX128(first): 72311088602808532523286912166257feeGrowthInside1LastX128(first): 29354860053667370145800991738605288969228equal 0 (after swap): trueequal 1 (after swap): truefeeGrowthInside0LastX128(after collect): 72311299261479720625185125361673feeGrowthInside1LastX128(after collect): 29354860053667370145800991738605288969228feeGrowthInside0LastX128(more): 210658671188101898213195416feeGrowthInside1LastX128(more): 0
Recommended Mitigation
AfterLiquidityPosition.collectLiquidity(), executeBase.prepareLeverage()to ensure the latestfeeGrowthInside0LastX128/feeGrowthInside1LastX128.
function openPosition(DataStruct.OpenPositionParams calldata params) public override nonReentrant returns (uint96 lienId, uint256 collateralTo) {function openPosition(DataStruct.OpenPositionParams calldata params) public override nonReentrant returns (uint96 lienId, uint256 collateralTo) {if (params.liquidity == 0) revert Errors.InsufficientBorrow();// local cache to avoid stack too deepDataCache.OpenPositionCache memory cache;-       // prepare data for swap-       (-           cache.tokenFrom,-            cache.tokenTo,-            cache.feeGrowthInside0LastX128,-            cache.feeGrowthInside1LastX128,-            cache.collateralFrom,-            collateralTo-        ) = Base.prepareLeverage(params.tokenId, params.liquidity, params.zeroForOne);// decrease liquidity from LP position, pull the amount to this contract(cache.amountFromBorrowed, cache.amountToBorrowed) = LiquidityPosition.decreaseLiquidity(params.tokenId,params.liquidity);LiquidityPosition.collectLiquidity(params.tokenId,uint128(cache.amountFromBorrowed),uint128(cache.amountToBorrowed),address(this));+       // prepare data for swap+        (+            cache.tokenFrom,+            cache.tokenTo,+            cache.feeGrowthInside0LastX128,+            cache.feeGrowthInside1LastX128,+            cache.collateralFrom,+            collateralTo+        ) = Base.prepareLeverage(params.tokenId, params.liquidity, params.zeroForOne);
wukong-particle (Particle) confirmed