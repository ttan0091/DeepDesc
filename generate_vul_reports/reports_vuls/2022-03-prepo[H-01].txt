[H-01] Strategy Migration May Leave Tokens in the Old Strategy Impacting Share Calculations
Submitted by kirk-baird
If a strategy does not have sufficient funds towithdraw()for the full amount then it is possible that tokens will be left in this yield contract duringmigrate().
It is common for withdrawal from a strategy to withdraw less than a userâ€™s balance. The reason is that these yield protocols may lend the deposited funds to borrowers, if there is less funds in the pool than the withdrawal amount the withdrawal may succeed but only transfer the funds available rather than the full withdrawal amount.
The impact of tokens remaining in the old strategy is that when we callStrategyController.totalValue()this will only account for the tokens deposited in the new strategy and not those stuck in the previous strategy. ThereforetotalValue()is undervalued.
Thus, when a user callsCollateral.deposit()the share calculations_shares = (_amountToDeposit * totalSupply()) / (_valueBefore);will be over stated (note:uint256 _valueBefore = _strategyController.totalValue();). Hence, the user will receive more shares than they should.
The old tokens may be recovered by callingmigrate()back to the old strategy. If this is done thentotalValue()will now include the tokens previously stuck. The recent depositer may now withdraw and will be owed(_strategyController.totalValue() * _amount) / totalSupply(). SincetotalValue()is now includes the previously stuck tokens_owedwill be overstated and the user will receive more collateral than they should.
The remaining users who had deposited beforemigrate()will lose tokens proportional to their share of thetotalSupply().
Proof of Concept
SingleStrategyController.sol#L51-L72
function migrate(IStrategy _newStrategy)externaloverrideonlyOwnernonReentrant{uint256 _oldStrategyBalance;IStrategy _oldStrategy = _strategy;_strategy = _newStrategy;_baseToken.approve(address(_newStrategy), type(uint256).max);if (address(_oldStrategy) != address(0)) {_baseToken.approve(address(_oldStrategy), 0);_oldStrategyBalance = _oldStrategy.totalValue();_oldStrategy.withdraw(address(this), _oldStrategyBalance);_newStrategy.deposit(_baseToken.balanceOf(address(this)));}emit StrategyMigrated(address(_oldStrategy),address(_newStrategy),_oldStrategyBalance);}
Recommended Mitigation Steps
The recommendation is to ensure thatrequire(_oldStrategy.totalValue() == 0)after calling_oldStrategy.withdraw(). This ensures that no funds are left in the strategy. Consider the code example below.
function migrate(IStrategy _newStrategy)externaloverrideonlyOwnernonReentrant{uint256 _oldStrategyBalance;IStrategy _oldStrategy = _strategy;_strategy = _newStrategy;_baseToken.approve(address(_newStrategy), type(uint256).max);if (address(_oldStrategy) != address(0)) {_baseToken.approve(address(_oldStrategy), 0);_oldStrategyBalance = _oldStrategy.totalValue();_oldStrategy.withdraw(address(this), _oldStrategyBalance);require(_oldStrategy.totalValue() == 0)_newStrategy.deposit(_baseToken.balanceOf(address(this)));}emit StrategyMigrated(address(_oldStrategy),address(_newStrategy),_oldStrategyBalance);}
ramenforbreakfast (prePO) confirmed and commented:
This is a valid claim, although it is an edge case. I will maintain the severity of this issue as is. Should consider removing a fixed migration procedure altogether as this issue demonstrates one of the many problems that can occur.
gzeon (judge) commented:
Agree with sponsor.