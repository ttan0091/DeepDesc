[H-02]exitPositioninTapiocaOptionBrokermay incorrectly inflate position weights
Submitted byItsNio, also found byKIntern_NA
Users whoparticipate()and place stakes with large magnitudes may have their weight removed prematurely frompool.cumulative, hence causing the weight logic of participation to be wrong.pool.cumulativewill have an incomplete image of the actual pool hence allowing future users to have divergent power when they should not. In particular, this occurs during theexitPosition()function.
Proof of Concept
This vulnerability stems fromexitPosition()using the currentpool.AverageMagnitudeinstead of the respective magnitudes of the user’s weights to updatepool.cumulativeon line 316. Hence, when users callexitPosition(), the amount thatpool.cumulativeis updated but may not be representative of the weight of the user’s input.
Imagine if we have three users, Alice, Bob, and Charlie who all decide to callparticipate(). Alice callsparticipate()with a smaller amount and a smaller time, hence having a weight of 10. Bob callsparticipate()with a larger amount and a larger time, hence having a weight of 50. Charlie callsparticipate()with a weight of 20.
Scenario
Alice callsparticipate()first at time 0 with the aforementioned amount and time. Thepool.cumulativeis now 10 and thepool.AverageMagnitudeis 10 as well. Alice’s position will expire at time 10.Bob callsparticipate()at time 5. Thepool.cumulativeis now 10 + 50 = 60 and thepool.AverageMagnitudeis 50.Alice callsexitPosition()at time 10.pool.cumulativeis 60, butpool.AverageMagnitudeis still 50. Hence,pool.cumulativewill be decreased by 50, even though the weight of Alice’s input is 10.Charlie callsparticipatewith weight 20. Charlie will have divergent power in the pool with both Bob and Charlie, since 20 >pool.cumulative(10).
If Alice does not participate at all, Charlie will not have divergent power in a pool with Bob and Charlie, since thepool.cumulative= Bob’s weight = 50 > Charlie’s weight (20).
We have provided a test to demonstrate thepool.cumulativeinflation. Copy the following code intotap-token-audit/test/oTAP/tOB.test.tsas one of the tests.
it('POC',async()=>{const{signer,tOLP,tOB,tapOFT,sglTokenMock,sglTokenMockAsset,yieldBox,oTAP,} =awaitloadFixture(setupFixture);// Setup tOBawaittOB.oTAPBrokerClaim();awaittapOFT.setMinter(tOB.address);// Setup - register a singularity, mint and deposit in YB, lock in tOLPconstamount=3e10;constlockDurationA=10;constlockDurationB=100;awaittOLP.registerSingularity(sglTokenMock.address,sglTokenMockAsset,0,);awaitsglTokenMock.freeMint(amount);awaitsglTokenMock.approve(yieldBox.address,amount);awaityieldBox.depositAsset(sglTokenMockAsset,signer.address,signer.address,amount,0,);constybAmount=awaityieldBox.toAmount(sglTokenMockAsset,awaityieldBox.balanceOf(signer.address,sglTokenMockAsset),false,);awaityieldBox.setApprovalForAll(tOLP.address,true);//A (short less impact)console.log(ybAmount);awaittOLP.lock(signer.address,sglTokenMock.address,lockDurationA,ybAmount.div(100),);//B (long, big impact)awaittOLP.lock(signer.address,sglTokenMock.address,lockDurationB,ybAmount.div(2),);consttokenID=awaittOLP.tokenCounter();constsnapshot=awaittakeSnapshot();console.log("A Duration: ",lockDurationA," B Duration: ",lockDurationB);// Just A Participateconsole.log("Just A participation");awaittOLP.approve(tOB.address,tokenID.sub(1));awaittOB.participate(tokenID.sub(1));constparticipationA=awaittOB.participants(tokenID.sub(1));constoTAPTknID=awaitoTAP.mintedOTAP();awaittime.increase(lockDurationA);constprevPoolState=awaittOB.twAML(sglTokenMockAsset);console.log("[B4] Just A Cumulative: ",awaitprevPoolState.cumulative);console.log("[B4] Just A Average: ",participationA.averageMagnitude);awaitoTAP.approve(tOB.address,oTAPTknID);awaittOB.exitPosition(oTAPTknID);console.log("Exit A position");constnewPoolState=awaittOB.twAML(sglTokenMockAsset);console.log("[A4] Just A Cumulative: ",awaitnewPoolState.cumulative);console.log("[A4] Just A Average: ",awaitparticipationA.averageMagnitude);//Both Participationsconsole.log();console.log("Run both participation---");constctime1=newDate();console.log("Time: ",ctime1);//A and B Participateawaitsnapshot.restore();//Before everythingconstinitPoolState=awaittOB.twAML(sglTokenMockAsset);console.log("[IN] Initial Cumulative: ",awaitinitPoolState.cumulative);//First participate AawaittOLP.approve(tOB.address,tokenID.sub(1));awaittOB.participate(tokenID.sub(1));constxparticipationA=awaittOB.participants(tokenID.sub(1));constATknID=awaitoTAP.mintedOTAP();console.log("Participate A (smaller weight)");console.log("[ID] A Token ID: ",ATknID);constxprevPoolState=awaittOB.twAML(sglTokenMockAsset);console.log("[B4] Both A Cumulative: ",awaitxprevPoolState.cumulative);console.log("[B4] Both A Average: ",awaitxparticipationA.averageMagnitude);console.log();//Time skip to half A's durationawaittime.increase(5);constctime2=newDate();console.log("Participate B (larger weight), Time(+5): ",ctime2);//Participate BawaittOLP.approve(tOB.address,tokenID);awaittOB.participate(tokenID);constxparticipationB=awaittOB.participants(tokenID);constBTknID=awaitoTAP.mintedOTAP();console.log("[ID] B Token ID: ",ATknID);constxbothPoolState=awaittOB.twAML(sglTokenMockAsset);console.log("[B4] Both AB Cumulative: ",awaitxbothPoolState.cumulative);console.log("[B4] Both B Average: ",awaitxparticipationB.averageMagnitude);//Time skip end Aawaittime.increase(6);awaitoTAP.approve(tOB.address,ATknID);awaittOB.exitPosition(ATknID);constexitAPoolState=awaittOB.twAML(sglTokenMockAsset);constctime3=newDate();console.log();console.log("Exit A (Dispraportionate Weight, Time(+6 Expire A): ",ctime3);console.log("[!X!] Just B Cumulative: ",awaitexitAPoolState.cumulative);console.log("[A4] Just B Average: ",xparticipationB.averageMagnitude);//TIme skip end Bawaittime.increase(lockDurationB);awaitoTAP.approve(tOB.address,BTknID);awaittOB.exitPosition(BTknID);constexitBPoolState=awaittOB.twAML(sglTokenMockAsset);constctime4=newDate();console.log("Exit B, Time(+100 Expire B): ",ctime4);console.log("[A4] END Cumulative: ",awaitexitBPoolState.cumulative);});
This test runs the aforementioned scenario.
Expected Output:
BigNumber { value:"30000000000"}A Duration:  10  B Duration:  100Just A participation[B4] Just A Cumulative:  BigNumber { value:"10"}[B4] Just A Average:  BigNumber { value:"10"}Exit A position[A4] Just A Cumulative:  BigNumber { value:"0"}[A4] Just A Average:  BigNumber { value:"10"}Run both participation---Time:  2023-08-03T21:40:52.700Z[IN] Initial Cumulative:  BigNumber { value:"0"}Participate A (smaller weight)[ID] A Token ID:  BigNumber { value:"1"}[B4] Both A Cumulative:  BigNumber { value:"10"}[B4] Both A Average:  BigNumber { value:"10"}Participate B (larger weight), Time(+5):  2023-08-03T21:40:52.801Z[ID] B Token ID:  BigNumber { value:"1"}[B4] Both AB Cumulative:  BigNumber { value:"60"}[B4] Both B Average:  BigNumber { value:"50"}Exit A (Dispraportionate Weight, Time(+6 Expire A):  2023-08-03T21:40:52.957Z[!X!] Just B Cumulative:  BigNumber { value:"10"}[A4] Just B Average:  BigNumber { value:"50"}Exit B, Time(+100 Expire B):  2023-08-03T21:40:53.029Z[A4] END Cumulative:  BigNumber { value:"0"}✔ POC (1077ms)
The POC is split into two parts:
The first part starting withJust A Participationis when just A enters and exits. This is correct, with thepool.cumulativeincreasing by 10 (the weight of A) and then being decreased by 10 when A exits.
The second part starting withRun both participation---describes the scenario mentioned by the bullet points. In particular, thepool.cumulativestarts as 0 ([IN] Initial Cumulative).
Then, A enters the pool, and thepool.cumulativeis increased to 10 ([B4] Both A Cumulative) similar to the first part.
Then, B enters the pool, before A exits. B has a weight of 50, thus thepool.cumulativeincreases to 60 ([B4] Both AB Cumulative).
The bug can be seen after the line beginning with[!X!]. Thepool.cumulativelabeled by “Just B Cumulative” is decreased by 60 - 10 = 50 when A exits, although the weight of A is only 10.
Recommended Mitigation Steps
There may be a need to store weights at the time of adding a weight instead of subtracting the last computed weight inexitPosition(). For example, when Alice callsparticipate(), the weight at that time is stored and removed whenexitPosition()is called.
0xRektora (Tapioca) confirmed