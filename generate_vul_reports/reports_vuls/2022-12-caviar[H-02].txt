[H-02] Liquidity providers may lose funds when adding liquidity
Submitted byJeiwan, also found byminhtrng,minhquanym,HE1M,wait,hansfriese,BAHOZ,unforgiven,0xxm,Junnon,bytehat,UNCHAIN,carlitox477,RaymondFam,Chom,CRYP70,9svR6w,mauricio1802,__141345__,hihen,caventa,koxuan,obront,nicobevi,shung,cccz,Bobface, andchaduke
Liquidity providers may lose a portion of provided liquidity in either of the pair tokens. While theminLpTokenAmountprotects from slippage when adding liquidity, it doesn’t protect from providing liquidity at different K.
Proof of Concept
ThePaircontract is designed to receive liquidity from liquidity providers (Pair.sol#L63). First liquidity provider in a pool may provide arbitrary token amounts and set the initial price (Pair.sol#L425-L426), but all other liquidity providers must provide liquidity proportionally to current pool reserves (Pair.sol#L420-L423). Since a pool is made of two tokens and liquidity is provided in both tokens, there’s a possibility for a discrepancy: token amounts may be provided in different proportions. When this happens, the smaller of the proportions is chosen to calculate the amount of LP tokens minted (Pair.sol#L420-L423):
// calculate amount of lp tokens as a fraction of existing reservesuint256baseTokenShare= (baseTokenAmount*lpTokenSupply) /baseTokenReserves();uint256fractionalTokenShare= (fractionalTokenAmount*lpTokenSupply) /fractionalTokenReserves();returnMath.min(baseTokenShare,fractionalTokenShare);
As a result, the difference in proportions will create an excess of tokens that won’t be redeemable for the amount of LP tokens minted. The excess of tokens gets, basically, donated to the pool: it’ll be shared among all liquidity providers of the pool. While theminLpTokenAmountargument of theaddfunction (Pair.sol#L63) allows liquidity providers to set the minimal amount of LP tokens they want to receive, it doesn’t allow them to minimize the disproportion of token amounts or avoid it at all.
// test/Pair/unit.Add.t.solfunctiontestLockOfFunds_AUDIT()public{addressalice=address(0x31337);addressbob=address(0x12345);vm.label(alice,"alice");vm.label(bob,"bob");deal(address(usd),alice,100e18,true);deal(address(usd),bob,100e18,true);deal(address(p),alice,100e18,true);deal(address(p),bob,100e18,true);// Alice is the first liquidity provider.vm.startPrank(alice);usd.approve(address(p),type(uint256).max);p.add(10ether,10ether,0);vm.stopPrank();// Bob provides liquidity to the pool and sets the minimal LP amount.// The token amounts are deposited in different proportions, thus the smaller// one will be chosen to calculate the amount of LP tokens Bob will receive.vm.startPrank(bob);usd.approve(address(p),type(uint256).max);uint256minLPAmount=1e18;uint256bobLPAmount=p.add(1.2ether,1ether,minLPAmount);vm.stopPrank();// Bob has received the minimal LP amount he wanted.assertEq(bobLPAmount,minLPAmount);// However, after removing all his liquidity from the pool...(uint256bobUSDBefore,uint256bobFracBefore) = (usd.balanceOf(bob),p.balanceOf(bob));vm.prank(bob);p.remove(minLPAmount,0,0);(uint256bobUSDAfter,uint256bobFracAfter) = (usd.balanceOf(bob),p.balanceOf(bob));// ... Bob received less USD than he deposited.assertEq(bobUSDAfter-bobUSDBefore,1.018181818181818181ether);assertEq(bobFracAfter-bobFracBefore,1.000000000000000000ether);}
Recommended Mitigation Steps
In theaddfunction, consider calculating optimal token amounts based on the amounts specified by user, current pool reserves, and the minimal LP tokens amount specified by user. As a reference, consider this piece from the Uniswap V2 Router:UniswapV2Router02.sol#L45-L60.
outdoteth (Caviar) confirmed and commented:
Fixed in:https://github.com/outdoteth/caviar/pull/2By allowing a user to specify aminPriceandmaxPricethat they are willing to LP at along with theminLpTokenAmountthat they would like to receive. The price calculation is based on this:https://github.com/outdoteth/caviar/blob/main/src/Pair.sol#L471