[H-02] The return value of the _sendForReceiver function is not set, causing the receiver to receive more fees
Submitted by cccz, also found by WatchPug
In the NFTXSimpleFeeDistributor.sol contract, the distribute function is used to distribute the fee, and the distribute function judges whether the fee is sent successfully according to the return value of the _sendForReceiver function.
functiondistribute(uint256vaultId)externaloverridevirtualnonReentrant{require(nftxVaultFactory!=address(0));address_vault=INFTXVaultFactory(nftxVaultFactory).vault(vaultId);uint256tokenBalance=IERC20Upgradeable(_vault).balanceOf(address(this));if(distributionPaused||allocTotal==0) {IERC20Upgradeable(_vault).safeTransfer(treasury,tokenBalance);return;}uint256length=feeReceivers.length;uint256leftover;for(uint256i=0;i<length;i++) {FeeReceivermemory_feeReceiver=feeReceivers[i];uint256amountToSend=leftover+ ((tokenBalance*_feeReceiver.allocPoint) /allocTotal);uint256currentTokenBalance=IERC20Upgradeable(_vault).balanceOf(address(this));amountToSend=amountToSend>currentTokenBalance?currentTokenBalance:amountToSend;boolcomplete=_sendForReceiver(_feeReceiver,vaultId,_vault,amountToSend);if(!complete) {leftover=amountToSend;}else{leftover=0;}}
In the _sendForReceiver function, when _receiver is not a contract, no value is returned. By default, this will return false. This will make the distribute function think that the fee sending has failed, and will send more fees next time.
function_sendForReceiver(FeeReceivermemory_receiver,uint256_vaultId,address_vault,uint256amountToSend)internalvirtualreturns(bool) {if(_receiver.isContract) {IERC20Upgradeable(_vault).approve(_receiver.receiver,amountToSend);// If the receive is not properly processed, send it to the treasury instead.bytesmemorypayload=abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector,_vaultId,amountToSend);(boolsuccess,) =address(_receiver.receiver).call(payload);// If the allowance has not been spent, it means we can pass it forward to next.returnsuccess&&IERC20Upgradeable(_vault).allowance(address(this),_receiver.receiver) ==0;}else{IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver,amountToSend);}}
Proof of Concept
https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L157-L168
https://github.com/code-423n4/2021-12-nftx/blob/main/nftx-protocol-v2/contracts/solidity/NFTXSimpleFeeDistributor.sol#L49-L67
Recommended Mitigation Steps
function_sendForReceiver(FeeReceivermemory_receiver,uint256_vaultId,address_vault,uint256amountToSend)internalvirtualreturns(bool) {if(_receiver.isContract) {IERC20Upgradeable(_vault).approve(_receiver.receiver,amountToSend);// If the receive is not properly processed, send it to the treasury instead.bytesmemorypayload=abi.encodeWithSelector(INFTXLPStaking.receiveRewards.selector,_vaultId,amountToSend);(boolsuccess, ) =address(_receiver.receiver).call(payload);// If the allowance has not been spent, it means we can pass it forward to next.returnsuccess&&IERC20Upgradeable(_vault).allowance(address(this),_receiver.receiver) ==0;}else{-IERC20Upgradeable(_vault).safeTransfer(_receiver.receiver,amountToSend);+returnIERC20Upgradeable(_vault).safeTransfer(_receiver.receiver,amountToSend);}}
0xKiwi (NFTX) confirmed, but disagreed with high severity and commented:
Good catch, thank you. Disagreeing with severity though since this is a permissioned contract, no user funds are at risk and this would most likely cause some failures.We aren’t using any EOAs as receivers in production or testing, so this has not been caught. Thank you.
0xKiwi (NFTX) resolved
LSDan (judge) commented:
I agree with the warden on this one. Funds are directly at risk and the likelihood of this occurring is 100%. I’m not sure if it matters if the funds are user funds or protocol funds. This would eventually have become a big problem that affected the protocol’s ability to function.