[H-02] Incorrect Expiry Used ingetHlPricesFunction When Burning A ProductIDAllow Double Withdrawal Exploit in DNT Vaults
Lines of Code
DNTVaultAAVEDNTleverageDNT
Description
ThegetHlPricesfunction may include prices after the intendedexpirytime when theburn()function is called inDNTVaultcontract after theexpirydate (more than 1 day atleast). This can lead to incorrect settlement calculations and allow an attacker to double withdraw his bet.The expiry passed togetHlPrices()might be later than the product’s actualexpiry, that’s because we always passlatestExpiry, which is basically current time rounded  togetMakerPayoffandgetMinterPayofffunctions:// some code ...>>uint256latestExpiry= (block.timestamp-28800) /86400*86400+28800;if(isMaker==1) {>>payoff=getMakerPayoff(latestTerm,latestExpiry,anchorPrices,amount);}else{>>     (payoff,settlementFee) =getMinterPayoff(latestTerm,latestExpiry,anchorPrices,amount);}Note that theexpirypassed togetHlPrices()might be later than the product’s actualexpiry, causing the function to iterate over and include prices that should not be considered and exclude some that should be included. This results in settling the payoff incorrectly, as prices beyond the product’s expiry can skew the high/low price determination.
>>payoff=STRATEGY.getMakerPayoff(anchorPrices,ORACLE.getHlPrices(term,expiry),amount);
Since the minter and the maker call this function separately, they might use differentlatestExpiryvalues if they burn their tokens at different times. This discrepancy can lead to inconsistent settlement values for the two parties.
Attack Example:
An attacker could take advantage of that by opening a position with themselves and monitoring the prices after the expiry. When prices are favorable to the minter, the attacker burns the minter’s token id.Conversely, when prices favor the maker, the attacker closes the maker’s position. This allows the attacker to double withdraw their bet, effectively draining the protocol with a large position.
Note: This issue is present in allDNT Vaults.
Recommendation
ForDNTvaults, always ensure that the time used for settlement is equal to or less than the product’s realexpiry. Implement checks to prevent using a later expiry time:
function _burn(uint256 term, uint256 expiry, uint256[2] memory anchorPrices, uint256 isMaker) internal nonReentrant returns (uint256 payoff) {uint256 productId = getProductId(term, expiry, anchorPrices, isMaker);(uint256 latestTerm, bool _isBurnable) = isBurnable(term, expiry, anchorPrices);require(_isBurnable, "Vault: not burnable");// check if settled-        uint256 latestExpiry = (block.timestamp - 28800) / 86400 * 86400 + 28800;+        uint256 current = (block.timestamp - 28800) / 86400 * 86400 + 28800;+        uint256 latestExpiry = current > expiry ? expiry : currentrequire(ORACLE.settlePrices(latestExpiry, 1) > 0, "Vault: not settled");// more code ...}function _burnBatch(Product[] calldata products) internal nonReentrant returns (uint256 totalPayoff) {//some code ..for (uint256 i = 0; i < products.length; i++) {// check if settled-            uint256 latestExpiry = (block.timestamp - 28800) / 86400 * 86400 + 28800;+            Product memory product = products[i];+            uint256 current = (block.timestamp - 28800) / 86400 * 86400 + 28800;+            uint256 latestExpiry = current > product.expiry ? product.expiry  : current+            require(ORACLE.settlePrices(latestExpiry, 1) > 0, "Vault: not settled");-            Product memory product = products[i];}// more code ....}
Sofa Protocol
Fixed in commit#a83b.
Code4rena Pro League
Verified. The DNT vaults now ensure that settlement calculation will not include prices after product expiry.