[H-11]ConvexStakingWrapper._calcRewardIntegral()Can Be Manipulated To Steal Tokens From Other Pools
Submitted by leastwood, also found by cmichel and kirk-baird
TheConvexStakingWrapper.solimplementation makes several modifications to the original design. One of the key changes is the ability to add multiple pools into the wrapper contract, where each pool is represented by a unique_pid. By doing this, we are able to aggregate pools and their LP tokens to simplify the token distribution process.
However, the interdependence between pools introduces new problems. Because the original implementation uses the contract’s reward token balance to track newly claimed tokens, it is possible for a malicious user to abuse the unguardedgetRewardfunction to maximise the profit they are able to generate. By callinggetRewardon multiple pools with the same reward token (i.e.cvx), users are able to siphon rewards from other pools. This inevitably leads to certain loss of rewards for users who have deposited LP tokens into these victim pools. Ascrvandcvxare reward tokens by default, it is very likely that someone will want to exploit this issue.
Proof of Concept
Let’s consider the following scenario:
There are two convex pools with_pid0 and 1.Both pools currently only distributecvxtokens.Alice deposits LP tokens into the pool with_pid0.Both pools earn 100cvxtokens which are to be distributed to the holders of the two pools.While Alice is a sole staker of the pool with_pid0, the pool with_pid1 has several stakers.Alice decides she wants to maximise her potential rewards, so she directly calls the unguardedIRewardStaking(convexPool[_pid]).getRewardfunction on both pools, resulting in 200cvxtokens being sent to the contract.She then decides to deposit the 0 amount to execute the_calcRewardIntegralfunction on the pool with_pid0. However, this function will calculated_rewardasbal - reward.remainingwhich is effectively the change in contract balance. As we have directly claimedcvxtokens over the two pools, thisd_rewardwill be equal to 200.Alice is then entitled to the entire 200 tokens as she is the sole staker of her pool. So instead of receiving 100 tokens, she is able to siphon rewards from other pools.
Altogether, this will lead to the loss of rewards for other stakers as they are unable to then claim their rewards.
ConvexStakingWrapper.sol#L216-L259
function _calcRewardIntegral(uint256 _pid,uint256 _index,address _account,uint256 _balance,uint256 _supply) internal {RewardType memory reward = rewards[_pid][_index];//get difference in balance and remaining rewards//getReward is unguarded so we use remaining to keep track of how much was actually claimeduint256 bal = IERC20(reward.token).balanceOf(address(this));uint256 d_reward = bal - reward.remaining;// send 20 % of cvx / crv reward to treasuryif (reward.token == cvx || reward.token == crv) {IERC20(reward.token).transfer(treasury, d_reward / 5);d_reward = (d_reward * 4) / 5;}IERC20(reward.token).transfer(address(claimContract), d_reward);if (_supply > 0 && d_reward > 0) {reward.integral =reward.integral +uint128((d_reward * 1e20) / _supply);}//update user integralsuint256 userI = userReward[_pid][_index][_account].integral;if (userI < reward.integral) {userReward[_pid][_index][_account].integral = reward.integral;claimContract.pushReward(_account,reward.token,(_balance * (reward.integral - userI)) / 1e20);}//update remaining reward here since balance could have changed if claimingif (bal != reward.remaining) {reward.remaining = uint128(bal);}rewards[_pid][_index] = reward;}
Tools Used
Manual code review.Confirmation from Taek.
Recommended Mitigation Steps
Consider redesigning this mechanism such that all pools have theirgetRewardfunction called in_checkpoint. The_calcRewardIntegralfunction can then ensure that each pool is allocated only a fraction of the total rewards instead of the change in contract balance. Other implementations might be more ideal, so it is important that careful consideration is taken when making these changes.
leekt (Concur) confirmed
Alex the Entreprenerd (judge) commented:
The warden has shown how, by having the same token as rewards for multiple pools, the math for claiming can be broken, allowing the depositor of one pool to claim a portion of the token reward earned by all pools.Normally this would be contingent on implementation or overlap of the tokens, however, because we’re dealing with CVX we already know for certain that CVX and cvxCRV is going to be a reward for the majority of the pools.This finding ultimately shows how to break the accounting of the reward contract while stealing yield from all other pools, and for that reason, I believe High Severity to be valid.