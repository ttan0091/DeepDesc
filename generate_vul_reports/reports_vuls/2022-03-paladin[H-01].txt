[H-01]DropPerSecondis not updated homogeneously, the rewards emission can be much higher than expected in some cases
Submitted by WatchPug, also found by Czar102
HolyPaladinToken.sol#L715-L743
function_updateDropPerSecond()internalreturns(uint256){// If no more need for monthly updates => decrease duration is overif(block.timestamp>startDropTimestamp+dropDecreaseDuration) {// Set the current DropPerSecond as the end value// Plus allows to be updated if the end value is later updatedif(currentDropPerSecond!=endDropPerSecond) {currentDropPerSecond=endDropPerSecond;lastDropUpdate=block.timestamp;}returnendDropPerSecond;}if(block.timestamp<lastDropUpdate+MONTH)returncurrentDropPerSecond;// Update it once a monthuint256dropDecreasePerMonth= (startDropPerSecond-endDropPerSecond) / (dropDecreaseDuration/MONTH);uint256nbMonthEllapsed= (block.timestamp-lastDropUpdate) /MONTH;uint256dropPerSecondDecrease=dropDecreasePerMonth*nbMonthEllapsed;// We calculate the new dropPerSecond value// We don't want to go under the endDropPerSeconduint256newDropPerSecond=currentDropPerSecond-dropPerSecondDecrease>endDropPerSecond?currentDropPerSecond-dropPerSecondDecrease:endDropPerSecond;currentDropPerSecond=newDropPerSecond;lastDropUpdate=block.timestamp;returnnewDropPerSecond;}
When current time islastDropUpdate + (2*MONTH-1):
nbMonthEllapsedwill be round down to1, while it’s actually 1.99 months passed, but because of precision loss, the smart contract will believe it’s only 1 month elapsed, as a result,DropPerSecondwill only decrease by 1 *dropDecreasePerMonth.
In another word, due to the precision loss in calculating the number of months elapsed, for each_updateDropPerSecond()there can be a short of up to1 * dropDecreasePerMonthfor the decrease of emission rate.
At the very edge case, if all the updates happened just like the scenario above. by the end of thedropDecreaseDuration, it will drop only12 * dropDecreasePerMonthin total, while it’s expected to be24 * dropDecreasePerMonth.
So only half of(startDropPerSecond - endDropPerSecond)is actually decreased. And the last timeupdateDropPerSecondis called,DropPerSecondwill suddenly drop toendDropPerSecond.
Impact
As theDropPerSecondis not updated correctly, in most of thedropDecreaseDuration, the actual rewards emission rate is much higher than expected. As a result, the total rewards emission can be much higher than expected.
Recommended Mitigation Steps
Change to:
function_updateDropPerSecond()internalreturns(uint256){// If no more need for monthly updates => decrease duration is overif(block.timestamp>startDropTimestamp+dropDecreaseDuration) {// Set the current DropPerSecond as the end value// Plus allows to be updated if the end value is later updatedif(currentDropPerSecond!=endDropPerSecond) {currentDropPerSecond=endDropPerSecond;lastDropUpdate=block.timestamp;}returnendDropPerSecond;}if(block.timestamp<lastDropUpdate+MONTH)returncurrentDropPerSecond;// Update it once a monthuint256dropDecreasePerMonth= (startDropPerSecond-endDropPerSecond) / (dropDecreaseDuration/MONTH);uint256nbMonthEllapsed=UNIT* (block.timestamp-lastDropUpdate) /MONTH;uint256dropPerSecondDecrease=dropDecreasePerMonth*nbMonthEllapsed/UNIT;// We calculate the new dropPerSecond value// We don't want to go under the endDropPerSeconduint256newDropPerSecond=currentDropPerSecond-dropPerSecondDecrease>endDropPerSecond?currentDropPerSecond-dropPerSecondDecrease:endDropPerSecond;currentDropPerSecond=newDropPerSecond;lastDropUpdate=block.timestamp;returnnewDropPerSecond;}
Kogaroshi (Paladin) confirmed and commented:
Mitigation for this issue can be found here:PaladinFinance/Paladin-Tokenomics@4d050eb.Mitigation chosen is different from the Warden recommendation: since we want to keep thedropPerSecondto have a monthly decrease, we set the newlastUpdateas the previouslastUpdate+ (nb_of_months_since_last_update*month_duration).