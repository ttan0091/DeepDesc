[H-02] Risk of reentrancyonERC721Receivedfunction to manipulate collateral token configs shares
Submitted byAymen0909, also found byb0g0
https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/V3Vault.sol#L454-L473https://github.com/code-423n4/2024-03-revert-lend/blob/main/src/V3Vault.sol#L1223-L1241
Issue Description
TheonERC721Receivedfunction is invoked whenever the vault contract receives a Uniswap V3 position ERC721 token. This can happen either when an owner creates a new position or when a transformation occurs.
For this issue, we’ll focus on the second case, specifically when a position is going through a transformation, which creates a new position token. In such a case, we havetokenId != oldTokenId, and the else block is run, as shown below:
functiononERC721Received(address,addressfrom,uint256tokenId,bytescalldatadata)externaloverridereturns(bytes4){...if{...}else{uint256oldTokenId=transformedTokenId;// if in transform mode - and a new position is sent - current position is replaced and returnedif(tokenId!=oldTokenId) {addressowner=tokenOwner[oldTokenId];// set transformed token to new onetransformedTokenId=tokenId;// copy debt to new tokenloans[tokenId] =Loan(loans[oldTokenId].debtShares);_addTokenToOwner(owner,tokenId);emitAdd(tokenId,owner,oldTokenId);// clears data of old loan_cleanupLoan(oldTokenId,debtExchangeRateX96,lendExchangeRateX96,owner);//@audit can reenter with onERC721Received and call repay or borrow to call _updateAndCheckCollateral twice and manipulate collateral token configs// sets data of new loan_updateAndCheckCollateral(tokenId,debtExchangeRateX96,lendExchangeRateX96,0,loans[tokenId].debtShares);}}returnIERC721Receiver.onERC721Received.selector;}
We should note that the_cleanupLoanfunction does return the old position token to the owner:
function_cleanupLoan(uint256tokenId,uint256debtExchangeRateX96,uint256lendExchangeRateX96,addressowner)internal{_removeTokenFromOwner(owner,tokenId);_updateAndCheckCollateral(tokenId,debtExchangeRateX96,lendExchangeRateX96,loans[tokenId].debtShares,0);deleteloans[tokenId];nonfungiblePositionManager.safeTransferFrom(address(this),owner,tokenId);emitRemove(tokenId,owner);}
The issue that can occur is that the_cleanupLoanis invoked before the_updateAndCheckCollateralcall. So, a malicious owner can use theonERC721Receivedcallback when receiving the old token to call theborrowfunction, which makes changes toloans[tokenId].debtSharesand calls_updateAndCheckCollateral. When the call resumes, theV3Vault.onERC721Receivedfunction will call_updateAndCheckCollateralagain, resulting in incorrect accounting of internal token configs debt shares (tokenConfigs[token0].totalDebtShares&tokenConfigs[token1].totalDebtShares) and potentially impacting the vault borrowing process negatively.
Proof of Concept
Let’s use the following scenario to demonstrate the issue:
Before starting, we suppose the following states:
tokenConfigs[token0].totalDebtShares = 10000tokenConfigs[token1].totalDebtShares = 15000Bob has previously deposited a UniswapV3 position (which usestoken0andtoken1) withtokenId = 12and borrowedloans[tokenId = 12].debtShares = 1000debt shares.Bob calls thetransformfunction to change the range of his position using the AutoRange transformer, which mints a new ERC721 tokentokenId = 20for the newly arranged position and sends it to the vault.Upon receiving the new token, theV3Vault.onERC721Receivedfunction is triggered. As we’re in transformation mode and the token ID is different, the second else block above will be executed.V3Vault.onERC721Receivedwill copy loan debt shares to the new token, so we’ll haveloans[tokenId = 20].debtShares = 1000.ThenV3Vault.onERC721Receivedwill invoke the_cleanupLoanfunction to clear the data of the old loan and transfer the old position tokentokenId = 12back to Bob.5.1._cleanupLoanwill also call_updateAndCheckCollateralfunction to changeoldShares = 1000 --> newShares = 0(remove old token shares), resulting in:tokenConfigs[token0].totalDebtShares = 10000 - 1000 = 9000.tokenConfigs[token1].totalDebtShares = 15000 - 1000 = 14000.Bob, upon receiving the old position token, will also use the ERC721onERC721Receivedcallback to call theborrowfunction. He will borrow 200 debt shares against his new position tokentokenId = 20.6.1. Theborrowfunction will update the token debt shares fromloans[tokenId = 20].debtShares = 1000to:loans[tokenId = 20].debtShares = 1000 + 200 = 1200(assuming the position is healthy).6.2. Theborrowfunction will also invoke the_updateAndCheckCollateralfunction to changeoldShares = 1000 --> newShares = 1200fortokenId = 20, resulting in:tokenConfigs[token0].totalDebtShares = 9000 + 200 = 9200.tokenConfigs[token1].totalDebtShares = 14000 + 200 = 14200.Bob’s borrow call ends, and theV3Vault.onERC721Receivedcall resumes._updateAndCheckCollateralgets called again, changingoldShares = 0 --> newShares = 1200(as the borrow call changed the token debt shares), resulting in:tokenConfigs[token0].totalDebtShares = 9200 + 1200 = 10400.tokenConfigs[token1].totalDebtShares = 14200 + 1200 = 15400.
Now, let’s assess what Bob managed to achieve by taking a normal/honest transformation process (without using theonERC721Receivedcallback) and then a borrow operation scenario:
Normally, whenV3Vault.onERC721Receivedis called, it shouldn’t change the internal token configs debt shares (tokenConfigs[token0].totalDebtShares&tokenConfigs[token1].totalDebtShares). After a normalV3Vault.onERC721Received, we should still have:tokenConfigs[token0].totalDebtShares = 10000.tokenConfigs[token1].totalDebtShares = 15000.Then, when Bob borrows 200 debt shares against the new token, we should get:tokenConfigs[token0].totalDebtShares = 10000 + 200 = 10200.tokenConfigs[token1].totalDebtShares = 15000 + 200 = 15200.
We observe that by using theonERC721Receivedcallback, Bob managed to increase the internal token configs debt shares (tokenConfigs[token0].totalDebtShares&tokenConfigs[token1].totalDebtShares) by 200 debt shares more than expected.
This means that Bob, by using this attack, has manipulated the internal token configs debt shares, making the vault believe it has 200 additional debt shares. Bob can repeat this attack multiple times until he approaches the limit represented bycollateralValueLimitFactorX32andcollateralValueLimitFactorX32multiplied by the amount of asset lent as shown below:
uint256lentAssets=_convertToAssets(totalSupply(),lendExchangeRateX96,Math.Rounding.Up);uint256collateralValueLimitFactorX32=tokenConfigs[token0].collateralValueLimitFactorX32;if(collateralValueLimitFactorX32<type(uint32).max&&_convertToAssets(tokenConfigs[token0].totalDebtShares,debtExchangeRateX96,Math.Rounding.Up) >(lentAssets*collateralValueLimitFactorX32) /Q32) {revertCollateralValueLimit();}collateralValueLimitFactorX32=tokenConfigs[token1].collateralValueLimitFactorX32;if(collateralValueLimitFactorX32<type(uint32).max&&_convertToAssets(tokenConfigs[token1].totalDebtShares,debtExchangeRateX96,Math.Rounding.Up) >(lentAssets*collateralValueLimitFactorX32) /Q32) {revertCollateralValueLimit();}
Then, when other borrowers try to call theborrowfunction, it will revert because_updateAndCheckCollateralwill trigger theCollateralValueLimiterror, thinking there is too much debt already. However, this is not the case, as the internal token configs debt shares have been manipulated (increased) by an attacker (Bob).
This attack is irreversible because there is no way to correct the internal token configs debt shares (tokenConfigs[token0].totalDebtShares&tokenConfigs[token1].totalDebtShares), and the vault will remain in that state, not allowing users to borrow, resulting in no interest being accrued and leading to financial losses for the lenders and the protocol.
Impact
A malicious attacker could use the AutoRange transformation process to manipulate the internal token configs debt shares, potentially resulting in:
Fewer loans being allowed by the vault than expected.A complete denial-of-service (DOS) for all borrow operations.
Tools Used
VS Code
Recommended Mitigation
The simplest way to address this issue is to ensure that theonERC721Receivedfunction follows the Correctness by Construction (CEI) pattern, as follows:
function onERC721Received(address, address from, uint256 tokenId, bytes calldata data)externaloverridereturns (bytes4){...if {...} else {uint256 oldTokenId = transformedTokenId;// if in transform mode - and a new position is sent - current position is replaced and returnedif (tokenId != oldTokenId) {address owner = tokenOwner[oldTokenId];// set transformed token to new onetransformedTokenId = tokenId;// copy debt to new tokenloans[tokenId] = Loan(loans[oldTokenId].debtShares);_addTokenToOwner(owner, tokenId);emit Add(tokenId, owner, oldTokenId);--          // clears data of old loan--          _cleanupLoan(oldTokenId, debtExchangeRateX96, lendExchangeRateX96, owner);// sets data of new loan_updateAndCheckCollateral(tokenId, debtExchangeRateX96, lendExchangeRateX96, 0, loans[tokenId].debtShares);++          // clears data of old loan++          _cleanupLoan(oldTokenId, debtExchangeRateX96, lendExchangeRateX96, owner);}}return IERC721Receiver.onERC721Received.selector;}
Assessed type
Context
kalinbas (Revert) confirmed via duplicate Issue #309:
Revert mitigated:
PRshereandhere- removed sending of NFT to avoid reentrancy.
Status:Mitigation confirmed. Full details in reports fromthank_you,ktgandb0g0.