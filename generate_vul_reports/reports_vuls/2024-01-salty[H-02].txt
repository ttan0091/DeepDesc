[H-02] First Liquidity provider can claim all initial pool rewards
Submitted by0xCiphky, also found by 0xCiphky (1,2),J4X,Toshii,stackachu,Silvermist,DedOhWale,OMEN,zhaojie, 0x3b (1,2,3),ether_sky,Evo,israeladelaja, RootKit0xCE (1,2),a3yip6,Stormreckson, andtwcctop
https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/staking/StakingRewards.sol#L57
https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/staking/StakingRewards.sol#L147
https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/staking/StakingRewards.sol#L232
Liquidity providers can add liquidity to the protocol using the depositCollateralAndIncreaseShare or depositLiquidityAndIncreaseShare functions, both functions call the _increaseUserShare function to stake the users liquidity and account for the positions rewards. The current implementation has an issue, particularly in how it deals with the virtualRewards calculation for the first user. Since there is no current shares in the pool, then the virtualRewards calculation is skipped.
// Increase a user's share for the given whitelisted pool.function_increaseUserShare(addresswallet,bytes32poolID,uint256increaseShareAmount,booluseCooldown)internal{...uint256existingTotalShares=totalShares[poolID];if(existingTotalShares!=0// prevent / 0) {// Round up in favor of the protocol.uint256virtualRewardsToAdd=Math.ceilDiv(totalRewards[poolID] *increaseShareAmount,existingTotalShares);user.virtualRewards+=uint128(virtualRewardsToAdd);totalRewards[poolID] +=uint128(virtualRewardsToAdd);}// Update the deposit balancesuser.userShare+=uint128(increaseShareAmount);totalShares[poolID] =existingTotalShares+increaseShareAmount;...}
To understand the implications of this, we need to look at how a user’s rewards are calculated. The formula used in the userRewardForPool function is:
uint256 rewardsShare= (totalRewards[poolID] * user.userShare) / totalShares[poolID];
From this calculated rewardsShare, virtualRewards are then deducted:
return rewardsShare - user.virtualRewards;
In the case where the first user stakes in an empty pool, they end up having the same number of shares as the totalShares in the pool, but with zero virtualRewards. This means that the first user can claim all the pools rewards in the staking contract, as their share of rewards would not have the necessary deduction of virtualRewards.
// Returns the user's pending rewards for a specified pool.functionuserRewardForPool(addresswallet,bytes32poolID)publicviewreturns(uint256) {...// Determine the share of the rewards for the user based on their deposited shareuint256rewardsShare= (totalRewards[poolID] *user.userShare) /totalShares[poolID];...returnrewardsShare-user.virtualRewards;}
A potential issue is thelackof Initial Rewards in the Contract. Initially, the staking contract does not contain any rewards, meaning that if a user were to claim rewards immediately, they would receive nothing. To overcome this, the user needs to trigger theupkeepfunction. This function is responsible for transferring up to the maximum allowable daily rewards to the staking contract.
Theupkeepcontract employs a timer to regulate the frequency and quantity of rewards distribution. However, since this timer begins counting from the moment of the contract’s deployment (in the constructor), and considering the initial voting period for starting up the exchange spans several days, it becomes feasible to distribute the maximum daily reward amount by invoking upkeep.
Impact
A LP can exploit this vulnerability to claim all the current staking rewards in the contract. Initially, there are 555k SALT bootstrap rewards per pool in the stakingRewardsEmitter, which are emitted at a rate of 1% per day. As a result, the first LP could claim up to 5.5k SALT.
Proof Of Concept
functiontestFirstLPCanClaimAllRewards()public{assertEq(salt.balanceOf(alice),0);bytes32poolID1=PoolUtils._poolID(wbtc,weth);bytes32[]memorypoolIDs=newbytes32[](1);poolIDs[0] =poolID1;skip(2days);// Total needs to be worth at least $2500uint256depositedWBTC= (1000ether*10**8) /priceAggregator.getPriceBTC();uint256depositedWETH= (1000ether*10**18) /priceAggregator.getPriceETH();(uint256reserveWBTC,uint256reserveWETH) =pools.getPoolReserves(wbtc,weth);vm.startPrank(alice);// Alice call upkeepupkeep.performUpkeep();// check total rewards for pooluint256[]memorytotalRewards=newuint256[](1);totalRewards=collateralAndLiquidity.totalRewardsForPools(poolIDs);// Alice will deposit collateral(uint256addedAmountWBTC,uint256addedAmountWETH,uint256addedLiquidity) =collateralAndLiquidity.depositCollateralAndIncreaseShare(depositedWBTC,depositedWETH,0,block.timestamp,false);// check alices rewardsuintrewardsAlice=collateralAndLiquidity.userRewardForPool(alice,poolIDs[0]);collateralAndLiquidity.claimAllRewards(poolIDs);vm.stopPrank();assertEq(totalRewards[0],rewardsAlice);assertEq(salt.balanceOf(alice),totalRewards[0]);}
Tools Used:
Foundry
Recommendation:
The protocol can address this vulnerability in two ways:
Call theperformUpkeepfunction just before the initial distribution. This resets the timer, ensuring that a very small amount of rewards is sent to the staking contract if called again.Change thelastUpkeepTimeto the start of when the exchange goes live, instead of in the constructor. This also ensures that only a minimal amount of rewards is sent to the staking contract upon subsequent calls, mitigating the problem.
othernet-global (Salty.IO) confirmed and commented:
performUpkeep is now called at the start of BootstrapBallot.finalizeBallot to reset the emissions timers just before liquidity rewards claiming is started.https://github.com/othernet-global/salty-io/commit/4f0c9c6a6e3e4234135ab7119a0e380af3e9776c
Status:Mitigation confirmed. Full details in reports fromzzebra83,0xpiken, andt0x1c.