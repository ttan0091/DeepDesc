[H-02] PositionManager’smoveLiquiditycan set wrong deposit time and permanently freeze LP funds moved
Submitted byhyh, also found bynobody2018
moveLiquidity()set new destination index LP entry deposit time to be equal to the source index deposit time, while destination bucket might have defaulted after that time.
This is generally not correct as source bucket bankruptcy is controlled (i.e. LP shares that are moved are healthy), while the destination bucket’s bankruptcy time, being arbitrary, can be higher than source index deposit time, and in this case the funds will become inaccessible after such a move (i.e. healthy shares will be marked as defaulted due to incorrect deposit time used).
In other words the funds are moved from healthy non-default zone to an arbitrary point, which can be either healthy or not. In the latter case this constitutes a loss for an owner astoIndexbucket bankruptcy time exceeding deposit time means that all other retrieval operations will be blocked.
Impact
Owner will permanently lose access to the LP shares wheneverpositions[params_.tokenId][params_.toIndex]bucket bankruptcy time is greater thanpositions[params_.tokenId][params_.fromIndex].depositTime.
moveLiquidity()is a common operation, while source and destination bucket bankruptcy times can be related in an arbitrary manner, and the net impact is permanent fund freeze, so this is a fund loss without material prerequisites, setting the severity to be high.
Proof of Concept
moveLiquidity()setstoPositiondeposit time to befromPosition.depositTime:
https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L262-L323
functionmoveLiquidity(MoveLiquidityParamscalldataparams_)externaloverridemayInteract(params_.pool, params_.tokenId)nonReentrant{PositionstoragefromPosition=positions[params_.tokenId][params_.fromIndex];MoveLiquidityLocalVarsmemoryvars;>>vars.depositTime=fromPosition.depositTime;// handle the case where owner attempts to move liquidity after they've already done soif(vars.depositTime==0)revertRemovePositionFailed();// ensure bucketDeposit accounts for accrued interestIPool(params_.pool).updateInterest();// retrieve info of bucket from which liquidity is moved(vars.bucketLP,vars.bucketCollateral,vars.bankruptcyTime,vars.bucketDeposit,) =IPool(params_.pool).bucketInfo(params_.fromIndex);// check that bucket hasn't gone bankrupt since memorializationif(vars.depositTime<=vars.bankruptcyTime)revertBucketBankrupt();// calculate the max amount of quote tokens that can be moved, given the tracked LPvars.maxQuote=_lpToQuoteToken(vars.bucketLP,vars.bucketCollateral,vars.bucketDeposit,fromPosition.lps,vars.bucketDeposit,_priceAt(params_.fromIndex));EnumerableSet.UintSetstoragepositionIndex=positionIndexes[params_.tokenId];// remove bucket index from which liquidity is moved from tracked positionsif(!positionIndex.remove(params_.fromIndex))revertRemovePositionFailed();// update bucket set at which a position has liquidity// slither-disable-next-line unused-returnpositionIndex.add(params_.toIndex);// move quote tokens in pool(vars.lpbAmountFrom,vars.lpbAmountTo,) =IPool(params_.pool).moveQuoteToken(vars.maxQuote,params_.fromIndex,params_.toIndex,params_.expiry);PositionstoragetoPosition=positions[params_.tokenId][params_.toIndex];// update position LP statefromPosition.lps-=vars.lpbAmountFrom;toPosition.lps+=vars.lpbAmountTo;// update position deposit time to the from bucket deposit time>>toPosition.depositTime=vars.depositTime;
I.e. there is no check forparams_.toIndexbucket situation, the time is just copied.
While there is checking logic in LenderActions, which checks fortoBucketbankruptcy and sets the time accordingly:
https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/libraries/external/LenderActions.sol#L315-L327
vars.toBucketDepositTime=toBucketLender.depositTime;if(vars.toBucketBankruptcyTime>=vars.toBucketDepositTime) {// bucket is bankrupt and deposit was done before bankruptcy time, reset lender lp amounttoBucketLender.lps=toBucketLP_;// set deposit time of the lender's to bucket as bucket's last bankruptcy timestamp + 1 so deposit won't get invalidatedvars.toBucketDepositTime=vars.toBucketBankruptcyTime+1;}else{toBucketLender.lps+=toBucketLP_;}// set deposit time to the greater of the lender's from bucket and the target buckettoBucketLender.depositTime=Maths.max(vars.fromBucketDepositTime,vars.toBucketDepositTime);
This way, while bucket structure deposit time will be controlled and updated, PositionManager’s structure will have the deposit time copied over.
In the case whenpositions[params_.tokenId][params_.fromIndex].depositTimewas less thanparams_.toIndexbankruptcyTime, this will freeze these LP funds as further attempts to use them will be blocked:
https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L262-L285
functionmoveLiquidity(MoveLiquidityParamscalldataparams_)externaloverridemayInteract(params_.pool, params_.tokenId)nonReentrant{PositionstoragefromPosition=positions[params_.tokenId][params_.fromIndex];MoveLiquidityLocalVarsmemoryvars;>>vars.depositTime=fromPosition.depositTime;// handle the case where owner attempts to move liquidity after they've already done soif(vars.depositTime==0)revertRemovePositionFailed();// ensure bucketDeposit accounts for accrued interestIPool(params_.pool).updateInterest();// retrieve info of bucket from which liquidity is moved(vars.bucketLP,vars.bucketCollateral,>>vars.bankruptcyTime,vars.bucketDeposit,) =IPool(params_.pool).bucketInfo();// check that bucket hasn't gone bankrupt since memorialization>>if(vars.depositTime<=vars.bankruptcyTime)revertBucketBankrupt();
https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L352-L372
functionreedemPositions(RedeemPositionsParamscalldataparams_)externaloverridemayInteract(params_.pool, params_.tokenId) {EnumerableSet.UintSetstoragepositionIndex=positionIndexes[params_.tokenId];...for(uint256i=0;i<indexesLength; ) {index=params_.indexes[i];Positionmemoryposition=positions[params_.tokenId][index];if(position.depositTime==0||position.lps==0)revertRemovePositionFailed();// check that bucket didn't go bankrupt after memorialization>>if(_bucketBankruptAfterDeposit(pool,index,position.depositTime))revertBucketBankrupt();
https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L436-L443
function_bucketBankruptAfterDeposit(IPoolpool_,uint256index_,uint256depositTime_)internalviewreturns(bool) {(, ,uint256bankruptcyTime, , ) =pool_.bucketInfo(index_);>>returndepositTime_<=bankruptcyTime;}
Recommended Mitigation Steps
Consider using the resulting time of the destination position, for example:
https://github.com/code-423n4/2023-05-ajna/blob/276942bc2f97488d07b887c8edceaaab7a5c3964/ajna-core/src/PositionManager.sol#L262-L323
function moveLiquidity(MoveLiquidityParams calldata params_) external override mayInteract(params_.pool, params_.tokenId) nonReentrant {Position storage fromPosition = positions[params_.tokenId][params_.fromIndex];MoveLiquidityLocalVars memory vars;vars.depositTime = fromPosition.depositTime;...Position storage toPosition = positions[params_.tokenId][params_.toIndex];// update position LP statefromPosition.lps -= vars.lpbAmountFrom;toPosition.lps   += vars.lpbAmountTo;-       // update position deposit time to the from bucket deposit time+       // update position deposit time with the renewed to bucket deposit time+       (, vars.depositTime) = pool.lenderInfo(params_.toIndex, address(this));toPosition.depositTime = vars.depositTime;
Notice, that this time value will be influenced by the other PositionManager positions in theparams_.toIndexbucket, but the surface described will be closed as it will be controlled againstparams_.toIndexbucket bankruptcy time.
ith-harvey (Ajna) confirmed