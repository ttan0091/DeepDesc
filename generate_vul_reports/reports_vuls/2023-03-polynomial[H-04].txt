[H-04]KangarooVault.removeCollateralupdates storage without actually removing collateral, resulting in lost collateral
Submitted byjoestakey, also found byjuancito,auditor0517,bin2chen,KIntern_NA,chaduke,Bauer, and0x52
The admin can callKangarooVault.addCollateralto add additional collateral to a Power Perp position.
File:src/KangarooVault.sol424:functionaddCollateral(uint256additionalCollateral)externalrequiresAuthnonReentrant{425:SUSD.safeApprove(address(EXCHANGE),additionalCollateral);426:EXCHANGE.addCollateral(positionData.positionId,additionalCollateral);427:428:usedFunds+=additionalCollateral;429:positionData.totalCollateral+=additionalCollateral;430:431:emitAddCollateral(positionData.positionId,additionalCollateral);432:     }
This transfersSUSDto theEXCHANGEand updates theusedFundsandpositionData.totalCollateral
The functionKangarooVault.removeCollateralallows the admin to remove collateral if a position is healthy enough.
File:src/KangarooVault.sol436:functionremoveCollateral(uint256collateralToRemove)externalrequiresAuthnonReentrant{437:         (uint256markPrice,) =LIQUIDITY_POOL.getMarkPrice();438:uint256minColl=positionData.shortAmount.mulWadDown(markPrice);439:minColl=minColl.mulWadDown(collRatio);440:441:require(positionData.totalCollateral>=minColl+collateralToRemove);442:443:usedFunds-=collateralToRemove;444:positionData.totalCollateral-=collateralToRemove;445:446:emitRemoveCollateral(positionData.positionId,collateralToRemove);447:     }
The issue is that this function does not callEXCHANGE.removeCollateral.While it updates storage, it does not actually retrieve any collateral.
Impact
2 problems arising:
processWithdrawalQueuewill revert unexpectedly, asusedFundswill be lower than it should, leading toavailableFundsbeing greater than the real balance ofSUSDavailable (KangarooVault.sol#L279).the main problem: the amount of collateral “removed” inremoveCollateralwill be lost :
When closing a position inKangarooVault._closePosition, the amount of collateral to retrieve is written intradeParams.collateralAmount. As you can see below, it is capped bypositionData.totalCollateral, which was decremented inremoveCollateral.
File:src/KangarooVault.sol687:if(amt>=positionData.shortAmount) {688:longPositionToClose=positionData.longPerp;689:690:tradeParams.amount=positionData.shortAmount;691:tradeParams.collateralAmount=positionData.totalCollateral;//@audit here692:         }else{693:longPositionToClose=amt.mulDivDown(positionData.longPerp,positionData.shortAmount);694:uint256collateralToRemove=amt.mulDivDown(positionData.totalCollateral,positionData.shortAmount);695:696:tradeParams.amount=amt;697:tradeParams.collateralAmount=collateralToRemove;698:         }699:700:SUSD.safeApprove(address(LIQUIDITY_POOL),maxCost);701:uint256totalCost=EXCHANGE.closeTrade(tradeParams);
This is the amount of collateral that will be transferred back to the trader (here theKangarooVault)
src/Exchange.sol_closeTrade()316:shortCollateral.sendCollateral(params.positionId,params.collateralAmount);
File:src/ShortCollateral.sol106:functionsendCollateral(uint256positionId,uint256amount)externaloverrideonlyExchangenonReentrant{107:UserCollateralstorageuserCollateral=userCollaterals[positionId];108:109:userCollateral.amount-=amount;110:111:addressuser=shortToken.ownerOf(positionId);112:113:ERC20(userCollateral.collateral).safeTransfer(user,amount);//@audit capped by `positionData.totalCollateral`
In conclusion, callingremoveCollateralwill result in that amount being lost.
Proof of Concept
Amend this test toKangarooVault.t.sol, which shows how collateral is not transferred upon callingremoveCollateral().
429:     function testCollateralManagement() public {430:         uint256 amt = 1e18;431:         uint256 collDelta = 1000e18;432:433:         kangaroo.openPosition(amt, 0);434:         skip(100);435:         kangaroo.executePerpOrders(emptyData);436:         kangaroo.clearPendingOpenOrders(0);437:438:         (,,,,,,, uint256 initialColl,) = kangaroo.positionData();+439:         uint256 balanceBefore = susd.balanceOf(address(kangaroo));440:441:         kangaroo.addCollateral(collDelta);+442:         uint256 balanceAfter = susd.balanceOf(address(kangaroo));+443:         assertEq(collDelta, balanceBefore - balanceAfter);444:         (,,,,,,, uint256 finalColl,) = kangaroo.positionData();445:446:         assertEq(finalColl, initialColl + collDelta);447:+448:         uint256 balanceBefore2 = susd.balanceOf(address(kangaroo));449:         kangaroo.removeCollateral(collDelta);+450:         uint256 balanceAfter2 = susd.balanceOf(address(kangaroo));+451:         assertEq(0, balanceAfter2 - balanceBefore2); //@audit collateral not removed452:453:         (,,,,,,, uint256 newColl,) = kangaroo.positionData();454:455:         assertEq(newColl, initialColl);456:     }
Tools Used
Manual Analysis, Foundry
Recommended Mitigation
EnsureExchange.removeCollateralis called:
File: src/KangarooVault.sol436:     function removeCollateral(uint256 collateralToRemove) external requiresAuth nonReentrant {437:         (uint256 markPrice,) = LIQUIDITY_POOL.getMarkPrice();438:         uint256 minColl = positionData.shortAmount.mulWadDown(markPrice);439:         minColl = minColl.mulWadDown(collRatio);440:441:         require(positionData.totalCollateral >= minColl + collateralToRemove);442:443:         usedFunds -= collateralToRemove;444:         positionData.totalCollateral -= collateralToRemove;445:+            EXCHANGE.removeCollateral(positionData.positionId, collateralToRemove)446:         emit RemoveCollateral(positionData.positionId, collateralToRemove);447:     }
mubaris (Polynomial) confirmed via duplicate issue#111
Dravee (judge) increased severity to High