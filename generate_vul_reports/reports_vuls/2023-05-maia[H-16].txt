[H-16] Overpaying remaining gas to the user for failinganyExecutecall due to an incorrect gas unit calculation inBranchBridgeAgent
Submitted byKoolex, also found byKoolex
TheanyExecutemethod is called by theAnycall Executoron the destination chain to execute interaction. The user has to pay for the remote callExecutionGas; this is done at the end of the call. However, if there is not enoughgasRemaining, theanyExecutewill be reverted due to a revert caused by theAnycall Executor.
Here is the calculation for the gas used:
///Save gas leftuint256gasLeft=gasleft();//Get Branch Environment Execution Costuint256minExecCost=tx.gasprice* (MIN_EXECUTION_OVERHEAD+_initialGas-gasLeft);//Check if sufficient balanceif(minExecCost>gasRemaining) {_forceRevert();return;}
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1018-L1054
_forceRevertwill withdraw all of the execution budget:
// Withdraw all execution gas budget from anycall for tx to revert with "no enough budget"if (executionBudget > 0) try anycallConfig.withdraw(executionBudget) {} catch {}
SoAnycall Executorwill revert if there is not enough budget. This is done at:
uint256budget=executionBudget[_from];require(budget>totalCost,"no enough budget");executionBudget[_from] =budget-totalCost;
https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L206C42-L206C58
(1) Gas Calculation:
To calculate how much the user has to pay, the following formula is used:
//Get Branch Environment Execution Costuint256minExecCost=tx.gasprice* (MIN_EXECUTION_OVERHEAD+_initialGas-gasLeft);
Gas units are calculated as follows:
Storegasleft()atinitialGasat the beginning ofanyExecutemethod:
//Get Initial Gas Checkpointuint256initialGas=gasleft();
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1125
Nearly at the end of the method, deductgasleft()frominitialGas. This covers everything between the initial gas checkpoint and the end gas checkpoint.
///Save gas leftuint256gasLeft=gasleft();//Get Branch Environment Execution Costuint256minExecCost=tx.gasprice* (MIN_EXECUTION_OVERHEAD+_initialGas-gasLeft);
AddMIN_EXECUTION_OVERHEADwhich is160_000.
uint256 internal constant MIN_EXECUTION_OVERHEAD = 160_000; // 100_000 for anycall + 35_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Executions
This overhead is supposed to cover:
100_000foranycall. This is an extra cost required byAnycall:
Line:38uint256constantEXECUTION_OVERHEAD=100000;..Line:203uint256gasUsed=_prevGasLeft+EXECUTION_OVERHEAD-gasleft();
https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L203
35_000Pre-First Gas Checkpoint Execution. For example, to cover the modifierrequiresExecutor.25_000Post-Last Gas Checkpoint Execution. To cover everything after the end gas checkpoint:
//Get Branch Environment Execution Costuint256minExecCost=tx.gasprice* (MIN_EXECUTION_OVERHEAD+_initialGas-gasLeft);//Check if sufficient balanceif(minExecCost>gasRemaining) {_forceRevert();return;}//Replenish Gas_replenishGas(minExecCost);//Transfer gas remaining to recipientSafeTransferLib.safeTransferETH(_recipient,gasRemaining-minExecCost);//Save Gasuint256gasAfterTransfer=gasleft();//Check if sufficient balanceif(gasLeft-gasAfterTransfer>TRANSFER_OVERHEAD) {_forceRevert();return;}
The issue is,60_000is not enough to cover pre-first gas checkpoint and post-last gas checkpoint. This means, that the user is paying less than the actual gas cost. According to the sponsor, theBridge Agentdeployer deposits the first time intoanycallConfig, where the goal is to replenish the execution budget after use every time. The issue could possibly lead to:
Overpaying the remaining gas the user.The execution budget is decreasing over time (slow draining) in case it has funds already.TheanyExecutecalls will fail since the calculation of the gas used in theAnycallcontracts is way bigger. InAnycall, this is done by the modifierchargeDestFee:modifierchargeDestFee:modifierchargeDestFee(address_from,uint256_flags) {if(_isSet(_flags,AnycallFlags.FLAG_PAY_FEE_ON_DEST)) {uint256_prevGasLeft=gasleft();_;IAnycallConfig(config).chargeFeeOnDestChain(_from,_prevGasLeft);}else{_;}}https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Upgradeable.sol#L163-L171functionchargeFeeOnDestChain:functionchargeFeeOnDestChain(address_from,uint256_prevGasLeft)externalonlyAnycallContract{if(!_isSet(mode,FREE_MODE)) {uint256gasUsed=_prevGasLeft+EXECUTION_OVERHEAD-gasleft();uint256totalCost=gasUsed* (tx.gasprice+_feeData.premium);uint256budget=executionBudget[_from];require(budget>totalCost,"no enough budget");executionBudget[_from] =budget-totalCost;_feeData.accruedFees+=uint128(totalCost);}}https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L203
(2) Gas Calculation inAnyCall:
There is also a gas consumption at theanyExecmethod called by the MPC (inAnyCall) here:
functionanyExec(address_to,bytescalldata_data,stringcalldata_appID,RequestContextcalldata_ctx,bytescalldata_extdata)externalvirtuallockwhenNotPausedchargeDestFee(_to, _ctx.flags)// <= starting from hereonlyMPC{...boolsuccess=_execute(_to,_data,_ctx,_extdata);..}
https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Upgradeable.sol#L276
The gas is nearly110_000. It is not taken into account.
(3) Base Fee & Input Data Fee:
FromEthereum yellow paper:
Gtransaction 21000 - Paid for every transaction.Gtxdatazero 4 - Paid for every zero byte of data or code for a transaction.Gtxdatanonzero 16 - Paid for every non-zero byte of data or code for a transaction.
So:
We have21_000as a base fee. This should be taken into account. However, it is paid byAnyCall, since the TX is sent by MPC. So, we are fine here. This probably explains the overhead (100_000) added byanycall.Because theanyExecutemethod has bytes data to be passed, we have extra gas consumption which is not taken into account.
For every zero byte=>4.
For every non-zero byte=>16.
So generally speaking, the bigger the data is, the bigger the gas becomes. You can simply prove this by adding arbitrary data to theanyExecutemethod in PoC #1 test below and you will see the gas spent increases.
Summary
MIN_EXECUTION_OVERHEADis underestimated.The gas consumed by theanyExecmethod called by the MPC is not considered.Input data fee isn’t taken into account.
There are two PoCs proving the first two points above. The third point can be proven by simply adding arbitrary data to theanyExecutemethod in PoC #1 test.
Proof of Concept
PoC #1 (MIN_EXECUTION_OVERHEADis underestimated):
This PoC is independent from the codebase (but uses the same code). There are two contracts simulatingBranchBridgeAgent.anyExecute:
BranchBridgeAgent- which has the code of the pre-first gas checkpoint and the post-last gas checkpoint.BranchBridgeAgentEmpty- which has the code of the pre-first gas checkpoint and the post-last gas checkpointcommented out.
We run the same test for both, the difference in gas is what’s at least nearly the minimum required to cover the pre-first gas checkpoint and the post-last gas checkpoint. In this case here it is78097which is bigger than60_000.
Here is the output of the test:
[PASS]test_calcgas() (gas: 119050)Logs:branchBridgeAgent.anyExecute Gas Spent => 92852[PASS]test_calcgasEmpty() (gas: 44461)Logs:branchBridgeAgentEmpty.anyExecute Gas Spent => 14755
92852 - 14755= 78097
Explanation
BranchBridgeAgent.anyExecutemethod depends on the following external calls:
AnycallExecutor.context()AnycallProxy.config()AnycallConfig.executionBudget()AnycallConfig.withdraw()AnycallConfig.deposit()WETH9.withdraw()
For this reason, I’ve copied the same code frommultichain-smart-contracts. For WETH9, I’ve used the contract from the codebase which has minimal code.
Please note that:
tx.gaspriceis replaced with a fixed value in the_payExecutionGasmethod, as it is not available in Foundry.In_replenishGas, reading the config viaIAnycallProxy(localAnyCallAddress).config()is replaced with an immediate call for simplicity. In other words, avoiding a proxy to make the PoC simpler and shorter. However, if done with a proxy the gas used would increase. So in both ways, it is in favor of the PoC.The conditionif (gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD)is replaced withif (gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD && false). This is to avoid entering theforceRevert. The increase of gas here is negligible.
The coded PoC
Foundry.toml
[profile.default]solc ='0.8.17'src ='solidity'test='solidity/test'out ='out'libs = ['lib']fuzz_runs = 1000optimizer_runs = 10_000
.gitmodules
[submodule"lib/ds-test"]path = lib/ds-testurl = https://github.com/dapphub/ds-testbranch = master[submodule"lib/forge-std"]path = lib/forge-stdurl = https://github.com/brockelmore/forge-stdbranch = master
remappings.txt
ds-test/=lib/ds-test/srcforge-std/=lib/forge-std/src
Test File:
// PoC => Maia OmniChain: gasCalculation in BranchBridgeAgentpragmasolidity>=0.8.4<0.9.0;import{Test}from"forge-std/Test.sol";import"forge-std/console.sol";import{DSTest}from"ds-test/test.sol";librarySafeTransferLib{/*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*//-                     CUSTOM ERRORS*//*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*//// @dev The ETH transfer has failed.errorETHTransferFailed();/// @dev The ERC20 `transferFrom` has failed.errorTransferFromFailed();/// @dev The ERC20 `transfer` has failed.errorTransferFailed();/// @dev The ERC20 `approve` has failed.errorApproveFailed();/*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*//-                       CONSTANTS*//*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*//// @dev Suggested gas stipend for contract receiving ETH/// that disallows any storage writes.uint256internalconstant_GAS_STIPEND_NO_STORAGE_WRITES=2300;/// @dev Suggested gas stipend for contract receiving ETH to perform a few/// storage reads and writes, but low enough to prevent griefing./// Multiply by a small constant (e.g. 2), if needed.uint256internalconstant_GAS_STIPEND_NO_GRIEF=100000;/*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*//-                     ETH OPERATIONS*//*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*//// @dev Sends `amount` (in wei) ETH to `to`./// Reverts upon failure.////// Note: This implementation does NOT protect against gas griefing./// Please use `forceSafeTransferETH` for gas griefing protection.functionsafeTransferETH(addressto,uint256amount)internal{/// @solidity memory-safe-assemblyassembly{// Transfer the ETH and check if it succeeded or not.ifiszero(call(gas(),to,amount,0,0,0,0)) {// Store the function selector of `ETHTransferFailed()`.mstore(0x00,0xb12d13eb)// Revert with (offset, size).revert(0x1c,0x04)}}}/// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`./// The `gasStipend` can be set to a low enough value to prevent/// storage writes or gas griefing.////// If sending via the normal procedure fails, force sends the ETH by/// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.////// Reverts if the current contract has insufficient balance.functionforceSafeTransferETH(addressto,uint256amount,uint256gasStipend)internal{/// @solidity memory-safe-assemblyassembly{// If insufficient balance, revert.iflt(selfbalance(),amount) {// Store the function selector of `ETHTransferFailed()`.mstore(0x00,0xb12d13eb)// Revert with (offset, size).revert(0x1c,0x04)}// Transfer the ETH and check if it succeeded or not.ifiszero(call(gasStipend,to,amount,0,0,0,0)) {mstore(0x00,to)// Store the address in scratch space.mstore8(0x0b,0x73)// Opcode `PUSH20`.mstore8(0x20,0xff)// Opcode `SELFDESTRUCT`.// We can directly use `SELFDESTRUCT` in the contract creation.// Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758ifiszero(create(amount,0x0b,0x16)) {// To coerce gas estimation to provide enough gas for the `create` above.ifiszero(gt(gas(),1000000)) {revert(0,0) }}}}}/// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend/// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default/// for 99% of cases and can be overridden with the three-argument version of this/// function if necessary.////// If sending via the normal procedure fails, force sends the ETH by/// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.////// Reverts if the current contract has insufficient balance.functionforceSafeTransferETH(addressto,uint256amount)internal{// Manually inlined because the compiler doesn't inline functions with branches./// @solidity memory-safe-assemblyassembly{// If insufficient balance, revert.iflt(selfbalance(),amount) {// Store the function selector of `ETHTransferFailed()`.mstore(0x00,0xb12d13eb)// Revert with (offset, size).revert(0x1c,0x04)}// Transfer the ETH and check if it succeeded or not.ifiszero(call(_GAS_STIPEND_NO_GRIEF,to,amount,0,0,0,0)) {mstore(0x00,to)// Store the address in scratch space.mstore8(0x0b,0x73)// Opcode `PUSH20`.mstore8(0x20,0xff)// Opcode `SELFDESTRUCT`.// We can directly use `SELFDESTRUCT` in the contract creation.// Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758ifiszero(create(amount,0x0b,0x16)) {// To coerce gas estimation to provide enough gas for the `create` above.ifiszero(gt(gas(),1000000)) {revert(0,0) }}}}}/// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`./// The `gasStipend` can be set to a low enough value to prevent/// storage writes or gas griefing.////// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.////// Note: Does NOT revert upon failure./// Returns whether the transfer of ETH is successful instead.functiontrySafeTransferETH(addressto,uint256amount,uint256gasStipend)internalreturns(boolsuccess){/// @solidity memory-safe-assemblyassembly{// Transfer the ETH and check if it succeeded or not.success :=call(gasStipend,to,amount,0,0,0,0)}}/*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*//-                    ERC20 OPERATIONS*//*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*//// @dev Sends `amount` of ERC20 `token` from `from` to `to`./// Reverts upon failure.////// The `from` account must have at least `amount` approved for/// the current contract to manage.functionsafeTransferFrom(addresstoken,addressfrom,addressto,uint256amount)internal{/// @solidity memory-safe-assemblyassembly{letm:=mload(0x40)// Cache the free memory pointer.mstore(0x60,amount)// Store the `amount` argument.mstore(0x40,to)// Store the `to` argument.mstore(0x2c,shl(96,from))// Store the `from` argument.// Store the function selector of `transferFrom(address,address,uint256)`.mstore(0x0c,0x23b872dd000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x1c,0x64,0x00,0x20))) {// Store the function selector of `TransferFromFailed()`.mstore(0x00,0x7939f424)// Revert with (offset, size).revert(0x1c,0x04)}mstore(0x60,0)// Restore the zero slot to zero.mstore(0x40,m)// Restore the free memory pointer.}}/// @dev Sends all of ERC20 `token` from `from` to `to`./// Reverts upon failure.////// The `from` account must have their entire balance approved for/// the current contract to manage.functionsafeTransferAllFrom(addresstoken,addressfrom,addressto)internalreturns(uint256amount){/// @solidity memory-safe-assemblyassembly{letm:=mload(0x40)// Cache the free memory pointer.mstore(0x40,to)// Store the `to` argument.mstore(0x2c,shl(96,from))// Store the `from` argument.// Store the function selector of `balanceOf(address)`.mstore(0x0c,0x70a08231000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.gt(returndatasize(),0x1f),// At least 32 bytes returned.staticcall(gas(),token,0x1c,0x24,0x60,0x20))) {// Store the function selector of `TransferFromFailed()`.mstore(0x00,0x7939f424)// Revert with (offset, size).revert(0x1c,0x04)}// Store the function selector of `transferFrom(address,address,uint256)`.mstore(0x00,0x23b872dd)// The `amount` argument is already written to the memory word at 0x60.amount :=mload(0x60)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x1c,0x64,0x00,0x20))) {// Store the function selector of `TransferFromFailed()`.mstore(0x00,0x7939f424)// Revert with (offset, size).revert(0x1c,0x04)}mstore(0x60,0)// Restore the zero slot to zero.mstore(0x40,m)// Restore the free memory pointer.}}/// @dev Sends `amount` of ERC20 `token` from the current contract to `to`./// Reverts upon failure.functionsafeTransfer(addresstoken,addressto,uint256amount)internal{/// @solidity memory-safe-assemblyassembly{mstore(0x14,to)// Store the `to` argument.mstore(0x34,amount)// Store the `amount` argument.// Store the function selector of `transfer(address,uint256)`.mstore(0x00,0xa9059cbb000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x10,0x44,0x00,0x20))) {// Store the function selector of `TransferFailed()`.mstore(0x00,0x90b8ec18)// Revert with (offset, size).revert(0x1c,0x04)}// Restore the part of the free memory pointer that was overwritten.mstore(0x34,0)}}/// @dev Sends all of ERC20 `token` from the current contract to `to`./// Reverts upon failure.functionsafeTransferAll(addresstoken,addressto)internalreturns(uint256amount) {/// @solidity memory-safe-assemblyassembly{mstore(0x00,0x70a08231)// Store the function selector of `balanceOf(address)`.mstore(0x20,address())// Store the address of the current contract.ifiszero(and(// The arguments of `and` are evaluated from right to left.gt(returndatasize(),0x1f),// At least 32 bytes returned.staticcall(gas(),token,0x1c,0x24,0x34,0x20))) {// Store the function selector of `TransferFailed()`.mstore(0x00,0x90b8ec18)// Revert with (offset, size).revert(0x1c,0x04)}mstore(0x14,to)// Store the `to` argument.// The `amount` argument is already written to the memory word at 0x34.amount :=mload(0x34)// Store the function selector of `transfer(address,uint256)`.mstore(0x00,0xa9059cbb000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x10,0x44,0x00,0x20))) {// Store the function selector of `TransferFailed()`.mstore(0x00,0x90b8ec18)// Revert with (offset, size).revert(0x1c,0x04)}// Restore the part of the free memory pointer that was overwritten.mstore(0x34,0)}}/// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract./// Reverts upon failure.functionsafeApprove(addresstoken,addressto,uint256amount)internal{/// @solidity memory-safe-assemblyassembly{mstore(0x14,to)// Store the `to` argument.mstore(0x34,amount)// Store the `amount` argument.// Store the function selector of `approve(address,uint256)`.mstore(0x00,0x095ea7b3000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x10,0x44,0x00,0x20))) {// Store the function selector of `ApproveFailed()`.mstore(0x00,0x3e3f8f73)// Revert with (offset, size).revert(0x1c,0x04)}// Restore the part of the free memory pointer that was overwritten.mstore(0x34,0)}}/// @dev Returns the amount of ERC20 `token` owned by `account`./// Returns zero if the `token` does not exist.functionbalanceOf(addresstoken,addressaccount)internalviewreturns(uint256amount) {/// @solidity memory-safe-assemblyassembly{mstore(0x14,account)// Store the `account` argument.// Store the function selector of `balanceOf(address)`.mstore(0x00,0x70a08231000000000000000000000000)amount :=mul(mload(0x20),and(// The arguments of `and` are evaluated from right to left.gt(returndatasize(),0x1f),// At least 32 bytes returned.staticcall(gas(),token,0x10,0x24,0x20,0x20)))}}}interfaceIAnycallExecutor{functioncontext()externalviewreturns(addressfrom,uint256fromChainID,uint256nonce);functionexecute(address_to,bytescalldata_data,address_from,uint256_fromChainID,uint256_nonce,uint256_flags,bytescalldata_extdata)externalreturns(boolsuccess,bytesmemoryresult);}interfaceIAnycallConfig{functioncalcSrcFees(address_app,uint256_toChainID,uint256_dataLength)externalviewreturns(uint256);functionexecutionBudget(address_app)externalviewreturns(uint256);functiondeposit(address_account)externalpayable;functionwithdraw(uint256_amount)external;}interfaceIAnycallProxy{functionexecutor()externalviewreturns(address);functionconfig()externalviewreturns(address);functionanyCall(address_to,bytescalldata_data,uint256_toChainID,uint256_flags,bytescalldata_extdata)externalpayable;functionanyCall(stringcalldata_to,bytescalldata_data,uint256_toChainID,uint256_flags,bytescalldata_extdata)externalpayable;}contractWETH9{stringpublicname="Wrapped Ether";stringpublicsymbol="WETH";uint8publicdecimals=18;eventApproval(addressindexedsrc,addressindexedguy,uint256wad);eventTransfer(addressindexedsrc,addressindexeddst,uint256wad);eventDeposit(addressindexeddst,uint256wad);eventWithdrawal(addressindexedsrc,uint256wad);mapping(address=>uint256)publicbalanceOf;mapping(address=>mapping(address=>uint256))publicallowance;// function receive() external payable {//   deposit();// }functiondeposit()publicpayable{balanceOf[msg.sender] +=msg.value;emitDeposit(msg.sender,msg.value);}functionwithdraw(uint256wad)public{require(balanceOf[msg.sender] >=wad);balanceOf[msg.sender] -=wad;payable(msg.sender).transfer(wad);emitWithdrawal(msg.sender,wad);}functiontotalSupply()publicviewreturns(uint256) {returnaddress(this).balance;}functionapprove(addressguy,uint256wad)publicreturns(bool) {allowance[msg.sender][guy] =wad;emitApproval(msg.sender,guy,wad);returntrue;}functiontransfer(addressdst,uint256wad)publicreturns(bool) {returntransferFrom(msg.sender,dst,wad);}functiontransferFrom(addresssrc,addressdst,uint256wad)publicreturns(bool) {require(balanceOf[src] >=wad);if(src!=msg.sender&&allowance[src][msg.sender] !=255) {require(allowance[src][msg.sender] >=wad);allowance[src][msg.sender] -=wad;}balanceOf[src] -=wad;balanceOf[dst] +=wad;emitTransfer(src,dst,wad);returntrue;}}contractAnycallExecutor{structContext{addressfrom;uint256fromChainID;uint256nonce;}// Context public override context;Contextpubliccontext;constructor() {context.fromChainID=1;context.from=address(2);context.nonce=1;}}contractAnycallV7Config{eventDeposit(addressindexedaccount,uint256amount);mapping(address=>uint256)publicexecutionBudget;/// @notice Deposit native currency crediting `_account` for execution costs on this chain/// @param _account The account to deposit and credit forfunctiondeposit(address_account)externalpayable{executionBudget[_account] +=msg.value;emitDeposit(_account,msg.value);}}contractBranchBridgeAgent{errorAnycallUnauthorizedCaller();errorGasErrorOrRepeatedTx();uint256publicremoteCallDepositedGas;uint256internalconstantMIN_EXECUTION_OVERHEAD=160_000;// 100_000 for anycall + 35_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Executionsuint256internalconstantTRANSFER_OVERHEAD=24_000;WETH9publicimmutablewrappedNativeToken;AnycallV7ConfigpublicanycallV7Config;uint256publicaccumulatedFees;/// @notice Local Chain Iduint24publicimmutablelocalChainId;/// @notice Address for Bridge Agent who processes requests submitted for the Root Router Address where cross-chain requests are executed in the Root Chain.addresspublicimmutablerootBridgeAgentAddress;/// @notice Local Anyexec Addressaddresspublicimmutablelocal`AnyCall`ExecutorAddress;/// @notice Address for Local AnycallV7 Proxy Address where cross-chain requests are sent to the Root Chain Router.addresspublicimmutablelocal`AnyCall`Address;constructor() {AnycallExecutoranycallExecutor=newAnycallExecutor();local`AnyCall`ExecutorAddress=address(anycallExecutor);localChainId=1;wrappedNativeToken=newWETH9();local`AnyCall`Address=address(3);rootBridgeAgentAddress=address(2);anycallV7Config=newAnycallV7Config();}modifierrequiresExecutor() {_requiresExecutor();_;}function_requiresExecutor()internalview{if(msg.sender!=local`AnyCall`ExecutorAddress)revertAnycallUnauthorizedCaller();(addressfrom,,) =IAnycallExecutor(local`AnyCall`ExecutorAddress).context();if(from!=rootBridgeAgentAddress)revertAnycallUnauthorizedCaller();}function_replenishGas(uint256_executionGasSpent)internalvirtual{//Deposit GasanycallV7Config.deposit{value:_executionGasSpent}(address(this));// IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config()).deposit{value: _executionGasSpent}(address(this));}function_forceRevert()internalvirtual{IAnycallConfiganycallConfig=IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config());uint256executionBudget=anycallConfig.executionBudget(address(this));// Withdraw all execution gas budget from anycall for tx to revert with "no enough budget"if(executionBudget>0)tryanycallConfig.withdraw(executionBudget) {}catch{}}/***@noticeInternal function repays gas used by Branch Bridge Agent to fulfill remote initiated interaction.-@param_recipientaddress to send excess gas to.-@param_initialGasgas used by Branch Bridge Agent.*/function_payExecutionGas(address_recipient,uint256_initialGas)internalvirtual{//Gas remaininguint256gasRemaining=wrappedNativeToken.balanceOf(address(this));//Unwrap GaswrappedNativeToken.withdraw(gasRemaining);//Delete Remote Initiated Action Statedelete(remoteCallDepositedGas);///Save gas leftuint256gasLeft=gasleft();//Get Branch Environment Execution Cost// Assume tx.gasPrice 1e9uint256minExecCost=1e9* (MIN_EXECUTION_OVERHEAD+_initialGas-gasLeft);//Check if sufficient balanceif(minExecCost>gasRemaining) {_forceRevert();return;}//Replenish Gas_replenishGas(minExecCost);//Transfer gas remaining to recipientSafeTransferLib.safeTransferETH(_recipient,gasRemaining-minExecCost);//Save Gasuint256gasAfterTransfer=gasleft();//Check if sufficient balanceif(gasLeft-gasAfterTransfer>TRANSFER_OVERHEAD&&false) {// added false here so it doesn't enter._forceRevert();return;}}functionanyExecute(bytesmemorydata)publicvirtualrequiresExecutorreturns(boolsuccess,bytesmemoryresult){//Get Initial Gas Checkpointuint256initialGas=gasleft();//Action Recipientaddressrecipient=address(0x1);// for simplicity and since it is irrelevant //address(uint160(bytes20(data[PARAMS_START:PARAMS_START_SIGNED])));// Other Code Here//Deduct gas costs from deposit and replenish this bridge agent's execution budget._payExecutionGas(recipient,initialGas);}functiondepositIntoWeth(uint256amt)external{wrappedNativeToken.deposit{value:amt}();}fallback()externalpayable{}}contractBranchBridgeAgentEmpty{errorAnycallUnauthorizedCaller();errorGasErrorOrRepeatedTx();uint256publicremoteCallDepositedGas;uint256internalconstantMIN_EXECUTION_OVERHEAD=160_000;// 100_000 for anycall + 35_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Executionsuint256internalconstantTRANSFER_OVERHEAD=24_000;WETH9publicimmutablewrappedNativeToken;AnycallV7ConfigpublicanycallV7Config;uint256publicaccumulatedFees;/// @notice Local Chain Iduint24publicimmutablelocalChainId;/// @notice Address for Bridge Agent who processes requests submitted for the Root Router Address where cross-chain requests are executed in the Root Chain.addresspublicimmutablerootBridgeAgentAddress;/// @notice Local Anyexec Addressaddresspublicimmutablelocal`AnyCall`ExecutorAddress;/// @notice Address for Local AnycallV7 Proxy Address where cross-chain requests are sent to the Root Chain Router.addresspublicimmutablelocal`AnyCall`Address;constructor() {AnycallExecutoranycallExecutor=newAnycallExecutor();local`AnyCall`ExecutorAddress=address(anycallExecutor);localChainId=1;wrappedNativeToken=newWETH9();local`AnyCall`Address=address(3);rootBridgeAgentAddress=address(2);anycallV7Config=newAnycallV7Config();}modifierrequiresExecutor() {_requiresExecutor();_;}function_requiresExecutor()internalview{if(msg.sender!=local`AnyCall`ExecutorAddress)revertAnycallUnauthorizedCaller();(addressfrom,,) =IAnycallExecutor(local`AnyCall`ExecutorAddress).context();if(from!=rootBridgeAgentAddress)revertAnycallUnauthorizedCaller();}function_replenishGas(uint256_executionGasSpent)internalvirtual{//Deposit GasanycallV7Config.deposit{value:_executionGasSpent}(address(this));// IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config()).deposit{value: _executionGasSpent}(address(this));}function_forceRevert()internalvirtual{IAnycallConfiganycallConfig=IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config());uint256executionBudget=anycallConfig.executionBudget(address(this));// Withdraw all execution gas budget from anycall for tx to revert with "no enough budget"if(executionBudget>0)tryanycallConfig.withdraw(executionBudget) {}catch{}}/***@noticeInternal function repays gas used by Branch Bridge Agent to fulfill remote initiated interaction.-@param_recipientaddress to send excess gas to.-@param_initialGasgas used by Branch Bridge Agent.*/function_payExecutionGas(address_recipient,uint256_initialGas)internalvirtual{//Gas remaininguint256gasRemaining=wrappedNativeToken.balanceOf(address(this));//Unwrap GaswrappedNativeToken.withdraw(gasRemaining);//Delete Remote Initiated Action Statedelete(remoteCallDepositedGas);///Save gas leftuint256gasLeft=gasleft();// Everything after this is not taken into account//Get Branch Environment Execution Cost// Assume tx.gasPrice 1e9// uint256 minExecCost = 1e9 * (MIN_EXECUTION_OVERHEAD + _initialGas - gasLeft);// //Check if sufficient balance// if (minExecCost > gasRemaining) {//     _forceRevert();//     return;// }// //Replenish Gas// _replenishGas(minExecCost);// //Transfer gas remaining to recipient// SafeTransferLib.safeTransferETH(_recipient, gasRemaining - minExecCost);// //Save Gas// uint256 gasAfterTransfer = gasleft();// //Check if sufficient balance// if (gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD && false) { // added false here so it doesn't enter.//     _forceRevert();//     return;// }}functionanyExecute(bytesmemorydata)publicvirtual// requiresExecutorreturns(boolsuccess,bytesmemoryresult){//Get Initial Gas Checkpointuint256initialGas=gasleft();//Action Recipientaddressrecipient=address(0x1);// for simplicity and since it is irrelevant //address(uint160(bytes20(data[PARAMS_START:PARAMS_START_SIGNED])));// Other Code Here//Deduct gas costs from deposit and replenish this bridge agent's execution budget._payExecutionGas(recipient,initialGas);}functiondepositIntoWeth(uint256amt)external{wrappedNativeToken.deposit{value:amt}();}fallback()externalpayable{}}contractGasCalcisDSTest,Test{BranchBridgeAgentbranchBridgeAgent;BranchBridgeAgentEmptybranchBridgeAgentEmpty;functionsetUp()public{branchBridgeAgentEmpty=newBranchBridgeAgentEmpty();vm.deal(address(branchBridgeAgentEmpty.local`AnyCall`ExecutorAddress()),100ether);// executer pays gasvm.deal(address(branchBridgeAgentEmpty),100ether);branchBridgeAgent=newBranchBridgeAgent();vm.deal(address(branchBridgeAgent.local`AnyCall`ExecutorAddress()),100ether);// executer pays gasvm.deal(address(branchBridgeAgent),100ether);}// code after end checkpoint gasLeft not includedfunctiontest_calcgasEmpty()public{// add weth balancebranchBridgeAgentEmpty.depositIntoWeth(100ether);vm.prank(address(branchBridgeAgentEmpty.local`AnyCall`ExecutorAddress()));uint256gasStart_=gasleft();branchBridgeAgentEmpty.anyExecute(bytes(""));uint256gasEnd_=gasleft();vm.stopPrank();uint256gasSpent_=gasStart_-gasEnd_;console.log("branchBridgeAgentEmpty.anyExecute Gas Spent => %d",gasSpent_);}// code after end checkpoint gasLeft includedfunctiontest_calcgas()public{// add weth balancebranchBridgeAgent.depositIntoWeth(100ether);vm.prank(address(branchBridgeAgent.local`AnyCall`ExecutorAddress()));uint256gasStart=gasleft();branchBridgeAgent.anyExecute(bytes(""));uint256gasEnd=gasleft();vm.stopPrank();uint256gasSpent=gasStart-gasEnd;console.log("branchBridgeAgent.anyExecute Gas Spent => %d",gasSpent);}}
PoC #2 (The gas consumed byanyExecmethod inAnyCall)
We have contracts that simulate theAnycallcontracts:
AnycallV7ConfigAnycallExecutorAnycallV7
The flow like this:MPC=>AnycallV7=>AnycallExecutor=>IApp
In the code,IApp(_to).anyExecuteis commented out because we don’t want to calculate its gas since it is done in PoC #1.
Here is the output of the test:
[PASS]test_gasInanycallv7() (gas: 102613)Logs:anycallV7.anyExec Gas Spent => 110893
The Coded PoC
// PoC => Maia OmniChain: gasCalculation in `AnyCall` v7  contractspragmasolidity>=0.8.4<0.9.0;import{Test}from"forge-std/Test.sol";import"forge-std/console.sol";import{DSTest}from"ds-test/test.sol";/// IAnycallConfig interface of the anycall configinterfaceIAnycallConfig{functioncheckCall(address_sender,bytescalldata_data,uint256_toChainID,uint256_flags)externalviewreturns(stringmemory_appID,uint256_srcFees);functioncheckExec(stringcalldata_appID,address_from,address_to)externalview;functionchargeFeeOnDestChain(address_from,uint256_prevGasLeft)external;}/// IAnycallExecutor interface of the anycall executorinterfaceIAnycallExecutor{functioncontext()externalviewreturns(addressfrom,uint256fromChainID,uint256nonce);functionexecute(address_to,bytescalldata_data,address_from,uint256_fromChainID,uint256_nonce,uint256_flags,bytescalldata_extdata)externalreturns(boolsuccess,bytesmemoryresult);}/// IApp interface of the applicationinterfaceIApp{/// (required) call on the destination chain to exec the interactionfunctionanyExecute(bytescalldata_data)externalreturns(boolsuccess,bytesmemoryresult);/// (optional,advised) call back on the originating chain if the cross chain interaction fails/// `_data` is the orignal interaction arguments exec on the destination chainfunctionanyFallback(bytescalldata_data)externalreturns(boolsuccess,bytesmemoryresult);}libraryAnycallFlags{// call flags which can be specified by useruint256publicconstantFLAG_NONE=0x0;uint256publicconstantFLAG_MERGE_CONFIG_FLAGS=0x1;uint256publicconstantFLAG_PAY_FEE_ON_DEST=0x1<<1;uint256publicconstantFLAG_ALLOW_FALLBACK=0x1<<2;// exec flags used internallyuint256publicconstantFLAG_EXEC_START_VALUE=0x1<<16;uint256publicconstantFLAG_EXEC_FALLBACK=0x1<<16;}contractAnycallV7Config{uint256publicconstantPERMISSIONLESS_MODE=0x1;uint256publicconstantFREE_MODE=0x1<<1;mapping(string=>mapping(address=>bool))publicappExecWhitelist;mapping(string=>bool)publicappBlacklist;uint256publicmode;uint256publicminReserveBudget;mapping(address=>uint256)publicexecutionBudget;constructor() {mode=PERMISSIONLESS_MODE;}functioncheckExec(stringcalldata_appID,address_from,address_to)externalview{require(!appBlacklist[_appID],"blacklist");if(!_isSet(mode,PERMISSIONLESS_MODE)) {require(appExecWhitelist[_appID][_to],"no permission");}if(!_isSet(mode,FREE_MODE)) {require(executionBudget[_from] >=minReserveBudget,"less than min budget");}}function_isSet(uint256_value,uint256_testBits)internalpurereturns(bool) {return(_value&_testBits) ==_testBits;}}contractAnycallExecutor{bytes32publicconstantPAUSE_ALL_ROLE=0x00;eventPaused(bytes32role);eventUnpaused(bytes32role);modifierwhenNotPaused(bytes32role) {require(!paused(role) && !paused(PAUSE_ALL_ROLE),"PausableControl: paused");_;}mapping(bytes32=>bool)private_pausedRoles;mapping(address=>bool)publicisSupportedCaller;structContext{addressfrom;uint256fromChainID;uint256nonce;}// Context public override context;Contextpubliccontext;functionpaused(bytes32role)publicviewvirtualreturns(bool) {return_pausedRoles[role];}modifieronlyAuth() {require(isSupportedCaller[msg.sender],"not supported caller");_;}constructor(addressanycall) {context.fromChainID=1;context.from=address(2);context.nonce=1;isSupportedCaller[anycall] =true;}function_isSet(uint256_value,uint256_testBits)internalpurereturns(bool){return(_value&_testBits) ==_testBits;}// @dev `_extdata` content is implementation based in each versionfunctionexecute(address_to,bytescalldata_data,address_from,uint256_fromChainID,uint256_nonce,uint256_flags,bytescalldata/*_extdata*/)externalvirtualonlyAuthwhenNotPaused(PAUSE_ALL_ROLE)returns(boolsuccess,bytesmemoryresult){boolisFallback=_isSet(_flags,AnycallFlags.FLAG_EXEC_FALLBACK);context=Context({from:_from,fromChainID:_fromChainID,nonce:_nonce});if(!isFallback) {// we skip calling anyExecute since it is irrelevant for this PoC// (success, result) = IApp(_to).anyExecute(_data);}else{(success,result) =IApp(_to).anyFallback(_data);}context=Context({from:address(0),fromChainID:0,nonce:0});}}contractAnycallV7{eventLog`AnyCall`(addressindexedfrom,addressto,bytesdata,uint256toChainID,uint256flags,stringappID,uint256nonce,bytesextdata);eventLog`AnyCall`(addressindexedfrom,stringto,bytesdata,uint256toChainID,uint256flags,stringappID,uint256nonce,bytesextdata);eventLogAnyExec(bytes32indexedtxhash,addressindexedfrom,addressindexedto,uint256fromChainID,uint256nonce,boolsuccess,bytesresult);eventStoreRetryExecRecord(bytes32indexedtxhash,addressindexedfrom,addressindexedto,uint256fromChainID,uint256nonce,bytesdata);// Context of the request on originating chainstructRequestContext{bytes32txhash;addressfrom;uint256fromChainID;uint256nonce;uint256flags;}addresspublicmpc;boolpublicpaused;// applications should give permission to this executoraddresspublicexecutor;// anycall config contractaddresspublicconfig;mapping(bytes32=>bytes32)publicretryExecRecords;boolpublicretryWithPermit;mapping(bytes32=>bool)publicexecCompleted;uint256nonce;uint256privateunlocked;modifierlock() {require(unlocked==1,"locked");unlocked=0;_;unlocked=1;}/// @dev Access control functionmodifieronlyMPC() {require(msg.sender==mpc,"only MPC");_;}/// @dev pausable control functionmodifierwhenNotPaused() {require(!paused,"paused");_;}function_isSet(uint256_value,uint256_testBits)internalpurereturns(bool){return(_value&_testBits) ==_testBits;}/// @dev Charge an account for execution costs on this chain/// @param _from The account to charge for execution costsmodifierchargeDestFee(address_from,uint256_flags) {if(_isSet(_flags,AnycallFlags.FLAG_PAY_FEE_ON_DEST)) {uint256_prevGasLeft=gasleft();_;IAnycallConfig(config).chargeFeeOnDestChain(_from,_prevGasLeft);}else{_;}}constructor(address_mpc) {unlocked=1;// needs to be unlocked initiallympc=_mpc;config=address(newAnycallV7Config());executor=address(newAnycallExecutor(address(this)));}/// @notice Calc unique IDfunctioncalcUniqID(bytes32_txhash,address_from,uint256_fromChainID,uint256_nonce)publicpurereturns(bytes32) {returnkeccak256(abi.encode(_txhash,_from,_fromChainID,_nonce));}function_execute(address_to,bytesmemory_data,RequestContextmemory_ctx,bytesmemory_extdata)internalreturns(boolsuccess) {bytesmemoryresult;tryIAnycallExecutor(executor).execute(_to,_data,_ctx.from,_ctx.fromChainID,_ctx.nonce,_ctx.flags,_extdata)returns(boolsucc,bytesmemoryres) {(success,result) = (succ,res);}catchError(stringmemoryreason) {result=bytes(reason);}catch(bytesmemoryreason) {result=reason;}emitLogAnyExec(_ctx.txhash,_ctx.from,_to,_ctx.fromChainID,_ctx.nonce,success,result);}/**@noticeExecute a cross chain interaction@devOnly callable by the MPC@param_toThe cross chain interaction target@param_dataThe calldata supplied for interacting with target@param_appIDThe app identifier to check whitelist@param_ctxThe context of the request on originating chain@param_extdataThe extension data for execute context*/// Note: changed from callback to memory so we can call it from the test contractfunctionanyExec(address_to,bytesmemory_data,stringmemory_appID,RequestContextmemory_ctx,bytesmemory_extdata)externalvirtuallockwhenNotPausedchargeDestFee(_to, _ctx.flags)onlyMPC{IAnycallConfig(config).checkExec(_appID,_ctx.from,_to);bytes32uniqID=calcUniqID(_ctx.txhash,_ctx.from,_ctx.fromChainID,_ctx.nonce);require(!execCompleted[uniqID],"exec completed");boolsuccess=_execute(_to,_data,_ctx,_extdata);// success = false on purpose, because when it is true, it consumes less gas. so we are considering worse case here// set exec completed (dont care success status)execCompleted[uniqID] =true;if(!success) {if(_isSet(_ctx.flags,AnycallFlags.FLAG_ALLOW_FALLBACK)) {// this will be executed here since the call failed// Call the fallback on the originating chainnonce++;stringmemoryappID=_appID;// fix Stack too deepemitLog`AnyCall`(_to,_ctx.from,_data,_ctx.fromChainID,AnycallFlags.FLAG_EXEC_FALLBACK|AnycallFlags.FLAG_PAY_FEE_ON_DEST,// pay fee on dest chainappID,nonce,"");}else{// Store retry record and emit a logbytesmemorydata=_data;// fix Stack too deepretryExecRecords[uniqID] =keccak256(abi.encode(_to,data));emitStoreRetryExecRecord(_ctx.txhash,_ctx.from,_to,_ctx.fromChainID,_ctx.nonce,data);}}}}contractGasCalc`AnyCall`v7isDSTest,Test{AnycallV7anycallV7;addressmpc=vm.addr(7);functionsetUp()public{anycallV7=newAnycallV7(mpc);}functiontest_gasInanycallv7()public{vm.prank(mpc);AnycallV7.RequestContextmemoryctx=AnycallV7.RequestContext({txhash:keccak256(""),from:address(0),fromChainID:1,nonce:1,flags:AnycallFlags.FLAG_ALLOW_FALLBACK});uint256gasStart_=gasleft();anycallV7.anyExec(address(0),bytes(""),"1",ctx,bytes(""));uint256gasEnd_=gasleft();vm.stopPrank();uint256gasSpent_=gasStart_-gasEnd_;console.log("anycallV7.anyExec Gas Spent => %d",gasSpent_);}}
Recommended Mitigation Steps
Increase theMIN_EXECUTION_OVERHEADby:
20_000forRootBridgeAgent.anyExecute.110_000foranyExecmethod inAnyCall.
20_000 + 110_000 = 130_000
SoMIN_EXECUTION_OVERHEADbecomes290_000instead of160_000.
Additionally, calculate the gas consumption of the input data passed then add it to the cost.
I suggest that theMIN_EXECUTION_OVERHEADshould be configurable/changeable. After launchingOmniChainfor some time, collect stats about the actual gas used forAnyCallon the chain, then adjust it accordingly. This also keeps you on the safe side in case any changes are applied onAnyCallcontracts in future, since it is upgradable.
0xBugsy (Maia) disagreed with severity and commented:
The variable data cost should be addressed by consultingpremium(). The value is used in their calcualtions here:uint256 totalCost = gasUsed * (tx.gasprice + _feeData.premium). We should abide and only pay as much as they will credit us as the remainder belonging to the user.
Trust (judge) commented:
Similar to #764 but different LOC and ultimately different vulnerability.
0xBugsy (Maia) confirmed and commented:
We recognize the audit’s findings on Anycall Gas Management. These will not be rectified due to the upcoming migration of this section to LayerZero.