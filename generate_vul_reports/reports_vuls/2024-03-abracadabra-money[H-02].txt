[H-02] Attacker can amplify a rounding error in MagicLP to break the I invariant and cause malicious pricing
Submitted byTrust
One of the two key parameters in MagicLP pools isI, which is defined to be the ideal ratio between the two reserves. It is set during MagicLP initialization:_I_ = i;
It is used when performing the initial LP deposit, inbuyShares():
if (totalSupply() == 0) {// case 1. initial supplyif (quoteBalance == 0) {revert ErrZeroQuoteAmount();}shares = quoteBalance < DecimalMath.mulFloor(baseBalance, _I_) ? DecimalMath.divFloor(quoteBalance, _I_) : baseBalance;_BASE_TARGET_ = shares.toUint112();_QUOTE_TARGET_ = DecimalMath.mulFloor(shares, _I_).toUint112();if (_QUOTE_TARGET_ == 0) {revert ErrZeroQuoteTarget();}if (shares <= 2001) {revert ErrMintAmountNotEnough();}_mint(address(0), 1001);shares -= 1001;
TheQUOTE_TARGETis determined by multiplying theBASE_TARGETwithI.
The flaw is in the check below:shares = quoteBalance < DecimalMath.mulFloor(baseBalance, _I_) ? DecimalMath.divFloor(quoteBalance, _I_) : baseBalance;Essentially there needs to be enoughquoteBalanceat theIratio to mintbaseBalanceshares, if there’s not enough then shares are instead determined by dividing thequoteBalancewithI.
An attacker can abuse themulFloor()to create a major inconsistency.
SupposequoteBalance = 1,baseBalance = 19999,I = 1e14. Then we have:1 < 19999 * 1e14 / 1e18 => 1 < 1 => FalseThereforeshares = 19999.
It sets the targets:
_BASE_TARGET_ = 19999_QUOTE_TARGET_ = 19999 * 1e14 / 1e18 = 1
The result is the ratio 1:19999, when the intended ratio fromIis 1:1000.
Essentially a small rounding error is magnified. The rounding direction should instead be:quoteBalance < DecimalMath.mulCeil(baseBalance, _I_)This would ensure thatDecimalMath.divFloor(quoteBalance, _I_)is executed. At this point, when calculatingQUOTE_TARGETthere will not be a precision error as above (it performs the opposing actions to the divFloor).
An attacker can abuse it by making users perform trades under the assumptionIis the effective ratio, however the ratio is actually2I. The pool’s pricing mechanics will be wrong. Note that users will legitimately trust any MagicLP pool created by the Factory as it is supposed to enforce that ratio.
The attack can be performed on another entity’s pool right after theinit()call, or on a self-created pool. The initial cost for the attack is very small due to the small numbers involved.
Impact
Attacker can initialize a Pool with malicious pricing mechanics that break the assumed invariants of the pool, leading to incorrect pool interactions.
POC
Step by step of the initialbuyShares()was provided above._QUOTE_TARGET_is used by the pricer:
function getPMMState() public view returns (PMMPricing.PMMState memory state) {state.i = _I_;state.K = _K_;state.B = _BASE_RESERVE_;state.Q = _QUOTE_RESERVE_;state.B0 = _BASE_TARGET_; // will be calculated in adjustedTargetstate.Q0 = _QUOTE_TARGET_;state.R = PMMPricing.RState(_RState_);PMMPricing.adjustedTarget(state);}...function sellBaseToken(PMMState memory state, uint256 payBaseAmount) internal pure returns (uint256 receiveQuoteAmount, RState newR) {if (state.R == RState.ONE) {// case 1: R=1// R falls below onereceiveQuoteAmount = _ROneSellBaseToken(state, payBaseAmount);newR = RState.BELOW_ONE;} else if (state.R == RState.ABOVE_ONE) {uint256 backToOnePayBase = state.B0 - state.B;uint256 backToOneReceiveQuote = state.Q -// @@@@@@@@@@   USED HEREstate.Q0;
Note that deposits/withdrawals will continue to apply the bad ratio:
} else if (baseReserve > 0 && quoteReserve > 0) {// case 2. normal caseuint256 baseInputRatio = DecimalMath.divFloor(baseInput, baseReserve);uint256 quoteInputRatio = DecimalMath.divFloor(quoteInput, quoteReserve);uint256 mintRatio = quoteInputRatio < baseInputRatio ? quoteInputRatio : baseInputRatio;shares = DecimalMath.mulFloor(totalSupply(), mintRatio);_BASE_TARGET_ = (uint256(_BASE_TARGET_) + DecimalMath.mulFloor(uint256(_BASE_TARGET_), mintRatio)).toUint112();_QUOTE_TARGET_ = (uint256(_QUOTE_TARGET_) + DecimalMath.mulFloor(uint256(_QUOTE_TARGET_), mintRatio)).toUint112();
Recommended Mitigation Steps
UseDecimalMaths.mulCeil()to protect against the rounding error.
0xCalibur (Abracadabra) acknowledged, but disagreed with severity and commented:
Based on our previous audit, it was discussed that using mulCeil here would not be the right answer since that would just create imprecision in the ratio in the other direction.It would be good if the submitter could provide a PoC showing a veritable exploit case for this one.Acknowledged, but will not fix it on contract level but filtering pool quality and legitimacy on our main frontend.
trust1995 commented:
Hi,The impact demonstrated is doubling the ratio of the pool, which is a core invariant of the MIMswap platform. It means pricing will be incorrect, which is the core functionality of an AMM. A user who will make a trade assuming they will follow the price set out by the I parameter will makeincorrect trades, losing their funds inappropriately.
I believe the direct risk of loss of funds by innocent traders who are not making a mistake, warrants the severity of High.
cccz (Judge) commented:
The attacker can compromiseQUOTETARGET_ in buyShares() after the pool is created.functioncreatePool(addressbaseToken,addressquoteToken,uint256lpFeeRate,uint256i,uint256k,addressto,uint256baseInAmount,uint256quoteInAmount)externalreturns(addressclone,uint256shares) {_validateDecimals(IERC20Metadata(baseToken).decimals(),IERC20Metadata(quoteToken).decimals());clone=IFactory(factory).create(baseToken,quoteToken,lpFeeRate,i,k);baseToken.safeTransferFrom(msg.sender,clone,baseInAmount);quoteToken.safeTransferFrom(msg.sender,clone,quoteInAmount);(shares, , ) =IMagicLP(clone).buyShares(to);  <========}The victim calls sellBase, and the call chain is as follows. In adjustedTarget, state.Q0 will not be adjusted since state.R == RState.ONE.functionsellBase(addressto)externalnonReentrantreturns(uint256receiveQuoteAmount) {uint256baseBalance=_BASE_TOKEN_.balanceOf(address(this));uint256baseInput=baseBalance-uint256(_BASE_RESERVE_);uint256mtFee;uint256newBaseTarget;PMMPricing.RStatenewRState;(receiveQuoteAmount,mtFee,newRState,newBaseTarget) =querySellBase(tx.origin,baseInput); <==============...functionquerySellBase(addresstrader,uint256payBaseAmount)publicviewreturns(uint256receiveQuoteAmount,uint256mtFee, PMMPricing.RStatenewRState,uint256newBaseTarget) {PMMPricing.PMMStatememorystate=getPMMState(); <========(receiveQuoteAmount,newRState) =PMMPricing.sellBaseToken(state,payBaseAmount); <======...functiongetPMMState()publicviewreturns(PMMPricing.PMMStatememorystate) {state.i=_I_;state.K=_K_;state.B=_BASE_RESERVE_;state.Q=_QUOTE_RESERVE_;state.B0=_BASE_TARGET_;// will be calculated in adjustedTargetstate.Q0=_QUOTE_TARGET_;state.R=PMMPricing.RState(_RState_);PMMPricing.adjustedTarget(state); <======}...functionadjustedTarget(PMMStatememorystate)internalpure{if(state.R==RState.BELOW_ONE) {state.Q0=Math._SolveQuadraticFunctionForTarget(state.Q,state.B-state.B0,state.i,state.K);}elseif(state.R==RState.ABOVE_ONE) {state.B0=Math._SolveQuadraticFunctionForTarget(state.B,state.Q-state.Q0,DecimalMath.reciprocalFloor(state.i),state.K);}}sellBaseToken callsROneSellBaseToken, and _ROneSellBaseToken calls _SolveQuadraticFunctionForTrade to use compromised _QUOTETARGET_ for calculation. It’ll compromise the victim.functionsellBaseToken(PMMStatememorystate,uint256payBaseAmount)internalpurereturns(uint256receiveQuoteAmount,RStatenewR) {if(state.R==RState.ONE) {// case 1: R=1// R falls below onereceiveQuoteAmount=_ROneSellBaseToken(state,payBaseAmount); <======newR=RState.BELOW_ONE;...function_ROneSellBaseToken(PMMStatememorystate,uint256payBaseAmount)internalpurereturns(uint256// receiveQuoteToken){// in theory Q2 <= targetQuoteTokenAmount// however when amount is close to 0, precision problems may cause Q2 > targetQuoteTokenAmountreturnMath._SolveQuadraticFunctionForTrade(state.Q0,state.Q0,payBaseAmount,state.i,state.K); <======}Therefore, High Severity is warranted.
Note: For full discussion, seehere.