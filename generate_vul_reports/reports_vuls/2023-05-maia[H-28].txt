[H-28] Removing aBribeFlywheelfrom a Gauge does not remove the reward asset from the rewards depo, making it impossible to add a new Flywheel with the same reward token
Submitted byABA, also found bygiovannidisienaandAudinarey
Removing a bribe Flywheel (FlywheelCore) from a Gauge (viaBaseV2Gauge::removeBribeFlywheel) does not remove the reward asset (callMultiRewardsDepot::removeAsset) from the rewards depo (BaseV2Gauge::multiRewardsDepot), making it impossible to add a new Flywheel (by callingBaseV2Gauge::addBribeFlywheel) with the same reward token (becauseMultiRewardsDepot::addAssetreverts as the assets already exist).
The impact is limiting protocol functionality in unwanted ways, possibly impacting gains in the long run. Example: due to incentives lost by not having a specific token bribe reward.
Proof of Concept
Observation: aBribeFlywheelis aFlywheelCorewith aFlywheelBribeRewardsset as theFlywheelRewards, typically created using theBribesFactory::createBribeFlywheel.
Scenario and execution flow
A project decides to add an initialBribeFlywheelto the recently deployedUniswapV3Gaugecontract.This is done by callingUniswapV3GaugeFactory::BaseV2GaugeFactory::addBribeToGauge.The execution further goes toBaseV2Gauge::addGaugetoFlywheelwherethe bribe flywheel reward token is addedto the multi reward depo.A project decides, for whatever reason (a bug in the contract, an exploit, a decommission, a more profitable wheel that would use the same rewards token), that they want to replace the old flywheel with a new one.Removing this is done via callingUniswapV3GaugeFactory::BaseV2GaugeFactory::removeBribeFromGauge.The execution further goes toBaseV2Gauge::removeBribeFlywheel, where the flywheel is removed but the reward token assetis not removed from the multi reward depo. There is no call toMultiRewardsDepot::removeAsset:
functionremoveBribeFlywheel(FlywheelCorebribeFlywheel)externalonlyOwner{/// @dev Can only remove active flywheelsif(!isActive[bribeFlywheel])revertFlywheelNotActive();/// @dev This is permanent; can't be re-addeddeleteisActive[bribeFlywheel];emitRemoveBribeFlywheel(bribeFlywheel);}
After removal, when trying to add a new flywheel with the same rewards token, the execution fails withErrorAddingAssetsince theaddAssetcall reverts sincethe rewards token was not removedwith the previous call toBaseV2Gauge::removeBribeFlywheel.
Recommended Mitigation Steps
whenBaseV2Gauge::removeBribeFlywheelis called for a particular flywheel, also remove its corresponding reward depo token.
Example implementation:
diff --git a/src/gauges/BaseV2Gauge.sol b/src/gauges/BaseV2Gauge.solindex c2793a7..8ea6c1e 100644--- a/src/gauges/BaseV2Gauge.sol+++ b/src/gauges/BaseV2Gauge.sol@@ -148,6 +148,9 @@ abstract contract BaseV2Gauge is Ownable, IBaseV2Gauge {/// @dev This is permanent; can't be re-addeddelete isActive[bribeFlywheel];+        address flyWheelRewards = address(bribeFlywheel.flywheelRewards());+        multiRewardsDepot.removeAsset(flyWheelRewards);+emit RemoveBribeFlywheel(bribeFlywheel);}
Trust (judge) increased the severity to High
0xLightt (Maia) confirmed, but disagreed with severity and commented:
This happens due to not being able to remove strategies fromFlyWheelCoreand the immutability in bribes. In accruing bribes for gauges, there is only one general FlyWheel per token, so removing it from theRewardsDepotwould actually brick all rewards of the FlyWheel’s token.The goal with removing the flywheel from the gauge is to stop forcing the user to callaccrueand update therewardIndexfor that flywheel to save gas or remove an unwanted token. After removing this forced accrual, users can increase their voting balance, accrue and then decrease the voting balance without accruing again. So the balances to accrue rewards can’t be trusted and would lead to issues if we tried to reuse the same FlyWheel for the same strategy. One solution would be to add the option to remove the strategy from the flywheel, but could lead to un-accrued rewards being bricked.If there is a need to migrate the bribe system, there needs to be a migration of the gauge system as well. This is intended so that users can opt in into the migration, in turn, protecting them.I believe the best solution would be to leave it up to the user to choose the bribes they want to accrue. By default, all users could have all bribes set asoptOutfor all strategies andFlywheelBoosterwould always return 0 when queryingboostedBalanceOfand wouldn’t take the user’s balance into account inboostedTotalSupply. If the user decides tooptIninto a bribe for strategy (we would mimic a minting scenario), they would accrue with 0 balance, having their current balance added to the the strategy’sboostedTotalSupplyandboostedBalanceOf, which would return the allocatedgaugeWeightinstead of 0. The opposite is when a user tries tooptOutafter beingoptIn. There should be the option to give up rewards, actually bricking in them, but it would be useful in case there is an issue with the token; for example, reverts when transferring from therewardsDepot. The gauge would force the user to accrue rewards for alloptInbribes when changing it’s balance.
This way, we can completely remove governance around bribes, but would still keep the immutability of the bribes system intact.
0xLightt (Maia) commented:
Addressedhere.