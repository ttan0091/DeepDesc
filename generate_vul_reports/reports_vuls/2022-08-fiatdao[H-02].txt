[H-02] Delegators can Avoid Lock Commitments if they can Reliably get Themselves Blocked when Needed
Submitted by Respx
https://github.com/code-423n4/2022-08-fiatdao/blob/fece3bdb79ccacb501099c24b60312cd0b2e4bb2/contracts/VotingEscrow.sol#L526-L625
Users can enjoy the voting power of long lock times whilst not committing their tokens. This could cause the entire system to break down as the incentives don’t work any more.
Exploit Method
This exploit only works if a user is able to use the system and reliably get themselves blocked. Blocking policies are not in scope, so I am assuming there would be a list of bannable offences, and thus this condition could be fulfilled.Consider a user with two accounts, called Rider and Horse.Rider has 100,000 tokens.Horse has 1 token.Rider is a smart contract (required for an account to be bannable).Rider locks for 1 week.Horse locks for 52 weeks.Rider delegates to Horse.Horse can continue to extend its lock period and enjoy the maximised voting power.Whenever the user wants their tokens back, they simply need to get the Rider account blocked.When Rider is blocked,Blocklist.block(RiderAddress)is called, which in turn callsve.forceUndelegate(RiderAddress).Rider is now an undelegated account with an expired lock. It can callve.withdraw()to get its tokens back.The user can repeat this process with a fresh account taking the role of Rider.
Recommended Mitigation Steps
forceUndelegate()could be made to setlocked_.end = fromLocked.end. This would mean that blocked users are still locked into the system for the period they delegated for. However, this does have the downside of tokens being locked in the system without the full rights of the system which other users enjoy.Alternatively, this might be addressable through not blocking users that seem to be doing this, but of course that might have other undersirable consequences.
Proof of Concept
Please see warden’sfull reportfor proof of concept.
lacoop6tu (FIAT DAO) confirmed, but disagreed with severity and commented:
2 — Med: Assets not at direct risk, but the function of the protocol or its availability could be impacted, or leak value with a hypothetical attack path with stated assumptions, but external requirements.
Justin Goro (judge) commented:
Well spotted by warden! The inflation of voting points may lead to an exploit, depending on possible proposals. Severity maintained.
IllIllI (warden) reviewed mitigation:
The sponsor disagreed with the severity and the judge updated the issue to be of Medium risk, and I agree with that severity. The finding was addressed via the fix forIssue 6where the sponsor implemented the suggestion of the warden, to use the delegatee’s lock endpoint in the re-delegation to self, rather than using the delegator’s existing endpoint, since that endpoint may be far in the past. The delegate() and undelegate() functions have checks to ensure that the target for the votes always has at least as long a duration as the source of the votes. The fix enforces the same requirement forforceUndelegate()by assigning a longer duration.
There are only two places in the code that changeLockedBalance.endto a smaller value, which could possibly violate the contract invariants: inquitLock()where the struct is never written back to storage, and inwithdraw()where it is indeed written back to storage. However, if the delegatee was able to withdraw, that means the delegator already would have been able to withdraw (since the delegatee’s timestamp must always be greater than or equal to the delegator’s whendelegatingorincreasing), and therefore the mitigation is correct. The only extra wrinkle that the change makes, is that it now allows a malicious delegatee to front-run a delegator’s block with anincreaseUnlock(MAXTIME), but it’s not clear what advantage that would give the delegatee, and furthermore, the delegator already put his/her trust in the delegatee, so it’s something that could have occurred anyway, even without a call toforceUndelegate().