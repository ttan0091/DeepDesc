[H-06] Lost Rewards in MultiRewardStaking Upon Third-Party Withdraw
Submitted bywaldenyan20, also found byulqiorra,hansfriese, andKingNFT
Affected contract:MultiRewardStaking
When assets are withdrawn for userAliceby an approved userBobto a receiver that is notAlice, the rewards are never accrued and the resultingstaking rewards are lost forever. This is becauseaccrueRewardsis called oncallerandreceiverbut neverowner.
Third-party withdrawals are allowed by the fact thatwithdraw(uint256, address, address)exists inERC4626Upgradeableand is never overwritten by a method with the same signature. Protocols composing with Popcorn will assume by the nature of this contract being anERC4626that this method is safe to use when it in fact costs the user significantly.
Proof of Concept
I created a test to reproduce this bug. When I included the below code withinMultiRewardStaking.t.solit passed, meaning Alice and Bob both had no rewards to claim by the end:
function test__withdraw_bug() public {// Add a reward token_addRewardToken(rewardToken1); // adds at 0.1 per second// Make a deposit for AlicestakingToken.mint(alice, 1 ether);vm.prank(alice);stakingToken.approve(address(staking), 1 ether);assertEq(stakingToken.allowance(alice, address(staking)), 1 ether);assertEq(staking.balanceOf(alice), 0);vm.prank(alice);staking.deposit(1 ether);assertEq(staking.balanceOf(alice), 1 ether);// Move 10 seconds into the futurevm.warp(block.timestamp + 10); // 1 ether should be owed to Alice in rewards// Approve Bob for withdrawalvm.prank(alice);staking.approve(bob, 1 ether);// Bob withdraws to himselfvm.prank(bob);staking.withdraw(1 ether, bob, alice);assertEq(staking.balanceOf(alice), 0);assertEq(stakingToken.balanceOf(bob), 1 ether);IERC20[] memory rewardsTokenKeys = new IERC20[](1);rewardsTokenKeys[0] = iRewardToken1;// Alice has no rewards to claimvm.prank(alice);vm.expectRevert(abi.encodeWithSelector(MultiRewardStaking.ZeroRewards.selector, iRewardToken1));staking.claimRewards(alice, rewardsTokenKeys);// Bob has no rewards to claimvm.prank(bob);vm.expectRevert(abi.encodeWithSelector(MultiRewardStaking.ZeroRewards.selector, iRewardToken1));staking.claimRewards(bob, rewardsTokenKeys);}
One can similarly create a test that doesnâ€™t expect the calls at the end to revert and that test will fail.
Tools Used
I reproduced the bug simply by adding a test within the existing Foundry project.
Recommended Mitigation Steps
Fix the code by changingthis line of codein_withdrawto instead call_accrueRewards(owner, receiver). It is okay to not accrue the rewards oncallersince the caller neither gains nor loses staked tokens.Add a similar test as above inMultiRewardStaking.t.solthatwill failif Alice is unable to withdraw1 etherof rewards in the end.
RedVeil (Popcorn) confirmed, but disagreed with severity