[H-04]MIN_FALLBACK_RESERVE(inBranchBridgeAgent) doesn’t consider the actual gas consumption inAnyCallcontracts, which lets the user underpay the actual cost when replenishing the execution budget
Submitted byKoolex
anyFallbackmethod is called by theAnycall Executoron the source chain in case of a failure of the functionanyExecuteon the root chain. The user has to pay for the execution gas cost for this, which is done at the end of the call. However, if there is not enoughdepositedGas, theanyFallbackmethod will be reverted, due to a revert caused by theAnycall Executor. This shouldn’t happen since the depositor deposited at least theMIN_FALLBACK_RESERVE(185_000) in the first place.
Here is the calculation for the gas used whenanyFallbackis called:
//Save gasuint256gasLeft=gasleft();//Get Branch Environment Execution Costuint256minExecCost=tx.gasprice* (MIN_FALLBACK_RESERVE+_initialGas-gasLeft);//Check if sufficient balanceif(minExecCost>getDeposit[_depositNonce].depositedGas) {_forceRevert();return;}
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1063-L1072
_forceRevertwill withdraw all of the execution budget:
// Withdraw all execution gas budget from anycall for tx to revert with "no enough budget"if (executionBudget > 0) try anycallConfig.withdraw(executionBudget) {} catch {}
SoAnycall Executorwill revert if there is not enough budget. This is done at:
uint256budget=executionBudget[_from];require(budget>totalCost,"no enough budget");executionBudget[_from] =budget-totalCost;
https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L206C42-L206C58
(1) Gas Calculation in ouranyFallbackand inAnyCallcontracts:
To calculate how much the user has to pay, the following formula is used:
//Get Branch Environment Execution Costuint256minExecCost=tx.gasprice* (MIN_FALLBACK_RESERVE+_initialGas-gasLeft);
Gas units are calculated as follows:
Storegasleft()atinitialGasat the beginning ofanyFallbackmethod:
//Get Initial Gas Checkpointuint256initialGas=gasleft();
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1233-L1234
Nearly at the end of the method, deductgasleft()frominitialGas. This covers everything between the initial gas checkpoint and the ending gas checkpoint.
//Save gasuint256gasLeft=gasleft();//Get Branch Environment Execution Costuint256minExecCost=tx.gasprice* (MIN_FALLBACK_RESERVE+_initialGas-gasLeft);
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1063-L1066
AddMIN_FALLBACK_RESERVEwhich is185_000.
This overhead is supposed to cover:
100_000foranycall. This is extra cost required byAnycall.
Line:38uint256constantEXECUTION_OVERHEAD=100000;..Line:203uint256gasUsed=_prevGasLeft+EXECUTION_OVERHEAD-gasleft();
https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L203
85_000for our fallback execution. For example, this is used to cover the modifierrequiresExecutorand to cover everything after the end gas checkpoint.
If we check how much this would actually cost,we can find it nearly70_000. So,85_000is safe enough. A PoC is also provided to prove this. However, there is an overhead of gas usage in theAnycallcontracts that’s not considered, which is different than the100_000extra that’s required byAnyCallanyway (see above).
This means, the user is paying less than the actual cost. According to the sponsor, Bridge Agent deployer deposits the first time intoanycallConfig, where the goal is to replenish the execution budget after use every time.
The issue leads to:
execution budget is decreasing over time (slow draining)in case it has funds already.anyExecute call will failsince the calculation of the gas used in theAnycallcontracts is bigger than the minimum reserve. InAnycall, this is done by the modifierchargeDestFee.ModifierchargeDestFee:modifierchargeDestFee(address_from,uint256_flags) {if(_isSet(_flags,AnycallFlags.FLAG_PAY_FEE_ON_DEST)) {uint256_prevGasLeft=gasleft();_;IAnycallConfig(config).chargeFeeOnDestChain(_from,_prevGasLeft);}else{_;}}https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Upgradeable.sol#L163-L171FunctionchargeFeeOnDestChain:functionchargeFeeOnDestChain(address_from,uint256_prevGasLeft)externalonlyAnycallContract{if(!_isSet(mode,FREE_MODE)) {uint256gasUsed=_prevGasLeft+EXECUTION_OVERHEAD-gasleft();uint256totalCost=gasUsed* (tx.gasprice+_feeData.premium);uint256budget=executionBudget[_from];require(budget>totalCost,"no enough budget");executionBudget[_from] =budget-totalCost;_feeData.accruedFees+=uint128(totalCost);}}https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Config.sol#L203
The gas consumption ofanyExecmethod called by the MPC (inAnyCall) here:
functionanyExec(address_to,bytescalldata_data,stringcalldata_appID,RequestContextcalldata_ctx,bytescalldata_extdata)externalvirtuallockwhenNotPausedchargeDestFee(_to, _ctx.flags)// <= starting from hereonlyMPC{...boolsuccess=_execute(_to,_data,_ctx,_extdata);..}
https://github.com/anyswap/multichain-smart-contracts/blob/main/contracts/anycall/v7/AnycallV7Upgradeable.sol#L276
The gas is nearly110_000and is not taken into account; as proven in the PoCs.
(2) Base Fee & Input Data Fee:
FromEthereum yellow paper:
Gtransaction- 21000 Paid for every transaction.Gtxdatazero- 4 Paid for every zero byte of data or code for a transaction.Gtxdatanonzero- 16 Paid for every non-zero byte of data or code for a transaction.
So:
We have21_000as the base fee. This should be taken into account; however, it is paid byAnyCallsince the TX is sent by MPC. So, we are fine here. This probably explains the overhead (100_000) added byanycall.Because theanyFallbackmethod has bytes data to be passed, we have extra gas consumption which is not taken into account.
For every zero byte=>4
For every non-zero byte=>16
So generally speaking, the bigger the data is, the bigger the gas becomes. You can simply prove this by adding arbitrary data to theanyFallbackmethod in the PoC #1 test below. You will also see the gas spent increases.
Summary
MIN_FALLBACK_RESERVEis safe enough, without considering theanyExecmethod (check next point).The gas consumed by theanyExecmethod called by the MPC is not considered.The input data fee isn’t taken into account.
There are two PoCs proving the first two points above. The third point can be proven by simply adding arbitrary data to theanyFallbackmethod in the PoC #1 test.
Note: this is also applicable forRootBridgeAgent, which I avoided writing a separate issue for it since the code for_payFallbackGasis almost the same. However, those 3 statements don’t exist inRootBridgeAgent._payFallbackGas.
//Withdraw GasIPort(localPortAddress).withdraw(address(this),address(wrappedNativeToken),minExecCost);//Unwrap GaswrappedNativeToken.withdraw(minExecCost);//Replenish Gas_replenishGas(minExecCost);
So, the gas spent is even less and55_000(from155_000inMIN_FALLBACK_RESERVEofRootBridgeAgent) is safe enough. But, the second two points are still not taken into account inRootBridgeAgent(see above).
Proof of Concept #1
MIN_FALLBACK_RESERVEis safe enough.
Note: estimation doesn’t consideranyExecmethod’s actual cost.
Overview
This PoC is independent from the codebase (but uses the same code). There are two contracts simulatingBranchBridgeAgent.anyFallback:
BranchBridgeAgent, which has the code of the pre-first gas checkpoint and the post-last gas checkpoint.BranchBridgeAgentEmpty, which has the code of the pre-first gas checkpoint and the post-last gas checkpointcommented out.
We’ll run the same test for both, but the difference in gas is what’s at least nearly the minimum required to cover the pre-first gas checkpoint and the post-last gas checkpoint.
In this case here, it is70_090which is smaller than85_000. So, we are fine.
Here is the output of the test:
[PASS]test_calcgas() (gas: 143835)Logs:branchBridgeAgent.anyFallback Gas Spent => 71993[PASS]test_calcgasEmpty() (gas: 73734)Logs:branchBridgeAgentEmpty.anyFallback Gas Spent => 1903Test result: ok. 2 passed; 0 failed; finishedin2.08ms
71_993 - 1903=70_090
Explanation
BranchBridgeAgent.anyFallbackmethod depends on the following external calls:
AnycallExecutor.context()AnycallProxy.config()AnycallConfig.executionBudget()AnycallConfig.withdraw()AnycallConfig.deposit()WETH9.withdraw()BranchPort.withdraw()
For this reason, I’ve copied the same code frommultichain-smart-contracts. ForWETH9, I’ve used the contract from the codebase which has minimal code. ForBranchPort, I copied from the codebase.
Note: For libraries, unused methods were removed. This is because I couldn’t submit the report, as it gave the error “too long body”. However, it doesn’t affect the gas spent
Please note that:
tx.gaspriceis replaced with a fixed value in the_payFallbackGasmethod, as it is not available in Foundry.In_replenishGas, reading the config viaIAnycallProxy(localAnyCallAddress).config()is replaced with animmediatecall for simplicity. In other words, avoiding proxy to make the PoC simpler and shorter. However, if done with proxy, the gas used would increase. So in both ways, it is in favor of the PoC.
The coded PoC
Foundry.toml
[profile.default]solc ='0.8.17'src ='solidity'test='solidity/test'out ='out'libs = ['lib']fuzz_runs = 1000optimizer_runs = 10_000
.gitmodules
[submodule"lib/ds-test"]path = lib/ds-testurl = https://github.com/dapphub/ds-testbranch = master[submodule"lib/forge-std"]path = lib/forge-stdurl = https://github.com/brockelmore/forge-stdbranch = master
remappings.txt
ds-test/=lib/ds-test/srcforge-std/=lib/forge-std/src
Test File:
// PoC => Maia OmniChain: gasCalculation for anyFallback in BranchBridgeAgentpragmasolidity>=0.8.4<0.9.0;import{Test}from"forge-std/Test.sol";import"forge-std/console.sol";import{DSTest}from"ds-test/test.sol";// copied from https://github.com/transmissions11/solmate/blob/main/src/tokens/ERC20.sol// only decimals is usedabstractcontractERC20{stringpublicname;stringpublicsymbol;uint8publicimmutabledecimals;constructor(stringmemory_name,stringmemory_symbol,uint8_decimals) {name=_name;symbol=_symbol;decimals=_decimals;}}// copied from Solady// removed unused methods, because I couldn't submit the report with too long codelibrarySafeTransferLib{/// @dev The ETH transfer has failed.errorETHTransferFailed();/// @dev The ERC20 `transferFrom` has failed.errorTransferFromFailed();/// @dev The ERC20 `transfer` has failed.errorTransferFailed();/// @dev The ERC20 `approve` has failed.errorApproveFailed();/// @dev Suggested gas stipend for contract receiving ETH/// that disallows any storage writes.uint256internalconstant_GAS_STIPEND_NO_STORAGE_WRITES=2300;/// @dev Suggested gas stipend for contract receiving ETH to perform a few/// storage reads and writes, but low enough to prevent griefing./// Multiply by a small constant (e.g. 2), if needed.uint256internalconstant_GAS_STIPEND_NO_GRIEF=100000;/// @dev Sends `amount` (in wei) ETH to `to`./// Reverts upon failure.////// Note: This implementation does NOT protect against gas griefing./// Please use `forceSafeTransferETH` for gas griefing protection.functionsafeTransferETH(addressto,uint256amount)internal{/// @solidity memory-safe-assemblyassembly{// Transfer the ETH and check if it succeeded or not.ifiszero(call(gas(),to,amount,0,0,0,0)) {// Store the function selector of `ETHTransferFailed()`.mstore(0x00,0xb12d13eb)// Revert with (offset, size).revert(0x1c,0x04)}}}functionsafeTransferFrom(addresstoken,addressfrom,addressto,uint256amount)internal{/// @solidity memory-safe-assemblyassembly{letm:=mload(0x40)// Cache the free memory pointer.mstore(0x60,amount)// Store the `amount` argument.mstore(0x40,to)// Store the `to` argument.mstore(0x2c,shl(96,from))// Store the `from` argument.// Store the function selector of `transferFrom(address,address,uint256)`.mstore(0x0c,0x23b872dd000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x1c,0x64,0x00,0x20))) {// Store the function selector of `TransferFromFailed()`.mstore(0x00,0x7939f424)// Revert with (offset, size).revert(0x1c,0x04)}mstore(0x60,0)// Restore the zero slot to zero.mstore(0x40,m)// Restore the free memory pointer.}}/// @dev Sends `amount` of ERC20 `token` from the current contract to `to`./// Reverts upon failure.functionsafeTransfer(addresstoken,addressto,uint256amount)internal{/// @solidity memory-safe-assemblyassembly{mstore(0x14,to)// Store the `to` argument.mstore(0x34,amount)// Store the `amount` argument.// Store the function selector of `transfer(address,uint256)`.mstore(0x00,0xa9059cbb000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x10,0x44,0x00,0x20))) {// Store the function selector of `TransferFailed()`.mstore(0x00,0x90b8ec18)// Revert with (offset, size).revert(0x1c,0x04)}// Restore the part of the free memory pointer that was overwritten.mstore(0x34,0)}}}/// copied from (https://github.com/vectorized/solady/blob/main/src/utils/SafeCastLib.sol)librarySafeCastLib{errorOverflow();functiontoUint128(uint256x)internalpurereturns(uint128) {if(x>=1<<128)_revertOverflow();returnuint128(x);}functiontoInt8(int256x)internalpurereturns(int8) {int8y=int8(x);if(x!=y)_revertOverflow();returny;}functiontoInt128(int256x)internalpurereturns(int128) {int128y=int128(x);if(x!=y)_revertOverflow();returny;}functiontoInt256(uint256x)internalpurereturns(int256) {if(x>=1<<255)_revertOverflow();returnint256(x);}/*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*//-                    PRIVATE HELPERS*//*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*/function_revertOverflow()privatepure{/// @solidity memory-safe-assemblyassembly{// Store the function selector of `Overflow()`.mstore(0x00,0x35278d12)// Revert with (offset, size).revert(0x1c,0x04)}}}interfaceIAnycallExecutor{functioncontext()externalviewreturns(addressfrom,uint256fromChainID,uint256nonce);functionexecute(address_to,bytescalldata_data,address_from,uint256_fromChainID,uint256_nonce,uint256_flags,bytescalldata_extdata)externalreturns(boolsuccess,bytesmemoryresult);}interfaceIAnycallConfig{functioncalcSrcFees(address_app,uint256_toChainID,uint256_dataLength)externalviewreturns(uint256);functionexecutionBudget(address_app)externalviewreturns(uint256);functiondeposit(address_account)externalpayable;functionwithdraw(uint256_amount)external;}interfaceIAnycallProxy{functionexecutor()externalviewreturns(address);functionconfig()externalviewreturns(address);functionanyCall(address_to,bytescalldata_data,uint256_toChainID,uint256_flags,bytescalldata_extdata)externalpayable;functionanyCall(stringcalldata_to,bytescalldata_data,uint256_toChainID,uint256_flags,bytescalldata_extdata)externalpayable;}contractWETH9{stringpublicname="Wrapped Ether";stringpublicsymbol="WETH";uint8publicdecimals=18;eventApproval(addressindexedsrc,addressindexedguy,uint256wad);eventTransfer(addressindexedsrc,addressindexeddst,uint256wad);eventDeposit(addressindexeddst,uint256wad);eventWithdrawal(addressindexedsrc,uint256wad);mapping(address=>uint256)publicbalanceOf;mapping(address=>mapping(address=>uint256))publicallowance;// function receive() external payable {//   deposit();// }functiondeposit()publicpayable{balanceOf[msg.sender] +=msg.value;emitDeposit(msg.sender,msg.value);}functionwithdraw(uint256wad)public{require(balanceOf[msg.sender] >=wad);balanceOf[msg.sender] -=wad;payable(msg.sender).transfer(wad);emitWithdrawal(msg.sender,wad);}functiontotalSupply()publicviewreturns(uint256) {returnaddress(this).balance;}functionapprove(addressguy,uint256wad)publicreturns(bool) {allowance[msg.sender][guy] =wad;emitApproval(msg.sender,guy,wad);returntrue;}functiontransfer(addressdst,uint256wad)publicreturns(bool) {returntransferFrom(msg.sender,dst,wad);}functiontransferFrom(addresssrc,addressdst,uint256wad)publicreturns(bool) {require(balanceOf[src] >=wad);if(src!=msg.sender&&allowance[src][msg.sender] !=255) {require(allowance[src][msg.sender] >=wad);allowance[src][msg.sender] -=wad;}balanceOf[src] -=wad;balanceOf[dst] +=wad;emitTransfer(src,dst,wad);returntrue;}}contractAnycallExecutor{structContext{addressfrom;uint256fromChainID;uint256nonce;}// Context public override context;Contextpubliccontext;constructor() {context.fromChainID=1;context.from=address(2);context.nonce=1;}}contractAnycallV7Config{eventDeposit(addressindexedaccount,uint256amount);mapping(address=>uint256)publicexecutionBudget;/// @notice Deposit native currency crediting `_account` for execution costs on this chain/// @param _account The account to deposit and credit forfunctiondeposit(address_account)externalpayable{executionBudget[_account] +=msg.value;emitDeposit(_account,msg.value);}}// IBranchPort interfaceinterfaceIPort{/*///////////////////////////////////////////////////////////////VIEW FUNCTIONS//////////////////////////////////////////////////////////////*//***@noticeReturns true if the address is a Bridge Agent.-@param_bridgeAgentBridge Agent address.-@returnbool.*/functionisBridgeAgent(address_bridgeAgent)externalviewreturns(bool);/***@noticeReturns true if the address is a Strategy Token.-@param_tokentoken address.-@returnbool.*/functionisStrategyToken(address_token)externalviewreturns(bool);/***@noticeReturns true if the address is a Port Strategy.-@param_strategystrategy address.-@param_tokentoken address.-@returnbool.*/functionisPortStrategy(address_strategy,address_token)externalviewreturns(bool);/***@noticeReturns true if the address is a Bridge Agent Factory.-@param_bridgeAgentFactoryBridge Agent Factory address.-@returnbool.*/functionisBridgeAgentFactory(address_bridgeAgentFactory)externalviewreturns(bool);/*///////////////////////////////////////////////////////////////PORT STRATEGY MANAGEMENT//////////////////////////////////////////////////////////////*//***@noticeAllows active Port Strategy addresses to withdraw assets.-@param_tokentoken address.-@param_amountamount of tokens.*/functionmanage(address_token,uint256_amount)external;/***@noticeallow approved address to repay borrowed reserves with reserves-@param_amountuint-@param_tokenaddress*/functionreplenishReserves(address_strategy,address_token,uint256_amount)external;/*///////////////////////////////////////////////////////////////hTOKEN MANAGEMENT//////////////////////////////////////////////////////////////*//***@noticeFunction to withdraw underlying / native token amount into Port in exchange for Local hToken.-@param_recipienthToken receiver.-@param_underlyingAddressunderlying / native token address.-@param_amountamount of tokens.**/functionwithdraw(address_recipient,address_underlyingAddress,uint256_amount)external;/***@noticeSetter function to increase local hToken supply.-@param_recipienthToken receiver.-@param_localAddresstoken address.-@param_amountamount of tokens.**/functionbridgeIn(address_recipient,address_localAddress,uint256_amount)external;/***@noticeSetter function to increase local hToken supply.-@param_recipienthToken receiver.-@param_localAddressestoken addresses.-@param_amountsamount of tokens.**/functionbridgeInMultiple(address_recipient,address[]memory_localAddresses,uint256[]memory_amounts)external;/***@noticeSetter function to decrease local hToken supply.-@param_localAddresstoken address.-@param_amountamount of tokens.**/functionbridgeOut(address_depositor,address_localAddress,address_underlyingAddress,uint256_amount,uint256_deposit)external;/***@noticeSetter function to decrease local hToken supply.-@param_depositoruser to deduct balance from.-@param_localAddresseslocal token addresses.-@param_underlyingAddresseslocal token address.-@param_amountsamount of local tokens.-@param_depositsamount of underlying tokens.**/functionbridgeOutMultiple(address_depositor,address[]memory_localAddresses,address[]memory_underlyingAddresses,uint256[]memory_amounts,uint256[]memory_deposits)external;/*///////////////////////////////////////////////////////////////ADMIN FUNCTIONS//////////////////////////////////////////////////////////////*//***@noticeAdds a new bridge agent address to the branch port.-@param_bridgeAgentaddress of the bridge agent to add to the Port*/functionaddBridgeAgent(address_bridgeAgent)external;/***@noticeSets the core router address for the branch port.-@param_newCoreRouteraddress of the new core router*/functionsetCoreRouter(address_newCoreRouter)external;/***@noticeAdds a new bridge agent factory address to the branch port.-@param_bridgeAgentFactoryaddress of the bridge agent factory to add to the Port*/functionaddBridgeAgentFactory(address_bridgeAgentFactory)external;/***@noticeReverts the toggle on the given bridge agent factory. If it's active, it will de-activate it and vice-versa.-@param_newBridgeAgentFactoryaddress of the bridge agent factory to add to the Port*/functiontoggleBridgeAgentFactory(address_newBridgeAgentFactory)external;/***@noticeReverts thfe toggle on the given bridge agent  If it's active, it will de-activate it and vice-versa.-@param_bridgeAgentaddress of the bridge agent to add to the Port*/functiontoggleBridgeAgent(address_bridgeAgent)external;/***@noticeAdds a new strategy token.*@param_tokenaddress of the token to add to the Strategy Tokens*/functionaddStrategyToken(address_token,uint256_minimumReservesRatio)external;/***@noticeReverts the toggle on the given strategy token. If it's active, it will de-activate it and vice-versa.*@param_tokenaddress of the token to add to the Strategy Tokens*/functiontoggleStrategyToken(address_token)external;/***@noticeAdds a new Port strategy to the given port*@param_portStrategyaddress of the bridge agent factory to add to the Port*/functionaddPortStrategy(address_portStrategy,address_token,uint256_dailyManagementLimit)external;/***@noticeReverts the toggle on the given port strategy. If it's active, it will de-activate it and vice-versa.*@param_portStrategyaddress of the bridge agent factory to add to the Port*/functiontogglePortStrategy(address_portStrategy,address_token)external;/***@noticeUpdates the daily management limit for the given port strategy.*@param_portStrategyaddress of the bridge agent factory to add to the Port*@param_tokenaddress of the token to update the limit for*@param_dailyManagementLimitnew daily management limit*/functionupdatePortStrategy(address_portStrategy,address_token,uint256_dailyManagementLimit)external;/*///////////////////////////////////////////////////////////////EVENTS//////////////////////////////////////////////////////////////*/eventDebtCreated(addressindexed_strategy,addressindexed_token,uint256_amount);eventDebtRepaid(addressindexed_strategy,addressindexed_token,uint256_amount);eventStrategyTokenAdded(addressindexed_token,uint256_minimumReservesRatio);eventStrategyTokenToggled(addressindexed_token);eventPortStrategyAdded(addressindexed_portStrategy,addressindexed_token,uint256_dailyManagementLimit);eventPortStrategyToggled(addressindexed_portStrategy,addressindexed_token);eventPortStrategyUpdated(addressindexed_portStrategy,addressindexed_token,uint256_dailyManagementLimit);eventBridgeAgentFactoryAdded(addressindexed_bridgeAgentFactory);eventBridgeAgentFactoryToggled(addressindexed_bridgeAgentFactory);eventBridgeAgentToggled(addressindexed_bridgeAgent);/*///////////////////////////////////////////////////////////////ERRORS//////////////////////////////////////////////////////////////*/errorInvalidMinimumReservesRatio();errorInsufficientReserves();errorUnrecognizedCore();errorUnrecognizedBridgeAgent();errorUnrecognizedBridgeAgentFactory();errorUnrecognizedPortStrategy();errorUnrecognizedStrategyToken();}contractBranchPort{usingSafeTransferLibforaddress;errorUnrecognizedBridgeAgent();/// @notice Mapping from Underlying Address to isUnderlying (bool).mapping(address=>bool)publicisBridgeAgent;constructor(addressbridgeAgent) {isBridgeAgent[bridgeAgent] =true;}/// @notice Modifier that verifies msg sender is an active Bridge Agent.modifierrequiresBridgeAgent() {if(!isBridgeAgent[msg.sender])revertUnrecognizedBridgeAgent();_;}functionwithdraw(address_recipient,address_underlyingAddress,uint256_deposit)externalvirtualrequiresBridgeAgent{_underlyingAddress.safeTransfer(_recipient,_denormalizeDecimals(_deposit,ERC20(_underlyingAddress).decimals()));}function_denormalizeDecimals(uint256_amount,uint8_decimals)internalpurereturns(uint256) {return_decimals==18?_amount: (_amount*1ether) / (10**_decimals);}}contractBranchBridgeAgent{usingSafeCastLibforuint256;enumDepositStatus{Success,Failed}structDeposit{uint128depositedGas;addressowner;DepositStatusstatus;address[]hTokens;address[]tokens;uint256[]amounts;uint256[]deposits;}errorAnycallUnauthorizedCaller();errorGasErrorOrRepeatedTx();uint256publicremoteCallDepositedGas;uint256internalconstantMIN_FALLBACK_RESERVE=185_000;// 100_000 for anycall + 85_000 fallback execution overhead// uint256 internal constant MIN_EXECUTION_OVERHEAD = 160_000; // 100_000 for anycall + 35_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Executionsuint256internalconstantTRANSFER_OVERHEAD=24_000;WETH9publicimmutablewrappedNativeToken;AnycallV7ConfigpublicanycallV7Config;uint256publicaccumulatedFees;/// @notice Local Chain Iduint24publicimmutablelocalChainId;/// @notice Address for Bridge Agent who processes requests submitted for the Root Router Address where cross-chain requests are executed in the Root Chain.addresspublicimmutablerootBridgeAgentAddress;/// @notice Local Anyexec Addressaddresspublicimmutablelocal`AnyCall`ExecutorAddress;/// @notice Address for Local AnycallV7 Proxy Address where cross-chain requests are sent to the Root Chain Router.addresspublicimmutablelocal`AnyCall`Address;/// @notice Address for Local Port Address where funds deposited from this chain are kept, managed and supplied to different Port Strategies.addresspublicimmutablelocalPortAddress;/// @notice Deposit nonce used for identifying transaction.uint32publicdepositNonce;/// @notice Mapping from Pending deposits hash to Deposit Struct.mapping(uint32=>Deposit)publicgetDeposit;constructor() {AnycallExecutoranycallExecutor=newAnycallExecutor();local`AnyCall`ExecutorAddress=address(anycallExecutor);localChainId=1;wrappedNativeToken=newWETH9();local`AnyCall`Address=address(3);rootBridgeAgentAddress=address(2);anycallV7Config=newAnycallV7Config();localPortAddress=address(newBranchPort(address(this)));getDeposit[1].depositedGas=1ether;// just for testing below}modifierrequiresExecutor() {_requiresExecutor();_;}function_requiresExecutor()internalview{if(msg.sender!=local`AnyCall`ExecutorAddress)revertAnycallUnauthorizedCaller();(addressfrom, , ) =IAnycallExecutor(local`AnyCall`ExecutorAddress).context();if(from!=rootBridgeAgentAddress)revertAnycallUnauthorizedCaller();}function_replenishGas(uint256_executionGasSpent)internalvirtual{//Deposit GasanycallV7Config.deposit{value:_executionGasSpent}(address(this));// IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config()).deposit{value: _executionGasSpent}(address(this));}function_forceRevert()internalvirtual{IAnycallConfiganycallConfig=IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config());uint256executionBudget=anycallConfig.executionBudget(address(this));// Withdraw all execution gas budget from anycall for tx to revert with "no enough budget"if(executionBudget>0)tryanycallConfig.withdraw(executionBudget) {}catch{}}/***@noticeInternal function repays gas used by Branch Bridge Agent to fulfill remote initiated interaction.-@param_depositNonceIdentifier for user deposit attatched to interaction being fallback.-@param_initialGasgas used by Branch Bridge Agent.*/function_payFallbackGas(uint32_depositNonce,uint256_initialGas)internalvirtual{//Save gasuint256gasLeft=gasleft();//Get Branch Environment Execution Cost// 1e9 for tx.gasPrice since it is zero in Foundryuint256minExecCost=1e9*(MIN_FALLBACK_RESERVE+_initialGas-gasLeft);//Check if sufficient balanceif(minExecCost>getDeposit[_depositNonce].depositedGas) {// getDeposit[1].depositedGas => 1 ether . set in the constructer above_forceRevert();return;}//Update user deposit reverts if not enough gas => user must boost deposit with gasgetDeposit[_depositNonce].depositedGas-=minExecCost.toUint128();//Withdraw GasIPort(localPortAddress).withdraw(address(this),address(wrappedNativeToken),minExecCost);//Unwrap GaswrappedNativeToken.withdraw(minExecCost);//Replenish Gas_replenishGas(minExecCost);}functionanyFallback(bytescalldatadata)externalvirtualrequiresExecutorreturns(boolsuccess,bytesmemoryresult){//Get Initial Gas Checkpointuint256initialGas=gasleft();/*** Other code here**/// we assume that the flag was 0x01 for simplicity and since it is also irrelevant anyway// passing deposit nonce as 1 since it is also irrelevant//Deduct gas costs from deposit and replenish this bridge agent's execution budget._payFallbackGas(1,initialGas);return(true,"");}functiondepositIntoWeth(uint256amt)external{wrappedNativeToken.deposit{value:amt*2}();// transfer half to the portwrappedNativeToken.transfer(localPortAddress,amt);}fallback()externalpayable{}}contractBranchBridgeAgentEmpty{usingSafeCastLibforuint256;enumDepositStatus{Success,Failed}structDeposit{uint128depositedGas;addressowner;DepositStatusstatus;address[]hTokens;address[]tokens;uint256[]amounts;uint256[]deposits;}errorAnycallUnauthorizedCaller();errorGasErrorOrRepeatedTx();uint256publicremoteCallDepositedGas;uint256internalconstantMIN_FALLBACK_RESERVE=185_000;// 100_000 for anycall + 85_000 fallback execution overheadWETH9publicimmutablewrappedNativeToken;AnycallV7ConfigpublicanycallV7Config;uint256publicaccumulatedFees;/// @notice Local Chain Iduint24publicimmutablelocalChainId;/// @notice Address for Bridge Agent who processes requests submitted for the Root Router Address where cross-chain requests are executed in the Root Chain.addresspublicimmutablerootBridgeAgentAddress;/// @notice Local Anyexec Addressaddresspublicimmutablelocal`AnyCall`ExecutorAddress;/// @notice Address for Local AnycallV7 Proxy Address where cross-chain requests are sent to the Root Chain Router.addresspublicimmutablelocal`AnyCall`Address;/// @notice Address for Local Port Address where funds deposited from this chain are kept, managed and supplied to different Port Strategies.addresspublicimmutablelocalPortAddress;/// @notice Deposit nonce used for identifying transaction.uint32publicdepositNonce;/// @notice Mapping from Pending deposits hash to Deposit Struct.mapping(uint32=>Deposit)publicgetDeposit;constructor() {AnycallExecutoranycallExecutor=newAnycallExecutor();local`AnyCall`ExecutorAddress=address(anycallExecutor);localChainId=1;wrappedNativeToken=newWETH9();local`AnyCall`Address=address(3);rootBridgeAgentAddress=address(2);anycallV7Config=newAnycallV7Config();localPortAddress=address(newBranchPort(address(this)));getDeposit[1].depositedGas=1ether;// just for testing below}modifierrequiresExecutor() {_requiresExecutor();_;}function_requiresExecutor()internalview{if(msg.sender!=local`AnyCall`ExecutorAddress)revertAnycallUnauthorizedCaller();(addressfrom, , ) =IAnycallExecutor(local`AnyCall`ExecutorAddress).context();if(from!=rootBridgeAgentAddress)revertAnycallUnauthorizedCaller();}function_replenishGas(uint256_executionGasSpent)internalvirtual{//Deposit GasanycallV7Config.deposit{value:_executionGasSpent}(address(this));// IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config()).deposit{value: _executionGasSpent}(address(this));}function_forceRevert()internalvirtual{IAnycallConfiganycallConfig=IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config());uint256executionBudget=anycallConfig.executionBudget(address(this));// Withdraw all execution gas budget from anycall for tx to revert with "no enough budget"if(executionBudget>0)tryanycallConfig.withdraw(executionBudget) {}catch{}}/***@noticeInternal function repays gas used by Branch Bridge Agent to fulfill remote initiated interaction.-@param_depositNonceIdentifier for user deposit attatched to interaction being fallback.-@param_initialGasgas used by Branch Bridge Agent.*/function_payFallbackGas(uint32_depositNonce,uint256_initialGas)internalvirtual{//Save gasuint256gasLeft=gasleft();// comment out all the lines after end gas checkpoint for gas calc purpose// //Get Branch Environment Execution Cost// // 1e9 for tx.gasPrice since it is zero in Foundry// uint256 minExecCost = 1e9 * (MIN_FALLBACK_RESERVE + _initialGas - gasLeft);// //Check if sufficient balance// if (minExecCost > getDeposit[_depositNonce].depositedGas) { // getDeposit[1].depositedGas => 1 ether . set in the constructer above//     _forceRevert();//     return;// }// //Update user deposit reverts if not enough gas => user must boost deposit with gas// getDeposit[_depositNonce].depositedGas -= minExecCost.toUint128();// //Withdraw Gas// IPort(localPortAddress).withdraw(address(this), address(wrappedNativeToken), minExecCost);// //Unwrap Gas// wrappedNativeToken.withdraw(minExecCost);// //Replenish Gas// _replenishGas(minExecCost);}functionanyFallback(bytescalldatadata)externalvirtualreturns(// requiresExecutor comment out this for gas calc purposeboolsuccess,bytesmemoryresult){//Get Initial Gas Checkpointuint256initialGas=gasleft();/*** Other code here**/// we assume that the flag was 0x01 for simplicity and since it is also irrelevant anyway// passing deposit nonce as 1 since it is also irrelevant//Deduct gas costs from deposit and replenish this bridge agent's execution budget._payFallbackGas(1,initialGas);// return (true, ""); // comment out this also for gas calc purpose}functiondepositIntoWeth(uint256amt)external{wrappedNativeToken.deposit{value:amt*2}();// transfer half to the portwrappedNativeToken.transfer(localPortAddress,amt);}fallback()externalpayable{}}contractGasCalcisDSTest,Test{BranchBridgeAgentbranchBridgeAgent;BranchBridgeAgentEmptybranchBridgeAgentEmpty;functionsetUp()public{branchBridgeAgentEmpty=newBranchBridgeAgentEmpty();vm.deal(address(branchBridgeAgentEmpty.local`AnyCall`ExecutorAddress()),100ether);// executer pays gasvm.deal(address(branchBridgeAgentEmpty),200ether);branchBridgeAgent=newBranchBridgeAgent();vm.deal(address(branchBridgeAgent.local`AnyCall`ExecutorAddress()),100ether);// executer pays gasvm.deal(address(branchBridgeAgent),200ether);}// code after end checkpoint gasLeft not includedfunctiontest_calcgasEmpty()public{// add weth balance to the agent and the port // 100 WETH for eachbranchBridgeAgentEmpty.depositIntoWeth(100ether);vm.prank(address(branchBridgeAgentEmpty.local`AnyCall`ExecutorAddress()));uint256gasStart=gasleft();branchBridgeAgentEmpty.anyFallback(bytes(""));uint256gasEnd=gasleft();vm.stopPrank();uint256gasSpent=gasStart-gasEnd;console.log("branchBridgeAgentEmpty.anyFallback Gas Spent => %d",gasSpent);}// code after end checkpoint gasLeft includedfunctiontest_calcgas()public{// add weth balance to the agent and the port // 100 WETH for eachbranchBridgeAgent.depositIntoWeth(100ether);vm.prank(address(branchBridgeAgent.local`AnyCall`ExecutorAddress()));uint256gasStart=gasleft();branchBridgeAgent.anyFallback(bytes(""));uint256gasEnd=gasleft();vm.stopPrank();uint256gasSpent=gasStart-gasEnd;console.log("branchBridgeAgent.anyFallback Gas Spent => %d",gasSpent);}}
Proof of Concept #2 (The gas consumed byanyExecmethod inAnyCall)
Overview
We have contracts that simulate theAnycallcontracts:
AnycallV7ConfigAnycallExecutorAnycallV7
The flow looks like this:
MPC=>AnycallV7=>AnycallExecutor=>IApp
In the code,IApp(_to).anyFallbackis commented out because we don’t want to calculate its gas, since it is done in PoC #1. We also setisFallbackto true, but the increased gas for this is negligible anyway.
Here is the output of the test:
[PASS]test_gasInanycallv7() (gas: 102640)Logs:anycallV7.anyExec Gas Spent => 110920Test result: ok. 1 passed; 0 failed; finishedin1.58ms
Coded PoC
// PoC => Maia OmniChain: gasCalculation for anyFallback in `AnyCall` v7  contractspragmasolidity>=0.8.4<0.9.0;import{Test}from"forge-std/Test.sol";import"forge-std/console.sol";import{DSTest}from"ds-test/test.sol";/// IAnycallConfig interface of the anycall configinterfaceIAnycallConfig{functioncheckCall(address_sender,bytescalldata_data,uint256_toChainID,uint256_flags)externalviewreturns(stringmemory_appID,uint256_srcFees);functioncheckExec(stringcalldata_appID,address_from,address_to)externalview;functionchargeFeeOnDestChain(address_from,uint256_prevGasLeft)external;}/// IAnycallExecutor interface of the anycall executorinterfaceIAnycallExecutor{functioncontext()externalviewreturns(addressfrom,uint256fromChainID,uint256nonce);functionexecute(address_to,bytescalldata_data,address_from,uint256_fromChainID,uint256_nonce,uint256_flags,bytescalldata_extdata)externalreturns(boolsuccess,bytesmemoryresult);}/// IApp interface of the applicationinterfaceIApp{/// (required) call on the destination chain to exec the interactionfunctionanyExecute(bytescalldata_data)externalreturns(boolsuccess,bytesmemoryresult);/// (optional,advised) call back on the originating chain if the cross chain interaction fails/// `_data` is the orignal interaction arguments exec on the destination chainfunctionanyFallback(bytescalldata_data)externalreturns(boolsuccess,bytesmemoryresult);}libraryAnycallFlags{// call flags which can be specified by useruint256publicconstantFLAG_NONE=0x0;uint256publicconstantFLAG_MERGE_CONFIG_FLAGS=0x1;uint256publicconstantFLAG_PAY_FEE_ON_DEST=0x1<<1;uint256publicconstantFLAG_ALLOW_FALLBACK=0x1<<2;// exec flags used internallyuint256publicconstantFLAG_EXEC_START_VALUE=0x1<<16;uint256publicconstantFLAG_EXEC_FALLBACK=0x1<<16;}contractAnycallV7Config{uint256publicconstantPERMISSIONLESS_MODE=0x1;uint256publicconstantFREE_MODE=0x1<<1;mapping(string=>mapping(address=>bool))publicappExecWhitelist;mapping(string=>bool)publicappBlacklist;uint256publicmode;uint256publicminReserveBudget;mapping(address=>uint256)publicexecutionBudget;constructor() {mode=PERMISSIONLESS_MODE;}functioncheckExec(stringcalldata_appID,address_from,address_to)externalview{require(!appBlacklist[_appID],"blacklist");if(!_isSet(mode,PERMISSIONLESS_MODE)) {require(appExecWhitelist[_appID][_to],"no permission");}if(!_isSet(mode,FREE_MODE)) {require(executionBudget[_from] >=minReserveBudget,"less than min budget");}}function_isSet(uint256_value,uint256_testBits)internalpurereturns(bool) {return(_value&_testBits) ==_testBits;}}contractAnycallExecutor{bytes32publicconstantPAUSE_ALL_ROLE=0x00;eventPaused(bytes32role);eventUnpaused(bytes32role);modifierwhenNotPaused(bytes32role) {require(!paused(role) && !paused(PAUSE_ALL_ROLE),"PausableControl: paused");_;}mapping(bytes32=>bool)private_pausedRoles;mapping(address=>bool)publicisSupportedCaller;structContext{addressfrom;uint256fromChainID;uint256nonce;}// Context public override context;Contextpubliccontext;functionpaused(bytes32role)publicviewvirtualreturns(bool) {return_pausedRoles[role];}modifieronlyAuth() {require(isSupportedCaller[msg.sender],"not supported caller");_;}constructor(addressanycall) {context.fromChainID=1;context.from=address(2);context.nonce=1;isSupportedCaller[anycall] =true;}function_isSet(uint256_value,uint256_testBits)internalpurereturns(bool){return(_value&_testBits) ==_testBits;}// @dev `_extdata` content is implementation based in each versionfunctionexecute(address_to,bytescalldata_data,address_from,uint256_fromChainID,uint256_nonce,uint256_flags,bytescalldata/*_extdata*/)externalvirtualonlyAuthwhenNotPaused(PAUSE_ALL_ROLE)returns(boolsuccess,bytesmemoryresult){boolisFallback=_isSet(_flags,AnycallFlags.FLAG_EXEC_FALLBACK) ||true;// let it fallbackcontext=Context({from:_from,fromChainID:_fromChainID,nonce:_nonce});if(!isFallback) {// we skip calling anyExecute since it is irrelevant for this PoC(success,result) =IApp(_to).anyExecute(_data);}else{// we skip calling anyExecute since it is irrelevant for this PoC// (success, result) = IApp(_to).anyFallback(_data);}context=Context({from:address(0),fromChainID:0,nonce:0});}}contractAnycallV7{eventLog`AnyCall`(addressindexedfrom,addressto,bytesdata,uint256toChainID,uint256flags,stringappID,uint256nonce,bytesextdata);eventLog`AnyCall`(addressindexedfrom,stringto,bytesdata,uint256toChainID,uint256flags,stringappID,uint256nonce,bytesextdata);eventLogAnyExec(bytes32indexedtxhash,addressindexedfrom,addressindexedto,uint256fromChainID,uint256nonce,boolsuccess,bytesresult);eventStoreRetryExecRecord(bytes32indexedtxhash,addressindexedfrom,addressindexedto,uint256fromChainID,uint256nonce,bytesdata);// Context of the request on originating chainstructRequestContext{bytes32txhash;addressfrom;uint256fromChainID;uint256nonce;uint256flags;}addresspublicmpc;boolpublicpaused;// applications should give permission to this executoraddresspublicexecutor;// anycall config contractaddresspublicconfig;mapping(bytes32=>bytes32)publicretryExecRecords;boolpublicretryWithPermit;mapping(bytes32=>bool)publicexecCompleted;uint256nonce;uint256privateunlocked;modifierlock() {require(unlocked==1,"locked");unlocked=0;_;unlocked=1;}/// @dev Access control functionmodifieronlyMPC() {require(msg.sender==mpc,"only MPC");_;}/// @dev pausable control functionmodifierwhenNotPaused() {require(!paused,"paused");_;}function_isSet(uint256_value,uint256_testBits)internalpurereturns(bool){return(_value&_testBits) ==_testBits;}/// @dev Charge an account for execution costs on this chain/// @param _from The account to charge for execution costsmodifierchargeDestFee(address_from,uint256_flags) {if(_isSet(_flags,AnycallFlags.FLAG_PAY_FEE_ON_DEST)) {uint256_prevGasLeft=gasleft();_;IAnycallConfig(config).chargeFeeOnDestChain(_from,_prevGasLeft);}else{_;}}constructor(address_mpc) {unlocked=1;// needs to be unlocked initiallympc=_mpc;config=address(newAnycallV7Config());executor=address(newAnycallExecutor(address(this)));}/// @notice Calc unique IDfunctioncalcUniqID(bytes32_txhash,address_from,uint256_fromChainID,uint256_nonce)publicpurereturns(bytes32) {returnkeccak256(abi.encode(_txhash,_from,_fromChainID,_nonce));}function_execute(address_to,bytesmemory_data,RequestContextmemory_ctx,bytesmemory_extdata)internalreturns(boolsuccess) {bytesmemoryresult;tryIAnycallExecutor(executor).execute(_to,_data,_ctx.from,_ctx.fromChainID,_ctx.nonce,_ctx.flags,_extdata)returns(boolsucc,bytesmemoryres) {(success,result) = (succ,res);}catchError(stringmemoryreason) {result=bytes(reason);}catch(bytesmemoryreason) {result=reason;}emitLogAnyExec(_ctx.txhash,_ctx.from,_to,_ctx.fromChainID,_ctx.nonce,success,result);}/**@noticeExecute a cross chain interaction@devOnly callable by the MPC@param_toThe cross chain interaction target@param_dataThe calldata supplied for interacting with target@param_appIDThe app identifier to check whitelist@param_ctxThe context of the request on originating chain@param_extdataThe extension data for execute context*/// Note: changed from callback to memory so we can call it from the test contractfunctionanyExec(address_to,bytesmemory_data,stringmemory_appID,RequestContextmemory_ctx,bytesmemory_extdata)externalvirtuallockwhenNotPausedchargeDestFee(_to, _ctx.flags)onlyMPC{IAnycallConfig(config).checkExec(_appID,_ctx.from,_to);bytes32uniqID=calcUniqID(_ctx.txhash,_ctx.from,_ctx.fromChainID,_ctx.nonce);require(!execCompleted[uniqID],"exec completed");boolsuccess=_execute(_to,_data,_ctx,_extdata);// success = false on purpose, because when it is true, it consumes less gas. so we are considering worse case here// set exec completed (dont care success status)execCompleted[uniqID] =true;if(!success) {if(_isSet(_ctx.flags,AnycallFlags.FLAG_ALLOW_FALLBACK)) {// this will be executed here since the call failed// Call the fallback on the originating chainnonce++;stringmemoryappID=_appID;// fix Stack too deepemitLog`AnyCall`(_to,_ctx.from,_data,_ctx.fromChainID,AnycallFlags.FLAG_EXEC_FALLBACK|AnycallFlags.FLAG_PAY_FEE_ON_DEST,// pay fee on dest chainappID,nonce,"");}else{// Store retry record and emit a logbytesmemorydata=_data;// fix Stack too deepretryExecRecords[uniqID] =keccak256(abi.encode(_to,data));emitStoreRetryExecRecord(_ctx.txhash,_ctx.from,_to,_ctx.fromChainID,_ctx.nonce,data);}}}}contractGasCalc`AnyCall`v7isDSTest,Test{AnycallV7anycallV7;addressmpc=vm.addr(7);functionsetUp()public{anycallV7=newAnycallV7(mpc);}functiontest_gasInanycallv7()public{vm.prank(mpc);AnycallV7.RequestContextmemoryctx=AnycallV7.RequestContext({txhash:keccak256(""),from:address(0),fromChainID:1,nonce:1,flags:AnycallFlags.FLAG_ALLOW_FALLBACK});uint256gasStart_=gasleft();anycallV7.anyExec(address(0),bytes(""),"1",ctx,bytes(""));uint256gasEnd_=gasleft();vm.stopPrank();uint256gasSpent_=gasStart_-gasEnd_;console.log("anycallV7.anyExec Gas Spent => %d",gasSpent_);}}
Recommended Mitigation Steps
Increase theMIN_FALLBACK_RESERVEby115_000to consider theanyExecmethod inAnyCall. SoMIN_FALLBACK_RESERVEbecomes300_000instead of185_000.
Additionally, calculate the gas consumption of the input data passed and add it to the cost. This should be done when the call was made in the first place.
Note: I suggest that theMIN_FALLBACK_RESERVEshould be configurable/changeable. After launchingOmniChainfor some time, collect stats about the actual gas used forAnyCallon the chain then adjust it accordingly. This also keeps you on the safe side in case any changes are applied onAnyCallcontracts in the future, since it is upgradeable.
0xBugsy (Maia) disagreed with severity and commented:
We should addpremium()uint256 to match their gas cost calculationtotalCost = gasUsed * (tx.gasprice + _feeData.premium)and abide by it since these are the calculations under which we will be charged in the execution budget.
Trust (judge) commented:
Unless there is additional reasoning to why the impact is reduced, High seems appropriate.
0xBugsy (Maia) confirmed and commented:
We recognize the audit’s findings on Anycall Gas Management. These will not be rectified due to the upcoming migration of this section to LayerZero.