[H-06] User can get their Kerosene stuck because of an invalid check on withdraw
Submitted by0xAlix2, also found byAamir, oakcobalt (1,2,3), MrPotatoMagic (1,2),Evo,favelanky,0xlemon,0xfox,TheSchnilch,Honour,SpicyMeatball,koo,Limbooo,KupiaSec,alix40,forgebyola,ke1caM,Jorgect,bhilare_,Dudex_2004,0xnev,petro_1912,FastChecker,Abdessamed,shikhar229169,Egis_Security,kennedy1030, and3docSec
The protocol allows users to deposit both Kerosene and non-Kerosene collateral, to mint Dyad users should have an equal value of non-Kerosene (exogenous) collateral. So users should have 100% non-Kerosene and the rest could be Kerosene collateral.
However, inVaultManagerV2::withdraw, the protocol allows users to withdraw Kerosene and non-Kerosene collateral, by just passing the corresponding vault. When withdrawing it checks if the (non-Kerosene value - withdraw value) is less than the minted Dyad, if so it reverts. This is also checked when withdrawing Kerosene collateral, which is wrong as it’s comparing non-Kerosene value with Kerosene value.
Ultimately, this blocks users from withdrawing their Kerosene collateral, even if they should be able to. Let’s take an example, a user has$100non-Kerosene and$100Kerosene collateral, and you have 100 Dyad minted, that’s a 200% ratio. If he tries to withdraw$1Kerosene, the TX will revert, becausegetNonKeroseneValue(id) = 100-value = 1<Dyad minted = 100, which again is a wrong check.
Proof of Concept
This assumes that a reported bug is fixed, which is using the correct licenser. To overcome this we had to manually change the licenser inaddKeroseneandgetKeroseneValue.
Because of another reported issue, a small change should be made to the code to workaround it; inVaultManagerV2::withdraw, replace_vault.oracle().decimals()with8. This just sets the oracle decimals to a static value of 8.
Test POC:
Make sure to fork the main net and set the block number to19703450:
contractVaultManagerTestisVaultManagerTestHelper{KerosinekeroseneV2;LicenservaultLicenserV2;VaultManagerV2vaultManagerV2;VaultethVaultV2;VaultWstEthwstEthV2;KerosineManagerkerosineManagerV2;UnboundedKerosineVaultunboundedKerosineVaultV2;BoundedKerosineVaultboundedKerosineVaultV2;KerosineDenominatorkerosineDenominatorV2;OracleMockwethOracleV2;addressbob=makeAddr("bob");addressalice=makeAddr("alice");ERC20wrappedETH=ERC20(MAINNET_WETH);ERC20wrappedSTETH=ERC20(MAINNET_WSTETH);DNftdNFT=DNft(MAINNET_DNFT);functionsetUpV2()public{(Contractsmemorycontracts,OracleMocknewWethOracle) =newDeployV2().runTestDeploy();keroseneV2=contracts.kerosene;vaultLicenserV2=contracts.vaultLicenser;vaultManagerV2=contracts.vaultManager;ethVaultV2=contracts.ethVault;wstEthV2=contracts.wstEth;kerosineManagerV2=contracts.kerosineManager;unboundedKerosineVaultV2=contracts.unboundedKerosineVault;boundedKerosineVaultV2=contracts.boundedKerosineVault;kerosineDenominatorV2=contracts.kerosineDenominator;wethOracleV2=newWethOracle;vm.startPrank(MAINNET_OWNER);Licenser(MAINNET_VAULT_MANAGER_LICENSER).add(address(vaultManagerV2));boundedKerosineVaultV2.setUnboundedKerosineVault(unboundedKerosineVaultV2);vm.stopPrank();}functiontest_CannotWithdrawKerosene()public{setUpV2();vm.prank(MAINNET_OWNER);keroseneV2.transfer(bob,100_000e18);deal(MAINNET_WETH,bob,1_000e18);deal(MAINNET_WETH,address(ethVaultV2),5_000e18);uint256bobNFT=dNFT.mintNft{value:1ether}(bob);// Bob adds Weth and Unbounded Kerosene vaults to his NFT// Bob deposits 1 Weth and 25,000 Kerosene// Bob mints Dyad exactly equal to the non-Kerosene value (1 Weth)vm.startPrank(bob);wrappedETH.approve(address(vaultManagerV2),type(uint256).max);keroseneV2.approve(address(vaultManagerV2),type(uint256).max);vaultManagerV2.add(bobNFT,address(ethVaultV2));vaultManagerV2.addKerosene(bobNFT,address(unboundedKerosineVaultV2));vaultManagerV2.deposit(bobNFT,address(ethVaultV2),1e18);vaultManagerV2.deposit(bobNFT,address(unboundedKerosineVaultV2),25_000e18);vaultManagerV2.mintDyad(bobNFT,vaultManagerV2.getNonKeroseneValue(bobNFT),bob);vm.stopPrank();// Verify that Bob's collateral ratio is greater than 300%assertGt(vaultManagerV2.collatRatio(bobNFT),2*vaultManagerV2.MIN_COLLATERIZATION_RATIO());vm.roll(1);// Bob tries to withdraw 1 Kerosene, revertsvm.prank(bob);vm.expectRevert(abi.encodeWithSelector(IVaultManager.NotEnoughExoCollat.selector));vaultManagerV2.withdraw(bobNFT,address(unboundedKerosineVaultV2),1e18,bob);}}
Recommended Mitigation Steps
Differentiate between Kerosene and non-Kerosene USD values when withdrawing either of them.
Assessed type
Invalid Validation
shafu0x (DYAD) confirmed and commented:
This is correct. Good find!