[H-27] Lack of a return value handing inArbitrumBranchBridgeAgent._performCall()could cause usersâ€™ deposit to be locked in contract
Submitted bypeakbolt, also found by Emmanuel (1,2)
InArbitrumBranchBridgeAgent, the_performCall()is overridden to directly callRootBridgeAgent.anyExecute()instead of performing anAnyCallcross-chain transaction, asRootBridgeAgentis also in Arbitrum. However, unlikeAnyCall,ArbitrumBranchBridgeAgent._performCall()is missing the handling of a return value foranyExecute().
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/ArbitrumBranchBridgeAgent.sol#L143
function_performCall(bytesmemory_callData)internaloverride{IRootBridgeAgent(rootBridgeAgentAddress).anyExecute(_callData);}
That is undesirable, asRootBridgeAgent.anyExecute()has a try/catch that prevents the revert from bubbling up. Instead, it expectsArbitrumBranchBridgeAgent._performCall()to revert whensuccess == false, which is currently missing.
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L1068-L1074
tryRootBridgeAgentExecutor(bridgeAgentExecutorAddress).executeSignedWithDeposit(address(userAccount),localRouterAddress,data,fromChainId)returns(bool,bytesmemoryres) {(success,result) = (true,res);}catch(bytesmemoryreason) {result=reason;}
Impact
Without handling the scenario whenRootBridgeAgent.anyExecute()returns false,ArbitrumBranchBridgeAgent._performCall()will continue the execution, even for failed calls and not revert due to the try/catch inRootBridgeAgent.anyExecute().
In the worst case, users could lose their bridged deposit when they useArbitrumBranchBridgeAgent.callOutSignedAndBridge()to interact with dApps and encountered failed calls.
When failed calls to dApps occur,ArbitrumBranchBridgeAgent.callOutSignedAndBridge()is expected to revert the entire transaction and reverse the bridging of the deposit. However, due to the issue with_performCall(), the bridged deposit will not be reverted, thus locking up user funds in the contract. Furthermore,RootBridgeAgent.anyExecute()will mark the deposit transaction as executed inexecutionHistory[], preventing anyretryDeposit()orretrieveDeposit()attempts to recover the funds.
Proof of Concept
Add the followingMockContractand test case toArbitrumBranchTest.t.soland run the test case:
contractMockContractisTest{functiontest()external{require(false);}}functiontestPeakboltArbCallOutWithDeposit()public{//Set uptestAddLocalTokenArbitrum();// deploy mock contract to call using multicallMockContractmockContract=newMockContract();//Prepare dataaddressoutputToken;uint256amountOut;uint256depositOut;bytesmemorypackedData;{outputToken=newArbitrumAssetGlobalAddress;amountOut=100ether;depositOut=50ether;Multicall2.Call[]memorycalls=newMulticall2.Call[](1);//prepare for a call to MockContract.test(), which will revertcalls[0] =Multicall2.Call({target:address(mockContract),callData:abi.encodeWithSignature("test()")});//Output ParamsOutputParamsmemoryoutputParams=OutputParams(address(this),outputToken,amountOut,depositOut);//toChainuint24toChain=rootChainId;//RLP Encode Calldatabytesmemorydata=abi.encode(calls,outputParams,toChain);//Pack FuncIdpackedData=abi.encodePacked(bytes1(0x02),data);}//Get some gas.hevm.deal(address(this),1ether);//Mint Underlying Token.arbitrumNativeToken.mint(address(this),100ether);//Approve spend by routerarbitrumNativeToken.approve(address(localPortAddress),100ether);//Prepare deposit infoDepositInputmemorydepositInput=DepositInput({hToken:address(newArbitrumAssetGlobalAddress),token:address(arbitrumNativeToken),amount:100ether,deposit:100ether,toChain:rootChainId});//Mock messaging layer feeshevm.mockCall(address(localAnyCongfig),abi.encodeWithSignature("calcSrcFees(address,uint256,uint256)",address(0),0,100),abi.encode(0));console2.log("Initial User Balance: %d",arbitrumNativeToken.balanceOf(address(this)));//Call Deposit functionarbitrumMulticallBridgeAgent.callOutSignedAndBridge{value:1ether}(packedData,depositInput,0.5ether);// This shows that deposit entry is successfully createdtestCreateDepositSingle(arbitrumMulticallBridgeAgent,uint32(1),address(this),address(newArbitrumAssetGlobalAddress),address(arbitrumNativeToken),100ether,100ether,1ether,0.5ether);// The following shows that the user deposited to the LocalPort, but it is not deposited/bridged to the user accountconsole2.log("LocalPort Balance (expected):",uint256(50ether));console2.log("LocalPort Balance (actual):",MockERC20(arbitrumNativeToken).balanceOf(address(localPortAddress)));//require(MockERC20(arbitrumNativeToken).balanceOf(address(localPortAddress)) == 50 ether, "LocalPort should have 50 tokens");console2.log("User Balance: (expected)",uint256(50ether));console2.log("User Balance: (actual)",MockERC20(arbitrumNativeToken).balanceOf(address(this)));//require(MockERC20(arbitrumNativeToken).balanceOf(address(this)) == 50 ether, "User should have 50 tokens");console2.log("User Global Balance: (expected)",uint256(50ether));console2.log("User Global Balance: (actual)",MockERC20(newArbitrumAssetGlobalAddress).balanceOf(address(this)));//require(MockERC20(newArbitrumAssetGlobalAddress).balanceOf(address(this)) == 50 ether, "User should have 50 global tokens");// retryDeposit() will fail as well as the transaction is marked executed in executionHistoryuint32depositNonce=arbitrumMulticallBridgeAgent.depositNonce() -1;hevm.deal(address(this),1ether);//hevm.expectRevert(abi.encodeWithSignature("GasErrorOrRepeatedTx()"));arbitrumMulticallBridgeAgent.retryDeposit{value:1ether}(true,depositNonce,"",0.5ether,rootChainId);}
Recommended Mitigation Steps
Handle the return value ofanyExecute()in_performCall()and revert onsuccess == false.
0xBugsy (Maia) confirmed
0xLightt (Maia) commented:
Addressedhere.