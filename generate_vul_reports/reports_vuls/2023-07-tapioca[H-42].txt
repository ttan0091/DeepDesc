[H-42] Attacker can steal victim’s oTAP position contents viaMagnetarMarketModule#_exitPositionAndRemoveCollateral()
Submitted byAck, also found byzzebra83
NOTE: This vulnerability relies on the team implementing anonERC721Received()function in Magnetar. As is currently written, attempts to exit oTAP positions via Magnetar will always revert as Magnetar cannot receive ERC721s, despite this being the clear intention of the function. This code path was not covered in the tests. Once implemented, however, an attack vector to steal twAML-locked oTAP positions opens.
Also, this is a similar but distinct attack vector from #933.
MagnetarMarketModule#_exitPositionAndRemoveCollateral()is a complex function used to perform any combination of: exiting an oTAP position, unlocking a locked tOLP position, removing assets and collateral from Singularity/bigBang, and repaying loans. The function achieves this by employing separate “if” clauses for each task that the caller would like to perform. These clauses are entered based on flags the caller provides in the argument structremoveAndRepayData.
Along with the set of operations to perform, the caller also provides:
addressuserto operate onaddress externalData.bigBangaddress externalData.singularityaddress yieldbox (obtained by calling the user-providedISingularity(externalData.singularity).yieldBox())
As the caller has full control of all of these parameters, he can execute attacks to steal assets that have been approved to Magnetar.
Impact
High - Theft of funds
Proof of concept
Unfortunately the Magnetar tests do not cover the case where we wish to exit our oTAP position, and the periphery testing infrastructure does not include helper functions for the oTAP workflows (at least that I was able to find). This makes a coded PoC difficult and time consuming. Please consider the following walkthrough and reach out if a coded example is necessary.
In this case, we’re going to assume that a victim wants to use this function as-designed to exit his twAML-locked oTAP position. In order to do so he needs to grant approval in  for Magnetar to transfer his position.
Once approved, anyone can call_exitPositionAndRemoveCollateral()with his own set of target addresses (some valid Tapioca addresses, some attacker-owned contracts) and the approver asuser.
The attack is as follows:
Victim approves Magnetar to control his oTAP positionsAttacker first calls_exitPositionAndRemoveCollateral(), with:removeAndRepayData.exitData.exit = trueremoveAndRepayData.unlockData.unlock = trueTheuserto steal fromthetokenIdto exit + stealremoveAndRepayData.unlockData.target = an attacker-controlled contract that just passes when called with.unlock()Magnetar transfers the oTAP position to itself and exits the position. It retains the yieldbox shares at the end of the callAttacker calls_exitPositionAndRemoveCollateral(), with:removeAndRepayData.exitData.exit = falseremoveAndRepayData.unlockData.unlock = trueTheuseris the attacker’s address for receiving the unlocked sharesthe tokenId to exit + stealremoveAndRepayData.unlockData.target = the real tOLP contract
(The attacker could have alternately used a similar bigBang attacker contract approach for removing the yieldbox shares in step 4 as in #933 )
function_exitPositionAndRemoveCollateral(// @audit called via delegatecall from core MagnetarV2 w/o any agument validationaddressuser,ICommonData.ICommonExternalContractscalldataexternalData,IUSDOBase.IRemoveAndRepaycalldataremoveAndRepayData)private{IMarketbigBang=IMarket(externalData.bigBang);// @audit all 3 of these can be attacker controlledISingularitysingularity=ISingularity(externalData.singularity);IYieldBoxBaseyieldBox=IYieldBoxBase(singularity.yieldBox());uint256tOLPId=0;if(removeAndRepayData.exitData.exit) {// @audit true, enter this blockrequire(removeAndRepayData.exitData.oTAPTokenID>0,// @audit oTAP ID we want to unlock+steal"Magnetar: oTAPTokenID 0");addressoTapAddress=ITapiocaOptionsBroker(removeAndRepayData.exitData.target// @audit target here is attacker-controlled, but retrieve the real oTAP address).oTAP();(,ITapiocaOptions.TapOptionmemoryoTAPPosition) =ITapiocaOptions(// @audit get the oTAP postion we're exitingoTapAddress).attributes(removeAndRepayData.exitData.oTAPTokenID);tOLPId=oTAPPosition.tOLP;addressownerOfTapTokenId=IERC721(oTapAddress).ownerOf(removeAndRepayData.exitData.oTAPTokenID);require(ownerOfTapTokenId==user||ownerOfTapTokenId==address(this),// @audit owner is user, passes"Magnetar: oTAPTokenID owner mismatch");if(ownerOfTapTokenId==user) {// @audit trueIERC721(oTapAddress).safeTransferFrom(// @audit transfer the token hereuser,address(this),removeAndRepayData.exitData.oTAPTokenID,"0x");}ITapiocaOptionsBroker(removeAndRepayData.exitData.target)// @audit address is.exitPosition(removeAndRepayData.exitData.oTAPTokenID);if(!removeAndRepayData.unlockData.unlock) {// @audit unlock = true, skip thisIERC721(oTapAddress).safeTransferFrom(address(this),user,removeAndRepayData.exitData.oTAPTokenID,"0x");}}// performs a tOLP.unlock operationif(removeAndRepayData.unlockData.unlock) {if(removeAndRepayData.unlockData.tokenId!=0) {if(tOLPId!=0) {require(tOLPId==removeAndRepayData.unlockData.tokenId,"Magnetar: tOLPId mismatch");}tOLPId=removeAndRepayData.unlockData.tokenId;}// @audit .target here is attacker controlled  - just pass first time!//        Second time, the attacker specifies the real tOLP contract and themselves as "user" to have the tokens unlocked to their addressITapiocaOptionLiquidityProvision(removeAndRepayData.unlockData.target).unlock(tOLPId,externalData.singularity,user);}
Recommended Mitigation Steps
Do not allow arbitrary address input in these complex, multi-use functions.Consider breaking this into multiple standalone functionsRequire user == msg.sender
> 0xRektora (Tapioca) confirmed