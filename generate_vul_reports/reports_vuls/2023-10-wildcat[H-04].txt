[H-04] WhenwithdrawalBatchDurationis set to zero lenders can withdraw more then allocated to a batch
Submitted by0xCiphky
Lines of code
https://github.com/code-423n4/2023-10-wildcat/blob/c5df665f0bc2ca5df6f06938d66494b11e7bdada/src/market/WildcatMarketWithdrawals.sol#L137https://github.com/code-423n4/2023-10-wildcat/blob/c5df665f0bc2ca5df6f06938d66494b11e7bdada/src/market/WildcatMarketWithdrawals.sol#L77
Vulnerability details
The Wildcat protocol utilizes a withdrawal cycle where lenders callqueueWithdrawalswhich then goes through a set amount of time (withdrawal duration period) before a withdrawal can be executed (if the protocol has enough funds to cover the withdrawal). Withdrawal requests that could not be fully honored at the end of their withdrawal cycle are batched together, marked as expired withdrawals, and added to the withdrawal queue. These batches are tracked using the time of expiry, and when assets are returned to a market with a non-zero withdrawal queue, assets are immediately routed to the unclaimed withdrawals pool and can subsequently be claimed by lenders with the oldest expired withdrawals first.
ThewithdrawalBatchDurationcan be set to zero so lenders do not have to wait before being able to withdraw funds from the market; however, this can cause issues where lenders in a batch can withdraw more than their pro-rata share of the batch’s paid assets.
A lender callsqueueWithdrawalfirst to initiate the withdrawal; this will place it in a batch respective to its expiry:
functionqueueWithdrawal(uint256amount)externalnonReentrant{MarketStatememorystate=_getUpdatedState();...// If there is no pending withdrawal batch, create a new one.if(state.pendingWithdrawalExpiry==0) {state.pendingWithdrawalExpiry=uint32(block.timestamp+withdrawalBatchDuration);emitWithdrawalBatchCreated(state.pendingWithdrawalExpiry);}// Cache batch expiry on the stack for gas savings.uint32expiry=state.pendingWithdrawalExpiry;WithdrawalBatchmemorybatch=_withdrawalData.batches[expiry];// Add scaled withdrawal amount to account withdrawal status, withdrawal batch and market state._withdrawalData.accountStatuses[expiry][msg.sender].scaledAmount+=scaledAmount;batch.scaledTotalAmount+=scaledAmount;state.scaledPendingWithdrawals+=scaledAmount;emitWithdrawalQueued(expiry,msg.sender,scaledAmount);// Burn as much of the withdrawal batch as possible with available liquidity.uint256availableLiquidity=batch.availableLiquidityForPendingBatch(state,totalAssets());if(availableLiquidity>0) {_applyWithdrawalBatchPayment(batch,state,expiry,availableLiquidity);}// Update stored batch data_withdrawalData.batches[expiry] =batch;// Update stored state_writeState(state);}
Now once thewithdrawalBatchDurationhas passed, a lender can callexecuteWithdrawalto finalize the withdrawal. This will grab the batch and let the lender withdraw a percentage of the batch if the batch is not fully paid or all funds if it is fully paid.
functionexecuteWithdrawal(addressaccountAddress,uint32expiry)externalnonReentrantreturns(uint256) {if(expiry>block.timestamp) {revertWithdrawalBatchNotExpired();}MarketStatememorystate=_getUpdatedState();WithdrawalBatchmemorybatch=_withdrawalData.batches[expiry];AccountWithdrawalStatusstoragestatus=_withdrawalData.accountStatuses[expiry][accountAddress];uint128newTotalWithdrawn=uint128(MathUtils.mulDiv(batch.normalizedAmountPaid,status.scaledAmount,batch.scaledTotalAmount));uint128normalizedAmountWithdrawn=newTotalWithdrawn-status.normalizedAmountWithdrawn;status.normalizedAmountWithdrawn=newTotalWithdrawn;state.normalizedUnclaimedWithdrawals-=normalizedAmountWithdrawn;...// Update stored state_writeState(state);returnnormalizedAmountWithdrawn;}
Let’s look at how this percentage is determined: thenewTotalWithdrawnfunction determines a lender’s available withdrawal amount by multiplying thenormalizedAmountPaidwith thescaledAmountand dividing the result by the batch’sscaledTotalAmount. This ensures that each lender in the batch can withdraw an even amount of the available funds in the batch depending on theirscaledAmount.
uint128newTotalWithdrawn=uint128(MathUtils.mulDiv(batch.normalizedAmountPaid,status.scaledAmount,batch.scaledTotalAmount));
This works fine whenwithdrawalBatchDurationis set over zero, as the batch values (exceptnormalizedAmountPaid) are finalized. However, when set to zero, we can end up with lenders in a batch being able to withdraw more thannormalizedAmountPaidin that batch, potentially violating protocol invariants.
Consider the following scenario:
There is only 5 tokens available to burn.
Lender A callsqueueWithdrawalwith 5 andexecuteWithdrawalinstantly.
newTotalWithdrawn = (normalizedAmountPaid) * (scaledAmount) / scaledTotalAmountnewTotalWithdrawn = 5 * 5 = 25 / 5 = 5
Lender A was able to fully withdraw.
Lender B comes along and callsqueueWithdrawalwith 5 andexecuteWithdrawalinstantly in the same block. This will add to the same batch as lender A as it is the same expiry.
Now let’s look atnewTotalWithdrawnfor Lender B:
newTotalWithdrawn = (normalizedAmountPaid) * (scaledAmount) / scaledTotalAmountnewTotalWithdrawn = 5 * 5 = 25 / 10 = 2.5
Lets see what the batch looks like now:
Lender A was able to withdraw 5 tokens in the batch.Lender B was able to withdraw 2.5 tokens in the batch.Thebatch.normalizedAmountPaidis 5, meaning the Lenders’ withdrawal amount surpassed the batch’s current limit.
Impact
This will break the following invariant in the protocol:
“Withdrawal execution can only transfer assets that have been counted as paid assets in the corresponding batch, i.e. lenders with withdrawal requests can not withdraw more than their pro-rata share of the batch’s paid assets.”
It will also mean that funds reserved for other batches may not be able to be fulfilled even if the batch’snormalizedAmountPaidnumber shows that it should be able to.
Proof Of Concept
For the following test, make sure you use the following parameters inExpectedStateTracker:
MarketParametersinternalparameters=MarketParameters({asset:address(0),namePrefix:"Wildcat ",symbolPrefix:"WC",borrower:borrower,controller:address(0),feeRecipient:address(0),sentinel:address(sanctionsSentinel),maxTotalSupply:uint128(DefaultMaximumSupply),protocolFeeBips:0,annualInterestBips:0,delinquencyFeeBips:DefaultDelinquencyFee,withdrawalBatchDuration:0,reserveRatioBips:DefaultReserveRatio,delinquencyGracePeriod:DefaultGracePeriod});
functiontest_ZeroWithdrawalDuration()externalasAccount(address(controller)) {assertEq(market.withdrawalBatchDuration(),0);// alice deposit_deposit(alice,2e18);// bob deposit_deposit(bob,1e18);// borrow 33% of deposits_borrow(1e18);// alice withdraw requeststartPrank(alice);market.queueWithdrawal(1e18);stopPrank();// fast forward 1 daysfastForward(1days);// alice withdraw requeststartPrank(alice);market.queueWithdrawal(1e18);stopPrank();// lets look at the withdrawal batchassertEq(market.getWithdrawalBatch(uint32(block.timestamp)).normalizedAmountPaid,1e18);assertEq(market.getWithdrawalBatch(uint32(block.timestamp)).scaledTotalAmount,1e18);assertEq(market.getWithdrawalBatch(uint32(block.timestamp)).scaledAmountBurned,1e18);// check amount alice has withdrawn so far (should be zero)assertEq(market.getAccountWithdrawalStatus(address(alice),uint32(block.timestamp)).normalizedAmountWithdrawn,0);// alice withdrawstartPrank(alice);market.executeWithdrawal(address(alice),uint32(block.timestamp));stopPrank();// check amount alice has withdrawn so far (should be 1e18)assertEq(market.getAccountWithdrawalStatus(address(alice),uint32(block.timestamp)).normalizedAmountWithdrawn,1e18);// bob withdraw request in same batchstartPrank(bob);market.queueWithdrawal(1e18);stopPrank();// lets look at the withdrawal batch nowassertEq(market.getWithdrawalBatch(uint32(block.timestamp)).normalizedAmountPaid,1e18);assertEq(market.getWithdrawalBatch(uint32(block.timestamp)).scaledTotalAmount,2e18);assertEq(market.getWithdrawalBatch(uint32(block.timestamp)).scaledAmountBurned,1e18);// check amount bob has withdrawn so far (should be zero)assertEq(market.getAccountWithdrawalStatus(address(bob),uint32(block.timestamp)).normalizedAmountWithdrawn,0);// bob withdrawstartPrank(bob);market.executeWithdrawal(address(bob),uint32(block.timestamp));stopPrank();// check amount bob has withdrawn so far (should be 5e17)assertEq(market.getAccountWithdrawalStatus(address(bob),uint32(block.timestamp)).normalizedAmountWithdrawn,5e17);// lets look at the withdrawal batch nowassertEq(market.getWithdrawalBatch(uint32(block.timestamp)).normalizedAmountPaid,1e18);assertEq(market.getWithdrawalBatch(uint32(block.timestamp)).scaledTotalAmount,2e18);assertEq(market.getWithdrawalBatch(uint32(block.timestamp)).scaledAmountBurned,1e18);// what happened is alice and bob have withdrawn 1e18 and 5e17 respectively// but the batch is 1e18uint128normalizedAmountPaid=market.getWithdrawalBatch(uint32(block.timestamp)).normalizedAmountPaid;uint128aliceWithdrawn=market.getAccountWithdrawalStatus(address(alice),uint32(block.timestamp)).normalizedAmountWithdrawn;uint128bobWithdrawn=market.getAccountWithdrawalStatus(address(bob),uint32(block.timestamp)).normalizedAmountWithdrawn;assertGt(aliceWithdrawn+bobWithdrawn,normalizedAmountPaid);}
Tools Used
Foundry
Recommendation
Review the protocol’s withdrawal mechanism and consider adjusting the behaviour of withdrawals whenwithdrawalBatchDurationis set to zero to ensure that lenders cannot withdraw more than their pro-rata share of the batch’s paid assets.
d1ll0n (Wildcat) confirmed and commented:
Thank you! Good catch - going to fix this by changing the assertion inexecuteWithdrawalfrom:if(expiry>block.timestamp) {revertWithdrawalBatchNotExpired();}to:if(expiry>=block.timestamp) {revertWithdrawalBatchNotExpired();}so that it’s guaranteed the withdrawal batch can not be added to when it’s in a state that allows execution.
laurenceday (Wildcat) commented:
Mitigatedhere.