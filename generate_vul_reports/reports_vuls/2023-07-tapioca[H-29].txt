[H-29] Exercise option cross chain message in the (m)TapiocaOFT will always revert in the destination, losing debited funds in the source chain
Submitted by0x73696d616f, also found byKIntern_NAandbin2chen
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/BaseTOFT.sol#L539-L545
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/bcf61f79464cfdc0484aa272f9f6e28d5de36a8f/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L153-L159
Exercise option cross chain message in the(m)TapiocaOFTwill always revert in the destination, but works in the source chain, where it debits the funds from users. Thus, these funds will not be credited in the destination and are forever lost.
Proof of Concept
In theBaseTOFT, if the packet from the received cross chain message inlzReceive()is of typePT_TAP_EXERCISE, it delegate calls to theBaseTOFTOptionsModule:
function_nonblockingLzReceive(uint16_srcChainId,bytesmemory_srcAddress,uint64_nonce,bytesmemory_payload)internalvirtualoverride{uint256packetType=_payload.toUint256(0);...}elseif(packetType==PT_TAP_EXERCISE) {_executeOnDestination(Module.Options,abi.encodeWithSelector(BaseTOFTOptionsModule.exercise.selector,_srcChainId,_srcAddress,_nonce,_payload),_srcChainId,_srcAddress,_nonce,_payload);...
In theBaseTOFTOptionsModule, theexercise()function is declared as:
functionexercise(addressmodule,uint16_srcChainId,bytesmemory_srcAddress,uint64_nonce,bytesmemory_payload)public{...}
Notice that theaddress moduleargument is specified in theexercise()function declaration, but not in the_nonBlockingLzReceive()call to it. This will make the message always revert because it fails when decoding the arguments to the function call, due to the extraaddress moduleargument.
The following POC illustrates this behaviour. TheexerciseOption()cross chain message fails on the destination:
// SPDX-License-Identifier: UNLICENSEDpragmasolidity^0.8.18;import{Test,console}from"forge-std/Test.sol";import{TapiocaOFT}from"contracts/tOFT/TapiocaOFT.sol";import{BaseTOFTOptionsModule}from"contracts/tOFT/modules/BaseTOFTOptionsModule.sol";import{IYieldBoxBase}from"tapioca-periph/contracts/interfaces/IYieldBoxBase.sol";import{ISendFrom}from"tapioca-periph/contracts/interfaces/ISendFrom.sol";import{ICommonData}from"tapioca-periph/contracts/interfaces/ICommonData.sol";import{ITapiocaOptionsBrokerCrossChain}from"tapioca-periph/contracts/interfaces/ITapiocaOptionsBroker.sol";contractTapiocaOFTPOCisTest{addresspublicconstantLZ_ENDPOINT=0x66A71Dcef29A0fFBDBE3c6a460a3B5BC225Cd675;uint16internalconstantPT_TAP_EXERCISE=777;eventMessageFailed(uint16_srcChainId,bytes_srcAddress,uint64_nonce,bytes_payload,bytes_reason);functiontest_POC_ExerciseWrongArguments()public{vm.createSelectFork("https://eth.llamarpc.com");addressoptionsModule_=address(newBaseTOFTOptionsModule(address(LZ_ENDPOINT),address(0),IYieldBoxBase(address(2)),"SomeName","SomeSymbol",18,block.chainid));TapiocaOFTtapiocaOft_=newTapiocaOFT(LZ_ENDPOINT,address(0),IYieldBoxBase(address(3)),"SomeName","SomeSymbol",18,block.chainid,payable(address(1)),payable(address(2)),payable(address(3)),payable(optionsModule_));addressuser_=makeAddr("user");deal(user_,2ether);vm.prank(user_);tapiocaOft_.wrap{value:1ether}(user_,user_,1ether);ITapiocaOptionsBrokerCrossChain.IExerciseOptionsDatamemoryoptionsData_;ITapiocaOptionsBrokerCrossChain.IExerciseLZDatamemorylzData_;ITapiocaOptionsBrokerCrossChain.IExerciseLZSendTapDatamemorytapSendData_;ICommonData.IApproval[]memoryapprovals_;optionsData_.from=user_;optionsData_.target=user_;optionsData_.paymentTokenAmount=1ether;optionsData_.oTAPTokenID=1;optionsData_.paymentToken=address(0);optionsData_.tapAmount=1ether;lzData_.lzDstChainId=102;lzData_.zroPaymentAddress=address(0);lzData_.extraGas=200_000;tapSendData_.withdrawOnAnotherChain=false;tapSendData_.tapOftAddress=address(0);tapSendData_.lzDstChainId=102;tapSendData_.amount=0;tapSendData_.zroPaymentAddress=address(0);tapSendData_.extraGas=0;tapiocaOft_.setTrustedRemoteAddress(102,abi.encodePacked(tapiocaOft_));vm.prank(user_);tapiocaOft_.exerciseOption{value:1ether}(optionsData_,lzData_,tapSendData_,approvals_);bytesmemorylzPayload_=abi.encode(PT_TAP_EXERCISE,optionsData_,tapSendData_,approvals_);vm.prank(LZ_ENDPOINT);vm.expectEmit(true,true,true,true,address(tapiocaOft_));emitMessageFailed(102,abi.encodePacked(tapiocaOft_,tapiocaOft_),0,lzPayload_,vm.parseBytes("0x4e487b710000000000000000000000000000000000000000000000000000000000000041"));tapiocaOft_.lzReceive(102,abi.encodePacked(tapiocaOft_,tapiocaOft_),0,lzPayload_);}}
Tools Used
Vscode, Foundry
Recommended Mitigation Steps
Adding the extra module parameter when encoding the function call in_nonBlockingLzReceive()would be vulnerable to someone calling theBaseTOFTOptionsModuledirectly on functionexercise()with a maliciousmoduleargument. It’s safer to remove themoduleargument and callexerciseInternal()directly, which should work since it’s apublicfunction.
function_nonblockingLzReceive(uint16_srcChainId,bytesmemory_srcAddress,uint64_nonce,bytesmemory_payload)internalvirtualoverride{uint256packetType=_payload.toUint256(0);...}elseif(packetType==PT_TAP_EXERCISE) {_executeOnDestination(Module.Options,abi.encodeWithSelector(BaseTOFTOptionsModule.exercise.selector,address(optionsModule),// here_srcChainId,_srcAddress,_nonce,_payload),_srcChainId,_srcAddress,_nonce,_payload);...
0xRektora (Tapioca) confirmed