[H-13] Possible reentrancy and fund theft inwithdrawDETH()ofGiantSavETHVaultPoolbecause there is no whitelist check for user provided Vaults and there is no reentrancy defense
Submitted byunforgiven
FunctionwithdrawDETH()inGiantSavETHVaultPoolallows a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults. This function make external calls to user provided addresses without checking those addresses and send increased dETH balance of contract during the call to user. User can provide malicious addresses to contract and then took the execution flow during the transaction and increase dETH balance of contract by other calls and make contract to transfer them to him.
Proof of Concept
This iswithdrawDETH()inGiantSavETHVaultPoolcode:
/// @notice Allow a user to burn their giant LP in exchange for dETH that is ready to withdraw from a set of savETH vaults/// @param _savETHVaults List of savETH vaults being interacted with/// @param _lpTokens List of savETH vault LP being burnt from the giant pool in exchange for dETH/// @param _amounts Amounts of giant LP the user owns which is burnt 1:1 with savETH vault LP and in turn that will give a share of dETHfunction withdrawDETH(address[] calldata _savETHVaults,LPToken[][] calldata _lpTokens,uint256[][] calldata _amounts) external {uint256 numOfVaults = _savETHVaults.length;require(numOfVaults > 0, "Empty arrays");require(numOfVaults == _lpTokens.length, "Inconsistent arrays");require(numOfVaults == _amounts.length, "Inconsistent arrays");// Firstly capture current dETH balance and see how much has been deposited after the loopuint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));for (uint256 i; i < numOfVaults; ++i) {SavETHVault vault = SavETHVault(_savETHVaults[i]);// Simultaneously check the status of LP tokens held by the vault and the giant LP balance of the userfor (uint256 j; j < _lpTokens[i].length; ++j) {LPToken token = _lpTokens[i][j];uint256 amount = _amounts[i][j];// Check the user has enough giant LP to burn and that the pool has enough savETH vault LP_assertUserHasEnoughGiantLPToClaimVaultLP(token, amount);require(vault.isDETHReadyForWithdrawal(address(token)), "dETH is not ready for withdrawal");// Giant LP is burned 1:1 with LPs from sub-networksrequire(lpTokenETH.balanceOf(msg.sender) >= amount, "User does not own enough LP");// Burn giant LP from user before sending them dETHlpTokenETH.burn(msg.sender, amount);emit LPBurnedForDETH(address(token), msg.sender, amount);}// Askvault.burnLPTokens(_lpTokens[i], _amounts[i]);}// Calculate how much dETH has been received from burningdETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this)) - dETHReceivedFromAllSavETHVaults;// Send giant LP holder dETH owedgetDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);}
As you can see first contract save the dETH balance of contract by this line:uint256 dETHReceivedFromAllSavETHVaults = getDETH().balanceOf(address(this));and then it loops through user provided vaults addresses and call those vaults to withdraw dETH and in the end it calculatesdETHReceivedFromAllSavETHVaultsand transfer those dETH to user:getDETH().transfer(msg.sender, dETHReceivedFromAllSavETHVaults);. attacker can perform these steps:
create a malicious contractAttackerVaultwhich is copy ofSavETHVaultwith modifiction.callwithdrawDETH()with Vault list[ValidVault1, ValidVault2, AttackerVault, ValidVaul3].contract would save the dETH balance of itself and then loops through Vaults to validate and burn LPTokens.contract would reach VaultAttackerVaultand call attacker controlled address.attacker contract call other functions to increase dETH balance of contract (if it’s not possible to increase dETH balance of contract by other way so there is no need to save contract initial balance of dETH before the loop and dETH balance of contract would be zero always)withdrawDETH()would finish the loop and transfer all the increase dETH balance to attacker which includes extra amounts.
Because contract don’t check the provided addresses and calls them and there is no reentrancy defense mechanism there is possibility of reentrancy attack which can cause fund lose.
Tools Used
VIM
Recommended Mitigation Steps
Check the provided addresses and also have some reentrancy defense mechanisim.
vince0656 (Stakehouse) confirmed