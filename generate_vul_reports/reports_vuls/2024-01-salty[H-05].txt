[H-05] User can evadeliquidationby depositing the minimum of tokens and gain time to not be liquidated
Submitted by0xbepresent, also found byArz, Audinarey (1,2),c0pp3rscr3w3r,stackachu,memforvik,HALITUS,Infect3d,Udsen,Toshii,J4X,Aymen0909,Kalyan-Singh,0xlemon,novodelta,mussucal,Draiakoo,0xpiken,zhaojie,zhaojohnson,00xSEV,juancito,CaeraDenoir,n0kto,DanielArmstrong,Auditwolf,Krace,israeladelaja,0xAsen,pkqs90,PENGUN,0xBinChook,lanrebayode77,twcctop,KingNFT,Jorgect,b0g0,0xRobocop,0xCiphky,djxploit,erosjohn,holydevoti0n,Banditx0x,iamandreiski,ayden,0xanmol,klau5,solmaxis69,developerjordy, and0xAlix2
https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/stable/CollateralAndLiquidity.sol#L140
https://github.com/code-423n4/2024-01-salty/blob/53516c2cdfdfacb662cdea6417c52f23c94d5b5b/src/stable/CollateralAndLiquidity.sol#L70
TheCollateralAndLiquiditycontract contains a critical vulnerability that allows a user undergoing liquidation to evade the process by manipulating theuser.cooldownExpirationvariable. This manipulation is achieved through theCollateralAndLiquidity::depositCollateralAndIncreaseSharefunction, specifically within theStakingRewards::_increaseUserSharefunction (code line#70):
File:StakingRewards.sol57:function_increaseUserShare(addresswallet,bytes32poolID,uint256increaseShareAmount,booluseCooldown)internal58: 		{59:require(poolsConfig.isWhitelisted(poolID),"Invalid pool");60:require(increaseShareAmount!=0,"Cannot increase zero share");61:62:UserShareInfostorageuser=_userShareInfo[wallet][poolID];63:64:if(useCooldown)65:if(msg.sender!=address(exchangeConfig.dao()) )// DAO doesn't use the cooldown66: 			{67:require(block.timestamp>=user.cooldownExpiration,"Must wait for the cooldown to expire");68:69:// Update the cooldown expiration for future transactions70:user.cooldownExpiration=block.timestamp+stakingConfig.modificationCooldown();71: 			}72:73:uint256existingTotalShares=totalShares[poolID];74:75:// Determine the amount of virtualRewards to add based on the current ratio of rewards/shares.76:// The ratio of virtualRewards/increaseShareAmount is the same as totalRewards/totalShares for the pool.77:// The virtual rewards will be deducted later when calculating the user's owed rewards.78:if(existingTotalShares!=0)// prevent / 079:         	{80:// Round up in favor of the protocol.81:uint256virtualRewardsToAdd=Math.ceilDiv(totalRewards[poolID] *increaseShareAmount,existingTotalShares);82:83:user.virtualRewards+=uint128(virtualRewardsToAdd);84:totalRewards[poolID] +=uint128(virtualRewardsToAdd);85: 	        }86:87:// Update the deposit balances88:user.userShare+=uint128(increaseShareAmount);89:totalShares[poolID] =existingTotalShares+increaseShareAmount;90:91:emitUserShareIncreased(wallet,poolID,increaseShareAmount);92: 		}
Malicious user can perform front-running of theliquidationfunction by depositing small amounts of tokens to his position, incrementing theuser.cooldownExpirationvariable. Consequently, the execution of theliquidationfunction will be reverted with the error messageMust wait for the cooldown to expire.This vulnerability could lead to attackers evading liquidation, potentially causing the system to enter into debt as liquidations are avoided.
Proof of Concept
A test case, namedtestUserLiquidationMayBeAvoided, has been created to demonstrate the potential misuse of the system. The test involves the following steps:
User Alice deposits and borrow the maximum amount.The collateral price crashes.Alice maliciously front-runs theliquidationexecution by depositing a the minimum amount using thecollateralAndLiquidity::depositCollateralAndIncreaseSharefunction.Theliquidationtransaction is reverted by “Must wait for the cooldown to expire” error.
// Filename: src/stable/tests/CollateralAndLiquidity.t.sol:TestCollateral// $ forge test --match-test "testUserLiquidationMayBeAvoided" --rpc-url https://yoururl -vv//functiontestUserLiquidationMayBeAvoided()public{// Liquidatable user can avoid liquidation//// Have bob deposit so alice can withdraw everything without DUST reserves restriction_depositHalfCollateralAndBorrowMax(bob);//// 1. Alice deposit and borrow the max amount// Deposit and borrow for Alice_depositHalfCollateralAndBorrowMax(alice);// Check if Alice has a positionassertTrue(_userHasCollateral(alice));//// 2. Crash the collateral price_crashCollateralPrice();vm.warp(block.timestamp+1days);//// 3. Alice maliciously front run the liquidation action and deposit a DUST amountvm.prank(alice);collateralAndLiquidity.depositCollateralAndIncreaseShare(PoolUtils.DUST+1,PoolUtils.DUST+1,0,block.timestamp,false);//// 4. The function alice liquidation will be reverted by "Must wait for the cooldown to expire"vm.expectRevert("Must wait for the cooldown to expire");collateralAndLiquidity.liquidateUser(alice);}
Recommended Mitigation Steps
Consider modifying theliquidationfunction as follows:
function liquidateUser( address wallet ) external nonReentrant{require( wallet != msg.sender, "Cannot liquidate self" );// First, make sure that the user's collateral ratio is below the required levelrequire( canUserBeLiquidated(wallet), "User cannot be liquidated" );uint256 userCollateralAmount = userShareForPool( wallet, collateralPoolID );// Withdraw the liquidated collateral from the liquidity pool.// The liquidity is owned by this contract so when it is withdrawn it will be reclaimed by this contract.(uint256 reclaimedWBTC, uint256 reclaimedWETH) = pools.removeLiquidity(wbtc, weth, userCollateralAmount, 0, 0, totalShares[collateralPoolID] );// Decrease the user's share of collateral as it has been liquidated and they no longer have it.--		_decreaseUserShare( wallet, collateralPoolID, userCollateralAmount, true );++		 _decreaseUserShare( wallet, collateralPoolID, userCollateralAmount, false );// The caller receives a default 5% of the value of the liquidated collateral.uint256 rewardPercent = stableConfig.rewardPercentForCallingLiquidation();uint256 rewardedWBTC = (reclaimedWBTC * rewardPercent) / 100;uint256 rewardedWETH = (reclaimedWETH * rewardPercent) / 100;// Make sure the value of the rewardAmount is not excessiveuint256 rewardValue = underlyingTokenValueInUSD( rewardedWBTC, rewardedWETH ); // in 18 decimalsuint256 maxRewardValue = stableConfig.maxRewardValueForCallingLiquidation(); // 18 decimalsif ( rewardValue > maxRewardValue ){rewardedWBTC = (rewardedWBTC * maxRewardValue) / rewardValue;rewardedWETH = (rewardedWETH * maxRewardValue) / rewardValue;}// Reward the callerwbtc.safeTransfer( msg.sender, rewardedWBTC );weth.safeTransfer( msg.sender, rewardedWETH );// Send the remaining WBTC and WETH to the Liquidizer contract so that the tokens can be converted to USDS and burned (on Liquidizer.performUpkeep)wbtc.safeTransfer( address(liquidizer), reclaimedWBTC - rewardedWBTC );weth.safeTransfer( address(liquidizer), reclaimedWETH - rewardedWETH );// Have the Liquidizer contract remember the amount of USDS that will need to be burned.uint256 originallyBorrowedUSDS = usdsBorrowedByUsers[wallet];liquidizer.incrementBurnableUSDS(originallyBorrowedUSDS);// Clear the borrowedUSDS for the user who was liquidated so that they can simply keep the USDS they previously borrowed.usdsBorrowedByUsers[wallet] = 0;_walletsWithBorrowedUSDS.remove(wallet);emit Liquidation(msg.sender, wallet, reclaimedWBTC, reclaimedWETH, originallyBorrowedUSDS);}
This modification ensures that theuser.cooldownExpirationexpiration check does not interfere with theliquidationprocess, mitigating the identified security risk.
othernet-global (Salty.IO) confirmed and commented:
The stablecoin framework: /stablecoin, /price_feed, WBTC/WETH collateral, PriceAggregator, price feeds and USDS have been removed:https://github.com/othernet-global/salty-io/commit/88b7fd1f3f5e037a155424a85275efd79f3e9bf9
Status:Mitigation confirmed. Full details in reports fromzzebra83,0xpiken, andt0x1c.