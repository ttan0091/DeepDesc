[H-01] selfdestruct may cause the funds to be lost
Submitted bybin2chen, also found bypauliax
https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/FixedPrice.sol#L110
https://github.com/code-423n4/2022-12-escher/blob/5d8be6aa0e8634fdb2f328b99076b0d05fefab73/src/minters/OpenEdition.sol#L122
Impact
After the contract is destroyed, the subsequent execution of the contract’s#buy()will always succede, the msg.value will be locked in this address.
Proof of Concept
When FixedPrice.sol and OpenEdition.sol are finished,selfdestruct()will be executed to destroy the contract.
But there is a problem with this:
Suppose when Alice and Bob execute the purchase transaction at the same time, the transaction is in the memory pool (or Alice executes the transaction, but Bob is still operating the purchase in the UI, the UI does not know that the contract has been destroyed)
If Alice meets the finalId, the contract is destroyed after her transaction ends.
Note: “When there is no code at the address, the transaction will succeed, and the msg.value will be stored in the contract. Although no code is executed.”
After that, Bob’s transaction will be executed.
This way the msg.value passed by Bob is lost and locked forever in the address of this empty code.
Suggestion: don’t use selfdestruct, use modified state to represent that the contract has completed the sale.
Recommended Mitigation Steps
contractFixedPriceisInitializable,OwnableUpgradeable,ISale{...function_end(Salememory_sale)internal{emitEnd(_sale);ISaleFactory(factory).feeReceiver().transfer(address(this).balance/20);-selfdestruct(_sale.saleReceiver);+sale.finalId=sale.currentId+sale.saleReceiver.transfer(address(this).balance);}
berndartmueller (judge) commented:
The warden demonstrates an issue that leads to loss of user funds in case the contract is destroyed withselfdestruct.This clearly differentiates from the other submissions outlining the deprecated use ofselfdestructdue toEIP-4758.
stevennevins (Escher) disputed and commented:
// SPDX-License-Identifier: MITpragma solidity ^0.8.17;import "forge-std/Test.sol";import {EscherTest, FixedPrice, FixedPriceFactory} from "test/FixedPrice.t.sol";contract Issue296Test is EscherTest {FixedPrice.Sale public fixedSale;FixedPriceFactory public fixedSales;FixedPrice public sale;function setUp() public virtual override {super.setUp();fixedSales = new FixedPriceFactory();fixedSale = FixedPrice.Sale({currentId: uint48(0),finalId: uint48(10),edition: address(edition),price: uint96(uint256(1 ether)),saleReceiver: payable(address(69)),startTime: uint96(block.timestamp)});sale = FixedPrice(fixedSales.createFixedSale(fixedSale));edition.grantRole(edition.MINTER_ROLE(), address(sale));sale.buy{value: 10 ether}(10);}function test_RevertsWhenAfterSelfDestruct_Buy() public {vm.expectRevert();sale.buy{value: 1 ether}(1);}}Any purchases after the selfdestruct would revert as shown above.  In order to accurately mock this in Foundry, you can’t perform the destruction within a test function since everything would be one large transaction and the code would still exist as far as Foundry is concerned because it’s all in the same call context. So you have to move the purchase that selfdestructs the contract into the setup function to demonstrate the behavior.
berndartmueller (judge) commented:
@stevennevins You’re right with your Foundry example. However, there are subtle nuances to this that make this finding valid.In your Foundry test, the Solidity function call viasale.buy{value: 1 ether}(1)at the end, uses theextcodesizeopcode to check that the contract that is about to be called actually exists and causes an exception if it does not.However, in the above demonstrated PoC, if a transaction gets executedafterthe contract got destroyed (due to buying the final token id), the transaction does not revert and any value sent along with the transaction will be stored in the contract.I was able to reproduce this behavior with a minimal example contract on Goerli via Remix:// SPDX-License-Identifier: UNLICENSEDpragmasolidity0.8.7;contractSale{functionbuy()externalpayable{_end();}function_end()internal{selfdestruct(payable(msg.sender));}}Calling theSale.buy()function in Remix twice, once with a value of1337 weiand once with333 wei:https://goerli.etherscan.io/tx/0x138d2c061ed547ec5bfd4d7d9b03b519f92b5f63a74b73c45a1af6efe202727chttps://goerli.etherscan.io/tx/0x7ca9032cf79f0a8e29da17061e7eeafb46edfddff96633dc9bbf5957f1aff142As you can see, the first transaction will destroy the contract,1337 weiis sent to the beneficiary (caller). The second transaction succeeds as well. However, the value of333 weiis kept at the address of the destroyed contract.After many considerations, I considerHighto be the appropriate severity. Multiple parallel transactions (e.g. front-runners) will likely try to buy the last NFT IDs, whereas all transactions executed after the last successful buy will render the sentmsg.valuelocked in the destroyed contract. Those users lost funds while not receiving any NFTs.