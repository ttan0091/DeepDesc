[H-06] Bond operations will always revert at certain time whenputOptionsRequiredis true
Submitted bysaid
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L481-L483
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVault.sol#L286
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVault.sol#L539-L551
whenputOptionsRequiredistrue, there is period of time where bond operations will always revert when try to purchase options from perp atlantic vault.
Proof of Concept
Whenbondis called andputOptionsRequiredistrue, it will call_purchaseOptionsproviding the calculatedrdpxRequired.
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L920-L922
functionbond(uint256_amount,uint256rdpxBondId,address_to)publicreturns(uint256receiptTokenAmount) {_whenNotPaused();// Validate amount_validate(_amount>0,4);// Compute the bond cost(uint256rdpxRequired,uint256wethRequired) =calculateBondCost(_amount,rdpxBondId);IERC20WithBurn(weth).safeTransferFrom(msg.sender,address(this),wethRequired);// update weth reservereserveAsset[reservesIndex["WETH"]].tokenBalance+=wethRequired;// purchase optionsuint256premium;if(putOptionsRequired) {>>>premium=_purchaseOptions(rdpxRequired);}_transfer(rdpxRequired,wethRequired-premium,_amount,rdpxBondId);// Stake the ETH in the ReceiptToken contractreceiptTokenAmount=_stake(_to,_amount);// reLPif(isReLPActive)IReLP(addresses.reLPContract).reLP(_amount);emitLogBond(rdpxRequired,wethRequired,receiptTokenAmount);}
Inside_purchaseOptions, it will callPerpetualAtlanticVault.purchaseproviding the amount andaddress(this)as receiver :
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/core/RdpxV2Core.sol#L471-L487
function_purchaseOptions(uint256_amount)internalreturns(uint256premium) {/*** Purchase options and store ERC721 option id* Note that the amount of options purchased is the amount of rDPX received* from the user to sufficiently collateralize the underlying DpxEth stored in the bond**/uint256optionId;>>> (premium,optionId) =IPerpetualAtlanticVault(addresses.perpetualAtlanticVault).purchase(_amount,address(this));optionsOwned[optionId] =true;reserveAsset[reservesIndex["WETH"]].tokenBalance-=premium;}
Then insidepurchase, it will calculatepremiumusingcalculatePremiumfunction, providingstrike,amount,timeToExpiry.
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVault.sol#L286
functionpurchase(uint256amount,addressto)externalnonReentrantonlyRole(RDPXV2CORE_ROLE)returns(uint256premium,uint256tokenId){_whenNotPaused();_validate(amount>0,2);updateFunding();uint256currentPrice=getUnderlyingPrice();// price of underlying wrt collateralTokenuint256strike=roundUp(currentPrice- (currentPrice/4));// 25% below the current priceIPerpetualAtlanticVaultLPperpetualAtlanticVaultLp=IPerpetualAtlanticVaultLP(addresses.perpetualAtlanticVaultLP);// Check if vault has enough collateral to write the optionsuint256requiredCollateral= (amount*strike) /1e8;_validate(requiredCollateral<=perpetualAtlanticVaultLp.totalAvailableCollateral(),3);uint256timeToExpiry=nextFundingPaymentTimestamp() -block.timestamp;// Get total premium for all options being purchased>>>premium=calculatePremium(strike,amount,timeToExpiry,0);// ... rest of operations}
Inside thiscalculatePremium, it will get price from option pricing :
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/perp-vault/PerpetualAtlanticVault.sol#L539-L551
functioncalculatePremium(uint256_strike,uint256_amount,uint256timeToExpiry,uint256_price)publicviewreturns(uint256premium) {premium= ((IOptionPricing(addresses.optionPricing).getOptionPrice(_strike,_price>0?_price:getUnderlyingPrice(),getVolatility(_strike),timeToExpiry) *_amount) /1e8);}
The providedOptionPricingSimple.getOptionPricewill use Black-Scholes model to calculate the price :
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/libraries/BlackScholes.sol#L33-L89
functioncalculate(uint8optionType,uint256price,uint256strike,uint256timeToExpiry,uint256riskFreeRate,uint256volatility)internalpurereturns(uint256) {bytes16S=ABDKMathQuad.fromUInt(price);bytes16X=ABDKMathQuad.fromUInt(strike);bytes16T=ABDKMathQuad.div(ABDKMathQuad.fromUInt(timeToExpiry),ABDKMathQuad.fromUInt(36500)// 365 * 10 ^ DAYS_PRECISION);bytes16r=ABDKMathQuad.div(ABDKMathQuad.fromUInt(riskFreeRate),ABDKMathQuad.fromUInt(10000));bytes16v=ABDKMathQuad.div(ABDKMathQuad.fromUInt(volatility),ABDKMathQuad.fromUInt(100));bytes16d1=ABDKMathQuad.div(ABDKMathQuad.add(ABDKMathQuad.ln(ABDKMathQuad.div(S,X)),ABDKMathQuad.mul(ABDKMathQuad.add(r,ABDKMathQuad.mul(v,ABDKMathQuad.div(v,ABDKMathQuad.fromUInt(2)))),T)),ABDKMathQuad.mul(v,ABDKMathQuad.sqrt(T)));bytes16d2=ABDKMathQuad.sub(d1,ABDKMathQuad.mul(v,ABDKMathQuad.sqrt(T)));if(optionType==OPTION_TYPE_CALL) {returnABDKMathQuad.toUInt(ABDKMathQuad.mul(_calculateCallTimeDecay(S,d1,X,r,T,d2),ABDKMathQuad.fromUInt(DIVISOR)));}elseif(optionType==OPTION_TYPE_PUT) {returnABDKMathQuad.toUInt(ABDKMathQuad.mul(_calculatePutTimeDecay(X,r,T,d2,S,d1),ABDKMathQuad.fromUInt(DIVISOR)));}elsereturn0;}
The problem lies insidecalculatePremiumdue to not properly check if current time less than 864 seconds (around 14 minutes). becausegetOptionPricewill use time expiry in days multiply by 100.
https://github.com/code-423n4/2023-08-dopex/blob/main/contracts/libraries/OptionPricingSimple.sol#L72
uint256timeToExpiry= (expiry*100) /86400;
IfnextFundingPaymentTimestamp() - block.timestampis less than 864 seconds, it will causetimeToExpiryinside option pricing is 0 and the call will always revert. This will cause an unexpected revert period around 14 minutes every funding epoch (in this case every week).
Foundry PoC :
Try to simulatecalculatePremiumwhennextFundingPaymentTimestamp() - block.timestampis less than 864 seconds.
Add this test toUnitcontract inside/tests/rdpxV2-core/Unit.t.sol, also addimport "forge-std/console.sol";andimport {OptionPricingSimple} from "contracts/libraries/OptionPricingSimple.sol";in the contract  :
functiontestOptionPricingRevert()public{OptionPricingSimpleoptionPricingSimple;optionPricingSimple=newOptionPricingSimple(100,5e6);(uint256rdpxRequired,uint256wethRequired) =rdpxV2Core.calculateBondCost(1*1e18,0);uint256currentPrice=vault.getUnderlyingPrice();// price of underlying wrt collateralTokenuint256strike=vault.roundUp(currentPrice- (currentPrice/4));// 25% below the current price// around 14 minutes before next funding paymentvm.warp(block.timestamp+7days-863seconds);uint256timeToExpiry=vault.nextFundingPaymentTimestamp() -block.timestamp;console.log("What is the current price");console.log(currentPrice);console.log("What is the strike");console.log(strike);console.log("What is time to expiry");console.log(timeToExpiry);uint256price=vault.getUnderlyingPrice();// will revertvm.expectRevert();optionPricingSimple.getOptionPrice(strike,price,100,timeToExpiry);}
Recommended Mitigation Steps
Set minimumtimeToExpiryinsidecalculatePremium:
function calculatePremium(uint256 _strike,uint256 _amount,uint256 timeToExpiry,uint256 _price) public view returns (uint256 premium) {premium = ((IOptionPricing(addresses.optionPricing).getOptionPrice(_strike,_price > 0 ? _price : getUnderlyingPrice(),getVolatility(_strike),-      timeToExpiry+      timeToExpiry < 864 ? 864 : timeToExpiry) * _amount) / 1e8);}
psytama (Dopex) confirmed and commented:
Modify time to expiry with a check for less than 864 seconds and make it more robust.
Alex the Entreprenerd (Judge) commented:
The DOS is not conditional on an external requirement because it consistently happens, Iâ€™ll ask judges, but am maintaining High Severity at this time.