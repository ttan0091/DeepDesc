[H-11] Adversary can utilise approved to MagnetaroTAPandtOLPNFTs
Submitted bydeadrxsezzz
The idea of Magnetar is to allow users to batch transactions towards certain contract within the Tapioca contracts, includingTapiocaOptionBrokerandTapiocaOptionLiquidityProvision. In order to do so, users will have to giveoTAPandtOLPallowance to the Magnetar contract.
The problem is that within the_processTapTokenOperationfunction, any user could make a call for another’s user’s approved NFT, as there are no checks that themsg.senderis the owner of the NFT.
function_processTapTokenOperation(address_target,bytescalldata_actionCalldata,uint256_actionValue,bool_allowFailure)private{if(!cluster.isWhitelisted(0,_target))revertMagnetar_NotAuthorized(_target,_target);bytes4funcSig=bytes4(_actionCalldata[:4]);if(funcSig==ITapiocaOptionBroker.exerciseOption.selector||funcSig==ITapiocaOptionBroker.participate.selector||funcSig==ITapiocaOptionBroker.exitPosition.selector||funcSig==ITapiocaOptionLiquidityProvision.lock.selector||funcSig==ITapiocaOptionLiquidityProvision.unlock.selector) {_executeCall(_target,_actionCalldata,_actionValue,_allowFailure);return;}revertMagnetar_ActionNotValid(MagnetarAction.TapToken,_actionCalldata);}
Example: A user can callexerciseOptionfor another person’s approvedoTAPand exercise their option:
functionexerciseOption(uint256_oTAPTokenID,ERC20_paymentToken,uint256_tapAmount)externalwhenNotPaused{// Load data(,TapOptionmemoryoTAPPosition) =oTAP.attributes(_oTAPTokenID);LockPositionmemorytOLPLockPosition=tOLP.getLock(oTAPPosition.tOLP);boolisPositionActive=_isPositionActive(tOLPLockPosition);if(!isPositionActive)revertOptionExpired();uint256cachedEpoch=epoch;PaymentTokenOraclememorypaymentTokenOracle=paymentTokens[_paymentToken];// Check requirementsif(paymentTokenOracle.oracle==ITapiocaOracle(address(0))) {revertPaymentTokenNotSupported();}if(!oTAP.isApprovedOrOwner(msg.sender,_oTAPTokenID)) {revertNotAuthorized();}if(block.timestamp<oTAPPosition.entry+EPOCH_DURATION) {revertOneEpochCooldown();}// Can only exercise after 1 epoch duration// Get eligible OTC amountuint256gaugeTotalForEpoch=singularityGauges[cachedEpoch][tOLPLockPosition.sglAssetID];uint256netAmount=uint256(netDepositedForEpoch[cachedEpoch][tOLPLockPosition.sglAssetID]);if(netAmount==0)revertNoLiquidity();uint256eligibleTapAmount=muldiv(tOLPLockPosition.ybShares,gaugeTotalForEpoch,netAmount);eligibleTapAmount-=oTAPCalls[_oTAPTokenID][cachedEpoch];// Subtract already exercised amountif(eligibleTapAmount<_tapAmount)revertTooHigh();uint256chosenAmount=_tapAmount==0?eligibleTapAmount:_tapAmount;if(chosenAmount<1e18)revertTooLow();oTAPCalls[_oTAPTokenID][cachedEpoch] +=chosenAmount;// Adds up exercised amount to current epoch// Finalize the deal_processOTCDeal(_paymentToken,paymentTokenOracle,chosenAmount,oTAPPosition.discount);emitExerciseOption(cachedEpoch,msg.sender,_paymentToken,_oTAPTokenID,chosenAmount);}
Recommended Mitigation Steps
Add checks within Magnetar that the user owns the NFT on which they’re making a call.
Assessed type
Access Control
0xWeiss (Tapioca) confirmed