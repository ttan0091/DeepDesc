[H-07]account.holdsTokenis never set
TheaddHoldingfunction does not update theaccount.holdsTokenmap.
functionaddHolding(CrossMarginAccountstorageaccount,addresstoken,uint256depositAmount)internal{if(!hasHoldingToken(account,token)) {// SHOULD SET account.holdsToken hereaccount.holdingTokens.push(token);}account.holdings[token] +=depositAmount;}
This leads to a critical vulnerability where deposits of the same token keep being pushed to theaccount.holdingTokensarray but the sum is correctly updated inaccount.holdings[token]. However, because of the duplicate token in theholdingTokensarray the same token is counted several times in thegetHoldingAmountsfunction:
functiongetHoldingAmounts(addresstrader)externalviewoverridereturns(address[]memoryholdingTokens,uint256[]memoryholdingAmounts){CrossMarginAccountstorageaccount=marginAccounts[trader];holdingTokens=account.holdingTokens;holdingAmounts=newuint256[](account.holdingTokens.length);for(uint256idx=0;holdingTokens.length>idx;idx++) {addresstokenAddress=holdingTokens[idx];// RETURNS SUM OF THE BALANCE FOR EACH TOKEN ENTRYholdingAmounts[idx] =account.holdings[tokenAddress];}}
TheMarginRouter.crossCloseAccountfunction uses these wrong amounts to withdraw all tokens:
functioncrossCloseAccount()external{(address[]memoryholdingTokens,uint256[]memoryholdingAmounts) =IMarginTrading(marginTrading()).getHoldingAmounts(msg.sender);// requires all debts paid offIMarginTrading(marginTrading()).registerLiquidation(msg.sender);for(uint256i;holdingTokens.length>i;i++) {Fund(fund()).withdraw(holdingTokens[i],msg.sender,holdingAmounts[i]);}}
An attacker can just deposit the same token X times which increases their balance by X times the actual value.
This inflated balance can then be withdrawn to steal all tokens.
Recommend correctly setting theaccount.holdsTokenmap inaddHolding.