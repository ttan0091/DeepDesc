[H-03]dMute.sol: Attacker can push lock items to victim’s array such that redemptions are forever blocked
Submitted byHollaDieWaldfee, also found byevanandchaduke
https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/dao/dMute.sol#L90-L129https://github.com/code-423n4/2023-03-mute/blob/4d8b13add2907b17ac14627cfa04e0c3cc9a2bed/contracts/dao/dMute.sol#L135-L139
This report deals with how an attacker can abuse the fact that he can lockMUTEtokens for any other user and thereby push items to the array ofUserLockInfostructs of the user.
There are two functions in thedMutecontract that iterate over all items in this array (RedeemToandGetUnderlyingTokens).
Thereby if the attacker pushes sufficient items to the array of a user, he can make the above two functions revert since they require more Gas than the Block Gas Limit.
According to thezkSyncdocumentation the block gas limit is currently 12.5 million (Link).
The attack is of “High” impact for theRedeemTofunction since this function needs to succeed in order for the user to redeem hisMUTEtokens.
The user might have a lot ofMUTEtokens locked and the attacker can make it such that they can never be redeemed. The attacker cannot gain a profit from this attack, i.e. he cannot steal anything, but due to the possibility of this attack users will not lock their tokens, especially not a lot of them.
This is all the more severe because theMuteBondandMuteAmplifiercontracts also rely on the locking functionality so those upstream features can also not be used securely.
In the Mitigation section I will show how theGetUnderlyingTokensfunction can be made to run in $O(1)$ time instead of $O(lock:array:length)$.
TheRedeemTofunction can be made to run in $O(indexes:array:length)$ instead of $O(lock:array:length)$. The length of the indexes array is determined by the user and simply tells how many locked items to redeem. So there is no possibility of DOS.
Proof of Concept
Note: a redemption costs~7 million Gaswhen 1000 items are locked. So when running on thezkSyncnetwork even 2000 items should be enough. The hardhat tests use a local Ethereum network instead of a fork ofzkSyncso in order to hit30 million Gas(which is the Ethereum block gas limit) we need to add more items to the queue.
You can add the following test to thedao.tstest file:
it('Lock DOS',asyncfunction() {vartx=awaitmuteToken.approve(dMuteToken.address,MaxUint256)letlock_time_week=newBigNumber(60*60*24*7);letmax_lock=lock_time_week.times(52);letlock_amount=newBigNumber(1).times(Math.pow(10,2))// @audit fill up arrayfor(leti=0;i<5000;i++) {tx=awaitdMuteToken.LockTo(lock_amount.toFixed(0),lock_time_week.toFixed(),owner.address)}awaittime.increase(60*60*24*7)tx=awaitdMuteToken.Redeem([0])})
It adds5000lock items to the array of theowneraddress. When theownerthen tries to redeem even a single lock the transaction fails due to an out of gas error.
(Sometimes it reverts withTransactionExecutionError: Transaction ran out of gaserror sometimes it reverts due to timeout. If you try a few times it should revert with the out of gas error.)
The amount ofMUTEtokens that the attacker loses to execute this attack is negligible. As you can see in the test100 Wei * 5000 = 500,000 Weiis sufficient (There needs to be some amount ofMUTEsuch that theLockTofunction does not revert). The only real cost comes down to Gas costs which are cheap onzkSync.
Tools Used
VSCode
Recommended Mitigation Steps
First for theGetUnderlyingTokensfunction: The contract should keep track of underlying token amounts for each user in a mapping that is updated with every lock / redeem call. TheGetUnderlyingTokensfunction then simply needs to return the value from this mapping.
Secondly, fixing the issue with theRedeemTofunction is a bit harder. I discussed this with the sponsor and I have been told they don’t want this function to require an already sortedlock_indexarray as parameter. So thelock_indexarray can contain indexes in random order.
This means it must be sorted internally. Depending on the expected length of thelock_indexarray different sorting algorithms may be used. I recommend to use an algorithm likequick sortto allow for many indexes to be specified at once.
I will use a placeholder for the sorting algorithm for now so the sponsor may decide which one to use.
The proposed fixes for both functions are then like this:
diff --git a/contracts/dao/dMute.sol b/contracts/dao/dMute.solindex 59f95b7..11d21fb 100644--- a/contracts/dao/dMute.sol+++ b/contracts/dao/dMute.sol@@ -18,6 +18,7 @@ contract dMute is dSoulBound {}mapping(address => UserLockInfo[]) public _userLocks;+    mapping(address => uint256) public _amounts;uint private unlocked = 1;@@ -79,6 +80,7 @@ contract dMute is dSoulBound {_mint(to, tokens_to_mint);_userLocks[to].push(UserLockInfo(_amount, block.timestamp.add(_lock_time), tokens_to_mint));+        _amounts[to] = _amounts[to] + _amount;emit LockEvent(to, _amount, tokens_to_mint, _lock_time);}@@ -91,8 +93,14 @@ contract dMute is dSoulBound {uint256 total_to_redeem = 0;uint256 total_to_burn = 0;-        for(uint256 i; i < lock_index.length; i++){-          uint256 index = lock_index[i];+        ///////////////////////////////////////////////+        //                                           //+        // sort lock_index array in ascending order //+        //                                          //+        //////////////////////////////////////////////++        for(uint256 i = lock_index.length; i > 0; i--){+          uint256 index = lock_index[i - 1];UserLockInfo memory lock_info = _userLocks[msg.sender][index];require(block.timestamp >= lock_info.time, "dMute::Redeem: INSUFFICIENT_LOCK_TIME");@@ -102,23 +110,14 @@ contract dMute is dSoulBound {total_to_redeem = total_to_redeem.add(lock_info.amount);total_to_burn = total_to_burn.add(lock_info.tokens_minted);-          _userLocks[msg.sender][index] = UserLockInfo(0,0,0);+          _userLocks[msg.sender][index] = _userLocks[msg.sender][_userLocks[msg.sender].length - 1];+          _userLocks[msg.sender].pop();}require(total_to_redeem > 0, "dMute::Lock: INSUFFICIENT_REDEEM_AMOUNT");require(total_to_burn > 0, "dMute::Lock: INSUFFICIENT_BURN_AMOUNT");--        for(uint256 i = _userLocks[msg.sender].length; i > 0; i--){-          UserLockInfo memory lock_info = _userLocks[msg.sender][i - 1];--          // recently redeemed lock, destroy it-          if(lock_info.time == 0){-            _userLocks[msg.sender][i - 1] = _userLocks[msg.sender][_userLocks[msg.sender].length - 1];-            _userLocks[msg.sender].pop();-          }-        }-+        _amounts[msg.sender] = _amounts[msg.sender] + total_to_redeem;//redeem tokens to userIERC20(MuteToken).transfer(to, total_to_redeem);//burn dMute@@ -133,8 +132,6 @@ contract dMute is dSoulBound {}function GetUnderlyingTokens(address account) public view returns(uint256 amount) {-        for(uint256 i; i < _userLocks[account].length; i++){-          amount = amount.add(_userLocks[account][i].amount);-        }+        return _amounts[account];}}
Picodes (judge) commented:
At first read, it looks like a great finding considering the project will be onzkSync.
mattt21 (Mute Switch) confirmed