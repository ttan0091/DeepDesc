[H-06]FeeRefund.tokenGasPriceFactoris not included in signed transaction data allowing the submitter to steal funds
Submitted byRuhum, also found byV_B,adriro,immeas,supernova,MalfurionWhitehat,cccz, andladboy233
contracts/smart-contract-wallet/SmartAccount.sol#L288contracts/smart-contract-wallet/SmartAccount.sol#L429-L444
The submitter of a transaction is paid back the transaction’s gas costs either in ETH or in ERC20 tokens. With ERC20 tokens the following formula is used: $(gasUsed + baseGas) \* gasPrice / tokenGasPriceFactor$.baseGas,gasPrice, andtokenGasPriceFactorare values specified by the tx submitter. Since you don’t want the submitter to choose arbitrary values and pay themselves as much as they want, those values are supposed to be signed off by the owner of the wallet. The signature of the user is included in the tx so that the contract can verify that all the values are correct. But, thetokenGasPriceFactorvalue is not included in those checks. Thus, the submitter is able to simulate the tx with value $x$, get the user to sign that tx, and then submit it with $y$ fortokenGasPriceFactor. That way they can increase the actual gas repayment and steal the user’s funds.
Proof of Concept
InencodeTransactionData()we can see thattokenGasPriceFactoris not included:
functionencodeTransactionData(Transactionmemory_tx,FeeRefundmemoryrefundInfo,uint256_nonce)publicviewreturns(bytesmemory) {bytes32safeTxHash=keccak256(abi.encode(ACCOUNT_TX_TYPEHASH,_tx.to,_tx.value,keccak256(_tx.data),_tx.operation,_tx.targetTxGas,refundInfo.baseGas,refundInfo.gasPrice,refundInfo.gasToken,refundInfo.refundReceiver,_nonce));returnabi.encodePacked(bytes1(0x19),bytes1(0x01),domainSeparator(),safeTxHash);}
The value is used to determine the gas repayment inhandlePayment()andhandlePaymentRevert():
functionhandlePayment(uint256gasUsed,uint256baseGas,uint256gasPrice,uint256tokenGasPriceFactor,addressgasToken,addresspayablerefundReceiver)privatenonReentrantreturns(uint256payment) {// uint256 startGas = gasleft();// solhint-disable-next-line avoid-tx-originaddresspayablereceiver=refundReceiver==address(0) ?payable(tx.origin) :refundReceiver;if(gasToken==address(0)) {// For ETH we will only adjust the gas price to not be higher than the actual used gas pricepayment= (gasUsed+baseGas) * (gasPrice<tx.gasprice?gasPrice:tx.gasprice);(boolsuccess,) =receiver.call{value:payment}("");require(success,"BSA011");}else{payment= (gasUsed+baseGas) * (gasPrice) / (tokenGasPriceFactor);require(transferToken(gasToken,receiver,payment),"BSA012");}// uint256 requiredGas = startGas - gasleft();//console.log("hp %s", requiredGas);}
That’s called at the end ofexecTransaction():
if(refundInfo.gasPrice>0) {//console.log("sent %s", startGas - gasleft());// extraGas = gasleft();payment=handlePayment(startGas-gasleft(),refundInfo.baseGas,refundInfo.gasPrice,refundInfo.tokenGasPriceFactor,refundInfo.gasToken,refundInfo.refundReceiver);emitWalletHandlePayment(txHash,payment);}
As an example, given that:
gasUsed = 1,000,000baseGas = 100,000gasPrice = 10,000,000,000(10 gwei)tokenGasPriceFactor = 18
You get $(1,000,000 + 100,000) \* 10,000,000,000 / 18 = 6.1111111e14$. If the submitter executes the transaction withtokenGasPriceFactor = 1they get $1.1e16$ instead, i.e. 18 times more.
Recommended Mitigation Steps
tokenGasPriceFactorshould be included in the encoded transaction data and thus verified by the user’s signature.
livingrockrises (Biconomy) confirmed