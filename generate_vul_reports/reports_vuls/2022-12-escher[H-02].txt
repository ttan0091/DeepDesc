[H-02]LPDAprice can underflow the price due to bad settings and potentially brick the contract
Submitted byadriro, also found byAymen0909,Franfran,kiki_dev,Ch_301,Chom,slvDev,lukris02,0xRobocop,minhquanym,immeas,nameruse,0xDecorativePineapple,carrotsmuggler,kaliberpoziomka8552,jonatascm,minhtrng,imare,neumo,ladboy233,Tricko,mahdikarimi,sorrynotsorry,kree-dotcom,pauliax,poirots,bin2chen,jayphbee,0xDave,jadezti,evan,reassor,gz627,0xbepresent,0xA5DF,hihen,chaduke,hansfriese,yixxas,Madalad,HollaDieWaldfee,Parth,0x446576,lumoswiz,danyams,obront,zapaz,rvierdiiev,8olidity, andRuhum
The dutch auction in theLPDAcontract is implemented by configuring a start price and price drop per second.
A bad set of settings can cause an issue where the elapsed duration of the sale multiplied by the drop per second gets bigger than the start price and underflows the current price calculation.
https://github.com/code-423n4/2022-12-escher/blob/main/src/minters/LPDA.sol#L117
functiongetPrice()publicviewreturns(uint256) {Salememorytemp=sale;(uint256start,uint256end) = (temp.startTime,temp.endTime);if(block.timestamp<start)returntype(uint256).max;if(temp.currentId==temp.finalId)returntemp.finalPrice;uint256timeElapsed=end>block.timestamp?block.timestamp-start:end-start;returntemp.startPrice- (temp.dropPerSecond*timeElapsed);}
This means that iftemp.dropPerSecond * timeElapsed > temp.startPricethen the unsigned integer result will become negative and underflow, leading to potentially bricking the contract and an eventual loss of funds.
Impact
Due to Solidity 0.8 default checked math, the subtraction of the start price and the drop will cause a negative value that will generate an underflow in the unsigned integer type and lead to a transaction revert.
Calls togetPricewill revert, and since this function is used in thebuyto calculate the current NFT price it will also cause the buy process to fail. The price drop will continue to increase as time passes, making it impossible to recover from this situation and effectively bricking the contract.
This will eventually lead to a loss of funds because currently the only way to end a sale and transfer funds to the sale and fee receiver is to buy the complete set of NFTs in the sale (i.e. buy everything up to thesale.finalId) which will be impossible if thebuyfunction is bricked.
Proof of Concept
In the following test, the start price is 1500 and the duration is 1 hour (3600 seconds) with a drop of 1 per second. At about ~40% of the elapsed time the price drop will start underflowing the price, reverting the calls to bothgetPriceandbuy.
// SPDX-License-Identifier: MITpragmasolidity^0.8.17;import"forge-std/Test.sol";import{FixedPriceFactory}from"src/minters/FixedPriceFactory.sol";import{FixedPrice}from"src/minters/FixedPrice.sol";import{OpenEditionFactory}from"src/minters/OpenEditionFactory.sol";import{OpenEdition}from"src/minters/OpenEdition.sol";import{LPDAFactory}from"src/minters/LPDAFactory.sol";import{LPDA}from"src/minters/LPDA.sol";import{Escher721}from"src/Escher721.sol";contractAuditTestisTest{addressdeployer;addresscreator;addressbuyer;FixedPriceFactoryfixedPriceFactory;OpenEditionFactoryopenEditionFactory;LPDAFactorylpdaFactory;functionsetUp()public{deployer=makeAddr("deployer");creator=makeAddr("creator");buyer=makeAddr("buyer");vm.deal(buyer,1e18);vm.startPrank(deployer);fixedPriceFactory=newFixedPriceFactory();openEditionFactory=newOpenEditionFactory();lpdaFactory=newLPDAFactory();vm.stopPrank();}functiontest_LPDA_getPrice_NegativePrice()public{// Setup NFT and create salevm.startPrank(creator);Escher721nft=newEscher721();nft.initialize(creator,address(0),"Test NFT","TNFT");// Duration is 1 hour (3600 seconds), with a start price of 1500 and a drop of 1, getPrice will revert and brick the contract at about 40% of the elapsed durationuint48startId=0;uint48finalId=1;uint80startPrice=1500;uint80dropPerSecond=1;uint96startTime=uint96(block.timestamp);uint96endTime=uint96(block.timestamp+1hours);LPDA.Salememorysale=LPDA.Sale(startId,// uint48 currentId;finalId,// uint48 finalId;address(nft),// address edition;startPrice,// uint80 startPrice;0,// uint80 finalPrice;dropPerSecond,// uint80 dropPerSecond;endTime,// uint96 endTime;payable(creator),// address payable saleReceiver;startTime// uint96 startTime;);LPDAlpdaSale=LPDA(lpdaFactory.createLPDASale(sale));nft.grantRole(nft.MINTER_ROLE(),address(lpdaSale));vm.stopPrank();// simulate we are in the middle of the sale durationvm.warp(startTime+0.5hours);vm.startPrank(buyer);// getPrice will revert due to the overflow caused by the price becoming negativevm.expectRevert();lpdaSale.getPrice();// This will also cause the contract to be bricked, since buy needs getPrice to check that the buyer is sending the correct amountuint256amount=1;uint256price=1234;vm.expectRevert();lpdaSale.buy{value:price*amount}(amount);vm.stopPrank();}}
Recommendation
Add a validation in theLPDAFactory.createLPDASalefunction to ensure that the given duration and drop per second settings canâ€™t underflow the price.
require((sale.endTime-sale.startTime) *sale.dropPerSecond<=sale.startPrice,"MAX DROP IS GREATER THAN START PRICE");
stevennevins (Escher) confirmed