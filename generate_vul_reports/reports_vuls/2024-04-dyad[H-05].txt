[H-05] Unable to withdraw Kerosene fromvaultmanagerv2::withdrawas it expects avault.oracle()method which is missing in Kerosene vaults
Submitted byCircolors, also found bydinkras,ahmedaghadi,0x175,Evo,0xfox,d3e4,Al-Qa-qa,0xlemon,Mahmud,Honour,sashik_eth,SBSecurity,amaron,TheSchnilch,Infect3d,ducanh2706,Limbooo,3th,0xShitgem,ke1caM,ljj,bhilare_,iamandreiski, Josh4324 (1,2),0xSecuri,bbl4de,Aamir,btk,alix40,0xnilay,steadyman,shaflow2,cinderblock,AlexCzm,y4y,Egis_Security,web3km, 0xAlix2 (1,2),0x486776,itsabinashb,carrotsmuggler,dimulski, and4rdiii
VaultManagerV2has onewithdrawfunction responsible for withdrawing both exogenous collateral (weth/wsteth) and endogenous collateral (Kerosene). However, the function expects thevaultpassed as an argument to have anoraclemethod. This is the case forVaultcontracts, but not the case for theBoundedKerosineVaultorUnboundedKerosineVaultcontracts. This means that whenever a user attempts to withdraw Kerosene deposited into the contract the call will revert, meaning the Kerosene remains stuck in the contract permanently.
Proof of Concept
Add the following test tov2.t.solto highlight this:
functiontestCannotWithdrawKero()public{// Set up alicelicenseVaultManager();addressalice=makeAddr("alice");uintaliceTokenId=sendNote(alice);sendKerosene(alice,10_000ether);// Alice deposits kerosene into the protocolvm.startPrank(alice);contracts.vaultManager.addKerosene(aliceTokenId,address(contracts.unboundedKerosineVault));Kerosine(MAINNET_KEROSENE).approve(address(contracts.vaultManager),10_000ether);contracts.vaultManager.deposit(aliceTokenId,address(contracts.unboundedKerosineVault),10_000ether);assertEq(ERC20(MAINNET_KEROSENE).balanceOf(alice),0);vm.roll(block.number+42);// Alice attempts to withdraw her kerosene but the tx revertscontracts.vaultManager.withdraw(aliceTokenId,address(contracts.unboundedKerosineVault),10_000ether,alice);}
The test reverts with the following stack traces:
├─ [9243] VaultManagerV2::withdraw(645,UnboundedKerosineVault: [0x416C42991d05b31E9A6dC209e91AD22b79D87Ae6],10000000000000000000000[1e22],alice: [0x328809Bc894f92807417D2dAD6b7C998c1aFdac6])│   ├─ [558]0xDc400bBe0B8B79C07A962EA99a642F5819e3b712::ownerOf(645) [staticcall]│   │   └─ ← [Return] alice: [0x328809Bc894f92807417D2dAD6b7C998c1aFdac6]│   ├─ [2623]0x305B58c5F6B5b6606fb13edD11FbDD5e532d5A26::mintedDyad(VaultManagerV2: [0xA8452Ec99ce0C64f20701dB7dD3abDb607c00496],645) [staticcall]│   │   └─ ← [Return]0│   ├─ [261] UnboundedKerosineVault::asset() [staticcall]│   │   └─ ← [Return]0xf3768D6e78E65FC64b8F12ffc824452130BD5394│   ├─ [262]0xf3768D6e78E65FC64b8F12ffc824452130BD5394::decimals() [staticcall]│   │   └─ ← [Return]18│   ├─ [214] UnboundedKerosineVault::oracle() [staticcall]│   │   └─ ← [Revert] EvmError:Revert│   └─ ← [Revert] EvmError:Revert
Recommended Mitigation
Given that thevalueof exogenous and endogenous collateral is calculated differently it is necessary to handle withdrawal of exogenous collateral and Kerosene differently. It would avoid added complexity to the function logic to have two differentwithdrawandwithdrawKerosenefunctions.
shafu0x (DYAD) confirmed and commented:
Good find. This is correct.
Note: For full discussion, seehere.