[H-22] Multiple issues withretrySettlement()andretrieveDeposit()will cause loss of users’ bridging deposits
Submitted bypeakbolt, also found by Noro (1,2), zzebra83 (1,2),Evo, andEmmanuel
BothretrySettlement()andretrieveDeposit()are incorrectly implemented with the following 3 issues:
BothretrySettlement()andretrieveDeposit()are lacking a call towrappedNativeToken.deposit()to wrap the native token paid by users for gas. This causes a subsequent call to_depositGas()to fail atBranchBridgeAgent.sol#L929-L931. This is also inconsistent with the other functions likeretryDeposit(), which wraps the received native token for gas (seeBranchBridgeAgent.sol#L441-L447).retrySettlement()has a redundant increment fordepositNonceinBranchBridgeAgent.sol#L426, which will cause a differentdepositNoncevalue to be used for the subsequent call to_createGasDepositinBranchBridgeAgent.sol#L836.BothretrySettlement()andretrieveDeposit()are missing a fallback implementation, asBranchBridgeAgent.anyFallback()is not handling flag0x07(retrySettlement) and flag0x08(retrieveDeposit), as evident inBranchBridgeAgent.sol#L1227-L1307.
Impact
Due to these issues, bothretrySettlement()andretrieveDeposit()will cease to function properly. That will prevent users from re-trying the failed settlement and retrieving deposits, resulting in a loss of users’ deposits for bridging. In addition, the gas paid by a user that is not wrapped will also be stuck inBranchBridgeAgent, as there is no function to withdraw the native token.
Proof of Concept
Add the following test case toRootTest.t.sol. This shows the issues with the lack of native token wrapping:
functiontestPeakboltRetrySettlement()public{//Set uptestAddLocalTokenArbitrum();//Prepare databytesmemorypackedData;{Multicall2.Call[]memorycalls=newMulticall2.Call[](1);//Mock actioncalls[0] =Multicall2.Call({target:0x0000000000000000000000000000000000000000,callData:""});//Output ParamsOutputParamsmemoryoutputParams=OutputParams(address(this),newAvaxAssetGlobalAddress,150ether,0);//RLP Encode Calldata Call with no gas to bridge out and we top up.bytesmemorydata=abi.encode(calls,outputParams,ftmChainId);//Pack FuncIdpackedData=abi.encodePacked(bytes1(0x02),data);}address_user=address(this);//Get some gas.hevm.deal(_user,1ether);hevm.deal(address(ftmPort),1ether);//assure there is enough balance for mock actionhevm.prank(address(rootPort));ERC20hTokenRoot(newAvaxAssetGlobalAddress).mint(address(rootPort),50ether,rootChainId);hevm.prank(address(avaxPort));ERC20hTokenBranch(avaxMockAssethToken).mint(_user,50ether);//Mint Underlying Token.avaxMockAssetToken.mint(_user,100ether);//Prepare deposit infoDepositInputmemorydepositInput=DepositInput({hToken:address(avaxMockAssethToken),token:address(avaxMockAssetToken),amount:150ether,deposit:100ether,toChain:ftmChainId});console2.log("-------------  Creating a failed settlement ----------------");//Call Deposit functionavaxMockAssetToken.approve(address(avaxPort),100ether);ERC20hTokenRoot(avaxMockAssethToken).approve(address(avaxPort),50ether);//Set MockAnycall AnyFallback mode ONMockAnycall(local`AnyCall`Address).toggleFallback(1);//this is for branchBridgeAgent anyExecuteuint128remoteExecutionGas=4e9;//msg.value is total gas amount for both Root and Branch agentsavaxMulticallBridgeAgent.callOutSignedAndBridge{value:1e11}(packedData,depositInput,remoteExecutionGas);//Set MockAnycall AnyFallback mode OFFMockAnycall(local`AnyCall`Address).toggleFallback(0);//Perform anyFallback transaction back to root bridge agentMockAnycall(local`AnyCall`Address).testFallback();//check settlement statusuint32settlementNonce=multicallBridgeAgent.settlementNonce() -1;Settlementmemorysettlement=multicallBridgeAgent.getSettlementEntry(settlementNonce);console2.log("Status after fallback:",settlement.status==SettlementStatus.Failed?"Failed":"Success");require(settlement.status==SettlementStatus.Failed,"Settlement status should be failed.");console2.log("------------- retrying Settlement ----------------");//Get some gas.hevm.deal(_user,1ether);//Retry Settlementuint256depositedGas=7.9e9;uint128gasToBridgeOut=1.6e9;// This is expected to fail the gas paid by user is not wrapped and transferredavaxMulticallBridgeAgent.retrySettlement{value:depositedGas}(settlementNonce,gasToBridgeOut);settlement=multicallBridgeAgent.getSettlementEntry(settlementNonce);require(settlement.status==SettlementStatus.Success,"Settlement status should be success.");addressuserAccount=address(RootPort(rootPort).getUserAccount(_user));}
Recommended Mitigation Steps
AddwrappedNativeToken.deposit{value: msg.value}();to bothretrySettlement()andretrieveDeposit().Remove the increment fromdepositNonceinBranchBridgeAgent.sol#L426.Add fallback implementation for both flag0x07(retrySettlement) and flag0x08(retrieveDeposit).
0xBugsy (Maia) confirmed and commented:
Retrieve and Retry are not intended to be featured in a fallback. You should always be able to retry again and retrieve if you just want to clear your assets for redemption; although, the gas and increment will be addressed according to your suggestion.
0xLightt (Maia) commented:
Addressedhere.