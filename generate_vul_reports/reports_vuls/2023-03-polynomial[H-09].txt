[H-09] Excessive trading fees can result in 99.9% collateral loss for the trader
Submitted bybytes032
This issue can lead to traders losing all their collateral due to excessive fees when opening and closing larger trades.
Proof of Concept
When the exchange opens/closes trades, it defines the order fees to be paid by the user using theorderFeefunction. The function takes into account both the hedging fee, which covers the cost of managing the risk associated with holding the position, and the trading fee, which accounts for the costs incurred when executing the trade.
The function works as follows:
It first calculates thedelta, a factor representing the rate at which the position size changes.Then, it computes thefuturesSizeDeltaby multiplying the inputsizeDeltawith the calculateddelta.It calls theperpMarket.orderFeefunction to get thehedgingFeeand a boolean flag,isInvalid, which indicates if the trade is invalid.It checks if the trade is valid by ensuringisInvalidis not set totrue. If the trade is invalid, it will throw an exception.It retrieves themarkPricefrom theexchange.getMarkPricefunction, which represents the current market price of the asset.The function calculates thevalueExchangedby multiplying themarkPricewith the absolute value ofsizeDelta. This represents the total value of the trade.It computes thetradeFeeusing thegetSlippageFeefunction, which calculates the fee based on the size of the trade.ThetradingFeeis calculated by multiplying thetradeFeewithvalueExchanged.Finally, the function returns the sum of thehedgingFeeandtradingFeeas the total fee for the trade.
By combining both the hedging fee and trading fee, theorderFeefunction comprehensively calculates the costs associated for the trade.
The problem here lies in thegetSlippageFee(LiquidityPool.sol#L367-L374) function.  The purpose of thegetSlippageFeefunction is to calculate the slippage fee for a trade based on the change in position size, represented by the inputsizeDelta. The slippage fee is a cost associated with executing a trade that accounts for the potential price impact and liquidity changes due to the size of the order. It helps ensure that the trading platform can effectively manage the impact of large trades on the market.
functiongetSlippageFee(int256sizeDelta)publicviewreturns(uint256) {// ceil(s/100) * baseFeeuint256size=sizeDelta.abs();uint256region=size/standardSize;if(size%standardSize!=0)region+=1;returnregion*baseTradingFee;}
The function works as follows:
It first calculates the absolute value ofsizeDeltato ensure the size is a positive value, regardless of whether the trade is a buy or sell.It then divides thesizebystandardSize(set by default to (LiquidityPool.sol#L142) 1e20), to determine the number of regions the trade occupies. This constant value represents the size of a “standard” trade, which is used to categorize trades into different regions based on their size.If there is a remainder after dividingsizeby the constant value, it increments theregionby 1. This ensures that even partial regions are taken into account when calculating the fee.Finally, the function calculates the slippage fee by multiplying theregionwithbaseTradingFee(currently set (TestSystem.sol#L202) to 6e15 in the test suite). This constant value represents the base fee for each region.
By calculating the slippage fee based on the size of the trade, thegetSlippageFeefunction helps account for the potential impact of the trade on the market. The larger the trade, the more regions it occupies, resulting in a higher slippage fee. This approach incentivizes traders to be mindful of the size of their trades and the potential impact they may have on market liquidity and pricing.
The issue is that region can get really big (depending on the trade) so that the openTrade/closeTradesorderFeecould >= 100% meaning all the collateral of the user will be used to pay taxes.
While I completely understand the intent of higher taxes for bigger trades, I think there should be a limit where the trade won’t get opened if a certain threshold is passed.
I’ve built a PoC with Foundry using the protocol test suite with a few comments here and there to represent the following cases:
functiondepositToPool(addressuser,uint256sum)internal{susd.mint(user,sum);vm.startPrank(user);susd.approve(address(pool),sum);pool.deposit(sum,user);vm.stopPrank();}functionopenShort(uint256amount,uint256collateral,addressuser)internalreturns(uint256positionId, Exchange.TradeParamsmemorytradeParams){tradeParams.amount=amount;tradeParams.collateral=address(susd);tradeParams.collateralAmount=collateral;tradeParams.minCost=0;vm.startPrank(user);susd.approve(address(exchange),collateral);(positionId,) =exchange.openTrade(tradeParams);vm.stopPrank();}functiontestSimpleShortCloseTrade()public{depositToPool(user_2,1000e18*25000);uint256pricingConstant=exchange.PRICING_CONSTANT();uint256expectedPrice=initialPrice.mulDivDown(initialPrice,pricingConstant);uint256multiplier=165;uint256collateralAmount= (expectedPrice*2) *multiplier;// 200% Collateral ratiouint256shortAmount=multiplier*1e18;susd.mint(user_1,collateralAmount);console.log("CollateralAmount",collateralAmount/1e18);console.log("ShortAmount",shortAmount/1e18);console.log("User_1 sUSD balance",susd.balanceOf(user_1) /1e18);console.log("*** OPEN TAX ***");(uint256positionId,) =openShort(shortAmount,collateralAmount,user_1);console.log("*** OPEN TAX ***\n");console.log("*** CLOSE TAX ***");closeShort(positionId,shortAmount,type(uint256).max,collateralAmount,user_1);console.log("*** CLOSE TAX ***");console.log("User_1 sUSD balance",susd.balanceOf(user_1) /1e18);}
I’m going to use the formula(orderFee * 2) / collateralAmountto calculate the tax percentage. For each case, I’ll just modify themultipliervariable.
Case 1: (multiplier 165)CollateralAmount 237600ShortAmount 165The tax % is: 1,7996633
Running the tests, yields the following results.

Case 2: (multiplier 1650)CollateralAmount 2376000ShortAmount 1650The tax % is: 10,8
Running the tests yields the following results.

Case 3: (multiplier 16500)CollateralAmount 23760000ShortAmount 16500The tax % is: 99,6

Case 3 proves the point that a user can potentially lose all his collateral just by paying taxes when opening/closing a trade.
Tools Used
Manual review, Foundry
Recommended Mitigation Steps
This invariant is heavily influenced by the calculation inLiquidityPool.sol#L371. In case 1 the region is 1, in case 2 is 16 and in case 3 is 165.
To address this issue, a protocol-wide maximum amount of taxes to be paid in a trade (total of open + close) should be established. If the calculated fee exceeds this threshold, the transaction should be reverted instead of opening the trade for the user. This will help protect traders from losing all their collateral due to excessive trading fees.
mubaris (Polynomial) confirmed