[H-05] Lenders can escape the blacklisting of their accounts because they can move their MarketTokens to different accounts and gain theWithdrawOnlyRole on any account they want
Submitted by0xStalin, also found byelprofesor,Infect3d,serial-coder,xeros,radev_sw,jasonxiale,ast3ros,QiuhaoLi,Fulum, TrungOre (1,2), SandNallani (1,2),SovaSlava,kodyvim,0xbepresent,Eigenvectors,3docSec,marqymarq10,ayden,HChang26, cu5t0mpeo (1,2), 0xCiphky (1,2), rvierdiiev (1,2),nobody2018,YusSecurity,gizzy,nisedo,bdmcbri,ZdravkoHr,0xComfyCat, andmax10afternoon
Lenders can escape the sanctioning of their account in any market.
Proof of Concept
Before diving into the details of how the lenders can escape the sanctioning of their account, first, let’s analyze how a lender can be excised from a Market:
When someone callsnukeFromOrbitwithin that market while flagged as sanctioned by the Chainanalysis oracle.When the lender invokesexecuteWithdrawalwhile flagged as sanctioned by the Chainalysis oracle
In either of the two options, the execution flow calls theSentinel::isSanctioned()functionto verify if the account(lender) is sanctioned by the borrower of the market
By analyzing theSentinel::isSanctioned()function, it can be noted that the lender’s account must have been sanctioned in the Oracle first before the account is finally sanction in a Market.
WildcatSanctionsSentinel.sol
functionisSanctioned(addressborrower,addressaccount)publicviewoverridereturns(bool) {//@audit-info => sanctionOverrides[borrower][account] must be false <==> sanction must not be overridden for this function to return true!//@audit-info => If sanctionOverrides[borrower][account] is set to true, this function will return false, as if the account would not be sanctioned//@audit-info => For this function to return true, the account's sanction should have not been overridden (it's set to false), and the account must have been sanctioned in the ChainalysisSanctionsList Oracle.return!sanctionOverrides[borrower][account] &&IChainalysisSanctionsList(chainalysisSanctionsList).isSanctioned(account);}
Now, based on the previous explanation, we know that the lender’s account needs to be sanctioned in the Chainalysis Oracle before theSentinel::isSanctioned()functionis called.
This opens up the doors for lenders who realize that their account has been sanctioned in the Chainalysis Oracle to move their MarketTokens to different accounts before the lender’s account is fully blocked in the Market. You may be wondering what’s the point of transferring tokens to accounts that have not been granted any role in the Market, I’ll explain more about this shortly.
The lender transfers their MarketTokens to different accounts using theWildcatMarketToken::transfer()function. As a result, the lender’s account that is sanctioned in the Chainalysis Oracle has no MarketTokens anymore; all those tokens have been moved to other accounts.
Now, at this point, anybody could call thenukeFromOrbit()function to fully sanction the lender’s account in a specific Market. Ether way, the Lender has already moved their tokens to other accounts.
At this point, the lender’s MarketTokens were distributed among different accounts of their own. Such accounts have never interacted with the Market, so their current role is theNullRole.
Everything might look fine because the accounts where the tokens were sent have no permissions to interact with the Market, but there is a bug that allows lenders to gain theWithdrawOnlyRole on any account they want, without having the consent of the borrower.
This problem is located in theWildcatMarketController::updateLenderAuthorization()function. The reason of this problem will be explained in the below code walkthrough:
In short, the Lender will be able to set theWithdrawOnlyRole to any account they wish. The reason is that any account that is not registered in the_authorizedLendersvariable of the Controller will forward the value of_isAuthorizedas false. In theWildMarketConfig::updateAccountAuthorization()function, because the value of_isAuthorizedis false, it will end up granting theWithdrawOnlyRole. This effectively allows any Lender to grant theWithdrawOnlyRole to any account they want to.
WildcatMarketController.sol
//@audit-info => Anybody can call this function and pass a lender and an array of markets where the changes will be applied!functionupdateLenderAuthorization(addresslender,address[]memorymarkets)external{for(uint256i;i<markets.length;i++) {addressmarket=markets[i];if(!_controlledMarkets.contains(market)) {revertNotControlledMarket();}//@audit-info => Forwards the value of the `lender` argument, and depending on the `lender` address is found in the _authorizedLenders EnumerableSet.AddressSet, will be forwarded a true or false accordingly//@audit => If the lender address is not found in the _authorizedLenders variable, it will forward a false to the Market::updateAccountAuthorization() functionWildcatMarket(market).updateAccountAuthorization(lender,_authorizedLenders.contains(lender));}}
EnumerableSet.sol
functioncontains(AddressSetstorageset,addressvalue)internalviewreturns(bool) {//@audit-info => Calls the internal _contains()//@audit-info => If the given value is found it will return true, otherwise it will return false!return_contains(set._inner,bytes32(uint256(uint160(value))));}//@audit-info => The internal function will just return a true or false if the given value is in the set or not, but the tx won't be reverted!/***@devReturns true if the value is in the set. O(1).*/function_contains(Setstorageset,bytes32value)privateviewreturns(bool) {returnset._indexes[value] !=0;}
WildcatMarketConfig.sol
functionupdateAccountAuthorization(address_account,//@audit-info => For any account that is not registered in the `_authorizedLenders` of the Controller, this flag was set as false!bool_isAuthorized)externalonlyControllernonReentrant{MarketStatememorystate=_getUpdatedState();//@audit-info => If the accountAddress is not registered in the storage, the approval role is set to Null//@audit-info => If the account has been blacklisted, tx will revert!Accountmemoryaccount=_getAccount(_account);if(_isAuthorized) {account.approval=AuthRole.DepositAndWithdraw;//@audit => Any account not registered in the Controller will be assigned the WithdrawOnly role.}else{account.approval=AuthRole.WithdrawOnly;}_accounts[_account] =account;_writeState(state);emitAuthorizationStatusUpdated(_account,account.approval);}
At this point, the Lender has been able to move their MarketTokens to different accounts and to grant theWithdrawOnlyRole to all of the accounts they wish to.
Now, they can decide to exit the Market by queuing and executing some withdrawal requests from the different accounts where the MarketTokens were moved. Any of those accounts have now theWithdrawOnlyRole and have a balance of MarketTokens, so the Lender will be able to exit the market from any of those accounts.
Recommended Mitigation Steps
The mitigation for this problem is very straight-forward, by limiting the access to which entities can call theWildcatMarketController::updateLenderAuthorization()function; either only allow the Borrower to call it, or create a type of whitelist of valid actors who are capable of updating the lender’s authorization on the Markets. In this way, the Lenders won’t be capable of granting theWithdrawOnlyRole to any account they want to; thus, they won’t be able even to attempt to escape the sanctions.
WildcatMarketController.sol
-functionupdateLenderAuthorization(addresslender,address[]memorymarkets)external{+functionupdateLenderAuthorization(addresslender,address[]memorymarkets)externalonlyAuthorizedEntities(){for(uint256i;i<markets.length;i++) {addressmarket=markets[i];if(!_controlledMarkets.contains(market)) {revertNotControlledMarket();}WildcatMarket(market).updateAccountAuthorization(lender,_authorizedLenders.contains(lender));}}modifieronlyAuthorizedEntities() {require(msg.sender==<authorizedEntities>, "you are not allowed sir");_;}
Assessed type
Context
0xTheC0der (judge) increased severity to High
laurenceday (Wildcat) commented:
Mitigatedhere.
laurenceday (Wildcat) confirmed