[H-06] Closing a SR during a wrong redemption proposal leads to loss of funds
Submitted byCosine, also found byklau5
https://github.com/code-423n4/2024-03-dittoeth/blob/91faf46078bb6fe8ce9f55bcb717e5d2d302d22e/contracts/facets/RedemptionFacet.sol#L267-L268
https://github.com/code-423n4/2024-03-dittoeth/blob/91faf46078bb6fe8ce9f55bcb717e5d2d302d22e/contracts/libraries/AppStorage.sol#L92
Impact
When a user creates a redemption proposal with theproposeRedemptionfunction the user has to provide a list of the short records (SRs) with the lowest collateral ratios (CR) in the system ascending.
To prevent users from creating proposals with a wrong SR list, anyone is allowed to dispute proposals with thedisputeRedemptionfunction. This function allows the disputer to prove that a SR with a lower CR was not included in the proposal and for doing so the disputer receives a penalty fee from the proposer.
If between these flows of creating a wrong proposal and disputing it a SR is closed (liquidation, exiting, transfer, …) the collateral is added to the closed SR and can not be recovered.
Proof of Concept
The following POC can be implemented in theRedemption.t.soltest file:
functiontest_dispute_on_non_existing_sr()public{// setup shortsmakeShorts({singleShorter:true});_setETH(1000ether);skip(1hours);STypes.ShortRecordmemorysr1=diamond.getShortRecord(asset,sender,C.SHORT_STARTING_ID);STypes.ShortRecordmemorysr2=diamond.getShortRecord(asset,sender,C.SHORT_STARTING_ID+1);STypes.ShortRecordmemorysr3=diamond.getShortRecord(asset,sender,C.SHORT_STARTING_ID+2);uint256cr1=diamond.getCollateralRatio(asset,sr1);uint256cr2=diamond.getCollateralRatio(asset,sr2);uint256cr3=diamond.getCollateralRatio(asset,sr3);// CRs are increasingassertGt(cr2,cr1);assertGt(cr3,cr2);// user creates a wrong proposalMTypes.ProposalInput[]memoryproposalInputs=makeProposalInputsForDispute({shortId1:C.SHORT_STARTING_ID+1,shortId2:C.SHORT_STARTING_ID+2});addressredeemer=receiver;vm.prank(redeemer);diamond.proposeRedemption(asset,proposalInputs,DEFAULT_AMOUNT*3/2,MAX_REDEMPTION_FEE);// on of the SRs in the proposal is closedfundLimitAskOpt(DEFAULT_PRICE,DEFAULT_AMOUNT/2,extra);exitShort(C.SHORT_STARTING_ID+2,DEFAULT_AMOUNT/2,DEFAULT_PRICE,sender);// SR is now closedsr3=diamond.getShortRecord(asset,sender,C.SHORT_STARTING_ID+2);assertEq(uint(sr3.status),uint(SR.Closed));uint88collateralBefore=sr3.collateral;// another user disputes the wrong proposaladdressdisputer=extra;vm.prank(disputer);diamond.disputeRedemption({asset:asset,redeemer:redeemer,incorrectIndex:0,disputeShorter:sender,disputeShortId:C.SHORT_STARTING_ID});// SR is still closed and collateral increasedsr3=diamond.getShortRecord(asset,sender,C.SHORT_STARTING_ID+2);assertEq(uint(sr3.status),uint(SR.Closed));assertGt(sr3.collateral,collateralBefore);}
Recommended Mitigation Steps
Opening up the SR again if it’s closed would be a solution, but it could probably be misused to avoid liquidations. Therefore, carefully think about the implications of changes in this context.
Assessed type
Context
ditto-eth (DittoETH) confirmed