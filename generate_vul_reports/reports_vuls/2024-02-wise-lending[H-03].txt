[H-03] Incorrect bad debt accounting can lead to a state where theclaimFeesBeneficialfunction is permanently bricked and no new incentives can be distributed, potentially locking pending and future protocol fees in theFeeManagercontract
Submitted byJCN, also found byserial-coder,0xStalin, andDraiakoo
Protocol fees can be collected from theWiseLendingcontract and sent to theFeeManagercontract via the permissionlessFeeManager::claimWiseFeesfunction. During this call, incentives will only be distributed forincentive ownersiftotalBadDebtETH(global bad debt) is equal to0:
FeeManager::claimWiseFees
663:if(totalBadDebtETH==0) {// @audit: incentives only distributed if there is no global bad debt664:665:tokenAmount=_distributeIncentives(// @audit: distributes incentives for `incentive owners` via `gatheredIncentiveToken` mapping666:tokenAmount,667:_poolToken,668:underlyingTokenAddress669:            );670:        }
The fees sent to theFeeManagerare then able to be claimed bybeneficialsvia theFeeManager::claimFeesBeneficialfunction or byincentive ownersvia theFeeManager::claimIncentivesfunction (if incentives have been distributed to the owners):
FeeManager::claimIncentives
284:functionclaimIncentives(285:address_feeToken286:    )287:public288:    {289:uint256amount=gatheredIncentiveToken[msg.sender][_feeToken];// @audit: mapping incremented in _distributeIncentives function290:291:if(amount==0) {292:revertNoIncentive();293:        }
However,beneficialsare only able to claim fees if there is currently no global bad debt in the system (totalBadDebtETH == 0).
FeeManager::claimFeesBeneficial
689:functionclaimFeesBeneficial(690:address_feeToken,691:uint256_amount692:    )693:external694:    {695:addresscaller=msg.sender;696:697:if(totalBadDebtETH>0) {// @audit: can't claim fees when there is bad debt698:revertExistingBadDebt();699:        }
Below I will explain how the bad debt accounting logic used during partial liquidations can result in a state wheretotalBadDebtETHis permanently greater than0. When this occurs,beneficialswill no longer be able to claim fees via theFeeManager::claimFeesBeneficialfunction and new incentives will no longer be distributed when fees are permissionlessly collected via theFeeManager::claimWiseFeesfunction.
When a position is partially liquidated, theWiseSecurity::checkBadDebtLiquidationfunction is executed to check if the position has created bad debt, i.e. if the position’s overall borrow value is greater than the overall (unweighted) collateral value. If the post liquidation state of the position created bad debt, then the bad debt is recorded in a global and position-specific state:
WiseSecurity::checkBadDebtLiquidation
405:functioncheckBadDebtLiquidation(406:uint256_nftId407:    )408:external409:onlyWiseLending410:    {411:uint256bareCollateral=overallETHCollateralsBare(412:_nftId413:        );414:415:uint256totalBorrow=overallETHBorrowBare(416:_nftId417:        );418:419:if(totalBorrow<bareCollateral) {// @audit: LTV < 100%420:return;421:        }422:423:unchecked{424:uint256diff=totalBorrow425:                -bareCollateral;426:427:FEE_MANAGER.increaseTotalBadDebtLiquidation(// @audit: global state, totalBadDebtETH += diff428:diff429:            );430:431:FEE_MANAGER.setBadDebtUserLiquidation(// @audit: position state, badDebtPosition[_nftId] = diff432:_nftId,433:diff434:            );435:        }436:    }
FeeManagerHeper.sol
77:function_setBadDebtPosition(78:uint256_nftId,79:uint256_amount80:    )81:internal82:    {83:badDebtPosition[_nftId] =_amount;// @audit: position bad debt set84:    }85:86:/**87:     *@devInternal increase function for global bad debt amount.88:     */89:function_increaseTotalBadDebt(90:uint256_amount91:    )92:internal93:    {94:totalBadDebtETH+=_amount;// @audit: total bad debt incremented
As we can see above, the method by which the global and position’s state is updated is not consistent (total debt increases, but position’s debt is set to recent debt). Since liquidations can be partial, a position with bad debt can undergo multiple partial liquidations and each time thetotalBadDebtETHwill be incremented. However, thebadDebtPositionfor the position will only be updated with the most recent bad debt that was recorded during the last partial liquidation. Note that due to the condition on line 419 ofWiseSecurity::checkBadDebtLiquidation, thebadDebtPositionwill be reset to0whentotalBorrow == bareCollateral(LTV == 100%). However, in this case, any previously recorded bad debt for the position willnotbe deducted from thetotalBadDebtETH. Lets consider two examples:
Scenario 1: Due to a market crash, a position’s LTV goes above 100%. The position gets partially liquidated, incrementingtotalBadDebtETHbyx(bad debt from 1st liquidation) and settingbadDebtPosition[_nftId]tox. The position gets partially liquidated again, this time incrementingtotalBadDebtETHbyy(bad debt from 2nd liquidation) and settingbadDebtPosition[_nftId]toy. The resulting state:
totalBadDebtETH == x + ybadDebtPosition[_nftId] == y
Scenario 2: Due to a market crash, a position’s LTV goes above 100%. The position gets partially liquidated, incrementingtotalBadDebtETHbyxand settingbadDebtPosition[_nftId]tox. The position gets partially liquidated again, but this time thetotalBorrowis equal tobareCollateral(LTV == 100%) and thus no bad debt is created. Due to the condition on line 419,totalBadDebtETHwill be incremented by0, butbadDebtPosition[_nftId]will be reset to0. The resulting state:
totalBadDebtETH == xbadDebtPosition[_nftId] == 0
Note: Scenario 1 is more likely to occur since Scenario 2 requires the additional partial liquidation to result in an LTV of exactly 100% for the position.
As we can see, partial liquidations can lead tototalBadDebtETHbeing artificially inflated with respect to the actual bad debt created by a position.
When bad debt is created, it is able to be paid back via theFeeManager::paybackBadDebtForTokenorFeeManager::paybackBadDebtNoRewardfunctions. However, the maximum amount of bad debt that can be deducted during these calls is capped at the bad debt recorded for the position specified (badDebtPosition[_nftId]). Therefore, the excess “fake” bad debt can not be deducted fromtotalBadDebtETH, resulting intotalBadDebtETHbeing permanently greater than0.
Below is the logic that deducts the bad debt created by a position when it is paid off via one of the payback functions mentioned above:
FeeManagerHelper::_updateUserBadDebt
170:unchecked{171:uint256newBadDebt=currentBorrowETH172:                -currentCollateralBareETH;173:174:_setBadDebtPosition(// @audit: badDebtPosition[_nftId] = newBadDebt175:_nftId,176:newBadDebt177:            );178:179:newBadDebt>currentBadDebt// @audit: totalBadDebtETH updated with respect to change in badDebtPosition180:                ?_increaseTotalBadDebt(newBadDebt-currentBadDebt)181:                :_decreaseTotalBadDebt(currentBadDebt-newBadDebt);
The above code is invoked in theFeeManagerHelper::updatePositionCurrentBadDebtfunction, which is in turn invoked during both of the payback functions previously mentioned. You will notice that the above code properly takes into account the change in the bad debt of the position in question. I.e. if thebadDebtPosition[_nftId]decreased (after being paid back), then thetotalBadDebtETHwill decrease as well. Therefore, thetotalBadDebtETHcan only be deducted by at most the current bad debt of a position. Returning to the previous example in Scenario 1, this means thattotalBadDebtETHwould remain equal tox, since onlyyamount of bad debt can be paid back.
Impact
In the event a position creates bad debt, partial liquidations of that position can lead to the globaltotalBadDebtETHstate variable being artificially inflated. This additional “fake debt” can not be deducted from the global state when the actual bad debt of the position is paid back. Thus, theFeeManager::claimFeesBeneficialfunction will be permanently DOS-ed, preventing anybeneficialsfrom claiming fees in theFeeManagercontract. Additionally, no new incentives are able to be distributed toincentive ownersin this state. However, protocol fees can still be collected in this state via the permissionlessFeeManager::claimWiseFeesfunction, and sinceincentive ownersandbeneficialsare the only entities able to claim these fees, this can lead to fees being permanently locked in theFeeManagercontract.
Justification for Medium Severity
Although not directly affecting end users, the function of claiming beneficial fees and distributing new incentives will be permanently bricked. To make matters worse, anyone can continue to collect fees via the permissionlessFeeManager::claimWiseFeesfunction, which will essentially “burn” any pending or future fees by locking them in theFeeManager(assuming all previously gathered incentives have been claimed). This value is, therefore, leaked from the protocol every time additional fees are collected in this state.
Once this state is reached, any pending or future fees should ideally be left in theWiseLendingcontract, providing value back to the users instead of allowing that value to be unnecessarily “burned”. However, the permissionless nature of theFeeManager::claimWiseFeesfunction allows bad actors to further grief the protocol during this state by continuing to collect fees.
Note: Once this state is reached, andWiseLendingis made aware of the implications, all fees (for all pools) can be set to0by themasteraddress. This would ensure that no future fees are sent to theFeeManager. However, this does not stop pending fees from being collected. Additionally, a true decentralized system (such as a DAO) would likely have some latency between proposing such a change (decreasing fee value) and executing that change. Therefore, any fees distributed during that period can be collected.
Proof of Concept
Place the following test in thecontracts/directory and run withforge test --match-path contracts/BadDebtTest.t.sol:
// SPDX-License-Identifier: -- WISE --pragmasolidity=0.8.24;import"./WiseLendingBaseDeployment.t.sol";contractBadDebtTestisBaseDeploymentTest{addressborrower=address(0x01010101);addresslender=address(0x02020202);uint256depositAmountETH=10e18;// 10 etheruint256depositAmountToken=10;// 10 etheruint256borrowAmount=5e18;// 5 etheruint256nftIdLiquidator;// nftId of lenderuint256nftIdLiquidatee;// nftId of borroweruint256debtShares;function_setupIndividualTest()internaloverride{_deployNewWiseLending(false);// set token value for simple calculationsMOCK_CHAINLINK_2.setValue(1ether);// 1 token == 1 ETHassertEq(MOCK_CHAINLINK_2.latestAnswer(),MOCK_CHAINLINK_ETH_ETH.latestAnswer());vm.stopPrank();// fund lender and borrowervm.deal(lender,depositAmountETH);deal(address(MOCK_WETH),lender,depositAmountETH);deal(address(MOCK_ERC20_2),borrower,depositAmountToken*2);}functiontestScenario1()public{// --- scenario is set up --- //_setUpScenario();// --- shortfall event/crash creates bad debt, position partially liquidated logging bad debt --- //_marketCrashCreatesBadDebt();// --- borrower gets partially liquidated again --- //vm.prank(lender);LENDING_INSTANCE.liquidatePartiallyFromTokens(nftIdLiquidatee,nftIdLiquidator,address(MOCK_WETH),address(MOCK_ERC20_2),debtShares*2e16/1e18);// --- global bad det increases again, but user bad debt is set to current bad debt created --- //uint256newTotalBadDebt=FEE_MANAGER_INSTANCE.totalBadDebtETH();uint256newUserBadDebt=FEE_MANAGER_INSTANCE.badDebtPosition(nftIdLiquidatee);assertGt(newUserBadDebt,0);// userBadDebt reset to new bad debt, newUserBadDebt == current_bad_debt_createdassertGt(newTotalBadDebt,newUserBadDebt);// global bad debt incremented again// newTotalBadDebt = old_global_bad_debt + current_bad_debt_created// --- user bad debt is paid off, but global bad is only partially paid off (remainder is fake debt) --- //_tryToPayBackGlobalDebt();// --- protocol fees can no longer be claimed since totalBadDebtETH will remain > 0 --- //vm.expectRevert(bytes4(keccak256("ExistingBadDebt()")));FEE_MANAGER_INSTANCE.claimFeesBeneficial(address(0),0);}functiontestScenario2()public{// --- scenario is set up --- //_setUpScenario();// --- shortfall event/crash creates bad debt, position partially liquidated logging bad debt --- //_marketCrashCreatesBadDebt();// --- Position manipulated so second partial liquidation results in totalBorrow == bareCollateral --- //// borrower adds collateralvm.prank(borrower);LENDING_INSTANCE.solelyDeposit(nftIdLiquidatee,address(MOCK_ERC20_2),6);// borrower gets partially liquidated againvm.prank(lender);LENDING_INSTANCE.liquidatePartiallyFromTokens(nftIdLiquidatee,nftIdLiquidator,address(MOCK_WETH),address(MOCK_ERC20_2),debtShares*2e16/1e18);uint256collateral=SECURITY_INSTANCE.overallETHCollateralsBare(nftIdLiquidatee);uint256debt=SECURITY_INSTANCE.overallETHBorrowBare(nftIdLiquidatee);assertEq(collateral,debt);// LTV == 100% exactly// --- global bad debt is unchanged, while user bad debt is reset to 0 --- //uint256newTotalBadDebt=FEE_MANAGER_INSTANCE.totalBadDebtETH();uint256newUserBadDebt=FEE_MANAGER_INSTANCE.badDebtPosition(nftIdLiquidatee);assertEq(newUserBadDebt,0);// user bad debt reset to 0assertGt(newTotalBadDebt,0);// global bad debt stays the same (fake debt)// --- attempts to pay back fake global debt result in a noop, totalBadDebtETH still > 0 --- //uint256paybackShares=_tryToPayBackGlobalDebt();assertEq(LENDING_INSTANCE.userBorrowShares(nftIdLiquidatee,address(MOCK_WETH)),paybackShares);// no shares were paid back// --- protocol fees can no longer be claimed since totalBadDebtETH will remain > 0 --- //vm.expectRevert(bytes4(keccak256("ExistingBadDebt()")));FEE_MANAGER_INSTANCE.claimFeesBeneficial(address(0),0);}function_setUpScenario()internal{// lender supplies ETHvm.startPrank(lender);nftIdLiquidator=POSITION_NFTS_INSTANCE.mintPosition();LENDING_INSTANCE.depositExactAmountETH{value:depositAmountETH}(nftIdLiquidator);vm.stopPrank();// borrower supplies collateral token and borrows ETHvm.startPrank(borrower);MOCK_ERC20_2.approve(address(LENDING_INSTANCE),depositAmountToken*2);nftIdLiquidatee=POSITION_NFTS_INSTANCE.mintPosition();LENDING_INSTANCE.solelyDeposit(// supply collateralnftIdLiquidatee,address(MOCK_ERC20_2),depositAmountToken);debtShares=LENDING_INSTANCE.borrowExactAmountETH(nftIdLiquidatee,borrowAmount);// borrow ETHvm.stopPrank();}function_marketCrashCreatesBadDebt()internal{// shortfall event/crash occursvm.prank(MOCK_DEPLOYER);MOCK_CHAINLINK_2.setValue(0.3ether);// borrower gets partially liquidatedvm.startPrank(lender);MOCK_WETH.approve(address(LENDING_INSTANCE),depositAmountETH);LENDING_INSTANCE.liquidatePartiallyFromTokens(nftIdLiquidatee,nftIdLiquidator,address(MOCK_WETH),address(MOCK_ERC20_2),debtShares*2e16/1e18+1);vm.stopPrank();// global and user bad debt is increaseduint256totalBadDebt=FEE_MANAGER_INSTANCE.totalBadDebtETH();uint256userBadDebt=FEE_MANAGER_INSTANCE.badDebtPosition(nftIdLiquidatee);assertGt(totalBadDebt,0);assertGt(userBadDebt,0);assertEq(totalBadDebt,userBadDebt);// user bad debt and global bad debt are the same}function_tryToPayBackGlobalDebt()internalreturns(uint256paybackShares) {// lender attempts to pay back global debtpaybackShares=LENDING_INSTANCE.userBorrowShares(nftIdLiquidatee,address(MOCK_WETH));uint256paybackAmount=LENDING_INSTANCE.paybackAmount(address(MOCK_WETH),paybackShares);vm.startPrank(lender);MOCK_WETH.approve(address(FEE_MANAGER_INSTANCE),paybackAmount);FEE_MANAGER_INSTANCE.paybackBadDebtNoReward(nftIdLiquidatee,address(MOCK_WETH),paybackShares);vm.stopPrank();// global bad debt and user bad debt updateduint256finalTotalBadDebt=FEE_MANAGER_INSTANCE.totalBadDebtETH();uint256finalUserBadDebt=FEE_MANAGER_INSTANCE.badDebtPosition(nftIdLiquidatee);assertEq(finalUserBadDebt,0);// user has no more bad debt, all paid offassertGt(finalTotalBadDebt,0);// protocol still thinks there is bad debt}}
Recommended Mitigation Steps
I would recommend updatingtotalBadDebtETHwith thedifferenceof the previous and new bad debt of a position in theWiseSecurity::checkBadDebtLiquidationfunction, similar to how it is done in theFeeManagerHelper::_updateUserBadDebtinternal function.
Example implementation:
diff --git a/./WiseSecurity/WiseSecurity.sol b/./WiseSecurity/WiseSecurity.solindex d2cfb24..75a34e8 100644--- a/./WiseSecurity/WiseSecurity.sol+++ b/./WiseSecurity/WiseSecurity.sol@@ -424,14 +424,22 @@ contract WiseSecurity is WiseSecurityHelper, ApprovalHelper {uint256 diff = totalBorrow- bareCollateral;-            FEE_MANAGER.increaseTotalBadDebtLiquidation(-                diff-            );+            uint256 currentBadDebt = FEE_MANAGER.badDebtPosition(_nftId);FEE_MANAGER.setBadDebtUserLiquidation(_nftId,diff);++            if (diff > currentBadDebt) {+                FEE_MANAGER.increaseTotalBadDebtLiquidation(+                    diff - currentBadDebt+                );+            } else {+                FEE_MANAGER.decreaseTotalBadDebtLiquidation(+                    currentBadDebt - diff+                );+            }}}
Trust (judge) increased severity to High
vonMangoldt (Wise Lending) commented via duplicate issue #243:
This doesn’t lead to loss of user funds though. Hence, it should be downgraded since one could just migrate and redeploy after discovering that. Otherwise good find.
Foon256 (Wise Lending) commented via duplicate issue #243:
Would agree with that! This is a good insight, but users’ funds are never at risk. This is related to thefeeManagerand the fees taken from the protocol. Therefore, a Medium issue.
Alex the Entreprenerd (Appellate Court judge) commented:
Summary of the issueWhen a market accrues bad debt, which can be inflated due to an accounting error, fees and incentives will no longer be distributed.Note: The discussion had quite a bit of back and forth, for this reason the whole conversation is pasted below:DiscussionAlex the Entreprenerd (Appellate Court lead judge) commented:This seems to be tied to a specific interpretation of this discussion we’ve had around loss of yield as high.hickuphh3 (judge 2) commented:Fees would be considered as matured yield? Given that it extends beyond the protocol to beneficials and incentive owners, I’m leaning towards a high more than a medium.Alex the Entreprenerd (Appellate Court lead judge) commented:Yes it would be considered matured. I don’t have an opinion on this report yet and will follow up later today with my notes.Not fully made up my mind but here’s a couple of points:For Medium: Loss of Yield -> There is no loss of principal so Med seems fine.For High: The contract is not losing yield in some case, the contract is losing 100% of all yield. The contract is no longer serving it’s purpose.External Conditions: Bad debt must be formed. Bad debt handling is part of the system design, so assuming this can happen is fair, and starting from a scenario in which this can happen is also fair.That said, in reality, this may never happen.My main point for downgrading is that while the contract is losing all of the yield, nothing beside that is impacted, not fully sure on this one.LSDan (judge 3) commented:I’m aligned with high on this one. Even though the conditions that lead to it are rare and there are arguably external conditions in some scenarios, there is a direct loss of funds and the functional loss of a contract’s purpose. Once this situation occurs, there is no clean way back from it.Alex the Entreprenerd (Appellate Court lead judge) commented:I think this is the issue where we will have some contention. I think the Sponsor interpretation is important to keep in mind as it’s pretty rational. I would like to think about it a bit more.Alex the Entreprenerd (Appellate Court lead judge) commented:I’m leaning towards Med on this report, I think the Sponsors POV is valid.There is an accounting error, it would not cause permanent loss of funds. It would be mitigated by deprecating the market and creating a new one.My main argument is that if this was live, this would trigger a re-deploy but it would not trigger any white hat rescue operation, as funds would be safe.hickuphh3 (judge 2) commented:#74: When we stick to the c4a rules to which we agreed, all the loss of fees are no user funds and therefore, should be treated differently.The core argument for Medium severity is that fees are a secondary concern.This goes against the supreme court decision where fees shouldn’t be treated as 2nd class citizenshere.Loss of fees should be regarded as an impact similar to any other loss of capital. Loss of real amounts depends on specific conditions and likelihood considerations.Likelihood: Requirement of bad debt formation. Once there is, funds (fees) are permanently bricked.There is an accounting error, it would not cause permanent loss of funds; it would be mitigated by deprecating the market and creating a new one.The funds you are referring to are user funds? Separately, I don’t see how it would mitigate the bricking once it happens.Alex the Entreprenerd (Appellate Court lead judge) commented:I don’t think that the ruling means that loss of fees should be treated as high at all times.The main argument is that the broken accounting doesn’t create a state that is not recoverable:Some fees are lost.User deprecates market (raises interests or pauses).Deployes new Market.System resumes functioning as intended.My main argument is that this would not cause a War Room, it would cause a deprecation that the system can handle.hickuphh3 (judge 2) commented:In what cases/scenarios would loss of fees be high then? Most, if not all, won’t have a war room for protocol fees.The reason I would consider to justify downgrading is the low likelihood of the external requirement of bad debt formation+>=2 partial liquidations.I would dissent and argue for high severity.Permanent loss of unclaimed fees.Blast radius: affects not just the protocol, but incentive owners and beneficiaries.Had the fees gone only to the protocol, I’d lean a bit more towards Medium.IsWiseLendingimmutable in apoolTokeninstance?What contracts would have to be re-deployed?Alex the Entreprenerd (Appellate Court lead judge) commented:Liquidation premium being denied could be a valid High loss of yield, loss of gas for refunds when the system entire goal is that (e.g. keepers, voting on Nouns).Alex the Entreprenerd’s (Appellate Court lead judge) InputThe finding shows how in the specific case of liquidations with bad debt, a market will stop accounting for fees.2 aggravating circumstances seem to be:Inability to pause and replace each market.The Math for bad debt is also wrong, leading to the inability to fix the bug.This would still cause a loss of fees for a certain period of time, as the admin would eventually be able to set the market fees to either a state that would cause users to stop using it or0as a means to stop the loss.I think that the accounting mistake is notable, and I understand the reasoning for raising severity.That said, because we have to judge by impact of the finding, I believe Medium Severity to be most appropriate.hickuphh3’s (judge 2) InputI maintain my stance for High severity for the reasons I stated above:Permanent loss of unclaimed fees.Impact on protocol ecosystem: beneficiaries and incentive owners.LSDan’s (judge 3) InputI’m still of the opinion that High is most appropriate here. The impact is significant enough that raising the severity beyond medium makes sense.DeliberationThe severity is kept at High Severity, with a non-unanimous verdict.Additional Context by the Lead JudgeI recommend monitoring how this decision influences future decisions on severities, especially when it comes to a percentage loss of yield, an attacker having the button to cause a loss of yield, against this instance which is the permanent inability for the contract to record a gain of yield.
Wise Lending commented:
Mitigatedhere.