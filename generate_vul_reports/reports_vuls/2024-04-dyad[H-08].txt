[H-08] Users can get their Kerosene stuck until TVL becomes greater than Dyad’s supply
Submitted by0xAlix2, also found byNentoR, Abdessamed (1,2),DarkTower,0xlucky,CodeWasp, sashik_eth (1,2,3),Egis_Security,Maroutis,TheFabled, 0xabhay (1,2), itsabinashb (1,2),Infect3d,windhustler,btk,Limbooo,KupiaSec, SpicyMeatball (1,2),imare,Circolors,gumgumzum,web3km,n4nika,0xtankr,cu5t0mpeo,Ryonen,ke1caM,oakcobalt,TheSchnilch,XDZIBECX,steadyman,VAD37,shaflow2,lian886,iamandreiski,dimulski, 0x486776 (1,2),Giorgio,T1MOH,kennedy1030,TheSavageTeddy,carrotsmuggler, zhaojohnson (1,2), andKrace
The protocol expects users to migrate their collateral from V1 vaults to V2 vaults, this significantly increases the TVL of the protocol’s V2. At the same time, the Kerosene price depends on the TVL, inUnboundedKerosineVault::assetPricethe numerator of the equation is:
uint256 numerator = tvl - dyad.totalSupply();
This will always revert until the TVL becomes>Dyad’s supply, which is around 600k. So when users deposit Kerosene in either Kerosene vaults their Kerosene will temporarily get stuck in there.
Proof of Concept
This assumes that a reported bug is fixed, which is using the correct licenser. To overcome this, we had to manually change the licenser inaddKeroseneandgetKeroseneValue.
Because of another reported issue, a small change should be made to the code to workaround it, inVaultManagerV2::withdraw, replace_vault.oracle().decimals()with8. This just sets the oracle decimals to a static value of 8.
Test POC:
Make sure to fork the main net and set the block number to19703450:
contract VaultManagerTest is VaultManagerTestHelper {Kerosine keroseneV2;Licenser vaultLicenserV2;VaultManagerV2 vaultManagerV2;Vault ethVaultV2;VaultWstEth wstEthV2;KerosineManager kerosineManagerV2;UnboundedKerosineVault unboundedKerosineVaultV2;BoundedKerosineVault boundedKerosineVaultV2;KerosineDenominator kerosineDenominatorV2;OracleMock wethOracleV2;address bob = makeAddr("bob");address alice = makeAddr("alice");ERC20 wrappedETH = ERC20(MAINNET_WETH);ERC20 wrappedSTETH = ERC20(MAINNET_WSTETH);DNft dNFT = DNft(MAINNET_DNFT);function setUpV2() public {(Contracts memory contracts, OracleMock newWethOracle) = new DeployV2().runTestDeploy();keroseneV2 = contracts.kerosene;vaultLicenserV2 = contracts.vaultLicenser;vaultManagerV2 = contracts.vaultManager;ethVaultV2 = contracts.ethVault;wstEthV2 = contracts.wstEth;kerosineManagerV2 = contracts.kerosineManager;unboundedKerosineVaultV2 = contracts.unboundedKerosineVault;boundedKerosineVaultV2 = contracts.boundedKerosineVault;kerosineDenominatorV2 = contracts.kerosineDenominator;wethOracleV2 = newWethOracle;vm.startPrank(MAINNET_OWNER);Licenser(MAINNET_VAULT_MANAGER_LICENSER).add(address(vaultManagerV2));boundedKerosineVaultV2.setUnboundedKerosineVault(unboundedKerosineVaultV2);vm.stopPrank();}function test_InvalidCalculationAssetPrice() public {setUpV2();deal(MAINNET_WETH, bob, 100e18);vm.prank(MAINNET_OWNER);keroseneV2.transfer(bob, 100e18);uint256 bobNFT = dNFT.mintNft{value: 1 ether}(bob);vm.startPrank(bob);wrappedETH.approve(address(vaultManagerV2), type(uint256).max);keroseneV2.approve(address(vaultManagerV2), type(uint256).max);vaultManagerV2.add(bobNFT, address(ethVaultV2));vaultManagerV2.addKerosene(bobNFT, address(unboundedKerosineVaultV2));vaultManagerV2.deposit(bobNFT, address(ethVaultV2), 1e18);vaultManagerV2.deposit(bobNFT, address(unboundedKerosineVaultV2), 1e18);vm.roll(1);vm.expectRevert(); // UnderflowvaultManagerV2.withdraw(bobNFT, address(unboundedKerosineVaultV2), 1e18, bob);}}
Recommended Mitigation Steps
This is a bit tricky, but I think the most straightforward and logical solution would be to block the usage of the Kerosene vaults (just keep them unlicensed) until enough users migrate their positions from V1, i.e. the TVL reaches the Dyad’s total supply.
Assessed type
Under/Overflow
shafu0x (DYAD) confirmed and commented:
Yes, it should only check for dyad minted from v1.