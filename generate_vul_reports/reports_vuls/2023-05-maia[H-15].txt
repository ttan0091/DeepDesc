[H-15] The difference betweengasLeftandgasAfterTransferis greater thanTRANSFER_OVERHEAD, causinganyExecuteto always fail
Submitted byKoolex
In_payExecutionGas,  there is the following code:
///Save gas leftuint256gasLeft=gasleft();....//Transfer gas remaining to recipientSafeTransferLib.safeTransferETH(_recipient,gasRemaining-minExecCost);//Save Gasuint256gasAfterTransfer=gasleft();//Check if sufficient balanceif(gasLeft-gasAfterTransfer>TRANSFER_OVERHEAD) {_forceRevert();return;}
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L1029-L1054
It checks if the difference betweengasLeftandgasAfterTransferis greater thanTRANSFER_OVERHEAD. Then, it calls_forceRevert()so thatAnycall Executorreverts the call. This check has been introduced to prevent any arbitrary code executed in the_recipient's fallback(this was confirmed by the sponsor). However, the conditiongasLeft - gasAfterTransfer > TRANSFER_OVERHEADis always true.TRANSFER_OVERHEADis24_000.
uint256internalconstantTRANSFER_OVERHEAD=24_000;
https://github.com/code-423n4/2023-05-maia/blob/main/src/ulysses-omnichain/BranchBridgeAgent.sol#L139
And thegas spent betweengasLeftandgasAfterTransferis nearly70_000which is higher than24_000. Thus, causing the function to always revert. Function_payExecutionGasis called byanyExecutewhich is called by theAnycall Executor. This meansanyExecutewill also fail. This happens because thegasLeftvalue is stored before replenishing gas and not before the transfer.
Proof of Concept
This PoC is independent from the codebase (but uses the same code). There is one contract simulatingBranchBridgeAgent.anyExecute.
When we run the test,anyExecutewill revert becausegasLeft - gasAfterTransferis always greater thanTRANSFER_OVERHEAD(24_000).
Here is the output of the test:
[PASS]test_anyexecute_always_revert_bc_transfer_overhead() (gas: 124174)Logs:(gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD) =>truegasLeft - gasAfterTransfer = 999999999999979606 - 999999999999909238 = 70368Test result: ok. 1 passed; 0 failed; finishedin1.88ms
Explanation
TheBranchBridgeAgent.anyExecutemethod depends on the following external calls:
AnycallExecutor.context()AnycallProxy.config()AnycallConfig.executionBudget()AnycallConfig.withdraw()AnycallConfig.deposit()WETH9.withdraw()
For this reason, I’ve copied the same code frommultichain-smart-contracts. ForWETH9, I’ve used the contract from the codebase which has minimal code.
Please note that:
tx.gaspriceis replaced with a fixed value in the_payExecutionGasmethod, as it is not available in Foundry.In_replenishGas, reading the config viaIAnycallProxy(localAnyCallAddress).config()is replaced with an immediate call for simplicity. In other words, avoiding a proxy to make the PoC simpler and shorter. However, if done with a proxy, the gas used would increase. So in both ways, it is in favor of the PoC.In_forceRevert, we callanycallConfig, immediately skipping the returned value fromAnycallProxy. This is irrelevant for this PoC.
The Coded PoC
Foundry.toml[profile.default]solc ='0.8.17'src ='solidity'test='solidity/test'out ='out'libs = ['lib']fuzz_runs = 1000optimizer_runs = 10_000.gitmodules
[submodule"lib/ds-test"]path = lib/ds-testurl = https://github.com/dapphub/ds-testbranch = master[submodule"lib/forge-std"]path = lib/forge-stdurl = https://github.com/brockelmore/forge-stdbranch = master
remappings.txt
ds-test/=lib/ds-test/srcforge-std/=lib/forge-std/src
Test File:
// PoC => Maia OmniChain: anyExecute always revert in BranchBridgeAgentpragmasolidity>=0.8.4<0.9.0;import{Test}from"forge-std/Test.sol";import"forge-std/console.sol";import{DSTest}from"ds-test/test.sol";librarySafeTransferLib{/*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*//-                     CUSTOM ERRORS*//*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*//// @dev The ETH transfer has failed.errorETHTransferFailed();/// @dev The ERC20 `transferFrom` has failed.errorTransferFromFailed();/// @dev The ERC20 `transfer` has failed.errorTransferFailed();/// @dev The ERC20 `approve` has failed.errorApproveFailed();/*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*//-                       CONSTANTS*//*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*//// @dev Suggested gas stipend for contract receiving ETH/// that disallows any storage writes.uint256internalconstant_GAS_STIPEND_NO_STORAGE_WRITES=2300;/// @dev Suggested gas stipend for contract receiving ETH to perform a few/// storage reads and writes, but low enough to prevent griefing./// Multiply by a small constant (e.g. 2), if needed.uint256internalconstant_GAS_STIPEND_NO_GRIEF=100000;/*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*//-                     ETH OPERATIONS*//*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*//// @dev Sends `amount` (in wei) ETH to `to`./// Reverts upon failure.////// Note: This implementation does NOT protect against gas griefing./// Please use `forceSafeTransferETH` for gas griefing protection.functionsafeTransferETH(addressto,uint256amount)internal{/// @solidity memory-safe-assemblyassembly{// Transfer the ETH and check if it succeeded or not.ifiszero(call(gas(),to,amount,0,0,0,0)) {// Store the function selector of `ETHTransferFailed()`.mstore(0x00,0xb12d13eb)// Revert with (offset, size).revert(0x1c,0x04)}}}/// @dev Force sends `amount` (in wei) ETH to `to`, with a `gasStipend`./// The `gasStipend` can be set to a low enough value to prevent/// storage writes or gas griefing.////// If sending via the normal procedure fails, force sends the ETH by/// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.////// Reverts if the current contract has insufficient balance.functionforceSafeTransferETH(addressto,uint256amount,uint256gasStipend)internal{/// @solidity memory-safe-assemblyassembly{// If insufficient balance, revert.iflt(selfbalance(),amount) {// Store the function selector of `ETHTransferFailed()`.mstore(0x00,0xb12d13eb)// Revert with (offset, size).revert(0x1c,0x04)}// Transfer the ETH and check if it succeeded or not.ifiszero(call(gasStipend,to,amount,0,0,0,0)) {mstore(0x00,to)// Store the address in scratch space.mstore8(0x0b,0x73)// Opcode `PUSH20`.mstore8(0x20,0xff)// Opcode `SELFDESTRUCT`.// We can directly use `SELFDESTRUCT` in the contract creation.// Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758ifiszero(create(amount,0x0b,0x16)) {// To coerce gas estimation to provide enough gas for the `create` above.ifiszero(gt(gas(),1000000)) {revert(0,0)}}}}}/// @dev Force sends `amount` (in wei) ETH to `to`, with a gas stipend/// equal to `_GAS_STIPEND_NO_GRIEF`. This gas stipend is a reasonable default/// for 99% of cases and can be overridden with the three-argument version of this/// function if necessary.////// If sending via the normal procedure fails, force sends the ETH by/// creating a temporary contract which uses `SELFDESTRUCT` to force send the ETH.////// Reverts if the current contract has insufficient balance.functionforceSafeTransferETH(addressto,uint256amount)internal{// Manually inlined because the compiler doesn't inline functions with branches./// @solidity memory-safe-assemblyassembly{// If insufficient balance, revert.iflt(selfbalance(),amount) {// Store the function selector of `ETHTransferFailed()`.mstore(0x00,0xb12d13eb)// Revert with (offset, size).revert(0x1c,0x04)}// Transfer the ETH and check if it succeeded or not.ifiszero(call(_GAS_STIPEND_NO_GRIEF,to,amount,0,0,0,0)) {mstore(0x00,to)// Store the address in scratch space.mstore8(0x0b,0x73)// Opcode `PUSH20`.mstore8(0x20,0xff)// Opcode `SELFDESTRUCT`.// We can directly use `SELFDESTRUCT` in the contract creation.// Compatible with `SENDALL`: https://eips.ethereum.org/EIPS/eip-4758ifiszero(create(amount,0x0b,0x16)) {// To coerce gas estimation to provide enough gas for the `create` above.ifiszero(gt(gas(),1000000)) {revert(0,0)}}}}}/// @dev Sends `amount` (in wei) ETH to `to`, with a `gasStipend`./// The `gasStipend` can be set to a low enough value to prevent/// storage writes or gas griefing.////// Simply use `gasleft()` for `gasStipend` if you don't need a gas stipend.////// Note: Does NOT revert upon failure./// Returns whether the transfer of ETH is successful instead.functiontrySafeTransferETH(addressto,uint256amount,uint256gasStipend)internalreturns(boolsuccess) {/// @solidity memory-safe-assemblyassembly{// Transfer the ETH and check if it succeeded or not.success :=call(gasStipend,to,amount,0,0,0,0)}}/*Â´:Â°â€¢.Â°+.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°â€¢.*â€¢Â´.*:Ëš.Â°*.Ëšâ€¢Â´.Â°:Â°â€¢.Â°+.*â€¢Â´.*:*//-                    ERC20 OPERATIONS*//*.â€¢Â°:Â°.Â´+Ëš.*Â°.Ëš:*.Â´â€¢*.+Â°.â€¢Â°:Â´*.Â´â€¢*.â€¢Â°.â€¢Â°:Â°.Â´:â€¢ËšÂ°.*Â°.Ëš:*.Â´+Â°.â€¢*//// @dev Sends `amount` of ERC20 `token` from `from` to `to`./// Reverts upon failure.////// The `from` account must have at least `amount` approved for/// the current contract to manage.functionsafeTransferFrom(addresstoken,addressfrom,addressto,uint256amount)internal{/// @solidity memory-safe-assemblyassembly{letm:=mload(0x40)// Cache the free memory pointer.mstore(0x60,amount)// Store the `amount` argument.mstore(0x40,to)// Store the `to` argument.mstore(0x2c,shl(96,from))// Store the `from` argument.// Store the function selector of `transferFrom(address,address,uint256)`.mstore(0x0c,0x23b872dd000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x1c,0x64,0x00,0x20))) {// Store the function selector of `TransferFromFailed()`.mstore(0x00,0x7939f424)// Revert with (offset, size).revert(0x1c,0x04)}mstore(0x60,0)// Restore the zero slot to zero.mstore(0x40,m)// Restore the free memory pointer.}}/// @dev Sends all of ERC20 `token` from `from` to `to`./// Reverts upon failure.////// The `from` account must have their entire balance approved for/// the current contract to manage.functionsafeTransferAllFrom(addresstoken,addressfrom,addressto)internalreturns(uint256amount) {/// @solidity memory-safe-assemblyassembly{letm:=mload(0x40)// Cache the free memory pointer.mstore(0x40,to)// Store the `to` argument.mstore(0x2c,shl(96,from))// Store the `from` argument.// Store the function selector of `balanceOf(address)`.mstore(0x0c,0x70a08231000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.gt(returndatasize(),0x1f),// At least 32 bytes returned.staticcall(gas(),token,0x1c,0x24,0x60,0x20))) {// Store the function selector of `TransferFromFailed()`.mstore(0x00,0x7939f424)// Revert with (offset, size).revert(0x1c,0x04)}// Store the function selector of `transferFrom(address,address,uint256)`.mstore(0x00,0x23b872dd)// The `amount` argument is already written to the memory word at 0x60.amount :=mload(0x60)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x1c,0x64,0x00,0x20))) {// Store the function selector of `TransferFromFailed()`.mstore(0x00,0x7939f424)// Revert with (offset, size).revert(0x1c,0x04)}mstore(0x60,0)// Restore the zero slot to zero.mstore(0x40,m)// Restore the free memory pointer.}}/// @dev Sends `amount` of ERC20 `token` from the current contract to `to`./// Reverts upon failure.functionsafeTransfer(addresstoken,addressto,uint256amount)internal{/// @solidity memory-safe-assemblyassembly{mstore(0x14,to)// Store the `to` argument.mstore(0x34,amount)// Store the `amount` argument.// Store the function selector of `transfer(address,uint256)`.mstore(0x00,0xa9059cbb000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x10,0x44,0x00,0x20))) {// Store the function selector of `TransferFailed()`.mstore(0x00,0x90b8ec18)// Revert with (offset, size).revert(0x1c,0x04)}// Restore the part of the free memory pointer that was overwritten.mstore(0x34,0)}}/// @dev Sends all of ERC20 `token` from the current contract to `to`./// Reverts upon failure.functionsafeTransferAll(addresstoken,addressto)internalreturns(uint256amount) {/// @solidity memory-safe-assemblyassembly{mstore(0x00,0x70a08231)// Store the function selector of `balanceOf(address)`.mstore(0x20,address())// Store the address of the current contract.ifiszero(and(// The arguments of `and` are evaluated from right to left.gt(returndatasize(),0x1f),// At least 32 bytes returned.staticcall(gas(),token,0x1c,0x24,0x34,0x20))) {// Store the function selector of `TransferFailed()`.mstore(0x00,0x90b8ec18)// Revert with (offset, size).revert(0x1c,0x04)}mstore(0x14,to)// Store the `to` argument.// The `amount` argument is already written to the memory word at 0x34.amount :=mload(0x34)// Store the function selector of `transfer(address,uint256)`.mstore(0x00,0xa9059cbb000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x10,0x44,0x00,0x20))) {// Store the function selector of `TransferFailed()`.mstore(0x00,0x90b8ec18)// Revert with (offset, size).revert(0x1c,0x04)}// Restore the part of the free memory pointer that was overwritten.mstore(0x34,0)}}/// @dev Sets `amount` of ERC20 `token` for `to` to manage on behalf of the current contract./// Reverts upon failure.functionsafeApprove(addresstoken,addressto,uint256amount)internal{/// @solidity memory-safe-assemblyassembly{mstore(0x14,to)// Store the `to` argument.mstore(0x34,amount)// Store the `amount` argument.// Store the function selector of `approve(address,uint256)`.mstore(0x00,0x095ea7b3000000000000000000000000)ifiszero(and(// The arguments of `and` are evaluated from right to left.// Set success to whether the call reverted, if not we check it either// returned exactly 1 (can't just be non-zero data), or had no return data.or(eq(mload(0x00),1),iszero(returndatasize())),call(gas(),token,0,0x10,0x44,0x00,0x20))) {// Store the function selector of `ApproveFailed()`.mstore(0x00,0x3e3f8f73)// Revert with (offset, size).revert(0x1c,0x04)}// Restore the part of the free memory pointer that was overwritten.mstore(0x34,0)}}/// @dev Returns the amount of ERC20 `token` owned by `account`./// Returns zero if the `token` does not exist.functionbalanceOf(addresstoken,addressaccount)internalviewreturns(uint256amount) {/// @solidity memory-safe-assemblyassembly{mstore(0x14,account)// Store the `account` argument.// Store the function selector of `balanceOf(address)`.mstore(0x00,0x70a08231000000000000000000000000)amount :=mul(mload(0x20),and(// The arguments of `and` are evaluated from right to left.gt(returndatasize(),0x1f),// At least 32 bytes returned.staticcall(gas(),token,0x10,0x24,0x20,0x20)))}}}interfaceIAnycallExecutor{functioncontext()externalviewreturns(addressfrom,uint256fromChainID,uint256nonce);functionexecute(address_to,bytescalldata_data,address_from,uint256_fromChainID,uint256_nonce,uint256_flags,bytescalldata_extdata)externalreturns(boolsuccess,bytesmemoryresult);}interfaceIAnycallConfig{functioncalcSrcFees(address_app,uint256_toChainID,uint256_dataLength)externalviewreturns(uint256);functionexecutionBudget(address_app)externalviewreturns(uint256);functiondeposit(address_account)externalpayable;functionwithdraw(uint256_amount)external;}interfaceIAnycallProxy{functionexecutor()externalviewreturns(address);functionconfig()externalviewreturns(address);functionanyCall(address_to,bytescalldata_data,uint256_toChainID,uint256_flags,bytescalldata_extdata)externalpayable;functionanyCall(stringcalldata_to,bytescalldata_data,uint256_toChainID,uint256_flags,bytescalldata_extdata)externalpayable;}contractWETH9{stringpublicname="Wrapped Ether";stringpublicsymbol="WETH";uint8publicdecimals=18;eventApproval(addressindexedsrc,addressindexedguy,uint256wad);eventTransfer(addressindexedsrc,addressindexeddst,uint256wad);eventDeposit(addressindexeddst,uint256wad);eventWithdrawal(addressindexedsrc,uint256wad);mapping(address=>uint256)publicbalanceOf;mapping(address=>mapping(address=>uint256))publicallowance;// function receive() external payable {//   deposit();// }functiondeposit()publicpayable{balanceOf[msg.sender] +=msg.value;emitDeposit(msg.sender,msg.value);}functionwithdraw(uint256wad)public{require(balanceOf[msg.sender] >=wad);balanceOf[msg.sender] -=wad;payable(msg.sender).transfer(wad);emitWithdrawal(msg.sender,wad);}functiontotalSupply()publicviewreturns(uint256) {returnaddress(this).balance;}functionapprove(addressguy,uint256wad)publicreturns(bool) {allowance[msg.sender][guy] =wad;emitApproval(msg.sender,guy,wad);returntrue;}functiontransfer(addressdst,uint256wad)publicreturns(bool) {returntransferFrom(msg.sender,dst,wad);}functiontransferFrom(addresssrc,addressdst,uint256wad)publicreturns(bool) {require(balanceOf[src] >=wad);if(src!=msg.sender&&allowance[src][msg.sender] !=255) {require(allowance[src][msg.sender] >=wad);allowance[src][msg.sender] -=wad;}balanceOf[src] -=wad;balanceOf[dst] +=wad;emitTransfer(src,dst,wad);returntrue;}}contractAnycallExecutor{structContext{addressfrom;uint256fromChainID;uint256nonce;}// Context public override context;Contextpubliccontext;constructor() {context.fromChainID=1;context.from=address(2);context.nonce=1;}}contractAnycallV7Config{eventDeposit(addressindexedaccount,uint256amount);mapping(address=>uint256)publicexecutionBudget;/// @notice Deposit native currency crediting `_account` for execution costs on this chain/// @param _account The account to deposit and credit forfunctiondeposit(address_account)externalpayable{executionBudget[_account] +=msg.value;emitDeposit(_account,msg.value);}}contractBranchBridgeAgent{errorAnycallUnauthorizedCaller();errorGasErrorOrRepeatedTx();uint256publicremoteCallDepositedGas;uint256internalconstantMIN_EXECUTION_OVERHEAD=160_000;// 100_000 for anycall + 35_000 Pre 1st Gas Checkpoint Execution + 25_000 Post last Gas Checkpoint Executionsuint256internalconstantTRANSFER_OVERHEAD=24_000;WETH9publicimmutablewrappedNativeToken;AnycallV7ConfigpublicanycallV7Config;uint256publicaccumulatedFees;/// @notice Local Chain Iduint24publicimmutablelocalChainId;/// @notice Address for Bridge Agent who processes requests submitted for the Root Router Address where cross-chain requests are executed in the Root Chain.addresspublicimmutablerootBridgeAgentAddress;/// @notice Local Anyexec Addressaddresspublicimmutablelocal`AnyCall`ExecutorAddress;/// @notice Address for Local AnycallV7 Proxy Address where cross-chain requests are sent to the Root Chain Router.addresspublicimmutablelocal`AnyCall`Address;constructor() {AnycallExecutoranycallExecutor=newAnycallExecutor();local`AnyCall`ExecutorAddress=address(anycallExecutor);localChainId=1;wrappedNativeToken=newWETH9();local`AnyCall`Address=address(3);rootBridgeAgentAddress=address(2);anycallV7Config=newAnycallV7Config();}modifierrequiresExecutor() {_requiresExecutor();_;}function_requiresExecutor()internalview{if(msg.sender!=local`AnyCall`ExecutorAddress)revertAnycallUnauthorizedCaller();(addressfrom, , ) =IAnycallExecutor(local`AnyCall`ExecutorAddress).context();if(from!=rootBridgeAgentAddress)revertAnycallUnauthorizedCaller();}function_replenishGas(uint256_executionGasSpent)internalvirtual{//Deposit GasanycallV7Config.deposit{value:_executionGasSpent}(address(this));// IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config()).deposit{value: _executionGasSpent}(address(this));}function_forceRevert()internalvirtual{IAnycallConfiganycallConfig=IAnycallConfig(IAnycallProxy(local`AnyCall`Address).config());// uint256 executionBudget = anycallConfig.executionBudget(address(this));uint256executionBudget=anycallV7Config.executionBudget(address(this));// Withdraw all execution gas budget from anycall for tx to revert with "no enough budget"if(executionBudget>0)tryanycallConfig.withdraw(executionBudget) {}catch{}}/***@noticeInternal function repays gas used by Branch Bridge Agent to fulfill remote initiated interaction.-@param_recipientaddress to send excess gas to.-@param_initialGasgas used by Branch Bridge Agent.*/function_payExecutionGas(address_recipient,uint256_initialGas)internalvirtual{//Gas remaininguint256gasRemaining=wrappedNativeToken.balanceOf(address(this));//Unwrap GaswrappedNativeToken.withdraw(gasRemaining);//Delete Remote Initiated Action Statedelete(remoteCallDepositedGas);///Save gas leftuint256gasLeft=gasleft();//Get Branch Environment Execution Cost// Assume tx.gasPrice 1e9uint256minExecCost=1e9*(MIN_EXECUTION_OVERHEAD+_initialGas-gasLeft);//Check if sufficient balanceif(minExecCost>gasRemaining) {_forceRevert();return;}//Replenish Gas_replenishGas(minExecCost);//Transfer gas remaining to recipientSafeTransferLib.safeTransferETH(_recipient,gasRemaining-minExecCost);//Save Gasuint256gasAfterTransfer=gasleft();//Check if sufficient balance // This condition is always trueif(gasLeft-gasAfterTransfer>TRANSFER_OVERHEAD) {console.log("(gasLeft - gasAfterTransfer > TRANSFER_OVERHEAD) => true");console.log("gasLeft - gasAfterTransfer = %d - %d = %d",gasLeft,gasAfterTransfer,gasLeft-gasAfterTransfer);_forceRevert();return;}}functionanyExecute(bytesmemorydata)publicvirtualrequiresExecutorreturns(boolsuccess,bytesmemoryresult){//Get Initial Gas Checkpointuint256initialGas=gasleft();//Action Recipientaddressrecipient=address(0x0);// for simplicity and since it is irrelevant //address(uint160(bytes20(data[PARAMS_START:PARAMS_START_SIGNED])));// Other Code Here//Deduct gas costs from deposit and replenish this bridge agent's execution budget._payExecutionGas(recipient,initialGas);}functiondepositIntoWeth(uint256amt)external{wrappedNativeToken.deposit{value:amt}();}fallback()externalpayable{}}contractGasCalcTransferOverHeadisDSTest,Test{BranchBridgeAgentbranchBridgeAgent;functionsetUp()public{branchBridgeAgent=newBranchBridgeAgent();vm.deal(address(branchBridgeAgent.local`AnyCall`ExecutorAddress()),100ether);// executer pays gasvm.deal(address(branchBridgeAgent),100ether);}functiontest_anyexecute_always_revert_bc_transfer_overhead()public{// add weth balancebranchBridgeAgent.depositIntoWeth(100ether);vm.prank(address(branchBridgeAgent.local`AnyCall`ExecutorAddress()));vm.expectRevert();branchBridgeAgent.anyExecute{gas:1ether}(bytes(""));vm.stopPrank();}}
Recommended Mitigation Steps
Increase theTRANSFER_OVERHEADto cover the actual gas spent. You could also add a gas checkpoint immediately before the transfer to make the naming makes sense (i.e.TRANSFER_OVERHEAD). However, the gas will be nearly34_378, which is still higher thanTRANSFER_OVERHEAD(24_000).
You can simply comment out the code aftergasLefttill the transfer, by removing_minExecCostfrom the value to transfer since it is commented out. Now, when you run the test again, you will see an output like this (with a failed test but we are not interested in it anyway):
[FAIL.Reason:Calldidnotrevertasexpected]test_anyexecute_always_revert_bc_transfer_overhead() (gas:111185)Logs:(gasLeft-gasAfterTransfer>TRANSFER_OVERHEAD)=>truegasLeft-gasAfterTransfer=999999999999979606-999999999999945228=34378Testresult:FAILED.0passed;1failed;finishedin1.26ms
gasLeft-gasAfterTransfer= 34378
Please note that I have tested a simple function in Remix as well and it gave the same gas spent (i.e. 34378):
// copy the library code from Solady and paste it here// https://github.com/Vectorized/solady/blob/main/src/utils/SafeTransferLib.solcontract Test {function testGas() payable public returns (uint256){///Save gas leftuint256 gasLeft = gasleft();//Transfer gas remaining to recipientSafeTransferLib.safeTransferETH(address(0), 1 ether);//Save Gasuint256 gasAfterTransfer = gasleft();return gasLeft-gasAfterTransfer;}}
The returned value will be 34378.
0xBugsy (Maia) confirmed and commented:
We recognize the audit’s findings on Anycall Gas Management. These will not be rectified due to the upcoming migration of this section to LayerZero.