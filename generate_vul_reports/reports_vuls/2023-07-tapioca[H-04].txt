[H-04] Incorrect solvency check because it multiplies collateralizationRate by share not amount when calculating liquidation threshold
Submitted byKoolex
When a Collateralized Debt Position (CDP) reaches that liquidation threshold, it becomes eligible for liquidation and anyone can repay a position in exchange for a portion of the collateral.Market._isSolventis used to check if the user is solvent. if not, then it can be liquidated. Here is the method body:
function _isSolvent(address user,uint256 _exchangeRate) internal view returns (bool) {// accrue must have already been called!uint256 borrowPart = userBorrowPart[user];if (borrowPart == 0) return true;uint256 collateralShare = userCollateralShare[user];if (collateralShare == 0) return false;Rebase memory _totalBorrow = totalBorrow;returnyieldBox.toAmount(collateralId,collateralShare *(EXCHANGE_RATE_PRECISION / FEE_PRECISION) *collateralizationRate,false) >=// Moved exchangeRate here instead of dividing the other side to preserve more precision(borrowPart * _totalBorrow.elastic * _exchangeRate) /_totalBorrow.base;}
Code link
The issue is that the collateralizationRate is multiplied by collateralShare (with precision constants) then converted to amount. This is incorrect,the collateralizationRate sholud be used with amounts and not shares. Otherwise, we get wrong results.
yieldBox.toAmount(collateralId,collateralShare*(EXCHANGE_RATE_PRECISION/FEE_PRECISION) *collateralizationRate,false)
Please note that when using sharesit is not in favour of the protocol, so amounts should be used instead. The only case where this is ok, is when the share/amount ratio is 1:1 which can not be, because totalAmount always get +1 and totalShares +1e8 to prevent 1:1 ratio type of attack.
function_toAmount(uint256share,uint256totalShares_,uint256totalAmount,boolroundUp)internalpurereturns(uint256amount) {// To prevent reseting the ratio due to withdrawal of all shares, we start with// 1 amount/1e8 shares already burned. This also starts with a 1 : 1e8 ratio which// functions like 8 decimal fixed point math. This prevents ratio attacks or inaccuracy// due to 'gifting' or rebasing tokens. (Up to a certain degree)totalAmount++;totalShares_+=1e8;
Code link
Moreover, in the method_computeMaxAndMinLTVInAssetwhich is supposed to returns the min and max LTV for user in asset price. Amount is used and not share. Here is the code:
function _computeMaxAndMinLTVInAsset(uint256 collateralShare,uint256 _exchangeRate) internal view returns (uint256 min, uint256 max) {uint256 collateralAmount = yieldBox.toAmount(collateralId,collateralShare,false);max = (collateralAmount * EXCHANGE_RATE_PRECISION) / _exchangeRate;min = (max * collateralizationRate) / FEE_PRECISION;}
Code Link
Iâ€™ve set this to high severity because solvency check is a crucial part of the protocol. In short, we have :
Inconsistency across the protocolInaccuracy of calculating the liquidation thresholdNot in favour of the protocol
Note: this is also applicable for ohter methods. For example,Market._computeMaxBorrowableAmount.
Proof of Concept
When you run the PoC below, you will get the following results:
[PASS]test_borrow_repay() (gas: 118001)Logs:===BORROW===UserBorrowPart: 745372500000000000000Total Borrow Base: 745372500000000000000Total Borrow Elastic: 745372500000000000000===356 days passed===Total Borrow Elastic: 749089151896269477984===Solvency#1 => multiply by share===A: 749999999999925000000750007499999924999B: 749089151896269477984000000000000000000===Solvency#2 => multiply by amount===A: 749999999999925000000750000000000000000B: 749089151896269477984000000000000000000===Result===Solvency#1.A != Solvency#2.ATest result: ok. 1 passed; 0 failed; finishedin16.69ms
As you can see, numbers are not equal, and when using shares it is not in favour of the protocol, so amount should be used instead.
Code: Please note some lines in borrow method were commented out for simplicity. It is irrelevant anyway._toAmountcopied from YieldBoxRebase
// PoC => BIGBANG - Solvency Check Inaccuracy// Command => forge test -vvpragmasolidity>=0.8.4<0.9.0;import{Test}from"forge-std/Test.sol";import"forge-std/console.sol";import{DSTest}from"ds-test/test.sol";structAccrueInfo{uint64debtRate;uint64lastAccrued;}structRebase{uint128elastic;uint128base;}/// @notice A rebasing library using overflow-/underflow-safe math.libraryRebaseLibrary{/// @notice Calculates the base value in relationship to `elastic` and `total`.functiontoBase(Rebasememorytotal,uint256elastic,boolroundUp)internalpurereturns(uint256base) {if(total.elastic==0) {base=elastic;}else{base= (elastic*total.base) /total.elastic;if(roundUp&& (base*total.elastic) /total.base<elastic) {base++;}}}/// @notice Calculates the elastic value in relationship to `base` and `total`.functiontoElastic(Rebasememorytotal,uint256base,boolroundUp)internalpurereturns(uint256elastic) {if(total.base==0) {elastic=base;}else{elastic= (base*total.elastic) /total.base;if(roundUp&& (elastic*total.base) /total.elastic<base) {elastic++;}}}/// @notice Add `elastic` to `total` and doubles `total.base`./// @return (Rebase) The new total./// @return base in relationship to `elastic`.functionadd(Rebasememorytotal,uint256elastic,boolroundUp)internalpurereturns(Rebasememory,uint256base) {base=toBase(total,elastic,roundUp);total.elastic+=uint128(elastic);total.base+=uint128(base);return(total,base);}/// @notice Sub `base` from `total` and update `total.elastic`./// @return (Rebase) The new total./// @return elastic in relationship to `base`.functionsub(Rebasememorytotal,uint256base,boolroundUp)internalpurereturns(Rebasememory,uint256elastic) {elastic=toElastic(total,base,roundUp);total.elastic-=uint128(elastic);total.base-=uint128(base);return(total,elastic);}/// @notice Add `elastic` and `base` to `total`.functionadd(Rebasememorytotal,uint256elastic,uint256base)internalpurereturns(Rebasememory) {total.elastic+=uint128(elastic);total.base+=uint128(base);returntotal;}/// @notice Subtract `elastic` and `base` to `total`.functionsub(Rebasememorytotal,uint256elastic,uint256base)internalpurereturns(Rebasememory) {total.elastic-=uint128(elastic);total.base-=uint128(base);returntotal;}/// @notice Add `elastic` to `total` and update storage./// @return newElastic Returns updated `elastic`.functionaddElastic(Rebasestoragetotal,uint256elastic)internalreturns(uint256newElastic) {newElastic=total.elastic+=uint128(elastic);}/// @notice Subtract `elastic` from `total` and update storage./// @return newElastic Returns updated `elastic`.functionsubElastic(Rebasestoragetotal,uint256elastic)internalreturns(uint256newElastic) {newElastic=total.elastic-=uint128(elastic);}}contractBIGBANG_MOCK{usingRebaseLibraryforRebase;uint256publiccollateralizationRate=75000;// 75% // made public to access it from test contractuint256publicliquidationMultiplier=12000;//12%uint256publicconstantFEE_PRECISION=1e5;// made public to access it from test contractuint256publicEXCHANGE_RATE_PRECISION=1e18;//made public to access it from test contractuint256publicborrowOpeningFee=50;//0.05%RebasepublictotalBorrow;uint256publictotalBorrowCap;AccrueInfopublicaccrueInfo;/// @notice borrow amount per usermapping(address=>uint256)publicuserBorrowPart;uint256publicUSDO_balance;// just to track USDO balance of BigBangfunction_accrue()public{// made public so we can call it from the test contractAccrueInfomemory_accrueInfo=accrueInfo;// Number of seconds since accrue was calleduint256elapsedTime=block.timestamp-_accrueInfo.lastAccrued;if(elapsedTime==0) {return;}//update debt rate // for simplicity we return bigBangEthDebtRate which is 5e15uint256annumDebtRate=5e15;// getDebtRate(); // 5e15 for eth. Check Penrose.sol Line:131_accrueInfo.debtRate=uint64(annumDebtRate/31536000);//per second_accrueInfo.lastAccrued=uint64(block.timestamp);Rebasememory_totalBorrow=totalBorrow;uint256extraAmount=0;// Calculate feesextraAmount=(uint256(_totalBorrow.elastic) *_accrueInfo.debtRate*elapsedTime) /1e18;_totalBorrow.elastic+=uint128(extraAmount);totalBorrow=_totalBorrow;accrueInfo=_accrueInfo;// emit LogAccrue(extraAmount, _accrueInfo.debtRate); // commented out since it irrelevant}functiontotalBorrowElastic()publicviewreturns(uint128) {returntotalBorrow.elastic;}functiontotalBorrowBase()publicviewreturns(uint128) {returntotalBorrow.base;}function_borrow(addressfrom,addressto,uint256amount)externalreturns(uint256part,uint256share) {uint256feeAmount= (amount*borrowOpeningFee) /FEE_PRECISION;// A flat % fee is charged for any borrow(totalBorrow,part) =totalBorrow.add(amount+feeAmount,true);require(totalBorrowCap==0||totalBorrow.elastic<=totalBorrowCap,"BigBang: borrow cap reached");userBorrowPart[from] +=part;// toBase from RebaseLibrary. userBorrowPart stores the sharee//mint USDO// IUSDOBase(address(asset)).mint(address(this), amount); // not neededUSDO_balance+=amount;//deposit borrowed amount to user// asset.approve(address(yieldBox), amount);  // not needed// yieldBox.depositAsset(assetId, address(this), to, amount, 0); // not neededUSDO_balance-=amount;// share = yieldBox.toShare(assetId, amount, false); // not needed// emit LogBorrow(from, to, amount, feeAmount, part); // not needed}// copied from YieldBoxRebasefunction_toAmount(uint256share,uint256totalShares_,uint256totalAmount,boolroundUp)externalpurereturns(uint256amount) {// To prevent reseting the ratio due to withdrawal of all shares, we start with// 1 amount/1e8 shares already burned. This also starts with a 1 : 1e8 ratio which// functions like 8 decimal fixed point math. This prevents ratio attacks or inaccuracy// due to 'gifting' or rebasing tokens. (Up to a certain degree)totalAmount++;totalShares_+=1e8;// Calculte the amount using te current amount to share ratioamount= (share*totalAmount) /totalShares_;// Default is to round down (Solidity), round up if requiredif(roundUp&& (amount*totalShares_) /totalAmount<share) {amount++;}}}contractBIGBANG_ISSUESisDSTest,Test{BIGBANG_MOCKbigbangMock;addressbob;functionsetUp()public{bigbangMock=newBIGBANG_MOCK();bob=vm.addr(1);}functiontest_borrow_repay()public{// borrowuint256amount=745e18;vm.warp(1days);bigbangMock._accrue();// acrrue before borrow (this is done on borrow)bigbangMock._borrow(bob,address(0),amount);console.log("===BORROW===");// console.log("Amount: %d", amount);console.log("UserBorrowPart: %d",bigbangMock.userBorrowPart(bob));console.log("Total Borrow Base: %d",bigbangMock.totalBorrowBase());console.log("Total Borrow Elastic: %d",bigbangMock.totalBorrowElastic());// time elapsedvm.warp(365days);console.log("===356 days passed===");bigbangMock._accrue();console.log("Total Borrow Elastic: %d",bigbangMock.totalBorrowElastic());// Check Insolvencyuint256_exchangeRate=1e18;uint256collateralShare=1000e18;uint256totalShares=1000e18;uint256totalAmount=1000e18;uint256EXCHANGE_RATE_PRECISION=bigbangMock.EXCHANGE_RATE_PRECISION();uint256FEE_PRECISION=bigbangMock.FEE_PRECISION();uint256collateralizationRate=bigbangMock.collateralizationRate();uint256borrowPart=bigbangMock.userBorrowPart(bob);uint256_totalBorrowElastic=bigbangMock.totalBorrowElastic();uint256_totalBorrowBase=bigbangMock.totalBorrowBase();console.log("===Solvency#1 => multiply by share===");// we pass totalShares and totalAmountuint256A=bigbangMock._toAmount(collateralShare*(EXCHANGE_RATE_PRECISION/FEE_PRECISION) *collateralizationRate,totalShares,totalAmount,false);// Moved exchangeRate here instead of dividing the other side to preserve more precisionuint256B= (borrowPart*_totalBorrowElastic*_exchangeRate) /_totalBorrowBase;// bool isSolvent = A >= B;console.log("A: %d",A);console.log("B: %d",B);console.log("===Solvency#2 => multiply by amount===");A=bigbangMock._toAmount(collateralShare,totalShares,totalAmount,false) *(EXCHANGE_RATE_PRECISION/FEE_PRECISION) *collateralizationRate;// Moved exchangeRate here instead of dividing the other side to preserve more precisionB=(borrowPart*_totalBorrowElastic*_exchangeRate) /_totalBorrowBase;// isSolvent = A >= B;console.log("A: %d",A);console.log("B: %d",B);console.log("===Result===");console.log("Solvency#1.A != Solvency#2.A");}}
Recommended Mitigation Steps
Use amount for calculation instead of shares. Check the PoC as it demonstrates such an example.
0xRektora (sponsor) confirmed