[H-03] Attacker can make0valuedeposit()calls to deny user from redeeming or withdrawing collateral
Submitted byMrPotatoMagic, also found by0xAkira,SBSecurity, 0xblack_bird (1,2),dinkras,xyz,falconhoof,Tychai0s,josephdara,0x175,DedOhWale,0xloscar01,0xlemon,djxploit,turvy_fuzz,kartik_giri_47538,sashik_eth,Honour,Pechenite,koo,grearlake,NentoR,Dinesh11G,Dots,KupiaSec,imare,Circolors,pep7siup,Mrxstrange,web3km,forgebyola,alix40,0xtankr,0xDemon,Ryonen,Imp,ke1caM,poslednaya,itsabinashb,Cryptor,asui,steadyman,DPS,VAD37,ljj,btk,TheFabled,c0pp3rscr3w3r,niser93,DMoore,d_tony7470,blutorque,0x77,adam-idarrha,ZanyBonzy,Vasquez,Angry_Mustache_Man,Jorgect,shaflow2,valentin_s2304,zigtur,Sabit,0xAsen,kennedy1030,caglankaan,GalloDaSballo,Giorgio,dimulski,T1MOH,3docSec,AlexCzm,0xabhay,4rdiii,PoeAudits,WildSniper,ptsanev,BiasedMerc,y4y,TheSavageTeddy,carrotsmuggler,Abdessamed,ubl4nk,zhaojohnson,0x486776,lionking927, andKrace
Functiondeposit()uses modifierisValidDNft()instead ofisDNftOwner(), which allows anyone to calldeposit()on behalf of any DNft id.
Impact
Attacker can make user devoid of withdrawing or redeeming collateral by making0valuedeposit()calls. Other than denying users from temporarily withdrawing their collateral, this is also an issue since it could force users into liquidations when they try to take preventative measures on their collateral ratio (especially throughredeemDyad()) in high collateral price volatility situations. If successful, the attacker could then perform the liquidation to profit from the situation.Attacker can make user devoid of removing vault due toid2asset > 0by depositing 1 wei of collateral.
Proof of Concept
First impact:
User callsredeemDyad()(orwithdraw()to directly withdraw collateral) to burn DYAD and withdraw their collateral asset.Attacker frontruns the call with a0valuedeposit()call. This would set theidToBlockOfLastDeposit[id]to the currentblock.number. The call does not revert since0value transfers are allowed.
File:VaultManagerV2.sol127:functiondeposit(128:uintid,129:addressvault,130:uintamount131:   )132:external133:isValidDNft(id)134:   {135:idToBlockOfLastDeposit[id] =block.number;136:Vault_vault=Vault(vault);137:_vault.asset().safeTransferFrom(msg.sender,address(vault),amount);138:_vault.deposit(id,amount);139:   }
When the user’sredeemDyad()call goes through, it internally calls thewithdraw()function, which would cause a revert due to the check on Line 152. The check evaluates to true and reverts since the attacker changes the last deposit block number to the current block through the0valuedeposit()call.
File:VaultManagerV2.sol143:functionwithdraw(144:uintid,145:addressvault,146:uintamount,147:addressto148:   )149:public150:isDNftOwner(id)151:   {152:if(idToBlockOfLastDeposit[id] ==block.number)revertDepositedInSameBlock();153:uintdyadMinted=dyad.mintedDyad(address(this),id);154:Vault_vault=Vault(vault);155:uintvalue=amount*_vault.assetPrice()156:                   *1e18157:                   /10**_vault.oracle().decimals()158:                   /10**_vault.asset().decimals();159:160:if(getNonKeroseneValue(id) -value<dyadMinted)revertNotEnoughExoCollat();161:_vault.withdraw(id,to,amount);162:if(collatRatio(id) <MIN_COLLATERIZATION_RATIO)revertCrTooLow();163:   }
If the collateral ratio of the user falls below the minimum threshold of 1.5e18 (in terms of high volatility of collateral asset price), the attacker could then exploit the situation to liquidate the user using theliquidate()function.
Second impact:
User tries to remove a vault by calling theremove()function.Attacker frontruns the call by making a 1 wei collateral deposit through thedeposit()function. This would increase theid2assetfor the user in the vault.
File:VaultManagerV2.sol127:functiondeposit(128:uintid,129:addressvault,130:uintamount131:   )132:external133:isValidDNft(id)134:   {135:idToBlockOfLastDeposit[id] =block.number;136:Vault_vault=Vault(vault);137:_vault.asset().safeTransferFrom(msg.sender,address(vault),amount);138:_vault.deposit(id,amount);139:   }
User’s call goes through and reverts due to the check on Line 102. This revert occurs sinceid2assetis now 1 wei for the vault the user is trying to remove. Note that although the attacker would be spending gas here, an equal amount of gas would also be required from the user’s side to withdraw the 1 wei. The attack will continue till the user gives up due to the high gas spent behind withdrawing. Another thing to note is that regular users (with no knowledge of contracts) might not have the option to withdraw 1 wei from the frontend, which would require additional overhead from their side to seek help from the team.
File:VaultManagerV2.sol095:functionremove(096:uintid,097:addressvault098:   )099:external100:isDNftOwner(id)101:   {102:if(Vault(vault).id2asset(id) >0)revertVaultHasAssets();103:if(!vaults[id].remove(vault))revertVaultNotAdded();104:emitRemoved(id,vault);105:   }
Recommended Mitigation Steps
Use modifierisDNftOwner()instead ofisValidDNft()on functiondeposit().
Assessed type
Invalid Validation
shafu0x (DYAD) confirmed and commented via duplicate Issue #489:
Good find! We should restrict it to only owner.