[H-01] Any fee claim lesser than the totalyieldFeeBalanceas unit of shares is lost and locked in thePrizeVaultcontract
Submitted byDarkTower, also found by0xJoyBoy03,smbv-1923,d3e4,0xlemon,trachev,aua_oo7,Afriauditor,Aymen0909,FastChecker,Dots,AgileJune,leegh,Tripathi,turvy_fuzz,GoSlang,McToady,zhaojie,radin100,yotov721,y4y,0xkeesmark,0xRiO,gesha17,iberry,0xmystery,sammy,Fitro,Greed,0xJaeger,wangxx2026,dd0x7e8,yvuchev,Abdessamed,Daniel526,kR1s,n1punp,AcT3R,SoosheeTheWise,valentin_s2304,btk,pa6kuda,Al-Qa-qa,asui,dvrkzy,crypticdefense,marqymarq10,DanielTan_MetaTrust, andKrace
Any fee claim by the fee recipient lesser than the accrued internal accounting of theyieldFeeBalanceis lost and locked in thePrizeVaultcontract with no way to pull out the funds.
Proof of Concept
TheclaimYieldFeeSharesallows theyieldFeeRecipientfee recipient to claim fees in yields from thePrizeVaultcontract. The claimer can claim up to theyieldFeeBalanceinternal accounting and no more. The issue with this function is it presents a vulnerable area of loss with the_sharesargument in the sense that if the accrued yield fee shares is 1000 shares and the claimer claims only 10, 200 or even any amount less than 1000, they forfeit whatever is left of theyieldFeeBalance(e.g if you claimed 200 and hence, got minted 200 shares, you lose the remainder 800 because it wipes theyieldFeeBalance1000 balance; whereas, they only minted 200 shares).
Let’s see a code breakdown of the vulnerableclaimYieldFeeSharesfunction:
functionclaimYieldFeeShares(uint256_shares)externalonlyYieldFeeRecipient{if(_shares==0)revertMintZeroShares();uint256_yieldFeeBalance=yieldFeeBalance;if(_shares>_yieldFeeBalance)revertSharesExceedsYieldFeeBalance(_shares,_yieldFeeBalance);yieldFeeBalance-=_yieldFeeBalance;// @audit issue stems and realized next line of code_mint(msg.sender,_shares);// @audit the point where the claimant gets to loseemitClaimYieldFeeShares(msg.sender,_shares);}
This line of the function caches the total yield fee balance accrued in the contract and hence, the fee recipient is entitled to (e.g 100).
uint256_yieldFeeBalance=yieldFeeBalance;
This next line of code enforces a comparison check making sure the claimer cannot grief other depositors in the vault because the claimant could, for example, try to claim and mint 150 shares; whereas, they are only entitled to 100.
if(_shares>_yieldFeeBalance)revertSharesExceedsYieldFeeBalance(_shares,_yieldFeeBalance);
This line of code subtracts the cached total yield fee balance from the state yield fee balance (e.g 100 - 100). So if say Bob, the claimant, tried to only mint 50 shares at this point in time with the_sharesargument, the code wipes the entire balance of 100.
yieldFeeBalance-=_yieldFeeBalance;
And this line of code then mints the specified_sharesamount (e.g 50 shares) to Bob:
_mint(msg.sender,_shares);
So what essentially happens is:
Total accrued fee is 100.Bob claims 50 shares of the 100.Bob gets minted 50 shares.Bob loses the rest 50 shares.
Here’s a POC for this issue. Place thetestUnclaimedFeesLostPOCfunction inside thePrizeVault.t.solfile and run the test.
functiontestUnclaimedFeesLostPOC()public{vault.setYieldFeePercentage(1e8);// 10%vault.setYieldFeeRecipient(bob);// fee recipient bobassertEq(vault.totalDebt(),0);// no deposits in vault yet// alice makes an initial deposit of 100 WETHunderlyingAsset.mint(alice,100e18);vm.startPrank(alice);underlyingAsset.approve(address(vault),100e18);vault.deposit(100e18,alice);vm.stopPrank();console.log("Shares balance of Alice post mint: ",vault.balanceOf(alice));assertEq(vault.totalAssets(),100e18);assertEq(vault.totalSupply(),100e18);assertEq(vault.totalDebt(),100e18);// mint yield to the vault and liquidateunderlyingAsset.mint(address(vault),100e18);vault.setLiquidationPair(address(this));uint256maxLiquidation=vault.liquidatableBalanceOf(address(underlyingAsset));uint256amountOut=maxLiquidation/2;uint256yieldFee= (100e18-vault.yieldBuffer()) / (2*10);// 10% yield fee + 90% amountOut = 100%vault.transferTokensOut(address(0),bob,address(underlyingAsset),amountOut);console.log("Accrued yield post in the contract to be claimed by Bob: ",vault.yieldFeeBalance());console.log("Yield fee: ",yieldFee);// yield fee: 4999999999999950000// alice mint: 100000000000000000000assertEq(vault.totalAssets(),100e18+100e18-amountOut);// existing balance + yield - amountOutassertEq(vault.totalSupply(),100e18);// no change in supply since liquidation was for assetsassertEq(vault.totalDebt(),100e18+yieldFee);// debt increased since we reserved shares for the yield feevm.startPrank(bob);vault.claimYieldFeeShares(1e17);console.log("Accrued yield got reset to 0: ",vault.yieldFeeBalance());console.log("But the shares minted to Bob (yield fee recipient) should be 4.9e18 but he only has 1e17 and the rest is lost: ",vault.balanceOf(bob));// shares bob: 100000000000000000assertEq(vault.totalDebt(),vault.totalSupply());assertEq(vault.yieldFeeBalance(),0);vm.stopPrank();}
Testlogsandresults:Logs:SharesbalanceofAlicepostmint:100000000000000000000AccruedyieldinthecontracttobeclaimedbyBob:4999999999999950000Yieldfee:4999999999999950000Accruedyieldgotresetto0:0ButthesharesmintedtoBob(yieldfeerecipient)shouldbe4.9e18butheonlyhas1e17andtherestislost:100000000000000000
Tools Used
Foundry
Recommended Mitigation Steps
Adjust theclaimYieldFeeSharesto only deduct the amount claimed/minted:
function claimYieldFeeShares(uint256 _shares) external onlyYieldFeeRecipient {if (_shares == 0) revert MintZeroShares();-  uint256 _yieldFeeBalance = yieldFeeBalance;-  if (_shares > _yieldFeeBalance) revert SharesExceedsYieldFeeBalance(_shares, _yieldFeeBalance);+  if (_shares > yieldFeeBalance) revert SharesExceedsYieldFeeBalance(_shares, yieldFeeBalance);-  yieldFeeBalance -= _yieldFeeBalance;+  yieldFeeBalance -= _shares;_mint(msg.sender, _shares);emit ClaimYieldFeeShares(msg.sender, _shares);}
trmid (PoolTogether) confirmed and commented:
Mitigatedhere.