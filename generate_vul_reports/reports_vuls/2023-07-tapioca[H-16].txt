[H-16] Attacker can block LayerZero channel due to variable gas cost of saving payload
Submitted bywindhustler
https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/BaseUSDO.sol#L399
https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/BaseTOFT.sol#L442
https://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/tokens/BaseTapOFT.sol#L52
This is an issue that affectsBaseUSDO,BaseTOFT, andBaseTapOFTor all the contracts which are sending and receiving LayerZero messages.
The consequence of this is that anyone can with low cost and high frequency keep on blocking the pathway between any two chains, making the whole system unusable.
Proof of Concept
I will illustrate the concept of blocking the pathway on the example of sending a message throughBaseTOFT’ssendToYAndBorrow.
This function allows the user to mint/borrowUSDOwith some collateral that is wrapped in aTOFTand gives the option of transferring mintedUSDOto another chain.
The attack starts by invokingsendToYBAndBorrowwhich delegate calls intoBaseTOFTMarketModule.
If we look at the implementation inside theBaseTOFTMarketModulenothing is validated there except for thelzPayloadwhich has the packetType ofPT_YB_SEND_SGL_BORROW.
The only validation of the message happens inside theLzAppwith the configuration which was set.
What is restrained within this configuration is thepayload size, which if not configured defaults to10k bytes.
The application architecture was set up in a way that all the messages regardless of their packetType go through the same_lzSendimplementation.
I’m mentioning that because it means that if the project decides to change the default payload size to something smaller(or bigger) it will be dictated by the message with the biggest possible payload size.
I’ve mentioned theminimum gas enforcement in my other issuebut even if that is fixed and a high min gas is enforced this is another type of issue.
To execute the attack we need to pass the following parameters to the function mentioned above:
functionexecuteAttack()public{addresstapiocaOFT=makeAddr("TapiocaOFT-AVAX");tapiocaOFT.sendToYBAndBorrow{value:enough_gas_to_go_through}(addressfrom=>// malicious user addressaddressto=>// malicious user addresslzDstChainId=>// any chain lzChainIdbytescalldataairdropAdapterParams=>// encode in a way to send to remote with minimum gas enforced by the layer zero configurationITapiocaOFT.IBorrowParamscalldataborrowParams,// can be anythingICommonData.IWithdrawParamscalldatawithdrawParams,// can be anythingICommonData.ISendOptionscalldataoptions,// can be anythingICommonData.IApproval[]calldataapprovals// Elaborating on this below)}
ICommonData.IApproval[] calldata approvalsare going to be fake data somax payload size limit is reached(10k). Thetargetof the 1st approval in the array will be theGasDrainingContractdeployed on the receiving chain and thepermitBorrow = true.
contractGasDrainingContract{mapping(uint256=>uint256)publicstorageVariables;functionpermitBorrow(addressowner,addressspender,uint256value,uint256deadline,uint8v,bytes32r,bytes32s)external{for(uint256i=0;i<100000;i++) {storageVariables[i] =i;}}}
Let’s take an example of an attacker sending a transaction on the home chain which specifies a 1 million gasLimit for the destination transaction.
Transaction is successfully received inside thelzReceiveafter which it reaches_blockingLzReceive.This is the first external call and according toEIP-150out of 1 million gas:63/64 or ~985k would be forwarded to the external call.1/64 or ~15k will be left for the rest of the execution.The cost of saving a big payload into thefailedMessagesand emitting events is higher than 15k.
When it comes to 10k bytes it is around 130k gas but even with smaller payloads, it is still significant. It can be tested with the following code:
// SPDX-License-Identifier: Unlicensepragmasolidity^0.8.19;import"forge-std/Test.sol";import"forge-std/console.sol";contractFailedMessagesTestisTest{mapping(uint16=>mapping(bytes=>mapping(uint64=>bytes32)))publicfailedMessages;eventMessageFailed(uint16_srcChainId,bytes_srcAddress,uint64_nonce,bytes_payload,bytes_reason);functionsetUp()public{}functiontestFMessagesGas()public{uint16srcChainid=1;bytesmemorysrcAddress=abi.encode(makeAddr("Alice"));uint64nonce=10;bytesmemorypayload=getDummyPayload(9999);// max payload size someone can send is 9999 bytesbytesmemoryreason=getDummyPayload(2);uint256gasLeft=gasleft();_storeFailedMessage(srcChainid,srcAddress,nonce,payload,reason);emitlog_named_uint("gas used",gasLeft-gasleft());}function_storeFailedMessage(uint16_srcChainId,bytesmemory_srcAddress,uint64_nonce,bytesmemory_payload,bytesmemory_reason)internalvirtual{failedMessages[_srcChainId][_srcAddress][_nonce] =keccak256(_payload);emitMessageFailed(_srcChainId,_srcAddress,_nonce,_payload,_reason);}functiongetDummyPayload(uint256payloadSize)internalpurereturns(bytesmemory) {bytesmemorypayload=newbytes(payloadSize);for(uint256i=0;i<payloadSize;i++) {payload[i] =bytes1(uint8(65+i));}returnpayload;}}
If the payload is 9999 bytes the cost of saving it and emitting the event is 131k gas.Even with a smaller payload of 500 bytes the cost is 32k gas.If we can drain the 985k gas in the rest of the execution since storingfailedMessageswould fail the pathway would be blocked because this will fail at the level of LayerZero and result inStoredPayload.Let’s continue the execution flow just to illustrate how this would occur, inside the implementation for_nonblockingLzReceivethe_executeOnDestinationis invoked for the right packet type and there we have anotherexternal callwhich delegatecalls into the right module.
Since it is also an external call only 63/64 gas is forwarded which is roughly:
970k would be forwarded to the module15k reserved for the rest of the functionThis 970k gas is used forborrow, and it would be totally drained inside ourmalicious GasDraining contract from above, and then the execution would continue inside theexecuteOnDestinationwhich also fails due to 15k gas not being enough, and finally, it fails inside the_blockingLzReceivedue to out of gas, resulting in blocked pathway.
Tools Used
Foundry
Recommended Mitigation Steps
_executeOnDestinationstoring logicis just code duplication and serves no purpose.
Instead of that you should override the_blockingLzReceive.
Create a new storage variable calledgasAllocationwhich can be set only by the owner and change the implementation to:
(boolsuccess,bytesmemoryreason) =address(this).excessivelySafeCall(gasleft() -gasAllocation,150,abi.encodeWithSelector(this.nonblockingLzReceive.selector,_srcChainId,_srcAddress,_nonce,_payload));
While ensuring thatgasleft() > gasAllocationin each and every case. This should be enforced on the sending side.
Now this is tricky because as I have shown the gas cost of storing payload varies with payload size meaning thegasAllocationneeds to be big enough to cover storing max payload size.
Other occurrences
This exploit is possible with all the packet types which allow arbitrary execution of some code on the receiving side with something like I showed with theGasDrainingContract. Since almost all packets allow this it is a common issue throughout the codebase, but anyway listing below where it can occur in various places:
BaseTOFThttps://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L205https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTMarketModule.sol#L204https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTLeverageModule.sol#L111https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L221https://github.com/Tapioca-DAO/tapiocaz-audit/blob/master/contracts/tOFT/modules/BaseTOFTOptionsModule.sol#L118BaseUSDOhttps://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L191https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L190https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOMarketModule.sol#L104https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOLeverageModule.sol#L93https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L206https://github.com/Tapioca-DAO/tapioca-bar-audit/blob/master/contracts/usd0/modules/USDOOptionsModule.sol#L103BaseTapOFThttps://github.com/Tapioca-DAO/tap-token-audit/blob/main/contracts/tokens/BaseTapOFT.sol#L225Here we would need to passIERC20[] memory rewardTokensas an array of one award token which is our malicious token which implements theERC20andISendFrominterfaces.
Since inside thetwTap.claimAndSendRewards(tokenID, rewardTokens)there are no reverts in case therewardTokenis
invalid we can execute the gas draining attack inside thesendFromwherebyrewardTokens[i]is our malicious contract.
0xRektora (Tapioca) confirmed