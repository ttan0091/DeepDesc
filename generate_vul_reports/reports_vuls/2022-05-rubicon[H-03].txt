[H-03] Attacker could steal almost all the bonus tokens in BathBuddy Vesting Wallet
Submitted by xiaoming90, also found by 0x52, PP1004, shenwilly, andsashiketh_
BathBuddy is a Vesting Wallet that payout withdrawers anybonusTokensthey may have accrued while staking in the Bath Token (e.g. network incentives/governance tokens).
BathBuddy Vesting Wallet releases a user their relative share of the pool’s total vested bonus token during the withdraw call on BathToken.sol. This vesting occurs linearly over Unix time.
It was observed that an attacker could steal almost all thebonusTokensin the BathBuddy Vesting Wallet.
Proof of Concept
The root cause of this issue is that the amount ofbonusTokensthat a user is entitled to is based on their relative share of the pool’s total vested bonus token at the point of the withdraw call. It is calculated based on the user’s “spot” share in the pool.
Thus, it is possible for an attacker to deposit large amount of tokens into a BathToken Pool to gain significant share of the pool (e.g. 95%), and then withdraw the all the shares immediately. The withdraw call will trigger theBathToken.distributeBonusTokenRewards, and since attacker holds overwhelming amount of share in the pool, they will receive almost all thebonusTokenin the BathBuddy Vesting wallet, leaving behind dust amount ofbonusTokenin the wallet. This could be perform in an atomic transaction and attacker can leverage on flash-loan to fund this attack.
The following shows an example of this issue:
A sponsor sent 1000 DAI to the BathBuddy Vesting Wallet to be used asbonusTokensfor bathWETH pool. The vesting duration is 4 weeks.Alice and Bob deposited 50 WETH and 50 WETH respectively. The total underlying asset of bathWETH is 100 WETH after depositing. Each of them hold 50% of the shares in the pool.Fast forward to the last hour of the vesting period, most of thebonusTokenhave been vested and ready for the recipients to claim. In this example, estimate 998 DAI are ready to be claimed at the final hour.Since Alice has 50% stake in the pool, she should have accured close to 449 DAI at this point. If she decided to withdraw all her bathWETH LP tokens at this point, she would receive close to 449 DAI asbonusTokens. But she choose not to withdraw yet.Unfortunately, an attacker performed a flash-loan to borrow 8500 WETH, and deposit large amount of WETH into the bathWETH gain significant share of the pool, and then withdraw the all the shares immediately.Since attacker hold the an overwhelming amount of shares in the pool, they will receive almost all thebonusToken(around 997 DAI) in the BathBuddy Vesting wallet, leaving behind dust amount ofbonusTokenin the wallet.At this point, Alice decided to withdraw all her bathWETH LP token. She only received dust amount of 0.7 DAI asbonusTokens
The following code shows that the amount ofbonusTokensa user is entitled is based on the user’s current share in the pool -amount = releasable * sharesWithdrawn/initialTotalSupply.
https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/peripheral_contracts/BathBuddy.sol#L87
/// @inheritdoc IBathBuddy/// @dev Added and modified release function. Should be the only callable release functionfunctionrelease(IERC20token,addressrecipient,uint256sharesWithdrawn,uint256initialTotalSupply,uint256poolFee)externaloverride{require(msg.sender==beneficiary,"Caller is not the Bath Token beneficiary of these rewards");uint256releasable=vestedAmount(address(token),uint64(block.timestamp)) -released(address(token));if(releasable>0) {uint256amount=releasable.mul(sharesWithdrawn).div(initialTotalSupply);uint256_fee=amount.mul(poolFee).div(10000);..SNIP..uint256amountWithdrawn=amount.sub(_fee);token.transfer(recipient,amountWithdrawn);_erc20Released[address(token)] +=amount;..SNIP..}}
Test Scripts
Following is the test output that demonstrates the above scenario:
Contract:RubiconExchangeandPoolsOriginalTestsDeployment✓isdeployed(1783ms)BathHouseInitializationofBathPairandBathTokens✓BathHouseisdeployedandinitialized(66ms)newbathWETH!0x237eda6f0102c1684caEbA3Ebd89e26a79258C6f✓WETHBathTokenforWETHassetisdeployedandinitialized(131ms)✓InitBathBuddyVestingWalletandAddBathBuddytoWETHBathTokenPool(54ms)✓BathPairisdeployedandinitializedw/BathHouse(59ms)undefined✓Alicedeposit50WETHtoWETHbathTokens(137ms)undefined✓Bobdeposit50WETHtoWETHbathTokens(174ms)bathAssetInstance.bonusTokens.length=1bathBuddyInstance(VestingWallet)has1000DAIbathBuddyInstance.vestedAmount(DAI) =0.000413359788359788bathBuddyInstance.vestedAmount(DAI) =500.000413359788359788(Endof2ndweek)bathBuddyInstance.vestedAmount(DAI) =998.512318121693121693(Lasthourofthevestingperiod)0DAIhasbeenreleasedfromBathBuddyVestingWalletCharleshas8500bathWETHtoken,0DAI,0WETHCharleswithdrawallhisbathWETHtokens997.338978147402060445DAIhasbeenreleasedfromBathBuddyVestingWalletCharleshas0bathWETHtoken,997.039776453957839827DAI,8497.45WETHAlicehas5bathWETHtoken,0DAI,0WETH998.075233164534207763DAIhasbeenreleasedfromBathBuddyVestingWalletAlicehas0bathWETHtoken,0.736034140627007674DAI,6.2731175WETH✓AddRewards(100DAI)toBathBuddyVestingWallet(749ms)bathAssetInstance:underlyingBalance() =6.2768825WETH,balanceOf=6.2768825WETH,OutstandingAmount=0WETH✓ [Debug]
Attacker Charles deposited 8500 WETH to the pool and withdraw them immediately at the final hour, and obtained almost all of thebonusTokens(997 DAI). When Alice withdraw from the pool, she only received 0.7 DAI asbonusTokens.
Script can be foundhttps://gist.github.com/xiaoming9090/2252f6b6f7e62fca20ecfbaac6f754f5
Note: Due to some unknown issue with the testing environment, please create a newBathBuddy.released2functions to fetch the amount of token already released.
Impact
Loss of Fund for the users. BathToken LPs not able to receive the accuredbonusTokenthat they are entitled to.
Recommended Mitigation Steps
Update the reward mechanism to ensure that thebonusTokensare distribute fairly and rewards of each user are accured correctly.
In the above example, since Alice holds 50% of the shares in the pool throughout the majority of the reward period, she should be entitled to close to 50% to the rewards/bonus. Anyone who joins the pool at the last hour of the reward period should only be entitled to dust amount ofbonusToken.
Additionally, “spot” (or current) share of the pool should not be used to determine the amount ofbonusTokena user is entitled to as it is vulnerable to pool/share manipulation or flash-loan attack. Checkpointing mechanism should be implemented so that at the minimum, the user’s amount of share in the previous block is used for determining the rewards. This make flash-loan attack infeasible as such attack has to happen within the same block/transaction.
For distributing bonus/rewards, I would suggest checking out a widely referencedSynthetix’s RewardContract as I think that it would be more relevant than OZ’s Vesting Wallet for this particular purpose.
bghughes (Rubicon) confirmed
HickupHH3 (judge) commented:
Great writeup and POC from the warden!#71is a little similar, but instead of a flash loan, uses a different method of repeated deposits and withdrawals to achieve the same result.Because of the higher quality of this report, I’m using it as the primary issue.