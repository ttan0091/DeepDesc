[H-09] Malicious User Could Burn The Assets After A Successful Migration
Submitted by xiaoming90, also found by 0x52, cccz, codexploder, hyh, kenzo, Lambda, oyc_109, and zzzitron
https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L334
https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L358
https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L383
Background
The following describes the migration process for a vault.
Assume that Alice is the proposer.Alice callsMigration.proposeto propose a set of modules and plugins to migrate a vault toOther contributors could join a migration proposal by contributing ether and fractional tokens by callingMigration.join.Alice callsMigration.committo kick off the buyout process for a migration after the proposal period (7 days)If the buyout is successful, Alice calls theMigration.settleVaultto settle a migration. Within this function,  a new vault with new set permissions and plugins will be deployed.Alice calls theMigration.settleFractionsto mint the fractional tokens for a new vault.Contributors who earlier joined the migration proposal could call theMigration.migrateFractionsto migrate their fractional tokens from the old vault to the new vault.Finally, Alice will callMigration.migrateVaultERC20,Migration.migrateVaultERC721, and/orMigration.migrateVaultERC1155to transfer the ERC20, ERC721 (NFT), and/or ERC1155 tokens from the old vault to the new vault.
Vulnerability Details
It was observed that after a successful vault migration, an attacker couldMigration.migrateVaultERC20,Migration.migrateVaultERC721, and/orMigration.migrateVaultERC1155with an invalid_proposalIdparameter, causing the assets within the vault to be burned.
Proof of Concept
The PoC forMigration.migrateVaultERC20,Migration.migrateVaultERC721, and/orMigration.migrateVaultERC1155is the same. Thus, only the PoC forMigration.migrateVaultERC721is shown below, and the PoC formigrateVaultERC20andmigrateVaultERC1155are omitted for brevity.
Assume that the following:
vault Aholds only one (1) APE ERC721 NFTAlice proposes to migratevault Ato a new vault, and the buyout is successful.Alice proceeds to callMigration.settleVaultto settle a migration, followed byMigration.settleFractionsto mint the fractional tokens for a new vault.An attacker callsMigration.migrateVaultERC721(vault A, invalid_proposal_id, ape_nft_address, ape_nft_tokenId, erc721TransferProof)with an invalid proposal ID (proposal ID that does not exist).Within theMigration.migrateVaultERC721function, thenewVault = migrationInfo[_vault][_proposalId].newVaultwill evaluate to zero. This is because the_proposalIdis a non-existent index in themigrationInfoarray, so it will point to an address space that has not been initialised yet. Thus, the valuezerowill be returned, andnewVaultwill be set toaddress(0).Next, theMigration.migrateVaultERC721function will attempt to transfer the ERC721 NFT from the old vault (_vault) to the new vault (newVault) by callingIBuyout(buyout).withdrawERC721. SincenewVaultis set toaddress(0), this will cause the ERC721 NFT to be sent toaddress(0), which effectively burns the NFT.
https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Migration.sol#L358
/// @notice Migrates an ERC-721 token to the new vault after a successful migration/// @param _vault Address of the vault/// @param _proposalId ID of the proposal/// @param _token Address of the ERC-721 token/// @param _tokenId ID of the token/// @param _erc721TransferProof Merkle proof for transferring an ERC-721 tokenfunctionmigrateVaultERC721(address_vault,uint256_proposalId,address_token,uint256_tokenId,bytes32[]calldata_erc721TransferProof)external{addressnewVault=migrationInfo[_vault][_proposalId].newVault;// Withdraws an ERC-721 token from the old vault and transfers to the new vaultIBuyout(buyout).withdrawERC721(_vault,_token,newVault,_tokenId,_erc721TransferProof);}
Additional Note #1 - AboutBuyout.withdrawERC721
When a user proposes a migration, the user will kick off the buyout process after the proposal period. TheMigrationmodule will initiate the buyout on behalf of the user. Thus, the proposer of this buyout, in this case, would be theMigrationmodule. WheneverBuyout.withdrawERC721function is called, it will verify thatmsg.senderis equal to theproposerto ensure that only the proposer who is the auction winner can migrate the assets from old vault to new vault.
In this example, the attacker has access toMigration.migrateVaultERC20,Migration.migrateVaultERC721, and/orMigration.migrateVaultERC1155functions that effectively instruct theMigrationmodule to perform the withdrawal. In this case, it will pass theif (msg.sender != proposer) revert NotWinner();validation within theBuyout.withdrawERC721because themsg.senderis theMigrationcontract who initiates the buyout at the start.
https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/modules/Buyout.sol#L343
functionIBuyout(buyout).withdrawERC721(address_vault,address_token,address_to,uint256_tokenId,bytes32[]calldata_erc721TransferProof)external{// Reverts if address is not a registered vault(,uint256id) =IVaultRegistry(registry).vaultToToken(_vault);if(id==0)revertNotVault(_vault);// Reverts if auction state is not successful(,addressproposer,Statecurrent, , , ) =this.buyoutInfo(_vault);Staterequired=State.SUCCESS;if(current!=required)revertInvalidState(required,current);// Reverts if caller is not the auction winnerif(msg.sender!=proposer)revertNotWinner();// Initializes vault transactionbytesmemorydata=abi.encodeCall(ITransfer.ERC721TransferFrom,(_token,_vault,_to,_tokenId));// Executes transfer of ERC721 token to caller..SNIP..}
Additional Note #2 - Can we send NFT to address(0)?
Yes, it is possible to send NFT toaddress(0).
If the ERC721 NFT contract usesOpenzeppelin’s ERC721 contractorSolmate’s ERC721 contract, then the NFT cannot be sent toaddress(0)because the contracts have implemented validation check to ensure that thetoaddress is notaddress(0).
However, not all the ERC721 NFT contracts use Openzeppelin or Solmate ERC721 implementation. Therefore, there will be a large number of custom implementations that allow NFT to be transferred toaddress(0).
The same theory applies to ERC20 and ERC1155 implementations.
Impact
Loss of assets for the users as the assets that they own can be burned by an attacker after a successful migration.
Recommended Mitigation Steps
It is recommended to implement additional validation to ensure that the_proposalIdsubmitted is valid.
Consider checking ifnewVaultpoints to a valid vault address before transferring the assets from old vault to new vault.
function migrateVaultERC721(address _vault,uint256 _proposalId,address _token,uint256 _tokenId,bytes32[] calldata _erc721TransferProof) external {address newVault = migrationInfo[_vault][_proposalId].newVault;+    if (newVault == address(0)) reverts VaultDoesNotExistOrInvalid;// Withdraws an ERC-721 token from the old vault and transfers to the new vaultIBuyout(buyout).withdrawERC721(_vault,_token,newVault,_tokenId,_erc721TransferProof);}
In the above implementation, if anyone attempts to submit an invalid_proposalId, thenewVaultwill be set to address(0). The newly implemented validation will detect the abnormal behavior and revert the transaction.
For defense-in-depth, perform additional validation to ensure that the_toaddress is notaddress(0)within theBuyout.withdrawERC721function.
function withdrawERC721(address _vault,address _token,address _to,uint256 _tokenId,bytes32[] calldata _erc721TransferProof) external {// Reverts if address is not a registered vault(, uint256 id) = IVaultRegistry(registry).vaultToToken(_vault);if (id == 0) revert NotVault(_vault);+   if (_to == 0) revert ToAddressIsZero();// Reverts if auction state is not successful(, address proposer, State current, , , ) = this.buyoutInfo(_vault);State required = State.SUCCESS;if (current != required) revert InvalidState(required, current);// Reverts if caller is not the auction winnerif (msg.sender != proposer) revert NotWinner();// Initializes vault transactionbytes memory data = abi.encodeCall(ITransfer.ERC721TransferFrom,(_token, _vault, _to, _tokenId));// Executes transfer of ERC721 token to callerIVault(payable(_vault)).execute(transfer, data, _erc721TransferProof);}
The same validation checks should be implemented onmigrateVaultERC20,migrateVaultERC1155,withdrawERC20andwithdrawERC1155
stevennevins (Fractional) confirmed
HardlyDifficult (judge) commented:
migrateVaultERC20could transfer assets to address(0). ERC721 and 1155 standards require revert when to is address(0), but this is not required by the ERC20 standard. This could be triggered by calling migrate with an invalidproposalId. Agree this is a High risk issue.Selecting this submission as the primary report for clearly outlining the potential high risk scenario here.