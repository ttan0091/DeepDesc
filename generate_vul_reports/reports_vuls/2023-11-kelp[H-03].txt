[H-03] The price of rsETH could be manipulated by the first staker
Submitted byKrace, also found bySBSecurity,spark,adriro,Madalad,peanuts,adam-idarrha,Phantasmagoria,Aymen0909,CatsSecurity,SandNallani,chaduke,AlexCzm,deth,bronze_pickaxe,osmanozdemir1,ast3ros,zach,m_Rassska,jasonxiale,mahyar,pep7siup,twcctop,ck,joaovwfreire,GREY-HAWK-REACH,0xDING99YA,zhaojie,qpzm,TheSchnilch,gumgumzum,QiuhaoLi,0xrugpull_detector,Aamir,almurhasan,ayden,wisdomn_,peter,max10afternoon,rouhsamad,SpicyMeatball,rvierdiiev,crack-the-kelp,Ruhum,ke1caM,ptsanev,mahdirostami,Banditx0x,critical-or-high,T1MOH,ubl4nk,Bauer, andbtk
https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/LRTDepositPool.sol#L95-L110https://github.com/code-423n4/2023-11-kelp/blob/c5fdc2e62c5e1d78769f44d6e34a6fb9e40c00f0/src/LRTOracle.sol#L52-L79
The first staker can potentially manipulate the price of rsETH through a donation attack, causing subsequent stakers to receive no rsETH after depositing. The first staker can exploit this method to siphon funds from other users.
Proof of Concept
The mining amount of rsETH is calculated in functiongetRsETHAmountToMintwhich directly utilizes the total value of the asset divided by the price of a single rsETH.
functiongetRsETHAmountToMint(addressasset,uint256amount)publicviewoverridereturns(uint256rsethAmountToMint){// setup oracle contractaddresslrtOracleAddress=lrtConfig.getContract(LRTConstants.LRT_ORACLE);ILRTOraclelrtOracle=ILRTOracle(lrtOracleAddress);// calculate rseth amount to mint based on asset amount and asset exchange ratersethAmountToMint= (amount*lrtOracle.getAssetPrice(asset)) /lrtOracle.getRSETHPrice();}
Subsequently, the price of rsETH is related to its totalSupply and the total value of deposited assets.
functiongetRSETHPrice()externalviewreturns(uint256rsETHPrice) {addressrsETHTokenAddress=lrtConfig.rsETH();uint256rsEthSupply=IRSETH(rsETHTokenAddress).totalSupply();if(rsEthSupply==0) {return1ether;}uint256totalETHInPool;addresslrtDepositPoolAddr=lrtConfig.getContract(LRTConstants.LRT_DEPOSIT_POOL);address[]memorysupportedAssets=lrtConfig.getSupportedAssetList();uint256supportedAssetCount=supportedAssets.length;for(uint16asset_idx;asset_idx<supportedAssetCount;) {addressasset=supportedAssets[asset_idx];uint256assetER=getAssetPrice(asset);uint256totalAssetAmt=ILRTDepositPool(lrtDepositPoolAddr).getTotalAssetDeposits(asset);totalETHInPool+=totalAssetAmt*assetER;unchecked{++asset_idx;}}//@audit the price of rsETH is calculated based on the asset and totalSupplyreturntotalETHInPool/rsEthSupply;}
The total value of deposited assets comprises three parts: the assets inLRTDepositPool, the assets inNodeDelagator, and the assets in the eigenlayer. Anyone can directly contribute asset tokens toLRTDepositPoolorNodeDelegatorto augment the total value of deposited assets.
functiongetAssetDistributionData(addressasset)publicviewoverrideonlySupportedAsset(asset)returns(uint256assetLyingInDepositPool,uint256assetLyingInNDCs,uint256assetStakedInEigenLayer){// Question: is here the right place to have this? Could it be in LRTConfig?assetLyingInDepositPool=IERC20(asset).balanceOf(address(this));uint256ndcsCount=nodeDelegatorQueue.length;for(uint256i;i<ndcsCount;) {assetLyingInNDCs+=IERC20(asset).balanceOf(nodeDelegatorQueue[i]);assetStakedInEigenLayer+=INodeDelegator(nodeDelegatorQueue[i]).getAssetBalance(asset);unchecked{++i;}}}
Case
Therefore, the price of rsETH is susceptible to manipulation by the first staker, considering the following scenario:
Alice is the first staker and she deposits 1 USDC (the price of USDC is set to $1), she will get 1 wei rsETH, and the totalSupply of rsETH is 1 wei.
Here is the test, add it totest/LRTDepositPoolTest.t.soland run withforge test --match-test test_ControlPrice -vv.
diff --git a/test/LRTDepositPoolTest.t.sol b/test/LRTDepositPoolTest.t.solindex 40abc93..63349c2 100644--- a/test/LRTDepositPoolTest.t.sol+++ b/test/LRTDepositPoolTest.t.sol@@ -9,10 +9,11 @@ import { ILRTDepositPool } from "src/interfaces/ILRTDepositPool.sol";import { TransparentUpgradeableProxy } from "@openzeppelin/contracts/proxy/transparent/TransparentUpgradeableProxy.sol";import { ProxyAdmin } from "@openzeppelin/contracts/proxy/transparent/ProxyAdmin.sol";+import "forge-std/console.sol";contract LRTOracleMock {function getAssetPrice(address) external pure returns (uint256) {-        return 1e18;+        return 1;}function getRSETHPrice() external pure returns (uint256) {@@ -109,6 +110,23 @@ contract LRTDepositPoolDepositAsset is LRTDepositPoolTest {lrtDepositPool.depositAsset(rETHAddress, 2 ether);}+    function test_ControlPrice() external {+        vm.startPrank(alice);++        // alice balance of rsETH before deposit+        uint256 aliceBalanceBefore = rseth.balanceOf(address(alice));++        rETH.approve(address(lrtDepositPool), 1 ether);+        lrtDepositPool.depositAsset(rETHAddress, 1 ether);++        // alice balance of rsETH after deposit+        uint256 aliceBalanceAfter = rseth.balanceOf(address(alice));+        vm.stopPrank();++        console.log(" rsETH of Alice: ", aliceBalanceAfter - aliceBalanceBefore);++    }+function test_DepositAsset() external {vm.startPrank(alice);
Alice donates 10000 USDC to theLRTDepositPoolto inflate the price of rsETH. Now the price of rsETH is: (10000 + 1)ether / 1 wei = 10001 etherAny subsequent staker who deposits assets worth less than 10001 USDC will not receive any rsETH, and they wonâ€™t be able to withdraw the deposited assets either. Alice can directly siphon off these funds.
For example, if Bob deposit 10000 USDC, then thersethAmountToMintis(10000 ether * 1) / (10001)ether = 0
rsethAmountToMint = (amount * lrtOracle.getAssetPrice(asset)) / lrtOracle.getRSETHPrice();
Moreover, there is no check on the actual amount of rsETH received by the user, and the execution continues even if this amount is zero.
function _mintRsETH(address _asset, uint256 _amount) private returns (uint256 rsethAmountToMint) {(rsethAmountToMint) = getRsETHAmountToMint(_asset, _amount);address rsethToken = lrtConfig.rsETH();// mint rseth for user//@audit sender could receive 0 tokenIRSETH(rsethToken).mint(msg.sender, rsethAmountToMint);}
Recommended Mitigation Steps
It is recommended to pre-mint some rsETH tokens to prevent price manipulation or ensure that thersethAmountToMintis greater than zero.
gus (Kelp) disagreed with severity and commented:
We agree this is an issue. We also agree that it should be of a MEDIUM severity as it is an edge case that happens on the first protocol interaction.
manoj9april (Kelp) confirmed
0xDjango (judge) commented:
Judging as HIGH. While it is an edge case, the potential loss of funds is present. Vault donation attacks have been judged as high in the majority of C4 audits where no safeguards are implemented.
manoj9april (Kelp) commented:
Initial minting is a way of mitigating this issue. And this mitigation could be done after deployment. Hence no safeguard were added in contract. Hence request to decrease to medium.
0xDjango (judge) commented:
Initial minting is a way of mitigating this issue. And this mitigation could be done after deployment. Hence no safeguard were added in contract. Hence request to decrease to medium.Based on the implementation, this issue will remain HIGH. Funds are at risk until Kelp takes subsequent action to mitigate.
gus (Kelp) confirmed and commented:
We disagree with the severity of this issue. Every protocol has to setup the contracts first before publicizing that contracts are ready for public usage. We take measures to ensure the exchange rate is closer to 1 before users interact with contracts.