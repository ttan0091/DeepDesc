[H-09]ReLPContractwrongfully assumes protocol owns all of the liquidity in the UniswapV2 pool
Submitted bydeadrxsezzz, also found bykutugu,said,QiuhaoLi,0xMango,pep7siup, and0xDING99YA
Possible full DoS forReLPContract
Proof of Concept
When taking out abondinRdpxV2CoreifisReLPActive == true, a call toReLPContract#reLPis made which ‘re-LPs the pool` (takes out an amount of RDPX, while still perfectly maintaining the token ratio of the pool).
(uint256reserveA,uint256reserveB) =UniswapV2Library.getReserves(// @audit - here it gets the reserves of the pool and assumes them as owned by the protocoladdresses.ammFactory,tokenASorted,tokenBSorted);TokenAInfomemorytokenAInfo=TokenAInfo(0,0,0);// get tokenA reservestokenAInfo.tokenAReserve=IRdpxReserve(addresses.tokenAReserve).rdpxReserve();// rdpx reserves// get rdpx pricetokenAInfo.tokenAPrice=IRdpxEthOracle(addresses.rdpxOracle).getRdpxPriceInEth();tokenAInfo.tokenALpReserve=addresses.tokenA==tokenASorted?reserveA:reserveB;uint256baseReLpRatio= (reLPFactor*Math.sqrt(tokenAInfo.tokenAReserve) *1e2) / (Math.sqrt(1e18));// 1e6 precisionuint256tokenAToRemove= ((((_amount*4) *1e18) /tokenAInfo.tokenAReserve) *tokenAInfo.tokenALpReserve*// @audit - here the total RDPX reserve in the pool is assumed to be owned by the protocolbaseReLpRatio) / (1e18*DEFAULT_PRECISION*1e2);uint256totalLpSupply=IUniswapV2Pair(addresses.pair).totalSupply();uint256lpToRemove= (tokenAToRemove*totalLpSupply) /tokenAInfo.tokenALpReserve;
The problem is that the protocol wrongfully assumes that it owns all of the liquidity within the pool. This leads to faulty calculations. In best case scenario wrong amounts are passed. However, when the protocol doesn’t own the majority of the pool LP balance, this could lead to full DoS, aslpToRemovewill be calculated to be more than the LP balance ofUniV2LiquidityAmoand the transaction will revert.
This can all be easily proven by a simple PoC (add the test to the givenPeriphery.t.sol)
Note: there’s an addedconsole.loginReLPContract#reLP, just before thetransferFromin order to better showcase the issue
uint256lpToRemove= (tokenAToRemove*totalLpSupply) /tokenAInfo.tokenALpReserve;console.log("lpToRemove value:    ",lpToRemove);// @audit - added console.log to prove the underflow// transfer LP tokens from the AMOIERC20WithBurn(addresses.pair).transferFrom(addresses.amo,address(this),lpToRemove);
functiontestReLpContract()public{testV2Amo();// set address in reLP contract and grant rolereLpContract.setAddresses(address(rdpx),address(weth),address(pair),address(rdpxV2Core),address(rdpxReserveContract),address(uniV2LiquidityAMO),address(rdpxPriceOracle),address(factory),address(router));reLpContract.grantRole(reLpContract.RDPXV2CORE_ROLE(),address(rdpxV2Core));reLpContract.setreLpFactor(9e4);// add liquidityuniV2LiquidityAMO.addLiquidity(5e18,1e18,0,0);uniV2LiquidityAMO.approveContractToSpend(address(pair),address(reLpContract),type(uint256).max);rdpxV2Core.setIsreLP(true);(uint256reserveA,uint256reserveB, ) =pair.getReserves();weth.mint(address(2),reserveB*10);rdpx.mint(address(2),reserveA*10);vm.startPrank(address(2));weth.approve(address(router),reserveB*10);rdpx.approve(address(router),reserveA*10);router.addLiquidity(address(rdpx),address(weth),reserveA*10,reserveB*10,0,0,address(2),12731316317831123);vm.stopPrank();console.log("UniV2Amo balance isn't enough and will underflow");uintpairBalance=pair.balanceOf(address(uniV2LiquidityAMO));console.log("UniV2Amo LP balance: ",pairBalance);vm.expectRevert("ds-math-sub-underflow");rdpxV2Core.bond(1*1e18,0,address(this));}
And the logs:
[PASS] testReLpContract() (gas: 3946961)Logs:UniV2Amo balance isn't enough and will underflowUniV2Amo LP balance:  2235173550604750304lpToRemove value:     17832559500122488916
Recommended Mitigation Steps
Change the logic and base all calculations on the pair balance ofUniV2LiquidityAmo
psytama (Dopex) confirmed and commented:
The re-LP formula used is incorrect.
Alex the Entreprenerd (Judge) commented:
The incorrect assumption does indeed cause reverts.