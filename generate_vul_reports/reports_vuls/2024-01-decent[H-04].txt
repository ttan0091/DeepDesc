[H-04] Users will lose their cross-chain transaction if the destination router do not have enough WETH reserves.
Submitted byhaxatron, also found byEV_om,MrPotatoMagic,deth,rouhsamad,Aamir,Topmark, andbart1e
When the DecentEthRouter receives the dcntEth OFT token from a cross-chain transaction, if the WETH balance of the destination router is less than amount of dcntEth received (this could be due to the router receiving more cross-chain transactions than than sending cross-chain transactions which depletes its WETH reserves), then the dcntEth will get transferred to the address specified by_to.
DecentEthRouter.sol#L266-L281
functiononOFTReceived(uint16_srcChainId,bytescalldata,uint64,bytes32,uint_amount,bytesmemory_payload)externaloverrideonlyLzApp{...if(weth.balanceOf(address(this)) <_amount) {=>dcntEth.transfer(_to,_amount);return;}if(msgType==MT_ETH_TRANSFER) {if(!gasCurrencyIsEth|| !deliverEth) {weth.transfer(_to,_amount);}else{weth.withdraw(_amount);payable(_to).transfer(_amount);}}else{weth.approve(address(executor),_amount);executor.execute(_from,_to,deliverEth,_amount,callPayload);}}
This dcntEth is sent to the user so that they can either redeem the WETH / ETH from the router once the WETH balance is refilled or send it back to the source chain to redeem back the WETH.
The problem is that if the msgType != MTETHTRANSFER, then the_toaddress is not the user, it is instead the target meant to be called by the destination chain’s bridge executor (if the source chain uses a decent bridge adapter, the target is always the destination chain’s bridge adapter which does not have a way to withdraw the dcntEth).
The following snippet shows what occurs in the bridge executor (_executeEthomitted as it does largely the same thing as_executeWeth):
DecentBridgeExecutor.sol#L24-L82
function_executeWeth(addressfrom,addresstarget,uint256amount,bytesmemorycallPayload)private{uint256balanceBefore=weth.balanceOf(address(this));weth.approve(target,amount);(boolsuccess, ) =target.call(callPayload);if(!success) {weth.transfer(from,amount);return;}uint256remainingAfterCall=amount-(balanceBefore-weth.balanceOf(address(this)));// refund the sender with excess WETHweth.transfer(from,remainingAfterCall);}...functionexecute(addressfrom,addresstarget,booldeliverEth,uint256amount,bytesmemorycallPayload)publiconlyOwner{weth.transferFrom(msg.sender,address(this),amount);if(!gasCurrencyIsEth|| !deliverEth) {_executeWeth(from,target,amount,callPayload);}else{_executeEth(from,target,amount,callPayload);}}
Therefore, once the dcntEth is transferred to the execution target (which is almost always the destination chain bridge adapter, see Appendix for the code walkthrough). The user cannot do anything to retrieve the dcntEth out of the execution target, so the cross-chain transaction is lost.
Recommended Mitigation Steps
Pass a destination chain refund address into the payload sent cross-chain and replace the_toaddress used inDecentEthRouter.sol#L267:
if(weth.balanceOf(address(this)) <_amount) {// REPLACE '_to' with the destination chain refund address=>dcntEth.transfer(_to,_amount);return;}
AppendixTo see why the target is always the destination bridge adapter if the source chain is a decent bridge adapter:UTB.sol will first call thebridgefunction in the adapter with the destination bridge adapter address as the 2nd argument.DecentBridgeAdapter.sol#L117C1-L124C11functionbridge(...router.bridgeWithPayload{value:msg.value}(lzIdLookup[dstChainId],destinationBridgeAdapter[dstChainId],swapParams.amountIn,false,dstGas,bridgePayload);}Which calls the below function in the router, where the_toAddressis the 2nd argument and therefore is the destination bridge adapter address:DecentEthRouter.sol#L196C1-L204C23/// @inheritdoc IDecentEthRouterfunctionbridgeWithPayload(uint16_dstChainId,address_toAddress,uint_amount,booldeliverEth,uint64_dstGasForCall,bytesmemoryadditionalPayload)publicpayable{return_bridgeWithPayload(MT_ETH_TRANSFER_WITH_PAYLOAD,_dstChainId,_toAddress,_amount,_dstGasForCall,additionalPayload,deliverEth);...which calls_bridgeWithPayloadwhich calls_getCallParamsto encode the payload to send to the destination chain:DecentEthRouter.sol#L148C1-L168C15function_bridgeWithPayload(uint8msgType,uint16_dstChainId,address_toAddress,uint_amount,uint64_dstGasForCall,bytesmemoryadditionalPayload,booldeliverEth)internal{(bytes32destinationBridge,bytesmemoryadapterParams,bytesmemorypayload) =_getCallParams(msgType,_toAddress,_dstChainId,_dstGasForCall,deliverEth,additionalPayload);...The_toAddressparameter is always the 3rd parameter in the payload sent.DecentEthRouter.sol#L101-L110function _getCallParams...if (msgType == MT_ETH_TRANSFER) {payload = abi.encode(msgType, msg.sender, _toAddress, deliverEth);} else {payload = abi.encode(msgType,msg.sender,_toAddress,deliverEth,additionalPayload);}...Which matches_tovariable inonOFTReceivedDecentEthRouter.sol#L236/// @inheritdoc IOFTReceiverV2functiononOFTReceived(uint16_srcChainId,bytescalldata,uint64,bytes32,uint_amount,bytesmemory_payload)externaloverrideonlyLzApp{(uint8msgType,address_from,address_to,booldeliverEth) =abi.decode(_payload, (uint8,address,address,bool));bytesmemorycallPayload="";if(msgType==MT_ETH_TRANSFER_WITH_PAYLOAD) {(, , , ,callPayload) =abi.decode(_payload,(uint8,address,address,bool,bytes));}...
wkantaros (Decent) confirmed but disagreed with severity
0xsomeone (Judge) commented:
This and all duplicate submissions detail an interesting way in which cross-chain relays will fail to properly invoke the target recipient of the relayed call, effectively leading to loss of funds as the assets will be transferred to an entity that potentially is not equipped to handle the token.Based on discussions in#505, this is a very likely scenario and thus a high-risk severity is appropriate as the vulnerability should manifest consistently in non-Ethereum chains.