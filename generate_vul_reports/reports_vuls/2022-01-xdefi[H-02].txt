[H-02] The reentrancy vulnerability in _safeMint can allow an attacker to steal all rewards
Submitted by cccz, also found by cmichel, Fitraldys, kenzo, onewayfunction, and tqts
There is a reentrancy vulnerability in the _safeMint function
function_safeMint(addressto,uint256tokenId,bytesmemory_data)internalvirtual{_mint(to,tokenId);require(_checkOnERC721Received(address(0),to,tokenId,_data),"ERC721: transfer to non ERC721Receiver implementer");}...function_checkOnERC721Received(addressfrom,addressto,uint256tokenId,bytesmemory_data)privatereturns(bool) {if(to.isContract()) {tryIERC721Receiver(to).onERC721Received(_msgSender(),from,tokenId,_data)returns(bytes4retval) {returnretval==IERC721Receiver.onERC721Received.selector;
The lock function changes the totalDepositedXDEFI variable after calling the _safeMint function
functionlock(uint256amount_,uint256duration_,addressdestination_)externalnoReenterreturns(uint256tokenId_) {// Lock the XDEFI in the contract.SafeERC20.safeTransferFrom(IERC20(XDEFI),msg.sender,address(this),amount_);// Handle the lock position creation and get the tokenId of the locked position.return_lock(amount_,duration_,destination_);}...function_lock(uint256amount_,uint256duration_,addressdestination_)internalreturns(uint256tokenId_) {// Prevent locking 0 amount in order generate many score-less NFTs, even if it is inefficient, and such NFTs would be ignored.require(amount_!=uint256(0) &&amount_<=MAX_TOTAL_XDEFI_SUPPLY,"INVALID_AMOUNT");// Get bonus multiplier and check that it is not zero (which validates the duration).uint8bonusMultiplier=bonusMultiplierOf[duration_];require(bonusMultiplier!=uint8(0),"INVALID_DURATION");// Mint a locked staked position NFT to the destination._safeMint(destination_,tokenId_=_generateNewTokenId(_getPoints(amount_,duration_)));// Track deposits.totalDepositedXDEFI+=amount_;
Since the updateDistribution function does not use the noReenter modifier, the attacker can re-enter the updateDistribution function in the _safeMint function. Since the value of totalDepositedXDEFI is not updated at this time, the _pointsPerUnit variable will become abnormally large.
functionupdateDistribution()external{uint256totalUnitsCached=totalUnits;require(totalUnitsCached>uint256(0),"NO_UNIT_SUPPLY");uint256newXDEFI=_toUint256Safe(_updateXDEFIBalance());if(newXDEFI==uint256(0))return;_pointsPerUnit+= ((newXDEFI*_pointsMultiplier) /totalUnitsCached);emitDistributionUpdated(msg.sender,newXDEFI);}...function_updateXDEFIBalance()internalreturns(int256newFundsTokenBalance_) {uint256previousDistributableXDEFI=distributableXDEFI;uint256currentDistributableXDEFI=distributableXDEFI=IERC20(XDEFI).balanceOf(address(this))-totalDepositedXDEFI;return_toInt256Safe(currentDistributableXDEFI)-_toInt256Safe(previousDistributableXDEFI);}
If the attacker calls the lock function to get the NFT before exploiting the reentrance vulnerability, then the unlock function can be called to steal a lot of rewards, and the assets deposited by the user using the reentrance vulnerability can also be redeemed by calling the unlock function. Since the unlock function calls the _updateXDEFIBalance function, the attacker cannot steal the assets deposited by the user
functionunlock(uint256tokenId_,addressdestination_)externalnoReenterreturns(uint256amountUnlocked_) {// Handle the unlock and get the amount of XDEFI eligible to withdraw.amountUnlocked_=_unlock(msg.sender,tokenId_);// Send the the unlocked XDEFI to the destination.SafeERC20.safeTransfer(IERC20(XDEFI),destination_,amountUnlocked_);// NOTE: This needs to be done after updating `totalDepositedXDEFI` (which happens in `_unlock`) and transferring out._updateXDEFIBalance();}...function_unlock(addressaccount_,uint256tokenId_)internalreturns(uint256amountUnlocked_) {// Check that the account is the position NFT owner.require(ownerOf(tokenId_) ==account_,"NOT_OWNER");// Fetch position.Positionstorageposition=positionOf[tokenId_];uint96units=position.units;uint88depositedXDEFI=position.depositedXDEFI;uint32expiry=position.expiry;// Check that enough time has elapsed in order to unlock.require(expiry!=uint32(0),"NO_LOCKED_POSITION");require(block.timestamp>=uint256(expiry),"CANNOT_UNLOCK");// Get the withdrawable amount of XDEFI for the position.amountUnlocked_=_withdrawableGiven(units,depositedXDEFI,position.pointsCorrection);// Track deposits.totalDepositedXDEFI-=uint256(depositedXDEFI);// Burn FDT Position.totalUnits-=units;deletepositionOf[tokenId_];emitLockPositionWithdrawn(tokenId_,account_,amountUnlocked_);}...function_withdrawableGiven(uint96units_,uint88depositedXDEFI_,int256pointsCorrection_)internalviewreturns(uint256withdrawableXDEFI_) {return(_toUint256Safe(_toInt256Safe(_pointsPerUnit*uint256(units_)) +pointsCorrection_) /_pointsMultiplier) +uint256(depositedXDEFI_);}
Proof of Concept
https://github.com/XDeFi-tech/xdefi-distribution/blob/v1.0.0-beta.0/contracts/XDEFIDistribution.sol#L253-L281
Recommended Mitigation Steps
-    function updateDistribution() external  {+    function updateDistribution() external  noReenter {
deluca-mike (XDEFI) resolved:
Valid and a big issue. However, due to other recommendations, I will not solve it this way. Instead,updateDistribution()will be called at the start of every lock/unlock function (so it canâ€™t have anoReentermodifier), and the_safeMintcalls will be moved to the end of their respective operations to prevent the effect of the re-entrancy (i.e. position will created with a_pointsPerUnitbefore a re-entering from_safeMintcan affect it). Tests will be added to show this is not longer possible.
deluca-mike (XDEFI) commented:
In our release candidate contract, as mentioned above,updateDistribution()is called before each locking and unlocking function, via aupdatePointsPerUnitAtStartmodifier, and thus,updateDistribution()is now a public fucntion, and since it is used by other functions, cannot be behind anoReenter.See:locklockWithPermitrelockunlockrelockBatchunlockBatchAlso,a test was writtento ensure that this is no longer exploitable, and that the contract behaves properly if a re-entrancy callupdateDistribution().
Ivshti (Judge) commented:
Agreed with the severity.Resolution of reordering the calls seems to be adequate