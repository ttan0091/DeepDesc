[H-20] Deadlock in vaults with underlying token with less then 18 decimals
Submitted byTointer, also found byjoestakey,gz627,Jeiwan,obront,unforgiven,rvierdiiev, andchaduke
If underlying token for the vault would have less then 18 decimals, then after liquidation there would be no way to process epoch, becauseclaimfunction inWithdrawProxy.solwould revert, this would lock all user out of their funds both in vault and in withdraw proxy. Alternatively, if there is more then 18 decimals, claim would leave much less funds than needed for withdraw, resulting in withdrawers losing funds.
To make report more concise, I would focus on tokens with less then 18 decimals, because they are much more frequent. For example, WBTC have 8 decimals and most stablecoins have 6.
Why is this happening
https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L314-L316this part making sure that withdraw ratio are always stored in 1e18 scale.
https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L271-L274but here, we are not transforming it into token decimals scale.transferAmountwould be orders of magnitudes larger than balance
https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L277then, here we would have underflow ofbalancevalue
https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L281and finally, here function would revert.
https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L156https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/PublicVault.sol#L299becausePublicVault.solneedclaimto proccess epoch, andWithdrawProxy.solunlocks funds only afterclaim, it will result in deadlock of the whole system.
Proof of Concept
First, creating token with 8 decimals:
contract Token8Decimals is ERC20{constructor() ERC20("TEST", "TEST", 8) {}function mint(address to, uint amount) public{_mint(to, amount);}}
Second, I changed_bidfunction inTestHelpers.t.solcontract, so it could take token address as a last parameter, and use it instead of WETH.
Then, here is modified “testLiquidation5050Split” test:
function testLiquidation5050Split() public {TestNFT nft = new TestNFT(2);_mintNoDepositApproveRouter(address(nft), 5);address tokenContract = address(nft);uint256 tokenId = uint256(1);Token8Decimals token = new Token8Decimals();// create a PublicVault with a 14-day epochvm.startPrank(strategistOne);//bpsaddress publicVault = (ASTARIA_ROUTER.newPublicVault(14 days,strategistTwo,address(token),uint256(0),false,new address[](0),uint256(0)));vm.stopPrank();uint amountToLend = 10**8 * 1000;token.mint(address(1), amountToLend);vm.startPrank(address(1));token.approve(address(TRANSFER_PROXY), amountToLend);ASTARIA_ROUTER.depositToVault(IERC4626(publicVault),address(1),amountToLend,uint256(0));vm.stopPrank();ILienToken.Details memory lien = standardLienDetails;lien.liquidationInitialAsk = amountToLend*2;(, ILienToken.Stack[] memory stack1) = _commitToLien({vault: publicVault,strategist: strategistOne,strategistPK: strategistOnePK,tokenContract: tokenContract,tokenId: tokenId,lienDetails: lien,amount: amountToLend/4,isFirstLien: true});uint256 collateralId = tokenContract.computeId(tokenId);_signalWithdraw(address(1), publicVault);WithdrawProxy withdrawProxy = PublicVault(publicVault).getWithdrawProxy(PublicVault(publicVault).getCurrentEpoch());skip(14 days);OrderParameters memory listedOrder1 = ASTARIA_ROUTER.liquidate(stack1,uint8(0));token.mint(bidder, amountToLend);_bid(Bidder(bidder, bidderPK), listedOrder1, amountToLend/2, address(token));vm.warp(withdrawProxy.getFinalAuctionEnd());emit log_named_uint("finalAuctionEnd", block.timestamp);PublicVault(publicVault).processEpoch();skip(13 days);withdrawProxy.claim();}
withdrawProxy.claim();at the last line would revert
Recommended Mitigation Steps
https://github.com/code-423n4/2023-01-astaria/blob/1bfc58b42109b839528ab1c21dc9803d663df898/src/WithdrawProxy.sol#L273Change this line to10**18
Severity
I think this is high risk, because
There are high demand for stablecoin denominated vaults, and Astaria are designed to support that.This bug is sneaky, there could be many epochs before first liquidation that would trigger the deadlock.ALL funds would be lost, which is catastrophic.
SantiagoGregory (Astaria) confirmed via duplicate issue#482