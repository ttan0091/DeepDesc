[H-08] Ineffective ReserveRatio Enforcement
Submitted by xiaoming90, also found by shenwilly and pedroais
https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathPair.sol#L324
https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathPair.sol#L160
Background
Per whitepaper, ReserveRatio ensures that some amount of pool liquidity is present in the contract at all times. This protects the pools from overutilization by strategists and ensures that a portion of the underlying pool assets are liquid so LPs can withdraw. If the ReserveRatio is set to 50, meaning 50% of a liquidity pool’s assets must remain in the pool at all times.
However, it was possible for the strategists to bypass the Reserve Ratio restriction and utilize all the funds in the pools, causing the pools to be illiquid.
Proof of Concept
Strategists place their market making trades via theBathPair.placeMarketMakingTradesfunction. This function would first check if the pool’s reserveRatio is maintained before proceeding. If true, strategists will be allowed to place their market making trades with orders with arbitrary pay amount. Strategists could place ask and bid orders with large pay amount causing large amount of funds to be withdrawn from the pools. The root cause is that at the end of the transaction, there is no additional validation to ensure the pools are not overutilized by strategists and the reserve ratio of the pools is maintained.
https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathPair.sol#L324
functionplaceMarketMakingTrades(address[2]memorytokenPair,// ASSET, Then Quoteuint256askNumerator,// Quote / Assetuint256askDenominator,// Asset / Quoteuint256bidNumerator,// size in ASSETuint256bidDenominator// size in QUOTES)publiconlyApprovedStrategist(msg.sender)returns(uint256id) {// Require at least one order is non-zerorequire((askNumerator>0&&askDenominator>0) ||(bidNumerator>0&&bidDenominator>0),"one order must be non-zero");address_underlyingAsset=tokenPair[0];address_underlyingQuote=tokenPair[1];(addressbathAssetAddress,addressbathQuoteAddress) =enforceReserveRatio(_underlyingAsset,_underlyingQuote);require(bathAssetAddress!=address(0) &&bathQuoteAddress!=address(0),"tokenToBathToken error");..SNIP..// Place new bid and/or ask// Note: placeOffer returns a zero if an incomplete orderuint256newAskID=IBathToken(bathAssetAddress).placeOffer(ask.pay_amt,ask.pay_gem,ask.buy_amt,ask.buy_gem);uint256newBidID=IBathToken(bathQuoteAddress).placeOffer(bid.pay_amt,bid.pay_gem,bid.buy_amt,bid.buy_gem);..SNIP..}
https://github.com/code-423n4/2022-05-rubicon/blob/8c312a63a91193c6a192a9aab44ff980fbfd7741/contracts/rubiconPools/BathPair.sol#L160
/// @notice This function enforces that the Bath House reserveRatio (a % of underlying pool liquidity) is enforced across all pools/// @dev This function should ensure that reserveRatio % of the underlying liquidity always remains on the Bath Token. Utilization should be 1 - reserveRatio in practice assuming strategists use all available liquidity.functionenforceReserveRatio(addressunderlyingAsset,addressunderlyingQuote)internalviewreturns(addressbathAssetAddress,addressbathQuoteAddress){bathAssetAddress=IBathHouse(bathHouse).tokenToBathToken(underlyingAsset);bathQuoteAddress=IBathHouse(bathHouse).tokenToBathToken(underlyingQuote);require((IBathToken(bathAssetAddress).underlyingBalance().mul(IBathHouse(bathHouse).reserveRatio())).div(100) <=IERC20(underlyingAsset).balanceOf(bathAssetAddress),"Failed to meet asset pool reserve ratio");require((IBathToken(bathQuoteAddress).underlyingBalance().mul(IBathHouse(bathHouse).reserveRatio())).div(100) <=IERC20(underlyingQuote).balanceOf(bathQuoteAddress),"Failed to meet quote pool reserve ratio");}
Test Cases
The following is the snippet of the test case result. Reserve Ratio is initialized to 80% in this example, which means only 20% of the funds could be utilized by strategists. The BathWETH and BathDAI pools contained 1 WETH and 100 DAI respectively after users deposited their funds into the pools. At the bottom half of the output, it shows that it was possible for the strategists to utilise 90% of the funds in the pools to place an ask and bid order, which exceeded the 20% limit.
The last two lines of the output show that 90% of the funds in the pools are outstanding.
..SNIP..---------------OrderBook---------------[-]asksindex0:ask_pay_amt=0,ask_buy_amt=0[-]asksindex1:ask_pay_amt=0,ask_buy_amt=0[-]asksindex2:ask_pay_amt=0,ask_buy_amt=0[-]asksindex3:ask_pay_amt=0,ask_buy_amt=0[+]bidsindex0:bid_pay_amt=0,bid_buy_amt=0[+]bidsindex1:bid_pay_amt=0,bid_buy_amt=0[+]bidsindex2:bid_pay_amt=0,bid_buy_amt=0[+]bidsindex3:bid_pay_amt=0,bid_buy_amt=0bathAssetInstance:underlyingBalance() =1WETH,balanceOf=1WETH,OutstandingAmount=0WETHbathQuoteInstance:underlyingBalance() =100DAI,balanceOf=100DAI,OutstandingAmount=0DAIAfterPlacingOrder---------------OrderBook---------------[-]asksindex0:ask_pay_amt=0.9,ask_buy_amt=180[-]asksindex1:ask_pay_amt=0,ask_buy_amt=0[-]asksindex2:ask_pay_amt=0,ask_buy_amt=0[-]asksindex3:ask_pay_amt=0,ask_buy_amt=0[+]bidsindex0:bid_pay_amt=90,bid_buy_amt=0.9[+]bidsindex1:bid_pay_amt=0,bid_buy_amt=0[+]bidsindex2:bid_pay_amt=0,bid_buy_amt=0[+]bidsindex3:bid_pay_amt=0,bid_buy_amt=0bathAssetInstance:underlyingBalance() =1WETH,balanceOf=0.1WETH,OutstandingAmount=0.9WETHbathQuoteInstance:underlyingBalance() =100DAI,balanceOf=10DAI,OutstandingAmount=90DAI..SNIP..
Test Script can be found athttps://gist.github.com/xiaoming9090/c4fcd4e967bd7d6940429e5d8e39004d
Impact
Following are the impacts of this issue:
Underlying pool assets are overutilized by strategists, causing the pools to be illiquid. Users might not be able to withdraw their funds from the pools as the pools might not have sufficient underlying assets remained as their assets have been deployed to the Rubicon Market.Reserve Ratio is one of the key security parameters to safeguard LP’s funds so that the amount of losses the pools could potentially incur is limited. Without effective reserve ratio enforcement, strategists could deploy (“invest”) all the user capital on the Rubicon Market. If the strategist makes a loss from all their orders, the LP would incur significant loss.
Recommended Mitigation Steps
Check that the reserveRatio for each of the underlying liquidity pools (asset and quote bathTokens) is observed before and after function execution.
functionplaceMarketMakingTrades(address[2]memorytokenPair,// ASSET, Then Quoteuint256askNumerator,// Quote / Assetuint256askDenominator,// Asset / Quoteuint256bidNumerator,// size in ASSETuint256bidDenominator// size in QUOTES)publiconlyApprovedStrategist(msg.sender)returns(uint256id) {// Require at least one order is non-zerorequire((askNumerator>0&&askDenominator>0) ||(bidNumerator>0&&bidDenominator>0),"one order must be non-zero");address_underlyingAsset=tokenPair[0];address_underlyingQuote=tokenPair[1];(addressbathAssetAddress,addressbathQuoteAddress) =enforceReserveRatio(_underlyingAsset,_underlyingQuote);require(bathAssetAddress!=address(0) &&bathQuoteAddress!=address(0),"tokenToBathToken error");..SNIP..// Place new bid and/or ask// Note: placeOffer returns a zero if an incomplete orderuint256newAskID=IBathToken(bathAssetAddress).placeOffer(ask.pay_amt,ask.pay_gem,ask.buy_amt,ask.buy_gem);uint256newBidID=IBathToken(bathQuoteAddress).placeOffer(bid.pay_amt,bid.pay_gem,bid.buy_amt,bid.buy_gem);..SNIP..// Ensure that the strategist does not overutilizeenforceReserveRatio(_underlyingAsset,_underlyingQuote);}
bghughes (Rubicon) confirmed and commented:
Good issue! I believe it needs to just be moved to the end of the function. Nice catch and already implemented in practice.